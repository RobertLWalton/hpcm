#!/bin/sh -f
#
# Run a program binary in a sandbox.
#
# File:		hpcm_sandbox
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Sat Sep  9 16:25:50 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/09/09 20:18:14 $
#   $RCSfile: hpcm_sandbox,v $
#   $Revision: 1.5 $

# If you have a linux system you can symbolically
# link this to ~/bin/hpcm_sandbox and use the problem
# Makefiles.

cputime=600
datasize=`expr 4 \* 1024 \* 1024`
filesize=`expr 4 \* 1024 \* 1024`
stacksize=`expr 4 \* 1024 \* 1024`
core=`expr 4 \* 1024 \* 1024`
openfiles=30
processes=30

operation=""
watch=""
program=""
badargs=""

for arg in "$@"; do

    case "$arg" in
	-cputime | -datasize | -filesize \
	         | -stacksize | -openfiles \
		 | -processes | -core )
	    if test -z "$operation"; then
		operation=$arg
	    else
	        echo "ERROR: misplaced argument: $arg"
		exit 1
	    fi
	    ;;
	[0-9]* )
	    if test `expr $arg : '.*[^0-9]' ` -ne 0
	    then
		number=`expr $arg : '\([0-9]*\)[^0-9]' `
		scale=`expr $arg : \
		            '[0-9]*\([^0-9].*\)$' `

		case $scale in
		    "" )	;;
		    k )	number=`expr $number \* 1024`
			    ;;
		    m )	number=`expr $number \* 1024 \
		                             \* 1024`
			    ;;
		    * )	echo "ERROR: bad number: $arg"
			    exit 1
			    ;;
		esac
	    else
	        number=$arg
	    fi

	    case $operation in
		-cputime )
		    cputime=$number
		    ;;
		-datasize )
		    datasize=$number
		    ;;
		-stacksize )
		    stacksize=$number
		    ;;
		-filesize )
		    filesize=$number
		    ;;
		-openfiles )
		    openfiles=$number
		    ;;
		-processes )
		    processes=$number
		    ;;
		-core )
		    core=$number
		    ;;
		* )	echo ERROR: misplaced \
				 argument: "$arg"
			exit 1
			;;
	    esac

	    operation=""
	    ;;

	-watch )
	    watch=yes
	    ;;

	"" )
	    ;;
	    
	-* )
	    badargs="$badargs $arg"
	    ;;

	* )
	    if test -z "$program"; then
	    	program=$arg
	    else
		badargs="$badargs $arg"
	    fi
	    ;;
    esac

done

if test -z "$program" -o ! -z "$badargs"; then
    if test ! -z "$badargs"; then
	echo "ERROR: bad arguments: $badargs"
    elif test -z "$program"; then
	echo ERROR: no program specified
    fi
    echo "
hpcm_sandbox [options] program

    This program first checks its arguments for
    options that set resource limits:

      -cputime N     Cpu Time in Seconds (600)
      -datasize N    Data Area Size in Bytes (4m)
      -stacksize N   Stack Size in Bytes (4m)
      -filesize N    Output File Size in Bytes (4m)
      -core N        Core Dump Size in Bytes (4m)
      -openfiles N   Number of Open Files (30)
      -processes N   Number of Processes (30)

    Here N is a positive decimal integer that can
    end with \`k' to multiply it by 1024 or \`m' to
    multiply it by 1024 * 1024.  The values above in
    parentheses are the default values.

    There is also another possible option:

      -watch

    With this option, this program forks with the
    parent waiting for the child to complete the
    the rest of this program's action.  If the
    child terminates with a signal, the parent
    prints an error message identifying the signal.
    It does this using \`sys_siglist' (psignal(3))
    and changes SIGKILL with measured CPU time over
    the limit to SIGXCPU.  The parent returns a 0
    exit code if the child does not terminate with a
    signal, and returns 128 + the signal number as
    an exit code if the child does terminate with
    a signal.

    Next, if this program's effective user ID is
    \`root', this program eliminates any supplemen-
    tary groups that the process might have, and
    changes the effective user and group IDs to
    those of \`sandbox', as looked up in /etc/passwd.

    Then this program sets the real user and group
    IDs to the effective user and group IDs, sets
    the resource limits determined by the options
    and defaults, sets the environment to contain
    just "SANDBOX", and executes the program with
    the given arguments.

    Normally the \`sandbox' user is not allowed to
    log in and owns no files or directories.

    This version of the program actually emulates
    the real hpcm_sandbox program, and does not
    set some of the resource limits or change
    the user and group IDs to \`sandbox'.
"
fi

ulimit -t $cputime
ulimit -d `expr $datasize / 1024`
ulimit -f `expr $filesize / 1024`
ulimit -s `expr $stacksize / 1024`
ulimit -c `expr $core / 1024`
ulimit -u $processes
ulimit -n $openfiles


if test ! -z "$watch"; then
    $program
    status=$?
    if test $status -ge 128; then
        signal=`expr $status - 128`
    	case $signal in
	    1 ) signame=SIGHUP ;;
	    2 ) signame=SIGINT ;;
	    3 ) signame=SIGQUIT ;;
	    4 ) signame=SIGILL ;;
	    5 ) signame=SIGTRAP ;;
	    6 ) signame=SIGABRT ;;
	    6 ) signame=SIGIOT ;;
	    7 ) signame=SIGBUS ;;
	    8 ) signame=SIGFPE ;;
	    9 ) signame=SIGKILL ;;
	    10 ) signame=SIGUSR1 ;;
	    11 ) signame=SIGSEGV ;;
	    12 ) signame=SIGUSR2 ;;
	    13 ) signame=SIGPIPE ;;
	    14 ) signame=SIGALRM ;;
	    15 ) signame=SIGTERM ;;
	    16 ) signame=SIGSTKFLT ;;
	    17 ) signame=SIGCHLD ;;
	    18 ) signame=SIGCONT ;;
	    19 ) signame=SIGSTOP ;;
	    20 ) signame=SIGTSTP ;;
	    21 ) signame=SIGTTIN ;;
	    22 ) signame=SIGTTOU ;;
	    23 ) signame=SIGURG ;;
	    24 ) signame=SIGXCPU ;;
	    25 ) signame=SIGXFSZ ;;
	    26 ) signame=SIGVTALRM ;;
	    27 ) signame=SIGPROF ;;
	    28 ) signame=SIGWINCH ;;
	    29 ) signame=SIGIO ;;
	    30 ) signame=SIGPWR ;;
	    * ) signame=UNKNOWN ;;
	esac
	echo "Program terminated by signal: $signame"
	exit $status
    fi
else
    $program
fi

exit 0
