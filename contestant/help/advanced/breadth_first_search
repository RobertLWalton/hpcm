BREADTH FIRST SEARCH PROBLEM HELP
			    Tue Aug  6 08:42:50 EDT 2002

Breadth first search is most commonly used in maze
problems, but can be used in other problems.  The idea
behind search is that one has a set of nodes, each node
has a list of other nodes that are its children, and the
search begins at a start node and progresses from the
current node to one of its children until the search
finds a goal node.

The idea behind breadth first search is that one makes a
`visited list' of the nodes in the order that they are
first visited by the search, and one has a pointer into
this list at the first node whose children have not yet
been examined.  Then one iteratively examines the child-
ren of the node pointed at, adds any children that are
not yet on the visited list to the end of the visited
list, and bumps the pointer to the next node on the
visited list.  One stops when one gets to a goal node.

The key to programming breadth first search is to
understand how you are going to represent the following
data structures:

A. The `visited list' of all the nodes that have been
   visited by the search.

B. An `allocated_list' of all nodes.  This is needed to
   free memory allocated to the nodes when the algorithm
   is finished.  Sometimes this can be the same as the
   visited list A.

C. For each node, a list of the node's children.

D. For each node, a bit indicating whether the node is
   on the visited list A.  Of course this is an effici-
   ency matter, but it is important except for very
   small problems.

E. For each node, a `parent pointer' to the parent node
   which caused the node to be put on the visited list
   A.  This pointer is used to construct the shortest
   path list F.

F. For each node on the shortest path from the start
   node to a goal, a `shortest path pointer' to the next
   node on the shortest path.  This pointer can be
   computed by traversing the shortest path in reverse
   order from goal to start node using the `parent
   pointer' E.

The various items above can be encoded in a `node' data
structure.  The members of this data structure can be:

0. Information naming the node.

A. A next_visited pointer that points at the next node
   in the visited list A.

B. A next_allocated pointer that points at the next node
   in the node list B.  This is needed only if nodes
   must be allocated before the search begins.

C. A first_child pointer and a next_sibling pointer.
   These are needed only if the list of children of a
   node cannot easily be generated on the fly from some
   simpler data structure.

D. If the question of whether a node is on the visited
   list A cannot be answered by some simple array, then
   it is necessary to answer it with a hash table, and
   include a next_hashed pointer to the next node in
   the same hash slot.

E. A `parent' pointer to the parent node which cause
   this node to be put on the listed list A.

F. A `next_shortest' pointer to the next node on the
   shortest path.

Note that there are a number of variants to basic
breadth first search.  Sometimes the starting node
can also be a goal, sometimes there are many goal
nodes, etc.

Given the right definition of a node structure, breadth
first search is easy enough to code.
   



File:		breadth_first_search
Author:		Bob Walton <walton@deas.harvard.edu>
Date:		See top of file.

The authors have placed this file in the public domain;
they make no warranty and accept no liability for this
file.

RCS Info (may not be true date or author):

    $Author: hc3 $
    $Date: 2002/08/06 13:17:49 $
    $RCSfile: breadth_first_search,v $
    $Revision: 1.1 $
