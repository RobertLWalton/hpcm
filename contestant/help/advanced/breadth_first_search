BREADTH FIRST SEARCH PROBLEM HELP
			    Tue Aug  6 11:30:21 EDT 2002

Breadth first search is most commonly used in maze
problems, but can be used in other problems.  The idea
behind search is that one has a set of nodes, each node
has a list of other nodes that are its children, and the
search begins at a start node and progresses from the
current node to one of its children until the search
finds a goal node.

The idea behind breadth first search is that one makes a
`visited list' of the nodes in the order that they are
first visited by the search, and one has a pointer into
this list at the first node whose children have not yet
been examined.  Then one iteratively examines the child-
ren of the node pointed at, adds any children that are
not yet on the visited list to the end of the visited
list, and bumps the pointer to the next node on the
visited list.  One stops when one gets to a goal node.

The key to programming breadth first search is to
understand how you are going to represent the following
data structures:

A. The `visited list' of all the nodes that have been
   visited by the search.

B. An `allocated_list' of all nodes.  This is needed to
   free memory allocated to the nodes when the algorithm
   is finished.  Sometimes this can be the same as the
   visited list A.

C. For each node, a list of the node's children.

D. For each node, a bit indicating whether the node is
   on the visited list A.  Of course this is an effici-
   ency matter, but it is important except for very
   small problems.

E. For each node, a `parent pointer' to the parent node
   which caused the node to be put on the visited list
   A.  This pointer is used to construct the shortest
   path list F.

F. For each node on the shortest path from the start
   node to a goal, a `shortest path pointer' to the next
   node on the shortest path.  This pointer can be
   computed by traversing the shortest path in reverse
   order from goal to start node using the `parent
   pointer' E.

The various items above can be encoded in a `node' data
structure.  The members of this data structure can be:

0. Information naming the node.

A. A next_visited pointer that points at the next node
   in the visited list A.

B. A previous_allocated pointer that points at the
   previous node on the node list B.  This is needed
   only if nodes must be allocated before each search
   begins and freed after each search ends.

C. A children pointer at a list of cons cells that list
   all the children of this node.  This is needed only
   if the list of children of a node cannot easily be
   generated on the fly from some simpler data struc-
   ture; e.g., if the list is read from input.

D. A visited flag if there is already an easy way of
   looking up a node given its name.  Otherwise some
   sort of hash table needs to be employed and visited
   nodes should be put in a hash bin and have a next_
   hashed pointer to the next node in their hash bin.

E. A `parent' pointer to the parent node which caused
   this node to be put on the visited list A.

F. A `next_shortest' pointer to the next node on the
   shortest path.

Note that there are a number of variants to basic
breadth first search.  Sometimes the starting node
can also be a goal, sometimes there are many goal
nodes, etc.

Given the right definition of a node structure, breadth
first search is easy enough to code.
   



File:		breadth_first_search
Author:		Bob Walton <walton@deas.harvard.edu>
Date:		See top of file.

The authors have placed this file in the public domain;
they make no warranty and accept no liability for this
file.

RCS Info (may not be true date or author):

    $Author: hc3 $
    $Date: 2002/08/06 15:42:02 $
    $RCSfile: breadth_first_search,v $
    $Revision: 1.2 $
