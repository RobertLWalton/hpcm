GEOMETRY EXERCISES HELP    Fri Mar 19 01:20:41 EST 2004

These are programming exercises you can do to help
strengthen your geometry problem skills.

Distances:
---------


Compute the distance between a point (x,y) and an
infinite line through points (x1,y1) and (x2,y2).

    Method1: Compute (dx,dy) to be the displacement
    vector from (x1,y1) to (x2,y2), rotate (dx,dy) 90
    degrees clockwise to get (dy,-dx), normalize to a
    unit vector, use this vector to compute coordinates
    in the direction perpendicular to the line of the
    points (x,y) and (x1,y1), and take the difference.

    Method2: As for method1 compute a unit vector in the
    direction of the line and another at right angles to
    the line.  Use these to change coordinates so the
    line is the x-axis (y = 0) and then compute the
    distance of the point in the new coordinates to the
    x-axis (its just the absolute value of the point's
    new y coordinate).

Ditto for the finite line segment from (x1,y1) to
(x2,y2).

    Method: Change coordinates so the finite line seg-
    ment is from (0,0) to (k,0) and the point coordi-
    nates are (x',y').  Then  divide into three cases:
    x' < 0, 0 <= x' <= k, k < x'.

Compute the distance between the finite line segment
from (xa1,ya1) to (xa2,ya2) and the finite line segment
from (xb1,yb1) to (xb1,yb2).

    Method: Change coordinates so one finite line seg-
    ment is from (0,0) to (k,0).  Then divide the other
    segment into three segments at the intersections of
    the lines x = 0 and x = k.  For the middle segment
    the distance is the minimum of the absolute value
    of the y coordinates at the end points.  For the
    other segments it is the distance between the other
    segment and either (0,0) or (k,0).  Take the  min-
    imum of the three distances (some of which may be
    missing if their segment is missing).

Compute the distance between a point (x,y,z) and an
infinite line through points (x1,y1,z1) and (x2,y2,z2).

    Method: Let U1 be the unit vector from (x1,y1,z1)
    to (x2,y2,z2).  Recall that the cross product of
    vectors is defined by

    	V1 = (X1,Y1,Z1)		V2 = (X2,Y2,Z2)

		V = V1 x V2 = (Y1*Z2 - Z1*Y2,
			       Z1*X2 - X1*Z2,
			       X1*Y2 - Y1*X2)

    Then V is perpendicular to V1 and V2.  If

    	UX = (1,0,0)    UY = (0,1,0)   (UZ) = (0,0,1)

    then

    	UX x UY = UZ	UY x UZ = UX	UZ x UX = UY

    and note that the vectors in these equations are all
    rotations of the order UX,UY,UZ.

    Examine U1 x UX, U1 x UY, U1 x UZ and take the first
    of these that has length > 0.5 (at least one will
    qualify).  Normalize this to a unit vector, call it
    U2, and take U3 = U1 x U2.  Then U1, U2, U3 are an
    orthogonal basis and U1 is in the direction of the
    line.  By computing coordinates of the line and point
    in the directions U2 and U3, one can project both
    on a plane perpendicular to the line, in which case
    the line is projected to a point, and the distance
    required is the 2D distance of the two projection
    points.

Compute the distance between a point (x,y,z) and an
finite line from (x1,y1,z1) to (x2,y2,z2).

    Method: Using the method of the last exercise,
    change coordinates so the line is from (0,0,0)
    to (k,0,0), and the point in these coordinates
    is (x',y',z').  Then divide into three cases:
    x' < 0, 0 <= x' <= k, k < x'.

Compute the distance between an infinite line through
the points (x1,y1,z1) to (x2,y2,z2) and a finite line
segment.

    Method: Change coordinates so the infinite line is
    the x axis.  Then project the line segment on the
    (y,z) plane and find its distance to the origin in
    that plane.

Compute the distance between two finite 3D line seg-
ments.

    Method: Change coordinates so one segment is from
    (0,0,0) to (k,0,0).  Divide the other segment into
    three parts using the intersections of that segment
    with the x = 0 and x = k planes.  Compute the dis-
    tance from the three parts to (0,0,0), the x-axis,
    and (k,0,0) respectively and take the minimum of the
    three distances.

Intersection of a line segment B from (x1,y1) to (x2,y2)
with another line segment C from (x3,y3) to (x4,y4),
with `corner cases'.

    Compute (dx,dy) = (x2-x1,y2-x1) so that (dy,-dx) is
    perpendicular and pointing to the right of the
    directed segment from (x1,y1) to (x2,y2).  Then
    you can compute whether any point is to the right
    of, on, or to the left of the infinite directed
    line extending B by comparing the dot product of
    the point with (dy,-dx) with the dot product of
    (x1,y1) (or equivalently (x2,y2)) with (dy,-dx).
    The computation of being `on' the line requires that
    the coordinates all be multiples of some quantum Q.
    Then dot products are taken as equal if they are
    within Q**2/4 of each other, assuming the accuracy
    of computation is much better than Q**2.  If the
    coordinates are integers, you can dispense with
    Q and use integer arithmetic for the dot products
    and comparisons.

    In order for the line segments to intersect at a
    mid-point of both segments, the end points of each
    segment must be on opposite sides of the other seg-
    ment, and this suffices.  Interpolation using the
    values of dot products with (-dy,dx) can be used
    to determine the location of the intersection.

    Otherwise, if the end points of each segment are NOT
    on the same side of the other segment, either there
    is an intersection which is one of the end points,
    or the two segments are parallel.  The later case is
    just that in which both endpoints of one segment are
    on the infinite line extending the other segment,
    in which case the same statement is true with the
    segments switched.  In the parallel case it is
    possible for the segments to overlap or be separate.
    You need to take dot products with (dx,dy) and
    compare these to see if there is an overlap.

A non-degenerate polygon is a sequence of vertices in
clockwise (or counterclockwise) order defining the
line segments of the boundary of the polygon, such that
the only intersections of two segments are those at the
endpoints of successive segments in the circular list
of segments.

Find all the intersections of a 2D line segment and a
boundary of a non-degenerate polygon.

    Method: You can find all the intersections of the
    line segment and the polygon side segments.  The
    one odd case is where the line segment overlaps
    a parallel side segment.

Determine if a 2D line segment intersects the interior
of a non-degenerate polygon.

    Method: Find the intersections of the line segment
    and the boundary of the polygon.
    
    One hard case is when an intersection is a vertex of
    the polygon: the line segment might pass into the
    interior or be tangential to the polygon.

    You therefore have a vertex with up to 4 line seg-
    ments leaving it: two polygon sides and 1 or 2 parts
    of the 2D line segment.  So is any part of the
    2D line segment going into the interior of the
    polygon.

    Treating polygon sides as clockwise directed, let
    OUT be the outgoing side and IN the incoming side
    and LINE a line part directed out from the vertex.
    Let -IN bet the incoming side with direction revers-
    ed.  Measure the counterclockwise angles from OUT to
    the segments -IN and LINE, and normalize these
    angles to the range [0,2pi).  Then letting OUT, -IN,
    and LINE denote the angles, so OUT = 0 and -IN > 0,
    we have that LINE goes into the interior of the
    polygon iff LINE > -IN.

    You need to decide when angles are exactly equal.
    Let point coordinates all have absolute value less
    than B and be exact multiples of Q with Q <= B*A.
    Then two angles that are different will differ by
    several times A**2/10, and two that are equal will
    differ by many times less than A**2/10, if the
    precision of computation is many times less than
    A**/10.

    With this in mind, the code to normalize an angle
    X to the range [0,2pi) is

	ACC = A**2/10
    	while ( X < - ACC ) X += 2pi
    	while ( X > 2pi - ACC ) X -= 2pi

    The other hard case is when the line segment and
    a boundary segment are parallel on the same infinite
    line.  Then one of there vertices may be in both
    segments, and this vertex can be treated as the
    intersection vertex and the above methods applied
    after identifying OUT, IN, and LINE.  If the vertex
    is not a vertex of the polygon, then we will have
    OUT = IN direction-wise.

A polygon is convex if and only if every line segment
between two points inside the polygon is completely
inside the polygon.

The convex hull of a set of points V in a plane is a
sequence of points of V, p(1), ..., p(N), such that
for every i, all the points of V are on or to the
right of the line through p(i) and p((i mod N)+1),
and such that no point p(j) is on this line except
of course p(i) and p((i mod N)+1).  Then the finite
lines from p(i) to p((i mod N)+1) for i = 1, ..., N
are the sides of the smallest convex polygon such
that all the points of V are inside this polygon or
on its boundary.

Find the convex hull of a set of 2D points.

    To find the convex hull, first find some point p(1)
    on the hull, which can be done say by choosing a
    leftmost point in V and given two leftmost points
    choosing the highest.  Then extend the hull recur-
    sively from p(i) to p(i+1) by using the following.

    Given a point p, define a relation among points q1,
    q2 that are not equal to p as follows:

	definition:  q1 > q2 iff q2 is to the right of
				 the line from p to q1
				 or q2 is on this line
				 and closer to p than
				 q1 is.

    If p is a hull point, this relation is antisymmetric
    and transitive (proof to reader).  So given the hull
    up to p(i), choose p(i+1) to be the maximum point in
    V according to this relation.  Stop when p(i+1) =
    p(1), in which case N=i.

    This is not the fastest algorithm, as it has time
    O(|V|**2) where |V| is the number of points in V.
    The fastest algorithm is the Gram-Schmidt algorithm
    that begins with a sort of V and has running time
    dominated by the sort time, O(|V| log|V|).

Find whether some point r is inside a convex polygon.

TBD

    Suppose we have a convex hull p(1), ..., p(N) in clockwise
    order that defines a convex polygon.  So the sides of
    the polygon with a clockwise orientation are the lines
    from p(i) to p((i mod N)+1), for i = 1, ..., N.  We
    assume no three of these points lie on the same line.

    Then a point r is inside the convex polygon but not on
    the boundary of the polygon iff r is to the right of
    each clockwise oriented side of the polygon.  Or more
    specifically, r is to the right of the infinite line
    that extends the side.

    So when does the interior of a line from r1 to r2 inter-
    sect the inside of a convex polygon?  It does if the
    interior of the line from r1 to r2 intersects the inter-
    ior of any side of the polygon.  It also does if r1 and
    r2 are both inside or on the boundary of the polygon,
    but are not both on the same single side of the polygon.

    These are the only two cases where the interior of the
    line from r1 to r2 can intersect the interior of the
    polygon, UNLESS some of the convex hull points p1, ...,
    p(N) are in the interior of the line from r1 to r2.  In
    this last case, use a convex hull point in the interior
    of the line to divide the line in two, and recursively
    ask if the interiors of either of the two new line seg-
    ments intersect the interior of the polygon.

    So all one has to do is take the clockwise sides of the
    polygon and check that the interior of the finite line
    from r1 and r2 intersects the interior of some side, or
    that for each polygon side, r1 and r2 are both on or to
    the right of the infinite line extending the side, and
    r1 and r2 are not both on that line.  During this pro-
    cess one checks each convex hull point p to see if it is
    in the interior of the line from r1 to r2, and if it is,
    one then divides the line from r1 to r2 up into two
    segments, one from r1 to p and one from p to r2, and
    then one applies the algorithm recursively to see if the
    interior of either of these two segments intersects the
    interior of the polygon.


Polygon Maze
------- ----

Problem: Given a set of convex polygons in a plane, and
two points p and q outside any convex polygon, find the
shortest path from p to q that does not go inside any
convex polygon.  Paths may travel on the edges of a
polygon if these are not inside some other polygon.

Solution: Let V be the set of vertices of the polygons
plus the two points p and q.  Then the path to be found
can be represented as a sequence of straight line
segments with vertices in V (proof to reader).  So it
is a shortest path in an undirected graph whose vertices
are V such that given points r1 and r2 in V, there is
an edge in this undirected graph between r1 and r2 iff
the interior of the line from r1 to r2 does not inter-
sect the interior of any polygon.  Actually, we can make
the computation simpler by also deleting an edge from r1
to r2 if the interior of the line from r1 to r2 contains
any member of V, as the shortest path can be composed of
line segments between members of V that do not contain
other members of V.


Circular Anti-Maze
-------- ---------

Find the shortest path between two points in a plane
that has circular holes in it.  The part of a path
that transverses a hole does NOT count toward the
length of the path.

Rotate 2D coordinates.

    A clockwise rotation R(theta) of a vector v=(vx,vy)
    by an angle theta is

		   |   cos(theta)   sin(theta) | | vx |
      R(theta).v = |                           | |    |
		   | - sin(theta)   cos(theta) | | vy |

		  |   vx cos(theta) + vy sin(theta) |
		= |                                 |
		  | - vx sin(theta) + vy cos(theta) |

    Most particularly, if theta = 90 degrees, then

		    
			    |  0   1 |
	    R(90 degrees) = |        |
			    | -1   0 |


	    R(90 degrees).v =  (vy,-vx)


Robot Arms
----- ----

Suppose we have a planar robot arm.  Such an arm con-
sists of line segments in an order.  The beginning of
each segment is a pivot point, around which a servo can
rotate the segment and anything attached to its end.
The end of a segment is attached to the beginning of the
next segment, or to the robot hand if the segment is the
last segment of the arm.  We will define the end of the
last segment to also be a pivot point: it could have a
servo to rotate the hand.

The parameters of the arm are the lengths of the seg-
ments and the angular settings of the servos.  A servo
is typically set to have 0 angle if the segment follow-
ing it continues in the same direction as the segment
preceding it.  We will assume that a positive angle
means the arm following the servo is rotated clockwise
by that angle.  Particular robot arms may use other
conventions for servo angles.  We will also assume that
the first pivot point is at the origin, and that the
setting of 0 degrees for the first servo points the
first segment along the positive x-axis.

The position of the pivot points of such an arm can be
computed recursively by induction on the number of
segments in the arm.  If there are 0 segments, there is
only one pivot point (the hand's), and it is at the
origin.  Otherwise assume for the moment that the first
segment is such that its end (not its beginning) is at
the origin and its orientation is in the direction of
the positive x-axis, so its server setting is 0 degrees.
Next compute the positions of the pivot points at the
ends of the other segments by induction.

Now translate the origin to the beginning of the first
segment by adding the length of this segment to the
x coordinate of every pivot point.  The beginning of the
first segment is now the origin.  The setting of the
first servo is still 0 degrees.

Now rotate all the pivot points about the origin by the
amount indicated by the setting of the first servo.
This finishes the computation.

This computation is easy because we use induction to
build the arm from its end, and not from its beginning.


File:		2D_geometry
Author:		Bob Walton <walton@deas.harvard.edu>
Date:		See top of file.

The authors have placed this file in the public domain;
they make no warranty and accept no liability for this
file.

RCS Info (may not be true date or author):

    $Author: hc3 $
    $Date: 2004/03/19 07:00:16 $
    $RCSfile: geometry_exercises,v $
    $Revision: 1.2 $

