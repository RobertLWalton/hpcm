GEOMETRY EXERCISES HELP    Sat Mar 20 10:47:05 EST 2004

These are programming exercises you can do to help
strengthen your geometry problem skills.

Problem: Find the shortest path between two points in a
plane that has circular holes in it.  The part of a path
that transverses a hole does NOT count toward the length
of the path.

    Solution: This is just a shortest path problem where
    the set of points is the original two points plus
    the centers of the circular holes, and the distance
    between two points is their total distance minus the
    radii of any holes centered at the points.

Compute the distance between a point (x,y) and an
infinite line through points (x1,y1) and (x2,y2).

    Method1: Compute (dx,dy) to be the displacement
    vector from (x1,y1) to (x2,y2), rotate (dx,dy) 90
    degrees clockwise to get (dy,-dx), normalize to a
    unit vector, use this vector to compute coordinates
    in the direction perpendicular to the line of the
    points (x,y) and (x1,y1), and take the difference.

    Method2: As for method1 compute a unit vector in the
    direction of the line and another at right angles to
    the line.  Use these to change coordinates so the
    line is the x-axis (y = 0) and then compute the
    distance of the point in the new coordinates to the
    x-axis (its just the absolute value of the point's
    new y coordinate).

Ditto for the finite line segment from (x1,y1) to
(x2,y2).

    Method: Change coordinates so the finite line seg-
    ment is from (0,0) to (k,0) and the point coordi-
    nates are (x',y').  Then  divide into three cases:
    x' < 0, 0 <= x' <= k, k < x'.

Compute the distance between the finite line segment
from (xa1,ya1) to (xa2,ya2) and the finite line segment
from (xb1,yb1) to (xb1,yb2).

    Method: Change coordinates so one finite line seg-
    ment is from (0,0) to (k,0).  Then divide the other
    segment into three segments at the intersections of
    the lines x = 0 and x = k.  For the middle segment
    the distance is the minimum of the absolute value
    of the y coordinates at the end points.  For the
    other segments it is the distance between the other
    segment and either (0,0) or (k,0).  Take the  min-
    imum of the three distances (some of which may be
    missing if their segment is missing).

Compute the distance between a point (x,y,z) and an
infinite line through points (x1,y1,z1) and (x2,y2,z2).

    Method: Let U1 be the unit vector from (x1,y1,z1)
    to (x2,y2,z2).  Recall that the cross product of
    vectors is defined by

    	V1 = (X1,Y1,Z1)		V2 = (X2,Y2,Z2)

		V = V1 x V2 = (Y1*Z2 - Z1*Y2,
			       Z1*X2 - X1*Z2,
			       X1*Y2 - Y1*X2)

    Then V is perpendicular to V1 and V2.  If

    	UX = (1,0,0)    UY = (0,1,0)   (UZ) = (0,0,1)

    then

    	UX x UY = UZ	UY x UZ = UX	UZ x UX = UY

    and note that the vectors in these equations are all
    rotations of the order UX,UY,UZ.

    Examine U1 x UX, U1 x UY, U1 x UZ and take the first
    of these that has length > 0.5 (at least one will
    qualify).  Normalize this to a unit vector, call it
    U2, and take U3 = U1 x U2.  Then U1, U2, U3 are an
    orthogonal basis and U1 is in the direction of the
    line.  By computing coordinates of the line and point
    in the directions U2 and U3, one can project both
    on a plane perpendicular to the line, in which case
    the line is projected to a point, and the distance
    required is the 2D distance of the two projection
    points.

Compute the distance between a point (x,y,z) and an
finite line from (x1,y1,z1) to (x2,y2,z2).

    Method: Using the method of the last exercise,
    change coordinates so the line is from (0,0,0)
    to (k,0,0), and the point in these coordinates
    is (x',y',z').  Then divide into three cases:
    x' < 0, 0 <= x' <= k, k < x'.

Compute the distance between an infinite line through
the points (x1,y1,z1) to (x2,y2,z2) and a finite line
segment.

    Method: Change coordinates so the infinite line is
    the x axis.  Then project the line segment on the
    (y,z) plane and find its distance to the origin in
    that plane.

Compute the distance between two finite 3D line seg-
ments.

    Method: Change coordinates so one segment is from
    (0,0,0) to (k,0,0).  Divide the other segment into
    three parts using the intersections of that segment
    with the x = 0 and x = k planes.  Compute the dis-
    tance from the three parts to (0,0,0), the x-axis,
    and (k,0,0) respectively and take the minimum of the
    three distances.

Intersection of a line segment B from (x1,y1) to (x2,y2)
with another line segment C from (x3,y3) to (x4,y4),
with `corner cases'.

    Compute (dx,dy) = (x2-x1,y2-x1) so that (dy,-dx) is
    perpendicular and pointing to the right of the
    directed segment from (x1,y1) to (x2,y2).  Then
    you can compute whether any point is to the right
    of, on, or to the left of the infinite directed
    line extending B by comparing the dot product of
    the point with (dy,-dx) with the dot product of
    (x1,y1) (or equivalently (x2,y2)) with (dy,-dx).
    The computation of being `on' the line requires that
    the coordinates all be multiples of some quantum Q.
    Then dot products are taken as equal if they are
    within Q**2/4 of each other, assuming the accuracy
    of computation is much better than Q**2.  If the
    coordinates are integers, you can dispense with
    Q and use integer arithmetic for the dot products
    and comparisons.

    In order for the line segments to intersect at a
    mid-point of both segments, the end points of each
    segment must be on opposite sides of the other seg-
    ment, and this suffices.  Interpolation using the
    values of dot products with (-dy,dx) can be used
    to determine the location of the intersection.

    Otherwise, if the end points of each segment are NOT
    on the same side of the other segment, either there
    is an intersection which is one of the end points,
    or the two segments are parallel.  The later case is
    just that in which both endpoints of one segment are
    on the infinite line extending the other segment,
    in which case the same statement is true with the
    segments switched.  In the parallel case it is
    possible for the segments to overlap or be separate.
    You need to take dot products with (dx,dy) and
    compare these to see if there is an overlap.

A non-degenerate polygon is a sequence of vertices in
clockwise (or counterclockwise) order defining the
line segments of the boundary of the polygon, such that
the only intersections of two segments are those at the
endpoints of successive segments in the circular list
of segments.

Find all the intersections of a 2D line segment and a
boundary of a non-degenerate polygon.

    Method: You can find all the intersections of the
    line segment and the polygon side segments.  The
    one odd case is where the line segment overlaps
    a parallel side segment.

Determine if a 2D line segment intersects the interior
of a non-degenerate polygon.

    Method: Find the intersections of the line segment
    and the boundary of the polygon.
    
    One hard case is when an intersection is a vertex of
    the polygon: the line segment might pass into the
    interior or be tangential to the polygon.

    You therefore have a vertex with up to 4 line seg-
    ments leaving it: two polygon sides and 1 or 2 parts
    of the 2D line segment.  So is any part of the
    2D line segment going into the interior of the
    polygon.

    Treating polygon sides as clockwise directed, let
    OUT be the outgoing side and IN the incoming side
    and LINE a line part directed out from the vertex.
    Let -IN bet the incoming side with direction revers-
    ed.  Measure the counterclockwise angles from OUT to
    the segments -IN and LINE, and normalize these
    angles to the range [0,2pi).  Then letting OUT, -IN,
    and LINE denote the angles, so OUT = 0 and -IN > 0,
    we have that LINE goes into the interior of the
    polygon iff LINE > -IN.

    You need to decide when angles are exactly equal.
    Let point coordinates all have absolute value less
    than B and be exact multiples of Q with Q <= B*A.
    Then two angles that are different will differ by
    several times A**2/10, and two that are equal will
    differ by many times less than A**2/10, if the
    precision of computation is many times less than
    A**/10.

    With this in mind, the code to normalize an angle
    X to the range [0,2pi) is

	ACC = A**2/10
    	while ( X < - ACC ) X += 2pi
    	while ( X > 2pi - ACC ) X -= 2pi

    The other hard case is when the line segment and
    a boundary segment are parallel on the same infinite
    line.  Then one of there vertices may be in both
    segments, and this vertex can be treated as the
    intersection vertex and the above methods applied
    after identifying OUT, IN, and LINE.  If the vertex
    is not a vertex of the polygon, then we will have
    OUT = IN direction-wise.

A polygon is convex if and only if every line segment
between two points inside the polygon is completely
inside the polygon.

The convex hull of a set of points V in a plane is a
sequence of points of V, p(1), ..., p(N), such that for
every i, all the points of V are on or to the right of
the line through p(i) and p((i mod N)+1), and such that
no point p(j) is on this line except of course p(i) and
p((i mod N)+1).  Then the finite lines from p(i) to
p((i mod N)+1) for i = 1, ..., N are the sides of the
smallest convex polygon such that all the points of V
are inside this polygon or on its boundary.

Find the convex hull of a set of 2D points.

    To find the convex hull, first find some point p(1)
    on the hull, which can be done say by choosing a
    leftmost point in V and given two leftmost points
    choosing the highest.  Then extend the hull recur-
    sively from p(i) to p(i+1) by using the following.

    Given a point p, define a relation among points q1,
    q2 that are not equal to p as follows:

	definition:  q1 > q2 iff q2 is to the right of
				 the line from p to q1
				 or q2 is on this line
				 and closer to p than
				 q1 is.

    If p is a hull point, this relation is antisymmetric
    and transitive (proof to reader).  So given the hull
    up to p(i), choose p(i+1) to be the maximum point in
    V according to this relation.  Stop when p(i+1) =
    p(1), in which case N=i.

    This is not the fastest algorithm, as it has time
    O(|V|**2) where |V| is the number of points in V.
    The fastest algorithm is the Gram-Schmidt algorithm
    that begins with a sort of V and has running time
    dominated by the sort time, O(|V| log|V|).

Find whether some point p is inside a convex polygon.

    Suppose we have a convex hull p(1), ..., p(N) in
    clockwise order that defines a convex polygon.  So
    the sides of the polygon with a clockwise orienta-
    tion are the lines from p(i) to p((i mod N)+1), for
    i = 1, ..., N, and no three points lie on the same
    line.

    Then a point p is inside the convex polygon but not
    on the boundary of the polygon iff p is to the right
    of each clockwise oriented side of the polygon.  Or
    more specifically, p is to the right of the infinite
    line that extends the side.

Find whether the interior of the line segment between
points pa and pb intersects the interior of a convex
polygon.

    The line segment intersects the interior of the
    polygon if the interior of the line segement inter-
    sects the interior of any side of the polygon.  It
    also does if pa and pb are both inside or on the
    boundary of the polygon, but are not both on the
    same single side of the polygon.

    These are the only two cases where the interior of
    the line segment can intersect the interior of the
    polygon, UNLESS some of the convex hull points p(1),
    ..., p(N) are in the interior of the line segment.
    In this last case, use a convex hull point in the
    interior of the line segment to divide the line
    segment in two, and recursively ask if the interiors
    of either of the two new line segments intersect the
    interior of the polygon.

    So all one has to do is take the clockwise sides of
    the polygon and check whether the interior of the
    line segment intersects the interior of some side,
    and whether for each polygon side, the line segment
    ends are both on or to the right of the infinite
    line extending the side, and the ends are not both
    on that line.  If the latter is true for all sides,
    the segment is inside the polygon.  During this
    process one checks each convex hull point to see if
    it is in the interior of the line segment, and if it
    is, one then divides the line segment up into two
    segments at the hull point, and then one applies the
    algorithm recursively to see if the interior of
    either of these two segments intersects the interior
    of the polygon.


Problem: Given a set of convex polygons in a plane, and
two points p and q outside any convex polygon, find the
shortest path from p to q that does not go inside any
convex polygon.  Paths may travel on the edges of a
polygon if these are not inside some other polygon.

    Solution: Let V be the set of vertices of the poly-
    gons plus the two points p and q.  Then the path to
    be found can be represented as a sequence of
    straight line segments with vertices in V (proof to
    reader).  So it is a shortest path in an undirected
    graph whose vertices are V such that given points pa
    and pb in V, there is an edge in this undirected
    graph between pa and pb iff the interior of the line
    from pa to pb does not intersect the interior of any
    polygon.  Actually, we can make the computation
    simpler by also deleting an edge from pa to pb if
    the interior of the line from pa to pb contains any
    member of V, as the shortest path can be composed of
    line segments between members of V that do not
    contain other members of V.

Intersect a horizontal infinite line with a non-degener-
ate polygon to produce a set of line segments.  Include
any part of the line that runs along a side of the poly-
gon.

    Consider a scan starting at negative infinity on the
    line and moving along the line to positive infinity.
    The scan is initially in the OUTSIDE state, and as
    it moves, may transition to the INSIDE state and
    back, where OUTSIDE means outside the polygon and
    INSIDE means inside or on the boundary of the poly-
    gon.  The list of transition points is the list of
    line segment ends needed.

    Sort the sides of the polygon by the x coordinate
    at which they cross the horizontal infinite line.
    If a side runs along the line, sort it by its
    minimum coordinate.  Then this is the order these
    sides will be encountered by the scan.

    If the scan encounters a side intersected in its
    interior by the infinite line, this is alwas a
    transition point, and the scan state flips, from
    OUTSIDE to INSIDE or vice versa.

    If the scan encounters a side intersecting at one
    of its ends, i.e., a polygon vertex, life is more
    interesting.  If the vertex is the low x vertex of
    a side running along and parallel to the scan line,
    the scan state becomes INSIDE.  Otherwise if the
    scan has not encountered another side with the same
    end point, the scan must move to the next side in
    the sorted list, which will NOT move the scan along
    its scan line, as the next side will share the end
    point with the current side.  Then when the scan has
    both sides with the end point, and one side is not
    parallel to the scan line, the scan must decide
    whether set its state to INSIDE or OUTSIDE.

    If the sides of the polygon are directed in clock-
    wise order, of the two sides that intersect in a
    common end which is the current scan point, one will
    be incoming and one outgoing.  Let OUT be the
    counterclockwise angle of the outgoing side with
    respect to the positive x-axis, and -IN be the
    counterclockwise angle of the direction reversed in-
    comiong side with respect to the positive x-axis.
    Then -IN != OUT (else the polygon would be
    degenerate), OUT != 0 (else the case where the
    scan is at the low x vertex of a side running along
    the scan line would apply), and IN != 0 (ditto).
    Set the scan state to INSIDE if and only if
    -IN > OUT, and to OUTSIDE if -IN < OUT.

Compute the intersection of two non-degenerate polygons.

    First compute the intersections of polygon sides,
    one side from each polygon, and put these in a list.
    For each intersection, compute an incoming and an
    outgoing polygon side, that indicate the direction
    of travel when the intersection point is used as
    a vertex in an intersection polygon.

    This is easy if all intersections are at the mid-
    points of sides.  Assume this for the moment.

    For each intersection compute its distance DI from
    the origin of its incoming side and the distance
    DO from the origin of its outgoing side.

    Then run the following alogorithm recursively.
    Pick a point from the list of intersections, and
    call it the anchor of a new intersection polygon.
    Make the anchor current.  Then iteratively compute
    a next intersection as follows.  The next intersec-
    tion must have as its incoming side the outgoing
    side of the current intersection.  The distance
    DI of the next intersection must be greater than
    the distance DO of the current intersection.  And
    if there are several qualifying next intersections,
    the one with minimum DI must be choosen.   After
    computing the next intersection, make it current,
    and remove it from the list of intersections.
    Stop if the new current intersection is the anchor.
    The list of current intersections found is another
    intersection polygon.

    Several intersection polygons can be found this way,
    and the process stops when the list of intersections
    is empty.

    The situation is more difficult when a vertex from
    one polygon can be on the boundary of the other
    polygon.  In this case, we conpute intersections by
    considering all pairs of sides, IN and OUT, one from
    each polygon, and ask whether there is an intersec-
    tion with IN as the incoming side and OUT as the
    outgoing side.  There are several cases.

    If IN and OUT do not intersect at all, there is no
    intersection.  If they intersect in their interiors,
    there is an intersection.  If they are parallel,
    the only intersection that needs to be considered is
    the target of IN, and this might be an intersection
    if it is on OUT and not the target of OUT.  Other-
    wise the intersection is a single point that is the
    end of one or both sides.  It must be the target of
    IN or the origin of OUT or both to be a possible
    intersection.

    Possible intersections are screened as follows.  If
    the possible intersection is the target of IN, the
    continuation IN' of IN is the side after IN in the
    clockwise list of sides of IN's polygon.  If the
    possible intersection is not the target of IN, then
    IN' = IN.  Simlarly the continuation of OUT, OUT',
    is the side before OUT in the clockwise list of the
    sides of OUT's polygon, if the possible intersection
    is the origin of OUT.  Otherwise OUT' = OUT.

    Now let IN, IN', OUT, OUT' denote the counterclock-
    wise angles of the directed sides of the same names
    measured from OUT, so OUT = 0.  Let -IN and -OUT'
    be the angles of the sides IN and OUT' with opposite
    direction.  Then -IN != IN' and -OUT' != OUT, else
    the polygons would be degenerate.  Also by defini-
    tion OUT = 0.




Rotate 2D coordinates.

    A clockwise rotation R(theta) of a vector v=(vx,vy)
    by an angle theta is

		   |   cos(theta)   sin(theta) | | vx |
      R(theta).v = |                           | |    |
		   | - sin(theta)   cos(theta) | | vy |

		  |   vx cos(theta) + vy sin(theta) |
		= |                                 |
		  | - vx sin(theta) + vy cos(theta) |

    Most particularly, if theta = 90 degrees, then

		    
			    |  0   1 |
	    R(90 degrees) = |        |
			    | -1   0 |


	    R(90 degrees).v =  (vy,-vx)

Rotate in 2D coordinates.

    The following is the rotation Rz(theta) around the
    z-axis of a vector v=(vx,vy,vz) by an angle theta:

    Rz(theta).v =

           |   cos(theta)   sin(theta)  0 | | vx |
           |                              | |    |
           | - sin(theta)   cos(theta)  0 | | vy | =
           |                              | |    |
	   |   0            0           1 | | vz |

	   |   vx cos(theta) + vy sin(theta) |
	   |                                 |
	   | - vx sin(theta) + vy cos(theta) |
	   |                                 |
	   |               vz                |


    Most particularly, if theta = 90 degrees, then

		
	                 |  0   1  0 |
	                 |           |
	Rz(90 degrees) = | -1   0  0 |
	                 |           |
	                 |  0   0  1 |
	

        Rz(90 degrees).v =  (vy,-vx,vz)

    We can see from this last that the signs of the
    sin(theta) elements of the rotation matrix have been
    chosen so that if the x-axis goes toward your right,
    the z-axis goes up, and the y-axis goes away from
    you, then a rotation with theta > 0 is clockwise
    looking down on the xy-plane.

    One can also write matrices easily for rotations
    about the x-axis or y-axis.  The only issue is
    choosing the signs of the sin(theta) components.
    There are two choices, as the two sin(theta) com-
    ponents always have opposite signs.

A robot arm is a set of line segments connected end to
end, and at the end of each line segment a servo that
can rotate all the segments beyond the servo.  The servo
at the last endpoint can rotate a hand at the end of
the last segment.  The hand is conceptually an ortho-
gonal basis, representable by an orthonormal matrix.
The line endpoints are conceptually just points.

The arm has a home position; e.g., all segments vertical
and the hand aligned with the coordinate system.  In
this home position, each servo is defined by the direc-
tion it can rotate.  In 2D a typical servo can rotate
clockwise or counterclockwise.  In 3D the servo can
rotate around any of the x-, y-, or z- axes.

Compute the locations of the endpoints and orientation
of the hand of a robot.

    The trick is to build the robot from the hand end
    up.  Assume the initial position of the robot is
    vertical with hand oriented along the coordinate
    axes.

    If the robot has no line segments and no servos,
    it has only an end point with a hand, and the hand
    is always oriented along the coordinate axes.  Thus
    the end point is the origin and the hand orientation
    is the unit matrix.

    If we add a servo that has a rotation matrix to the
    origin of the robot, all end points in the robot are
    rotated by the servo matrix, and the hand orientation
    is rotated by multiplying by that matrix.

    If we add a line segment to beginning of the robot,
    all end points in the robot are translated vertically
    by the length of the line segment, and the hand
    orientation does not change.
