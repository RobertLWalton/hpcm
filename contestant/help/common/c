C Help			    Sat Nov 24 07:27:12 EST 2012

C Language Program Structure 
- -------- ------- ---------

Typical program structure including end of file detect-
ion, finding symbols such as `*' that end a string of
numbers, and debugging is:

	// Standard libraries.
	//
	#include <stdlib>
	#include <stdio>   // scanf, printf

	// String and character computation.
	//
	#include <string>
	#include <ctype>

	// Math.
	//
	#include <math>
	#include <limits>
	#include <float>

	// Checking.
	//
	#include <assert>

	int debug;
	#define dprintf if ( debug ) printf

	char line[81];
	    // You can assume lines longer than
	    // 80 characters will not be read by
	    // `gets' below, UNLESS the problem
	    // statement says otherwise.

	int main ( int argc, char * argv[] )
	{
	    // argc - 1 == number of program arguments.
	    //
	    debug = ( argc > 1 );
	    . . . .
	    while ( gets ( line ) )
	    {
		// Print test case name.
		//
	        printf ( "%s\n", line );

		// Read input.
		//
		scanf ( ... );
		. . . . .
		// Read a string of numbers ending
		// in `*'.
		//
		while ( scanf ( "%d...", ... ) != 0 )
		{
		   . . . . .
		}

		// Skip `*' and preceeding whitespace.
		//
		scanf ( " *" );
		. . . . .

		// After reading test case data with
		// scanf, input will be just before the
		// line feed at the end of the test case
		// data.  This must be skipped or else
		// it will be erroneously read as an
		// empty next test case name.  Note:
		// you CANNOT use scanf ("\n") to do
		// this!
		//
		gets ( line );
		    // The line read consists of just a
		    // line feed and is discarded.

		// Compute.
		//
		dprintf ( ... );  // Print if debug.
		. . . . .

		// Output.
		//
		printf ( ... );
	    }

	    // Return 0 from `main' to tell system there
	    // is no error.
	    //
	    return 0;

	}

Input
-----

Input is read from the standard input; you MUST NOT open
any file for input.

Test cases begin with a test case name line that is
read by the first `gets'.  `gets' returns NULL on an
end of file, which is interpreted as `false', so the
outer loop processes one test case at a time.  As soon
as the test case name is successfully read into `line',
it is printed by `printf ( "%s\n", line )'.  All test
case name lines are 80 characters or less, so `line' as
enough room for 80 characters plus a `\0' NUL character
supplied by `gets' to end the input line.

After reading and printing the test case name line, the
rest of the test case data is read with `scanf'.  This
data may consist of numbers, perhaps with a few
characters like `*' thrown in to indicate the end of a
sequence of numbers.  The lines containing numbers may
be very long, so they should be read one number at a
time with `scanf', and NOT read in first with `gets'.
A `*' may be detected by looking at the return value
of `scanf', which is the number of numbers actually
read.  If you are expecting 4 integers or a `*', use
`scanf ( "%d%d%d%d", ... )' which returns 4 if it read
4 integers and 0 if it encountered a `*'.  Then in the
latter case you must skip the `*', which can be done
by `scanf ( " *" )' which skips first the whitespace
between the last number read and the input `*', and
then skips the input `*'.

Floating point numbers can be read by `scanf' by using
%lf instead of %d, and non-numbers can be read by using
%s or %c - see below for synopsis.  Sometimes a problem
will specifically ask you to read lines to be processed
as character strings, in which case use `gets' and be
sure your line buffer is long enough.

Occassionally one has a conflict with some name defined
in the `#include's.  E.g., you may have trouble naming a
global variable `time'.   To fix this, change the name
of your variable.  A simple way of doing this is to put
the following right after the `#include's:

	#define time Time


Output
------

Output is written to the standard output; you MUST NOT
open any file for input; you MUST NOT write to the
standard error output.

Output can be done with printf.  Some formats that may
be useful are "%.3f" to print a double with exactly 3
decimal places in as few columns as possible, "%10.3f"
to do the same in 10 columns padding with spaces on the
left, "%10s" to print a string right adjusted in 10
columns, and "%-10s" to pirnt a string LEFT adjusted in
10 column.  Here the numbers 3 and 10 are merely repre-
sentative, and can be replaced by any other non-zero
positive integer.


Debugging
---------

When your program is executed by the judge, it will
NOT be passed ANY arguments.  One standard debugging
technique is to output extra debugging information if
and only if your program is passed an argument.

The above program defines `debug' to be true if and
only if the program is called with one or more argu-
ments, and defined dprintf to do what printf does if
and only if `debug' is true.  Thus dprintf can be used
to print debugging information.

Debugging is best done with information printed by
`dout', and not with a debugger like `gdb'.  The excep-
tion is debugging programs that crash or go into an
infinite loop, which is best done with a debugger.

It is also a good idea to use `assert' statements
to check that assumptions you have made are valid during
actual program execution.  For example, if you are
certain that scanf should read 3 integers, then instead
of writing

	scanf ( "%d%d%d", ... );

it might be better to write

	assert ( scanf ( "%d%d%d", ... ) == 3 );


Function and Macro Specifications
-------- --- ----- --------------

You can get full documentation of the functions
mentioned above plus other useful information by using
the commands:

	man scanf
	man gets
	man 3 printf
	man assert
	man math.h
	man limits.h
	man float.h

The following is an extract from `man' pages of the
details needed to use the functions mentioned above,
plus some other useful information on number limits.
Here we assume you already know something about how to
use `scanf' and `printf', so we do not have to explain
them from scratch.

Note that an `int' is guarenteed to be at least 32 bits
and a `long long int' is guarenteed to be at least 64
bits.  Floating point computations should always be done
using `double's, and NOT `float's, to avoid having too
little precision.

int scanf ( const char * format, ... )

    Format can contain the following directives:

    %d		Scans an `int' after ignoring any
    		preceeding whitespace.

    %lld	Scans a `long long int' after ignoring
    		any preceeding whitespace.

    %lf		Scans a `double' after ignoring any
    		preceeding whitespace.

    %s		Scans a string of non-whitespace charac-
    		ters, after ignoring any preceeding
		whitespace.

    %c		Scans a single character.  Does NOT
    		ignore preceeding whitespace.

    whitespace	Matches any amount of whitespace,
    		including none.  Line feeds are white-
		space in this sense.

    other	Matches the given character.  E.g., if
    character	`*' is in the format, then `*' must be
    		next in the input if the input is to
		match.  If you want to skip whitespace
		followed by `*', you MUST put " *" and
		NOT just "*" in the format.

    Scanf returns the number of items successfully read
    by %... format directives.  Thus if you are expect-
    ing either a float or a `*', `scanf ( "%llf", ... )'
    will return 1 if a number was found and read, or 0
    if a `*' was found and NOT read.


char * gets ( char * buffer )

    Read characters from the standard input into the
    buffer until a line feed is read.  Replace the line
    feed by a '\0'.  If there are NO characters to be
    read because we are at the end of file, return NULL,
    which can be interpreted as `false'; otherwise
    return buffer, the address of the buffer, which can
    be interpreted as `true'.


int printf ( const char * format, ... )

    Format can contain the following directives, in
    in which W and P stand for sequences of decimal
    digits, where W is used for `widths' and P for
    `precisions':

    %d		Outputs an `int' as a decimal integer
    		with no spaces before or after.

    %Wd		Outputs an `int' as a decimal integer
    		right adjusted in W columns.

    %lld	Outputs a `long long int' as a decimal
    		integer with no spaces before or after.

    %Wlld	Outputs a `long long int' as a decimal
    		integer right adjusted in W columns.

    %f		Outputs a `double' as a floating point
    		number with 6 decimal places and no
		spaces before or after.

    %.Pf	Ditto but with P decimal places instead
    		of 6 decimal places.

    %Wf		Outputs a `double' as a floating point
    		number with 6 decimal places right
		adjusted in W columns.

    %W.Pf	Ditto but with P decimal places instead
    		of 6 decimal places.

    %s		Outputs a `const char *' or `char *'
    		string with no spaces before or after.

    %Ws		Ditto but outputs the string RIGHT
    		adjusted in W columns.

    %-Ws	Ditto but outputs the string LEFT
    		adjusted in W columns.

    %c		Outputs a `char' as an ASCII character
    		with no spaces before or after.
    		

INT_MAX, INT_MIN, LLONG_MAX, LLONG_MIN, DBL_MAX, DBL_MIN

    These are the maximum and minimum numbers that can
    be stored respectively in an `int', `long long int',
    or `double'.  The integer values are from `limits.h'
    and the floating point values from `float.h'.

M_PI, M_E

    The mathematical constants PI and e from math.h.


File:		c
Author:		Bob Walton <walton@seas.harvard.edu>
Date:		See top of file.

The authors have placed this file in the public domain;
they make no warranty and accept no liability for this
file.

RCS Info (may not be true date or author):

    $Author: walton $
    $Date: 2012/11/24 13:40:35 $
    $RCSfile: c,v $
    $Revision: 1.3 $
