C Help			    Thu Oct  4 14:53:08 EDT 2012

Program Structure 
------- ---------

Typical program structure including end of file detect-
ion, finding symbols such as `*' that end a string of
numbers, and debugging is:

	// Standard libraries.
	//
	#include <stdlib>
	#include <stdio>   // scanf, printf

	// String and character computation.
	//
	#include <string>
	#include <ctype>

	// Math.
	//
	#include <math>
	#include <limits>
	#include <float>

	// Checking.
	//
	#include <assert>

	bool debug;
	#define dprintf if ( debug ) printf

	char line[81];
	    // You can assume lines longer than
	    // 80 characters will not be read by
	    // `gets' below, UNLESS the problem
	    // statement says otherwise.

	int main ( int argc, char * argv[] )
	{
	    // argc-1 == number of program arguments.
	    debug = ( argc > 1 );
	    . . . .
	    while ( gets ( line ) )
	    {
	        printf ( "%s\n", line );

		// Read input.
		//
		scanf ( ... );
		. . . . .
		// Read a string of numbers ending
		// in `*'.
		//
		while ( scanf ( "%d...", ... ) != 0 )
		{
		   . . . . .
		}

		// Skip `*' and preceeding whitespace.
		//
		scanf ( " *" );
		. . . . .
		// After reading test case data with
		// scanf, input will be just before the
		// line feed at the end of the test case
		// data.  This must be skipped or else
		// it will be erroneously read as an
		// empty next test case name.  Note:
		// you CANNOT use scanf ("\n") to do
		// this!
		//
		gets ( line );

		// Compute.
		//
		dprintf ( ... );  // Print if debug.
		. . . . .

		// Output.
		//
		printf ( ... );
	    }

	    // Return 0 from `main' to tell system there
	    // is no error.
	    //
	    return 0;

	}

Input
-----

Test cases begin with a test case name line that is
read by the first `gets'.  `gets' returns NULL on an
end of file, which is interpreted as `false', so the
outer loop processes one test case at a time.  As soon
as the test case name is successfully read into `line',
it is printed by `printf ( "%s\n", line )'.  All test
case name lines are 80 characters or less, so `line' as
enough room for 80 characters plus a `\0' NUL character
supplied by `gets' to end the input line.

After reading and printing the test case name line, the
rest of the test case data is read with `scanf'.  This
data may consist of numbers, perhaps with a few
characters like `*' thrown in to indicate the end of a
sequence of numbers.  The lines containing numbers may
be very long, so they should be read one number at a
time with `scanf', and NOT read in first with `gets'.
A `*' may be detected by looking at the return value
of `scanf', which is the number of numbers actually
read.  If you are expecting 4 integers or a `*', use
`scanf ( "%d%d%d%d", ... )' which returns 4 if it read
4 integers and 0 if it encountered a `*'.  Then in the
latter case you must skip the `*', which can be done
by `scanf ( " *" )' which skips first the whitespace
between the last number read and the input `*', and
then skips the input `*'.

Non-numbers can also be read by `scanf'.  Sometimes a
problem will specifically ask you to read lines to be
processed as character strings, in which case use `gets'
and be sure your line buffer is long enough.


Output
------


After reading with `cin >> ...', cin.eof() is true
if and only if an end of file has occurred on cin.
No other error indication is given.  Note that
`cin.eof()' is normally false after successfully
reading some value, as the input is still before
the end of the line containing the value.

Many problems require you to detect certain input
values as end of data markers, instead of looking for
eof.  E.g., the problem might specify that x, y, and z
are all 0 to indicate end of data, in which case you
replace the above `if' statement by

	if ( x == 0 && y == 0 && z == 0 ) break;

Above `dout' behaves just like `cout' except no output
is produced unless your program is called with an
argument.  One must be careful, however, to remember
that `dout' contains an `if' statement and cannot be
followed directly by an `else if'; i.e., the following
will NOT work:

	if (...) dout << ...;
	else if ...

Put {} brackets around `dout << ...;' in this situation.

Debugging is best done with information printed by
`dout', and not with a debugger like `gdb'.  The excep-
tion is debugging programs that crash or go into an
infinite loop, which is best done with a debugger.

It is also a good idea to use `assert' statements
to check that assumptions you have made are valid during
actual program execution.

Include Files
------- -----

The following are typical includes in modern C:


Occassionally one has a conflict with some name defined
in the includes.  E.g., you may have trouble naming a
global variable `time'.   To fix this, change the name
of your variable.  A simple way of doing this is to put
the following right after the includes:

	#define time Time




Numeric Constants
------- ---------

The following code imports useful constants, which are
the minimum and maximum values of various number types,
and the values of PI and E.

    INCLUDE			IMPORTS

    #include <climits>		int INT_MAX;
				int INT_MIN;
				long LONG_MAX;
				long LONG_MIN;
				unsigned long ULONG_MIN;

    #include <cfloat>		double DBL_MAX;
				double DBL_MIN;
				float FLT_MAX;
				float FLT_MIN;

    #include <cmath>		double M_PI;
				double M_E;



Fixed Width Output
------------------

The following is useful for producing fixed width format
numbers.

To output a right adjusted integer I in N columns use:

		cout << setw (N) << I;

Setw sets the width of the next output; but each output
resets this to 0 so you must reset the width just before
outputting each N column number.  The width of 0 means
`use as many columns as necessary'.

To output a right adjusted floating point number F in N
columns with P decimal places use:

    cout << setiosflags ( ios::showpoint | ios::fixed );
    cout << setprecision (P);
    cout << setw (N) << F;

The precision P and flags do not get reset after the
number is output.  They can be reset to defaults by

  cout << resetiosflags ( ios::showpoint | ios::fixed );
  cout << setprecision (6);

Sometimes you are asked to use `0' as a high order fill
character, instead of ` ', or to output in hexadecimal
or octal instead of decimal.  This can be done with

   cout << setfill ('0');     // Set fill character.
   cout << setfill (' ');     // Reset fill character.
   cout << hex;               // Set base to 16.
   cout << dec;               // Set base to 10.
   cout << oct;               // Set base to 8.

To use setw etc. you need to:

    #include <iomanip.h>

You may also need

    using std::setw;
    using std::hex;
    using std::dec;
    using std::setprecision;
    using std::ios;

etc.  However, somewhat counter intuitively

    using std::setiosflags;
    using std::resetiosflags;

are not needed.

To left adjust use

    cout << setw ( my_width )
         << setiosflags ( ios::left )
         << my_string
         << resetiosflags ( ios::left )
	 ...

Character Input
--------- -----

You can use the following for character input:

    int c = cin.get();	// Get next character.
    int c = cin.peek();	// Return next character
    			// without skipping over it.
    cin.putback ( c );	// Put the character c just
    			// obtained by cin.get() back
			// at the beginning of the
			// input.

These return EOF for end of file.


Inputting Lines
--------- -----

To input a line use the getline function, as in 

	char buffer [SOME_SIZE];
	cin.getline ( buffer, sizeof ( buffer ) );

The new line at the end of the line is NOT stored in the
buffer; a NUL character is stored at the end of the line
in the buffer.  Do NOT try to use the `get' function in
place of `getline': its behavior is similar but it does
NOT skip over the new line in the input stream, and
therefore after reading the first line it reads empty
lines forever.

If you use non-line-oriented code to input a value V,
you CANNOT then use `getline' to get a following line,
unless you first skip by the end of line after V.
Failing to do this causes `getline' to read an empty
line, consisting of just the line feed after V.  Typical
correct code is:

	int x;
	cin >> x;	// Does not skip line end.
	while ( cin.get() != '\n' );
	cin.getline ( ... );


Parsing Lines
------- -----

You can parse a line after it is input by code such as

	#include <sstream>
	using std::istringstream;

	istringstream in ( buffer );

Now `in' is an input stream whose input is taken from
the buffer (actually, the input is copied from the
buffer into another buffer internal to the instring-
stream when the latter is created).

Here in.eof() will be true at the end of the string.
This is likely to be a problem because immediately after
reading a number at the end of the buffer in.eof() will
be true.  To compensate, check for eof BEFORE reading
each value by first executing `in >> ws' to skip past
whitespace, then testing in.eof(), and only then reading
the value.  Typical code is:

	in >> ws;
	if ( in.eof() ) break;
	in >> x;


Writing Strings
------- -------

Strings can be written using:

	#include <sstream>
	using std::ostringstream;
	using std::ends;

	ostringstream out;
	. . . out << . . .
	out << ends;
	const char * s = out.str().data();
	cout << s;

Here `out' is an output stream whose output is written
into an INTERNAL buffer (you CANNOT make a stream that
writes into your buffer).  You can get the starting
address of a string that contains the contents of the
internal buffer with `out.str().data()'.  Before doing
this, use `out << ends' to write a NUL into the buffer.

You can also use `cout << out.str()' to write the
internal buffer to `cout' directly, but do NOT use
`out << ends' in this case, as the NUL will be written
to `cout' if you do.


Writing Your Own << And >> Operators
------- ---- --- -- --- -- ---------

It is often convenient to define your own << operator
to output something.  Some examples are:

    using std::ostream;
    ostream & operator <<
	    ( ostream & out, mytype & value )
    {
	. . .
	out << . . .
	. . .
	return out;
    }

Suppose you want to output integers in a distinctive
format.  A simple way is

    struct myformat {
        int value;
	myformat ( int value ) : value ( value ) {}
    };
    ostream & operator <<
	    ( ostream & out, myformat s )
    {
    	out << ( ... s.value ... );
	. . .
	return out;
    }
    . . .
    cout << myformat ( 99 );

Here we have invented a typed structure to encapsulate
the value when it is to be printed.  Note the argument
to << may NOT be `myformat & s' because here s is not
constant, and in use the `myformat' value is a temporary
and temporaries are read-only.  However, the argument
may be `const myformat & s'.

Input operators can be define by:

    using std::istream;
    istream & operator >>
	    ( istream & in, mytype & value )
    {
	. . .
	in >> . . .
	. . .
	return in;
    }


STL API Documentation
--- --- ------------

Standard Template Library (STL) API documentation is
usually available on-line during a formal contest.  The
command to access it is:

	stlhelp

In a formal contest, you should NOT use other means to
access such documentation, as using the internet is a
violation of formal contest rules.


Function and Macro Specifications
-------- --- ----- --------------

The following is an extract from `man' pages of the
details needed to use the functions mentioned above.
Here we assume you already know something about how to
use `scanf' and `printf', so we do not have to explain
them from scratch.

scanf ( const char * format, ... )

    Format can contain the following directives:

    %d		Scans an `int' after ignoring any
    		preceeding whitespace.

    %lld	Scans a `long long int' after ignoring
    		any preceeding whitespace.

    %lf		Scans a `double' after ignoring any
    		preceeding whitespace.

    %s		Scans a string of non-whitespace charac-
    		ters, after ignoring any preceeding
		whitespace.

    %c		Scans a single character.  Does NOT
    		ignore preceeding whitespace.

    whitespace	Matches any amount of whitespace,
    		including none.

    other	Matches the given character.  E.g., if
    character	`*' is in the format, then `*' must be
    		next in the input if the input is to
		match.  If you want to skip whitespace
		followed by `*', you MUST put ` *' and
		NOT just `*' in the format.

    Scanf returns the number of items successfully read
    by %... format directives.



File:		c
Author:		Bob Walton <walton@seas.harvard.edu>
Date:		See top of file.

The authors have placed this file in the public domain;
they make no warranty and accept no liability for this
file.

RCS Info (may not be true date or author):

    $Author: walton $
    $Date: 2012/11/21 07:51:32 $
    $RCSfile: c,v $
    $Revision: 1.1 $
