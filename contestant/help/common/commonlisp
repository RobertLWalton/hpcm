Commonlisp Help		    Mon Feb 11 02:59:08 EST 2013


Commonlisp Language Program Stucture
---------- -------- ------- --------

Typical program structure including end of file detect-
ion, finding symbols such as `*' that end a string of
numbers, and debugging is:

    (defvar *debug* (rest *posix-argv*))

    (defun dformat (&rest r)
      (if *debug* (apply #'format t r)))

    (defvar *line*)

    ; Main loop
    ;
    (loop while (setf *line* (read-line nil nil)) do

      ; Print test case name.
      ;
      (format t "~A~%" *line*)

      (let token

        ; Read input.
	;
	(setf token (read))
        . . . . .

	; Read a string of integers ending in `*'.
	;
	(loop while (numberp (setf token (read)))
	  do
	  . . . . .)

	; Skip `*'.
	;
	(assert (equal token '*))

	; After reading the last token of a line, read
	; throws away the whitespace character that
	; terminated the token, and this disposes of
	; the line feed that ends the last line of at
	; test case.

	; Compute.

	(dformat ... )  ; Print if debug.
	. . . . .

	; Output.

	(format t ... )

    ))

All too frequently one has a conflict between a defvar
or defun defined name and a name already defined by
the COMMONLISP standard, and will get an error message
about trying to redefine a name that is already defined
in the `COMMON-LISP' package (this error message may
mention a `lock' on the COMMON-LISP package).  There are
two ways around this: changing your name, or shadowing.
One good rule is to always begin and end defvar names
with `*', so we use `*debug*' which is not defined by
the standard, instead of `debug' which IS defined by the
standard.  Shadowing is done as follows:

    (shadow 'error)
    (defun error ...)

Without the `shadow' the defun will fail because it
tries to redefine the COMMON-LISP package symbol
`ERROR'.  You should be aware, however, that shadowing
is not a good solution when writing large packages of
commercial code, as one tends to forget what one has
shadowed and get confused code.  But this is not the
situation of a programming contest solution where you
are working in the default COMMON-LISP-USER package
(which imports the COMMON-LISP package).


Input
-----

Input is read from the standard input; you MUST NOT open
any file for input.

You may assume that input is correctly formatted, except
for the rare problem where you are told to produce
special output if the input contains a formatting error.
Do not waste time checking for input errors when you do
not have to.

Test cases begin with a test case name line that is
read by the `(read-line nil nil)'.  The extra arguments
`nil nil' cause read-line to return nil on an end of
file, so the outer loop above processes one test case at
a time.  As soon as the test case name is successfully
read into `*line*', it is printed by `(format t "~A"
*line*)'.  Notice that this is the only read statement
that has the extra `nil t' arguments, as it is the only
one where you expect to have an end of file.

After reading and printing the test case name line, the
rest of the test case data is read with `read'.  This
data may consist of numbers, perhaps with a few
characters like `*' thrown in to indicate the end of a
sequence of numbers.  The non-numbers read as symbols.

See the `summer' demonstration problem solution which
reads numbers.

For some problems there are no test case name lines but
instead each test case has one input line containing
text and one output line containing text.  For these
the test case input line is read the same way as the
test case name line is read above.

See the `reverser' demonstration problem solution which
reads text lines.

Sometimes it is necessary to read input one character
at a time.  This is done with code like

    (defvar *NUL* (code-char 0))
    . . . .
    (setf c (read-char nil t *NUL*))

in which `read-char' reads one character and returns
that character or returns *NUL* on end of file.  Another
useful function call is

    (setf c (peek-char t nil t *NUL*))

which skips whitespace and returns the next character
WITHOUT skipping that character in the input.  *NUL*
is returned on end of file.

See the `vcalc' demonstration problem solution which
reads characters one at a time.


Output
------

Output is written to the standard output; you MUST NOT
open any file for output; you MUST NOT write to the
standard error output.

In general, to be correct your program must produce
EXACTLY the one and only correct sequence of output
characters.  The main exception is that when floating
point numbers are output with a given number of decimal
places, you are permitted to output numbers which differ
from other correct output by one unit in the last
decimal place.  You must use the correct upper or lower
case and use only a single space character as a separa-
tor unless instructed to line things up in columns.

Output can be written with `(format t ...)' using the
`~A' format to print non-numbers.  Some other useful
formats are "~,3F" to print a number with exactly 3
decimal places in as few columns as possible, "~10,3F"
to print the number right adjusted in 10 columns, "~10A"
to print a string right adjusted in 10 columns, and
"~10@A" to print a string LEFT adjusted in 10 columns.
Here the numbers 3 and 10 are merely representative, and
can be replaced by any other non-zero positive integers.

See the `summer' demonstration problem solution which
outputs floating point `double's.


Execution
---------

We use `Steel Bank Commonlisp', sbcl.  The Makefile
entry for .lsp file in the problem `pppp' directory
creates the file `pppp' whose contents are

	#! /bin/sh
	exec sbcl --script pppp.lsp

which compiles and evaluates the `pppp.lsp' COMMONLISP
code file.


Debugging
---------

When your program is executed by the judge, it will
NOT be passed ANY arguments.  A standard debugging
technique is to output extra debugging information if
and only if your program is passed an argument.

The above program defines `debug' to be true if and
only if the program is called with one or more argu-
ments, and defines dprintf to do what printf does if
and only if `debug' is true.  Thus dprintf can be used
to print debugging information.

Debugging is best done with information printed by
`dformat', and not with the builtin lisp debugger.  The
exception is debugging programs that crash or go into
an infinite loop, which is best done with the debugger
and with the program running in non-compiled interpre-
tive mode.  A special program, `ldebug', makes this
easier: see `help ldebug' for details.

It is also a good idea to use `assert' statements
to check that assumptions you have made are valid during
actual program execution.  For example, if you are
certain that the next thing to be read is a number,
instead of writing

    (setf n (read))

it might be better to write

    (assert (numberp (setf n (read))))

See the `summer' demonstration problem solution which
uses dformat and assert.


Function and Macro Synopsis
-------- --- ----- --------

You can get full documentation of the functions
mentioned above plus other useful information by using
the UNIX commands:

	man scanf
	man fgets
	man getchar
	man 3 printf
	man assert
	man math.h
	man limits.h
	man float.h

The following is an extract from `man' pages of details
needed to use the functions mentioned above, and also a
few numeric constants.  Here we assume you already know
something about how to use `scanf' and `printf', so we
do not have to explain them from scratch.

Note that an `int' is guaranteed to be at least 32 bits
and a `long long int' is guaranteed to be at least 64
bits.  Floating point computations should always be done
using `double's, and NOT `float's, to avoid having too
little precision.

int scanf ( const char * format, ... )

    Format can contain the following directives:

    %d		First skips whitespace.  Then if this is
    		followed by non-whitespace with the
		format of an `int', reads the `int'.

    %lld	Ditto but for `long long int' instead of
    		`int'.

    %lf		Ditto but for `double' instead of `int'.

    %s		Ditto but for a string of non-whitespace
    		characters, instead of `int'.

    %c		Reads a single character.  Does NOT skip
    		preceding whitespace.

    whitespace	Skips any amount of whitespace, includ-
    		ing none.  Line feeds are whitespace in
		this sense.

    other	Skips just the given character.  E.g.,
    character	if `*' is in the format, then `*' must
    		be next in the input if the input is to
		move forward.  If you want to skip
		whitespace followed by `*', you MUST put
		" *" and NOT just "*" in the format.

    Scanf returns the number of items successfully read
    by %... format directives.  Thus if you are expect-
    ing either a float or a `*', `scanf ( "%lf", ... )'
    will return 1 if a number was found and read, or 0
    if a `*' was found and NOT read.  Note that if it
    returns 0 it will have skipped the whitespace before
    the `*', so the `*' will be next.


char * fgets ( char * buffer, sizeof ( buffer ), stdin )

    Read characters from the standard input into the
    buffer until a line feed is read and stored, and
    then store a '\0' in the buffer.  If there are NO
    characters to be read because we are at the end of
    file, return NULL, which can be interpreted as
    `false'; otherwise return the address of the buffer,
    which can be interpreted as `true'.

    Note: `fgets' as it is used above is similar to
    `gets ( buffer )', but the `gets' function has been
    `deprecated', meaning that implementations need not
    and eventually will not support it.

int c = getchar()
ungetc ( c, stdin )
    getchar() reads one character from the standard
    input stream, or the special constant EOF (typically
    defined to be -1) if at end-of-file.  If c is the
    character just read by getchar(), then the call
    ungetc ( c, stdin ) backups up one character in the
    standard input, so c will be re-read by the next
    getchar().  Ungetc CANNOT reliably be called several
    times in a row to back over more than one character
    at a time.

int printf ( const char * format, ... )

    Format can contain the following directives, in
    in which W and P stand for sequences of decimal
    digits, where W is used for `widths' and P for
    `precisions':

    %d		Outputs an `int' as a decimal integer
    		with no spaces before or after.

    %Wd		Outputs an `int' as a decimal integer
    		right adjusted in W columns.

    %lld	Outputs a `long long int' as a decimal
    		integer with no spaces before or after.

    %Wlld	Outputs a `long long int' as a decimal
    		integer right adjusted in W columns.

    %f		Outputs a `double' as a floating point
    		number with 6 decimal places and no
		spaces before or after.

    %.Pf	Ditto but with P decimal places instead
    		of 6 decimal places.

    %Wf		Outputs a `double' as a floating point
    		number with 6 decimal places right
		adjusted in W columns.

    %W.Pf	Ditto but with P decimal places instead
    		of 6 decimal places.

    %s		Outputs a `const char *' or `char *'
    		string with no spaces before or after.

    %Ws		Ditto but outputs the string RIGHT
    		adjusted in W columns.

    %-Ws	Ditto but outputs the string LEFT
    		adjusted in W columns.

    %c		Outputs a `char' as an ASCII character
    		with no spaces before or after.
    		

INT_MAX, INT_MIN, LLONG_MAX, LLONG_MIN, DBL_MAX, DBL_MIN

    These are the maximum and minimum numbers that can
    be stored respectively in an `int', `long long int',
    or `double'.  The integer values are from `limits.h'
    and the floating point values from `float.h'.

M_PI, M_E

    The mathematical constants PI and e from math.h.


File:		c
Author:		Bob Walton <walton@seas.harvard.edu>
Date:		See top of file.

The authors have placed this file in the public domain;
they make no warranty and accept no liability for this
file.

RCS Info (may not be true date or author):

    $Author: walton $
    $Date: 2013/02/11 18:58:45 $
    $RCSfile: commonlisp,v $
    $Revision: 1.9 $

sbcl --eval '(setf *evaluator-mode* :interpret)' --load reverser.lsp <sample.in

File:		commonlisp
Author:		Bob Walton <walton@deas.harvard.edu>
Date:		See top of file.

The authors have placed this file in the public domain;
they make no warranty and accept no liability for this
file.

RCS Info (may not be true date or author):

    $Author: walton $
    $Date: 2013/02/11 18:58:45 $
    $RCSfile: commonlisp,v $
    $Revision: 1.9 $
