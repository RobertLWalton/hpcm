JAVA Help		    Fri Jan 11 11:56:11 EST 2013


JAVA Language Program Structure 
---- -------- ------- ---------

Typical program structure including end of file detect-
ion, finding symbols such as `=' that end a string of
numbers, and debugging is:

    import java.util.Scanner;

    public class PPP {
        // Here PPP is the program name and this code
	// is in the PPP.java file.

	static boolean debug = false;

	static Scanner scan = new Scanner ( System.in );

	// printf ( format, ... ) prints output using
	// the given format with ... representing the
	// format controlled arguments.
	//
	static void printf
		( String format, Object ... args )
	{
	    System.out.format ( format, args );
	}

	// Ditto but suppress if debug == false.
	//
	static void dprintf
		( String format, Object ... args )
	{
	    if ( debug )
		System.out.format ( format, args );
	}

	static class MyClass {
	    // If you define classes, remember to make
	    // them static.
	    //
	    . . . . .
	}

	public static void main ( String[] args )
	{
	    debug = ( args.length > 0 );

	    while ( scan.hasNextLine() )
	    {
		// Read and print test case name if
		// there is one.
		//
		String testcasename = scan.nextLine();
		System.out.println ( testcasename );

		// Read a number and process a number
		// if there is one.  WARNING: number
		// must be terminated by whitespace.
		//
		if ( scan.hasNextDouble() )
		{
		    double d = scan.nextDouble();
		    . . . . .
		    . . . Math.sin . . . Math.PI . . .
		}

		// Check that next thing is ZZZ.
		// WARNING: ZZZ must be terminated by
		// whitespace.
		//
		assert ( scan.next().equals ( "ZZZ" ) );

		// Skip line feed at end of line.
		// Needed because we must be at a line
		// beginning when we start the next test
		// case.
		//
		scan.nextLine();

		. . . . .

		// Debugging output.
		//
		dprintf ( ... );

		// Output.
		//
		printf ( "XXX %.6f XXX", ... );
		System.out.println ( ... + ... + ... );
		    // Numbers printed with println or
		    // print may use exponential nota-
		    // tion.

	    }
	}
    }


Remember that the main class of a program must have the
same name as the program, and also that everything
declared directly within this class, including sub-
classes, must be `static.

It is fairly common for JAVA programs that run well for
the contestant to crash when run by the judge.  The
usual cause is judge's input data that triggers an ex-
ception not observed with contestant's input data.  The
best debugging strategy is to type into the PPP.in file
a lot of legal input data that might break the program,
so your program will be run against it by `make submit'
and you will observe any crash before you submit.


Input
-----

Input is read from the standard input, System.in; you
MUST NOT open any file for input.

Test cases begin with a test case name line checked for
by Scanner `hasNextLine' and read by `nextLine'.  As
soon as the test case name is successfully read it is
printed by `System.out.println'.

After reading and printing the test case name line, the
rest of the test case data is read with Scanner
functions such as `next', `hasNextDouble' `nextDouble',
etc.  WARNING: this assumes that input tokens are
delimited by whitespace.  Dealing with delimiters other
that whitespace is tricky if the delimiters are also
important input, and one method of doing so is described
in the Delimiter Tokens section below.

Data may consist of numbers, perhaps with a non-number
tokens like `*' thrown in to indicate the end of a
sequence of numbers.  The lines containing numbers may
be very long, so they should be read one number at a
time and not read as a line.

See the `io/summer' demonstration problem solution which
reads numbers.

For some problems there are no test case name lines but
instead each test case has one input line containing
text and one output line containing text.  For these
the test case input line is read the same way as the
test case name line is read above.

See the `io/reverser' demonstration problem solution
which reads text lines.



Output
------

Output is written to the standard output, System.out;
you MUST NOT open any file for output; you MUST NOT
write to the standard error output.

Output can be written using System.out.print{ln} and the
+ string concatenation operator, or it can be written
using System.out.format.  The latter is necessary if
numbers must be written with decimal places, as convera-
ting numbers to Strings with + may produce numbers in
exponential notation.  Some formats that may be useful
are "%.3f" to print a double with exactly 3 decimal
places in as few columns as possible, "%10.3f" to print
the double right adjusted in 10 columns, "%10s" to print
a string right adjusted in 10 columns, and "%-10s" to
print a string LEFT adjusted in 10 columns.  Here the
numbers 3 and 10 are merely representative, and can be
replaced by any other non-zero positive integers.

When using System.out.format, use "%n" to output an
end-of-line.

See the `io/summer' demonstration problem solution which
outputs floating point `double's.


Debugging
---------

When your program is executed by the judge, it will
NOT be passed ANY arguments.  A standard debugging
technique is to output extra debugging information if
and only if your program is passed an argument.

The above program defines `debug' to be true if and
only if the program is called with one or more argu-
ments, and defines dprintf to do what System.out.
format does if and only if `debug' is true.  Thus
dprintf can be used to print debugging information.

Debugging is best done with information printed by
`dprintf', and not with a debugger.  In JAVA, crashes
usually give the line number where the fault occurred,
so using the debugger may not be necessary for crashes.
As the standard jdb debugger is difficult to use
directly, a special program is provided to run it if
you must: see `help jdebug' file.  This is of most use
if your program goes into an infinite loop or crashes.

It is also a good idea to use `assert' statements
to check that assumptions you have made are valid during
actual program execution.  For example, if you expect
the next input token to be "ZZZ" you can use

	assert ( scan.next().equals ( "ZZZ" ) );

In our environment JAVA is run with assert statement
execution enabled (by the -ae option to the `java(1)'
interpreter), so you can count on assert statements
executing (which would not be true in other programming
environments).

See the `io/summer' demonstration problem solution which
uses dprintf and assert.


Delimiter Tokens
--------- ------

If you want to use characters like `,' to delimit
numbers, but also want to make `,' into a token, you
have to use findWithinHorizon and some care.  The
following code makes `,', `(', `)', `:', and end-of-line
(represented by `\n') into both delimiters and
tokens.  The code also provides a means of determining
whether a token String represents a number and extract-
ing that number.

    import java.util.Scanner;
    import java.util.regex.Pattern;

    public class PPP {

	static Scanner s =
	    new Scanner ( System.in ).useDelimiter
	        ( "[ \t\f,():\n]+" );
	static Pattern p =
	    Pattern.compile ( "\\G[ \t\f]*([,():\n])" );

	// Return next token or null if end of file.
	//
	static String get_token ( void )
	{
	    String token = s.findWithinHorizon ( p, 0 );
	    if ( s != null )
	        token = s.match().group ( 1 );
	    else if ( s.hasNext )
	        token = s.next();
	    return token;
	}

	// Return Double if string is a number, or null
	// if not.  doubleValue() of the Double returns
	// the number proper.
	//
	Double get_number ( String s )
	{
	    try { return Double.valueOf ( s ); }
	    catch ( NumberFormatException e )
	        { return null; }
	}

The call to findWithinHorizon looks to see if the input
is just before whitespace within a line followed by one
of the characters `,', `(', `)', `:', or `\n'.  If so
non-null is returned and the call to s.match().group(1)
extracts just the last character of the match.  Groups
are delimited by () parentheses in the pattern regular
expression, so group 1 in this case matches `([,():\n])'
in the regular expression.  If there is no match, then
hasNext() is called to see if there is a next token
delimited by the delimiter specified by useDelimiter,
and if yes next() is called to get the token, or if no
then the token is left as null.  If a token is gotten,
get_number can be used to decide if the token is a
number and extract the number if yes.

See the `algorithms/vcalc' demonstration problem
solution which implements delimiters that are also
tokens.


Function and Macro Synopsis
-------- --- ----- --------

You can get full documentation of the functions mention-
ed above plus other useful information from your favor-
ite web site if you are permitted to use the web, or in
the case of ACM programming contests, from the
`javahelp' command that accesses local documentation.
Some useful classes are

	String
	Scanner
	Formatter
	Math
	Double

The following is an extract from JAVA documentation of
details needed to use common functions and numeric
constants.  Here we assume you already know something
about how to use the above classes so we do not have to
explain them from scratch.

Note that an `int' is guaranteed to be at least 32 bits
and a `long' is guaranteed to be at least 64 bits.
Floating point computations should always be done
using `double's, and NOT `float's, to avoid having too
little precision.

import java.util.Scanner;
import java.util.regex.Pattern;
Scanner s = new Scanner ( System.in );
Pattern p = Pattern.compile ( "\\G[ \t\f]*([,():\n])" );

    s.hasNextLine()   Returns true iff nextLine() will
    		      not raise an exception.
    s.nextLine()      Returns a String consisting of all
    		      input up to the next line end, and
		      skips that input and the line end.

    s.hasNextDouble() Returns true iff nextDouble(),
    s.hasNextInt()    nextInt(), or nextLong() will not
    s.hasNextLong()   raise an exception.

    s.nextDouble()    Returns next token which must be a
    s.nextInt()       number as a double, int, or long.
    s.nextLong()      Number must be delimited by white-
    		      space (if useDelimiter not used).

    s.hasNext()	      Returns true if next() will not
    		      raise an exception.
    s.next()	      Returns next token.  Token is a
    		      non-empty String delimited by
		      whitespace (if useDelimiter not
		      used).

    s.useDelimiter ( "[ \t\f\n,():]+" )
	Reset token delimiter to a regular expression.
	The example given makes whitespace and the
	characters `,', `(', `)', `:' delimiters.

    s.findWithinHorizon ( p, 0 )
        Return next String matching the Pattern p if
	such exists, or null otherwise.  For the
	example pattern above, to get a match the
	input must consist of within line whitespace
	followed by one of the characters `,', `(', `)',
	`:', or end of line (\n).
    s.match().group ( 1 )
        Return as a String the part of the last find-
	WithinHorizon matched string that matches the
	first () parenthesized group within the pat-
	tern's regular expression.  If our example
	pattern is used, one of ",", "(", ")", ":", or
	"\n" will be returned.

    Double.valueOf ( s )
        Returns Double containing numeric double value
	represented by String s, or if s does not
	represent a `double' number, raises the
	NumberFormatException.

    Double.valueOf(s).doubleValue()
        Returns the double numeric value represented by
	String s, or if s does not represent a `double'
	number, raises the NumberFormatException.
                    
System.out.format ( format, ... )

    Format is a String that can contain the following
    directives, in in which W and P stand for sequences
    of decimal digits, where W is used for `widths' and
    P for `precisions':

    %d		Outputs an `int' or `long' as a decimal
                integer with no spaces before or after.

    %Wd		Outputs an `int' or `long' as a decimal
                integer right adjusted in W columns.

    %f		Outputs a `double' as a floating point
    		number with 6 decimal places and no
		spaces before or after.

    %.Pf	Ditto but with P decimal places instead
    		of 6 decimal places.

    %Wf		Outputs a `double' as a floating point
    		number with 6 decimal places right
		adjusted in W columns.

    %W.Pf	Ditto but with P decimal places instead
    		of 6 decimal places.

    %s		Outputs a String (or char[]) with no
    		spaces before or after.

    %Ws		Ditto but outputs the String RIGHT
    		adjusted in W columns.

    %-Ws	Ditto but outputs the String LEFT
    		adjusted in W columns.

    %c		Outputs a `char' as UNICODE characters
    		with no spaces before or after.
    		
import java.text.DecimalFormat;
DecimalFormat d =
    new DecimalFormat ( "0.###############" );

    d.format ( n )
        Returns the number n converted to a string.
	Given d as above, the result will have up to
	15 decimal places with fraction low order 0's
        suppressed, unlike the %.15f format which does
	not suppress low order 0's.


Integer.MAX_VALUE, Integer.MIN_VALUE, Long.MAX_VALUE,
Long.MIN_VALUE, Double.MAX_VALUE, Double.MIN_VALUE.

    These are the maximum and minimum numbers that can
    be stored respectively in an `int', `long', or
    `double'.

Math.PI, Math.E
Math.abs, Math.sin, Math.cos, Math.atan2, Math.exp.

    The mathematical constants PI and e, and typical
    math functions.  These must have the `Math.'
    prefix.




File:		java
Author:		Bob Walton <walton@deas.harvard.edu>
Date:		See top of file.

The authors have placed this file in the public domain;
they make no warranty and accept no liability for this
file.

RCS Info (may not be true date or author):

    $Author: walton $
    $Date: 2013/01/11 18:35:20 $
    $RCSfile: java,v $
    $Revision: 1.15 $
