JAVA Help		    Tue Jan  8 02:54:51 EST 2013


JAVA Language Program Structure 
---- -------- ------- ---------

Typical program structure including end of file detect-
ion, finding symbols such as `=' that end a string of
numbers, and debugging is:

    import java.util.Scanner;

    public class PPP {

	static boolean debug = false;

	static Scanner scan = new Scanner ( System.in );

	// printf ( format, ... ) prints output using
	// the given format with ... representing the
	// format controlled arguments.
	//
	static void printf
		( String format, Object ... args )
	{
	    System.out.format ( format, args );
	}

	// Ditto but suppress if debug == false.
	//
	static void dprintf
		( String format, Object ... args )
	{
	    if ( debug )
		System.out.format ( format, args );
	}

	static class MyClass {
	    . . . . .
	}

	public static void main ( String[] args )
	{
	    debug = ( args.length > 0 );

	    while ( scan.hasNextLine() )
	    {
		// Read and print test case name if
		// there is one.
		//
		String testcasename = scan.nextLine();
		System.out.println ( testcasename );

		// Read a number and process a number
		// if there is one.  WARNING: number
		// must be terminated by whitespace.
		//
		if ( scan.hasNextDouble() )
		{
		    double d = scan.nextDouble();
		    . . . . .
		    . . . Math.sin . . .
			// Math functions do not need
			// import but must be prefaced
			// by `Math.'.
		}

		// Check that next thing is ZZZ.
		// WARNING: ZZZ must be terminated by
		// whitespace.
		//
		assert ( scan.next().equals ( "ZZZ" ) );

		// Skip line feed at end of line.
		// Needed because we must be at a line
		// beginning when we start the next test
		// case.
		//
		scan.nextLine();

		. . . . .

		// Debugging output.
		//
		dprintf ( ... );

		// Output.
		//
		printf ( ... );
		System.out.println ( ... + ... + ... );

	    }
	}
    }


Remember that the main class of a program must have the
same name as the program, and also that everything
declared directly within this class, including subclasses,
must be `static'.

It is fairly common for JAVA programs that run well for
the contestant to crash when run by the judge.  The
usual cause is judge's input data that triggers an ex-
ception not observed with contestant input data.  The
best debugging strategy is to type into the PPPP.in file
a lot of legal input data that might break the program,
so your program will be run against it by `make submit'
and you will observe any crash.


Input
-----

Input is read from the standard input; you MUST NOT open
any file for input.

Test cases begin with a test case name line checked for
by Scanner `hasNextLine' and read by `nextLine'.  As
soon as the test case name is successfully read it is
printed by `System.out.println'.

After reading and printing the test case name line, the
rest of the test case data is read with Scanner
functions such as `next', `hasNextDouble' `nextDouble',
etc.  WARNING: this assumes that input tokens are
delimited by whitespace.  Dealing with delimiters other
that whitespace is tricky if the delimiters are also
important input, and one method of doing so is described
in the Delimiter Tokens section below.

Data may consist of numbers, perhaps with a non-number
tokens like `*' thrown in to indicate the end of a
sequence of numbers.  The lines containing numbers may
be very long, so they should be read one number at a
time and not read as a line.

See the `summer' demonstration problem solution which
reads numbers.

For some problems there are no test case name lines but
instead each test case has one input line containing
text and one output line containing text.  For these
the test case input line is read the same way as the
test case name line is read above.

See the `reverser' demonstration problem solution which
reads text lines.



Output
------

Output is written to the standard output; you MUST NOT
open any file for output; you MUST NOT write to the
standard error output.

Output can be written using System.out.print{ln} and the
+ string concatenation operator, or it can be written
using System.out.format.  The latter is better if
numbers must be written with specific numbers of decimal
places.  Some formats that may be useful are "%.3f" to
print a double with exactly 3 decimal places in as few
columns as possible, "%10.3f" to print the double right
adjusted in 10 columns, "%10s" to print a string right
adjusted in 10 columns, and "%-10s" to print a string
LEFT adjusted in 10 columns.  Here the numbers 3 and 10
are merely representative, and can be replaced by any
other non-zero positive integers.

When using System.out.format, use "%n" to output an
end-of-line.

See the `summer' demonstration problem solution which
outputs floating point `double's.


Debugging
---------

When your program is executed by the judge, it will
NOT be passed ANY arguments.  A standard debugging
technique is to output extra debugging information if
and only if your program is passed an argument.

The above program defines `debug' to be true if and
only if the program is called with one or more argu-
ments, and defines dprintf to do what System.out.
format does if and only if `debug' is true.  Thus
dprintf can be used to print debugging information.

Debugging is best done with information printed by
`dprintf', and not with a debugger.  In JAVA, crashes
usually give the line number where the fault occured,
so using the debugger is not required even for crashes.
As the standard jdb debugger is difficult to use
directly, a special program is provided to run it if
you must: see `help jdebug' file.

It is also a good idea to use `assert' statements
to check that assumptions you have made are valid during
actual program execution.  For example, if you expect
the next input token to be "ZZZ" you can use

	assert ( scan.next().equals ( "ZZZ" ) );

Java is run with assert statement execution enabled
(by the -ae option to the `java(1)' interpreter), so
you can count on assert statements executing (which
would not be true in other programming environments).

See the `summer' demonstration problem solution which
uses dprintf and assert.

Delimiter Tokens
--------- ------

If you want to use characters like `,' to delimit
numbers, but also want to make `,' into a token, you
have to use findWithinHorizon and some care.  The
following code makes `,', `(', `)', and end-of-line
(represented by `\n') into both delimiters and
tokens.  The code also provides a means of determining
whether a token String represents a number and extract-
ing that number.

    import java.util.Scanner;
    import java.util.regex.Pattern;

    public class PPP {

	static Scanner s =
	    new Scanner ( System.in ).useDelimiter
	        ( "[ \t\f,()\n]+" );
	static Pattern p =
	    Pattern.compile ( "\\G[ \t\f]([,():\n])" );

	// Return next token or null if end of file.
	//
	static String get_token ( void )
	{
	    String token = s.findWithinHorizon ( p, 0 );
	    if ( s != null )
	        token = s.match().group ( 1 );
	    else if ( s.hasNext )
	        token = s.next();
	    return token;
	}

	// Return Double if string is a number, or null
	// if not.  doubleValue() of the Double returns
	// the number proper.
	//
	Double get_number ( String s )
	{
	    try { return Double.valueOf ( s ); }
	    catch ( NumberFormatException e )
	        { return null; }
	}

The call to findWithinHorizon looks to see if the input
is just before whitespace other than end-of-line
followed by one of the characters `,', `(', `)', or
`\n'.  If so, non-null is returned and the call to
s.match().group(1) extracts the substring that matched
just the one character.  Groups are delimited by ()
parentheses in the pattern regular expression, so the
group in this case matches `([,():\n])' in the regular
expression.  If there is no match, then hasNext() is
called to see if there is a next token delimited by the
delimiter specified by useDelimiter, and if yes next()
is called to get the token, or if no then the token is
left as null.


Function and Macro Synopsis
-------- --- ----- --------

You can get full documentation of the functions
mentioned above plus other useful information by from
your favorite web site if you are permitted to use it,
or in the case of ACM programming contests, from the
`javahelp' command that accesses local documentation.
Some useful classes are

	String
	Formatter
	Hashtable
	Double
	Math

The following is an extract from JAVA documentation of
details needed to use common functions and numeric
numeric constants.  Here we assume you already know
something about how to use the above classes so we
do not have to explain them from scratch.

Note that an `int' is guaranteed to be at least 32 bits
and a `long' is guaranteed to be at least 64 bits.
Floating point computations should always be done
using `double's, and NOT `float's, to avoid having too
little precision.

import java.util.Scanner;
import java.util.regex.Pattern;
Scanner s = new Scanner ( System.in );
Pattern p = Pattern.compile ( "\\G[ \t\f]([,():\n])" );

    s.hasNextLine()   Returns true iff nextLine() will
    		      not raise an exception.
    s.nextLine()      Returns a String consisting of all
    		      input up to the next line end, and
		      skips that input and the line end.

    s.hasNextDouble() Returns true iff nextDouble(),
    s.hasNextInt()    nextInt(), nextLong() will not
    s.hasNextLong()   raise an exception.

    s.nextDouble()    Returns next token which must be a
    s.nextInt()       number as a double, int, or long.
    s.nextLong()      Number must be delimited by white-
    		      space (if useDelimiter not used).

    s.hasNext()	      Returns true if next() will not
    		      raise and exception.
    s.next()	      Returns next token.  Token is a
    		      non-empty String delimited by
		      whitespace (if useDelimiter is not
		      used).

    s.useDelimiter ( "[ \t\f\n,():]+" )
	Reset token delimiter to a regular expression.
	The example given makes whitespace and the
	characters `,', `(', `)', `:' delimiters.

    s.findWithinHorizon ( p, 0 )
        Return next String matching the Pattern p if
	such exists, or null otherwise.  For the
	example pattern above, to get a match the
	input must consist of whitespace other than
	end of line followed by one of the characters
	`,', `(', `)', `:', or end of line (\n).
    s.match().group ( 1 )
        Return as a String the part of the last find-
	WithinHorizon matched string that matches the
	first () parenthesized group within the pat-
	tern's regular expression.  If our example
	pattern is used, one of ",", "(", ")", or "\n"
	will be returned.

                    
System.out.format ( format, ... )

    Format is a String that can contain the following
    directives, in in which W and P stand for sequences
    of decimal digits, where W is used for `widths' and
    P for `precisions':

    %d		Outputs an `int' or `long' as a decimal
                integer with no spaces before or after.

    %Wd		Outputs an `int' or `long' as a decimal
                integer right adjusted in W columns.

    %f		Outputs a `double' as a floating point
    		number with 6 decimal places and no
		spaces before or after.

    %.Pf	Ditto but with P decimal places instead
    		of 6 decimal places.

    %Wf		Outputs a `double' as a floating point
    		number with 6 decimal places right
		adjusted in W columns.

    %W.Pf	Ditto but with P decimal places instead
    		of 6 decimal places.

    %s		Outputs a String (or char[]) with no
    		no spaces before or after.

    %Ws		Ditto but outputs the String RIGHT
    		adjusted in W columns.

    %-Ws	Ditto but outputs the String LEFT
    		adjusted in W columns.

    %c		Outputs a `char' as UNICODE characters
    		with no spaces before or after.
    		

Integer.MAX_VALUE, Integer.MIN_VALUE, Long.MAX_VALUE,
Long.MIN_VALUE, Double.MAX_VALUE, Double.MIN_VALUE.

    These are the maximum and minimum numbers that can
    be stored respectively in an `int', `long', or
    `double'.

Math.PI, Math.E
Math.abs, Math.sin, Math.cos, Math.atan2, Math.exp.

    The mathematical constants PI and e, and typical
    math functions.  These must have the `Math.'
    prefix.




File:		java
Author:		Bob Walton <walton@deas.harvard.edu>
Date:		See top of file.

The authors have placed this file in the public domain;
they make no warranty and accept no liability for this
file.

RCS Info (may not be true date or author):

    $Author: walton $
    $Date: 2013/01/10 09:40:55 $
    $RCSfile: java,v $
    $Revision: 1.13 $
