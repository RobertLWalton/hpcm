Algorithm Festival Help	    Mon Mar  4 04:15:51 EST 2013


Introduction
------------

An algorithm festival is a low-key not too competitive
programming contest in which teams of 3 students try to
solve programming problems that are simplified versions
of real-world problems.  Teams may enter in either of
two categories, novice or experienced, according to
their prior experience with programming contests.

Teams get accounts days before the contest and can use
their accounts to practice on demonstration problems.
On the day of the contest teams congregate at one of
several host sites, and at 10am the phase I problems
are handed out and work begins.  From noon till 1pm
all programming is suspended to have lunch, during which
teams may talk with other teams or anyone else about
the problems, as long as they talk in person and do not
access their accounts or reference code printouts.  At
1pm the phase II problems are handed out and teams
resume work on either phase I or phase II problems.  The
results as of 4pm are used to award prizes - and teams
may wish to quit then, but in fact teams can continue to
work on the problems using their accounts for weeks
afterwards, for fun or education, as they wish.

Solutions are submitted to an autojudge, which runs test
cases against the solutions, and grades the solutions
correct or not.  If not, the autojudge returns to the
submitter the input and output of the first failed test
case, and the submitter loses 5% of the submitter's
remaining score on the problem.  The maximum score,
obtainable if the submitter's first submission for the
problem is correct, varies with the difficulty of the
problem, but is typically 100 or 200.  The autojudge is
monitored by human judges and maintains a complete audit
trail of its actions in case it misbehaves.

Only one terminal may be logged into a team account
during the contest period, in order to encourage team
members to program cooperatively.  Teams may consult the
web using other terminals or their one terminal,
however.  A printer will be available.


Honor Rules
----- -----

During the 10am to 4pm contest period teams are on their
honor not to log more than one terminal into their
account, not to read other team printouts that appear at
a common printer, and not to communicate with anyone
except team members and official host site advisers,
except during lunch.  Teams are on their honor not to
access accounts or read code printouts of themselves or
other teams during lunch.

Of course purely personal communications not about
contest details are exempt from these rules.


Your Account
---- -------

You will be given an account name and a password, and
the festival will have a web page which points at help
files.  You can look at the `terminals' help file to
get advice on logging in.

Here are some help files that may be of use:

    terminals
        Gives information about making extra terminal
	windows.

    print
        Gives information about printing files.

    c
    c++
    java
    commonlisp
	For each programming language you might use (C,
	C++, JAVA, COMMONLISP), there is a help file
	that gives information about how to structure
	your program and do input/output in the contest
	environment.

    algorithms
        Lists the algorithm help files and explains how
	to print them on the contest printer.

In your account a non-algorithmic help file xxx can be
displayed by the `help xxx' command, and the `help'
command gives an index of available non-algorithm help
files.  Algorithmic help files are pdf files and must
be displayed or printed from the web or as described in
the `algorithms' help file.

As soon as you are logged in, you should get and test
the demo problems as described below.


What Problems?
--------------

Problems are solved in problem directories.  When you
are first logged in, these do not yet exist.  You have
to get them by executing

	hpcm_get

Before the contest starts this will just get problem
directories for demo problems.  The directory for a demo
problem named `pppp' is named `~/demos/pppp'.  Problem
directories are where you write your solutions, and they
each contain an important file named `Makefile' that
defines operations you will need in order to solve and
submit the problem.  Solutions to the demo problems are
put by `hpcm_get' into the `~/demos/solutions' direc-
tory.  You can display an index of demo problems with
the `help demos' command.

You should test the contest tools on the demo problems
before the contest starts.  You can copy solutions from
`demos/solutions' to demo problem directories and try
submitting them (see below for how to do this).

Then after the contest starts at 10 am you need to exe-
cute `hpcm_get' AGAIN, JUST ONCE, to get all the problem
directories for Phase I.  A contest problem with name
`pppp' has a directory named `~/problems/pppp'.  You can
display an index of contest problems with the `help
problems' command.

Lastly, after 1pm you need to execute `hpcm_get' ONE
MORE TIME, to add all the Phase II problem directories
to your account.


Asking Questions
----------------

There are advisers at your host site who will answer
questions.  If you are an `experienced' team, answers to
questions about particular problems are restricted to
just pointing at help files or other documentation, or
giving keywords for web search.  If you are an `novice'
team, the advisers will give you as brief an answer as
they can that will get you unstuck from whatever
difficulty you are having.

You can use the web or printed materials to try to
answer your questions.  You can access the web from any
computer, not just the one logged into your account.

During lunch, you can ask any questions, get any
answers, from anyone, but, of course, only on Phase I
problems, and during lunch you must not access accounts
or read code printouts.


Working on a Problem
--------------------

For a problem named `pppp' you should write a file named
`pppp.c', `pppp.cc', `pppp.java', or `pppp.lsp' in your
`~/problems/pppp' directory.  The suffix of the file you
write determines the programming language you are using:

	.c 	for C		   see `help c'
	.cc	for C++		   see `help c++'
	.java	for JAVA	   see `help java'
	.lsp	for COMMONLISP	   see `help commonlisp'

You must write only ONE of these files; you CANNOT have
a solution in two different languages at once.  For each
language there is a language specific help file detail-
ing how to write solutions in that language.  For
example, use the `help java' command for how to write
solutions in JAVA.

After you write your program, execute the `make' command
in the problem directory.  This will compile your pro-
gram, create a file named `pppp.in', run your program
with `pppp.in' as input and `pppp.out' as output, and
display `pppp.out'.  You can test this by copying a
solution from `~/demos/solutions' into some demonstra-
tion problem directory `~/demos/pppp' and running `make'
and then `make test' in that directory.  Initially
`pppp.in' is a copy of `sample.in' in the problem direc-
tory, and if your program is correct, the `pppp.out'
produced should be essentially the same as the file
`sample.test' in the problem directory.

The `make test' command will make a file `pppp.test'
that is a copy of `sample.test', and then display the
difference between `pppp.test' and `pppp.out'. You can
then edit additional test data into `pppp.in' and run
`make', and after verifying the output you can copy
`pppp.out' to `pppp.test', so that whenever you change
your program you can use `make test' to check that it
has not changed previously correct results.  Also,
when you have an incorrect submission, the judge will
return to you the input and output of the judge's first
failed test case.  Add these respectively to `pppp.in'
and `pppp.test' and use `make test' to test.


Make Commands
---- --------

The full set of `make' commands you can execute in a
problem directory is:

    make
    	Same as `make pppp.out' (see below).

    make pppp
    	Makes the binary program file `pppp' by running
	gcc on pppp.c, or g++ on pppp.cc, or javac on
	pppp.java, etc.  Does nothing if `pppp' is more
	up to date than pppp.c, pppp.cc, etc.

	In addition to making `pppp', other files may be
	made for some languages, e.g., pppp.class for
	JAVA.

    make pppp.in
	If the file pppp.in does NOT already exist and
	the file sample.in does exist, this copies
	sample.in to pppp.in and makes the copy writable
	(editable) so you can add to pppp.in.  If
	pppp.in already exists this does nothing (even
	if sample.in is more recent than pppp.in).

	sample.in is the `Sample Input' from the problem
	description.

    make pppp.out
	Makes `pppp' and `pppp.in' as above and then
	runs pppp with standard input coming from the
	file pppp.in.  Puts the standard output in the
	file pppp.out, and also copies that to the
	screen.  Also outputs any standard error output
	to the screen.  Does nothing, however, if
	pppp.out is more recent than both pppp.in and
	pppp.

    make pppp.debug
	Ditto but runs `pppp debug' instead of `pppp'
	and puts the standard output in the file
	`pppp.debug' instead of `pppp.out'.  You should
	write your program to output debugging
	information to the standard output if the
	program is given any arguments.

    make debug	Same as `make pppp.debug'.

    make submit
	Makes `pppp.out' just to be sure that nothing
	crashes, and then e-mails pppp.c, pppp.cc,
	pppp.java, or pppp.lsp to the judges.  Note the
	pppp.in file MUST exist to submit (in order to
	make pppp.out), but pppp.in can be the minimum
	needed to keep your program from crashing.

    make pppp.test
	If the file pppp.test does NOT already exist and
	the file sample.test does exist, this copies
	sample.test to pppp.test and makes the copy
	writable (editable) so you can add to pppp.test.
	If pppp.test already exists this does nothing
	(even if sample.test is more recent than
	pppp.test).

	sample.test is the `Sample Output' from the
	problem description.

    make test
    	Makes pppp.out and pppp.test as above and then
	displays their differences using the command
	`diff -u pppp.out pppp.test'.  If the files are
	copies of sample.in and sample.test, they should
	be essentially the same, but need not be exactly
	the same: see the `scores' help file.

    make clean
        Removes `pppp', pppp.out, pppp.debug,
	pppp.class, etc.

The `make' UNIX commands work because of the way the
`Makefile' file in the problem directory is written.
The `Makefile' file contains some oddities resulting
from the fact that judges, who use the same `Makefile'
as contestants, run solutions in a sandbox account that
has permission problems accessing judge's files. 


Resource Limits
-------- ------

Problems intended for novice teams do not have important
resource limits, but problems intended for experienced
teams often have limits that require solutions to be
time and space efficient.

If you look at the `Makefile' in the problem directory
you will see that it contains memory and time resource
limits which constrain your problem.  Memory limits
are typically a few tens of megabytes and time limits
are typically 10 to 30 seconds.


Scoring
-------

Solutions are submitted to an autojudge, which runs test
cases against the solutions, grades the solutions cor-
rect or not, and returns an email to the submitter con-
taining the grade.  If incorrect, the email includes the
input and output of the judge's first failed test case,
and a little bit of other information that can be inter-
preted by using `help scores'.  For an incorrect submis-
sion the submitter loses 5% of the submitter's remaining
score on the problem.  The maximum score, obtainable if
the submitter's first submission for the problem is cor-
rect, varies with the difficulty of the problem, but is
typically 100 or 200.  The autojudge is monitored by a
human judge and maintains a complete audit trail of its
actions in case it misbehaves.

For incorrect submissions, the judge's return email will
contain the judge's input and output for the first
failed test case.  You should add these to your pppp.in
and pppp.test files and continue debugging your program.
For a correct solution the email will contain the
judge's solution for you to look at, either in the
same programming language you used, or in the language
most related to that for which the judge has a solution.

The `scoreboard' command displays the scoreboard which
contains an entry for each account and problem.  The
entry is `.....' if the account has not submitted any
solution for the problem, `.../N' if the account has
submitted N incorrect solutions, and `SSS/N' if the
account has submitted a correct solution and N previous
incorrect solutions, where SSS is the problem score, and
is equal to `MMM * 0.95^N' where MMM is the maximum
possible score for the problem.

The account with the highest total score (sum of scores
of all problems the account solved) is the best account.
Account scores are reported in the form TTT/P where TTT
is the sum of solved problem scores and P is the number
of problems solved by the account.

If the scoreboard is too long for its display window,
you can scroll down and up with the down and up arrow
keys.  If the scoreboard changes the display will be
updated and will go back to the top of the scoreboard.

There are actually two scoreboards, one for novice teams
and one for experienced teams.  You can display the
scoreboard that is NOT your team's by the commands
`scoreboard novice' and `scoreboard experienced'.


Prizes
------

Prizes are awarded to the members of high placing
teams.  Prizes are awarded separately in the novice
and experienced categories.  A list of prizes for
a particular contest is given on the contest web
page.

A prize consists of computer related books orderable
from the web whose total value including shipping does
not exceed a given amount.  If you win a prize, you will
be contacted via email by a prize granter, who will ask
you to find on the web the books you want to order.  The
granter will then order the books for you and have them
sent directly to you.  No money will be sent, even
though the book and shipping contest may be less than
the prize amount.

Though the prizes are small, you may be surprised by
the number of high quality computer science books
available cheaply as used books at sites like

	www.abebooks.com
	www.amazon.com

If you want advice about which books are good for a
particular computer science topic, the granter will
either give such advice or solicit advice from others
knowledgeable in the topic.


File:		algorithm_festival
Author:		Bob Walton <walton@seas.harvard.edu>
Date:		See top of file.

The authors have placed this file in the public domain;
they make no warranty and accept no liability for this
file.

RCS Info (may not be true date or author):

    $Author: walton $
    $Date: 2013/03/04 17:15:21 $
    $RCSfile: algorithm_festival,v $
    $Revision: 1.12 $
