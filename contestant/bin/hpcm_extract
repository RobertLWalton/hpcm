#!/bin/sh
#
# Extract files from mail.
#
# File:		hpcm_extract
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Mon Oct  9 11:44:47 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/10/10 04:39:57 $
#   $RCSfile: hpcm_extract,v $
#   $Revision: 1.5 $

# Print documentation if -... argument.
#
case "$1" in
    -*)
	echo "
hpcm_extract [directory]

    Reads mail from the standard input and extracts
    files in mail sent by HPCM in response to \`get'
    requests.  More specifically, any files surrounded
    by lines beginning with:

	---<>--<>---<>--<>---<>-----

    are extracted, if the last line beginning with

    	Subject:

    before the file is of the form:

    	Subject: RE: get ...

    The extracted files are placed in the directory
    specified by the single argument, or if no argument
    is given, by the directory specified by the
    \`HPCM_HOME' environment variable, or if that is
    also unset, in the account home directory \`~'.  If
    a file already exists in that directory, it is not
    extracted, but is compared against the existing
    file.

    The standard output records what was done.  It
    does not include the file contents."

	exit 1
	;;
esac

# Compute directory into which to place files.
#
if test "$1" != ""
then
    home="$1"
else
    home="${HPCM_HOME:-~}"
fi

if test ! -d "$home"
then
    echo "ERROR: \`$home' is not a directory."
    exit 0
fi

# Mode is one of:
#
#	header		Look for Subject: lines
#	extract		Extract lines
#	diff		Diff lines
#	skip		Skip lines (due to error)
#	look		Look at the current line
#			to choose between header,
#			extract, or diff.
#
mode=header
subject_ok=no
subject=
From=
from=
date=

# Loop through lines of stdin.
#
while test x = x
do
    # Read puts line in '$REPLY' and sets '$?' non-zero
    # iff there is an eof.
    #
    read -r

    if test $? -ne 0
    then
        if test $mode != header
	then
	    # Create fake missing end of file.
	    #
	    echo "ERROR: missing end of file line."
	    has_errors=yes
REPLY="---<>--<>---<>--<>---<>----- end of file"
	else
	    # Real end of file, end loop.
	    #
	    break
	fi
    fi

    case $mode in

    header)
        # For headers, save parts of header.
	#
    	case "$REPLY" in

	From\ *)
	    From="$REPLY"
	    from=
	    date=
	    subject=
	    subject_ok=no
	    ;;

	From:*)
	    from="$REPLY"
	    ;;

	Date:*)
	    date="$REPLY"
	    ;;

	Subject:*)
	    subject="$REPLY"
	    # Set subject_ok according to whether
	    # subject is `get ...'
	    #
	    SUBJECT="[Ss][Uu][Bb][Jj][Ee][Cc][Tt]"
	    WS="[ 	]*"
	    RE="[Rr][Ee]"
	    GET="[Gg][Ee][Tt]"
	    ok=`expr "$REPLY" : \
		"${SUBJECT}:${WS}${GET}" `
	    if test $ok -ne 0
	    then
	    	subject_ok=yes
	    else
	    	subject_ok=no
	    fi
	    ;;

	'---<>--<>---<>--<>---<>-----'*)
	    # Start of file.  Print header of a new
	    # message containing the output of hpcm_
	    # extract.
	    #
	    if test "$From" != ""
	    then echo "$From"; fi
	    if test "$from" != ""
	    then echo "$from"; fi
	    if test "$date" != ""
	    then echo "$date"; fi
	    if test "$subject" != ""
	    then echo "$subject"; fi
	    echo "X-HPCM-Subject:" \
		 "output of hpcm_extract"
	    echo ""
	    mode=look
	    has_errors=no
	    ;;
	esac
    	;;

    extract)
    	case "$REPLY" in
	'---<>--<>---<>--<>---<>-----'*)
	    # End of file being extracted.  Close fd 3.
	    #
	    exec 3>&-
	    echo "\`$file' extracted successfully."
	    mode=look
	    ;;
	*)
	    # Line in file being extacted.
	    #
	    echo "$REPLY" >&3
	    ;;
	esac
    	;;

    diff)
    	case "$REPLY" in
	'---<>--<>---<>--<>---<>-----'*)
	    # End of file being diffed.  Close fd 3.
	    #
	    exec 3<&-
	    if test $diff = yes
	    then
		echo ""
	    	echo "WARNING: received new \`$file'"
		echo "that is different" \
		     "from previous version."
		echo "Left previous version intact."
		echo ""
		has_errors=yes
	    else
		echo "\`$file' matched existing" \
	             "\`$home/$file'."
	    fi
	    mode=look
	    ;;
	*)
	    # Line in file being diffed.
	    #
	    line="$REPLY"
	    read -r <&3
	    if test "$REPLY" != "$line"
	    then
	    	diff=yes
	    fi
	    ;;
	esac
    	;;

    skip)
    	case "$REPLY" in
	'---<>--<>---<>--<>---<>-----'*)
	    # End of file being skipped.
	    #
	    mode=look
	    ;;
	esac
    	;;
    esac

    case $mode in
    look)
        # Line in $REPLY begins with `---<>...'.

        # Extract file name from line.
	#
        file=`expr "$REPLY" : \
	     '---<>--<>---<>--<>---<>-----\(.*\)$' `
	file=`expr "$file" : \
		   '[ 	]*\([^ 	].*\)$' `
	file=`expr "$file" : \
		   '\(.*[^ 	]\)[ 	]*$' `
	case "$file" in
	*:)
	    file=`expr "$file" : \
		       '\(.*\):$' `
	    ;;
	esac

	if test "$file" = "end of files"
	then
	    if test $has_errors = no
	    then
	    	echo NO ERRORS IN EXTRACTION
	    fi
	    echo ""
	    mode=header
	elif test $subject_ok = no
	then
	    mode=skip
	else

	    # Make directories required by file name.
	    # Note $file = "end of files" requires no
	    # directories.
	    #
	    dirs=""
	    dir=`dirname "$file"`
	    while test "$dir" != "."
	    do
		dirs="$dir $dirs"
		dir=`dirname "$dir"`
	    done

	    for dir in $dirs
	    do
		if test -d "$home/$dir"
		then do_nothing=
		elif mkdir "$home/$dir"
		then
		    echo "\`$home/$dir' made" \
		         "successfully."
		else
		    echo "ERROR: could not make" \
		         "\`$home/$dir'."
		    has_errors=yes
		    break
		fi
	    done

	    if test -r "$home/$file"
	    then
		if exec 3<"$home/$file"
		then
		    mode=diff
		    diff=no
		else
		    echo "ERROR: could not read" \
		         "\`$home/$file'."
		    has_errors=yes
		    mode=skip
		fi
	    elif test ! -e "$home/$file"
	    then
		if exec 3>"$home/$file"
		then
		    mode=extract
		else
		    echo "ERROR: could not write" \
		         "\`$home/$file'."
		    has_errors=yes
		    mode=skip
		fi
	    else
		echo "ERROR: unreadable" \
		     "\`$home/$file' already exists."
		mode=skip
		has_errors=yes
	    fi
	fi
    	;;
    esac
done

exit 0
