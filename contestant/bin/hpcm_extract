#!/bin/sh
#
# Extract files from mail.
#
# File:		hpcm_extract
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Sat Sep 30 06:18:17 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/09/30 12:09:38 $
#   $RCSfile: hpcm_extract,v $
#   $Revision: 1.2 $

# Print documentation if no argument or -... argument.
#
case "$1" in
    "" | -*)
	echo "
hpcm_extract directory

    Reads mail from the standard input and extracts
    files in the mail that were sent by HPCM in response
    to \`get' requests.  More specifically, any files
    surrounded by lines beginning with:

	---<>--<>---<>--<>---<>-----

    are extracted, if the last line beginning with

    	Subject:

    before the file is of the form:

    	Subject: RE: get ...

    The extracted files are placed in the directory
    specified by the single argument.  If a file
    already exists in that directory, it is not
    extracted, but is compared against the existing
    file.

    The standard output records what was done.  It
    does not include the file contents."

	exit 1
	;;
esac

# Mode is one of:
#
#	header		Look for Subject: lines
#	extract		Extract lines
#	diff		Diff lines
#	look		Look at the current line
#			to choose between header,
#			extract, or diff.
#
mode=header
subject_ok=no
subject=
From=
from=
date=

# Loop through lines of stdin.
#
while test x = x
do
    # Read puts line in '$REPLY' and sets '$?' non-zero
    # iff there is an eof.
    #
    read

    if test $? -ne 0
    then
        if test $mode != header
	then
	    # Create fake missing end of file.
	    #
	    echo "Missing end of file line."
	    has_errors=yes
REPLY="---<>--<>---<>--<>---<>----- end of file"
	else
	    # Real end of file, end loop.
	    #
	    break
	fi
    fi

    case $mode in

    header)
        # For headers, save parts of header.
	#
    	case "$REPLY" in
	From\ *)
	    From="$REPLY"
	    from=
	    date=
	    subject=
	    ;;
	From:*)
	    from="$REPLY"
	    ;;
	Date:*)
	    date="$REPLY"
	    ;;

	Subject:*)
	    subject="$REPLY"
	    # Set subject_ok according to whether
	    # subject is `get ...'
	    #
	    ok=`expr "$REPLY" : "Subject:[ 	]*get" `
	    if test $ok -ne 0
	    then
	    	subject_ok=yes
	    else
	    	subject_ok=no
	    fi
	    ;;

	'---<>--<>---<>--<>---<>-----'*)
	    # Start of file.  Print header of a new
	    # message containing the output of hpcm_
	    # extract.
	    #
	    if test "$From" != ""
	    then echo "$From"; fi
	    if test "$from" != ""
	    then echo "$from"; fi
	    if test "$date" != ""
	    then echo "$date"; fi
	    if test "$subject" != ""
	    then echo "$subject"; fi
	    echo "X-HPCM-Subject:" \
		 "output of hpcm_extract"
	    echo ""

	    mode=look
	    has_errors=no
	    ;;
	esac
    	;;

    extract)
    	case "$REPLY" in
	'---<>--<>---<>--<>---<>-----'*)
	    # End of file being extracted.  Close fd 3.
	    #
	    exec 3>&-
	    mode=look
	    ;;
	*)
	    # Line in file being extacted.
	    #
	    echo "$REPLY" >&3
	    ;;
	esac
    	;;

    diff)
    	case "$REPLY" in
	'---<>--<>---<>--<>---<>-----'*)
	    # End of file being diffed.  Close fd 3.
	    #
	    exec 3<&-
	    if test $diff = yes
	    then
	    	echo "Received new $file"
		echo "that is different" \
		     "from previous version."
		echo "Left previous version intact."
		has_errors=yes
	    fi
	    mode=look
	    ;;
	*)
	    # Line in file being diffed.
	    #
	    line="$REPLY"
	    read <&3
	    if test "$REPLY" != "$line"
	    then
	    	diff=yes
	    fi
	    ;;
	esac
    	;;

    skip)
    	case "$REPLY" in
	'---<>--<>---<>--<>---<>-----'*)
	    # End of file being skipped.
	    #
	    mode=look
	    ;;
	esac
    	;;
    esac

    case $mode in
    look)
        file=`expr "$REPLY" : \
	     '---<>--<>---<>--<>---<>-----\(.*\)$' `
	file=`expr "$file" : \
		   '[ 	]*\([^ 	].*\)$' `
	file=`expr "$file" : \
		   '\(.*[^ 	]\)[ 	]*$' `
	case "$file" in
	*:)
	    file=`expr "$file" : \
		       '\(.*[^ 	]\):$' `
	    ;;
	esac

	dirs=""
	dir=`dirname "$file"`
	while test "$dir" != "."
	do
	    dirs="$dir $dirs"
	    dir=`dirname "$dir"`
	done

	for dir in $dirs
	do
	    if test ! -d "$1/$dir"
	    then
		mkdir "$1/$dir"
		if test $? -ne 0
		then
		    echo "Could not make $1/$dir."
		    has_errors=yes
		fi
	    fi
	done

	if test "$file" = "end of files"
	then
	    if test $has_errors = no
	    then
	    	echo NO ERRORS IN EXTRACTION
	    fi
	    echo ""
	    mode=header
	elif test ! -d "$1";
	then
	    mode=skip
	    echo "$1 is not a directory."
	    has_errors=yes
	elif test -r "$1/$file"
	then
	    mode=diff
	    diff=no
	    exec 3<"$1/$file"
	elif test ! -e "$1/$file"
	then
	    mode=extract
	    exec 3>"$1/$file"
	else
	    mode=skip
	    echo "Unreadable $1/$file already exists."
	    has_errors=yes
	fi
    	;;
    esac
done

exit 0
