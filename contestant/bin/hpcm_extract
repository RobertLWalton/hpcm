#!/bin/sh
#
# Extract files from mail.
#
# File:		hpcm_extract
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Wed Sep 12 04:58:23 EDT 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/09/12 18:07:42 $
#   $RCSfile: hpcm_extract,v $
#   $Revision: 1.10 $

# If this is not bash and bash is available, switch
# to using bash.  Note that `which bash` may output
# a grubby error message and no error code if bash
# does not exist.
#
bash=`which bash 2>&1`
if test "$BASH" = "" -a -x "$bash"
then
    exec bash "$0" "$@"
fi

# Print documentation if -... argument.
#
case "$1" in
    -*)
	echo "
hpcm_extract [directory]

    Reads mail from the standard input and extracts
    files in mail sent by HPCM in response to \`get'
    requests.  More specifically, any files surrounded
    by lines beginning with:

	---<>--<>---<>--<>---<>-----

    are extracted, if the last line beginning with

    	Subject:

    before the file is of the form:

    	Subject: get ...

    Note that this line will NOT be the subject line of
    the reply message, but the subject line of the
    request message that is quoted in the reply message
    just before the files: the difference being that
    there is no \` RE:' in the request message subject.

    The extracted files are placed in the directory
    specified by the single argument, or if no argument
    is given, by the directory specified by the
    \`HPCM_HOME' environment variable, or if that is
    also unset, in the account home directory \`~'.  If
    a file already exists in that directory, it is not
    extracted, but is compared against the existing
    file.

    The standard output records what was done.  It
    does not include the file contents.  The standard
    output is formatted as one or more email messages
    that can be stored in a mailbox or piped into a
    mailer program such as UNIX \`procmail'."

	exit 1
	;;
esac

# Compute directory into which to place files.
#
if test "$1" != ""
then
    home="$1"
else
    home="${HPCM_HOME:-$HOME}"
fi

if test ! -d "$home"
then
    echo "ERROR: \`$home' is not a directory."
    exit 1
fi

# Mode is one of:
#
#	header		Look for Subject: lines
#	extract		Extract lines
#	diff		Diff lines
#	skip		Skip lines (due to error)
#	look		Look at the current line
#			to choose between header,
#			extract, or diff.
#
mode=header
subject_ok=no
subject=
From=
from=
date=

# Loop through lines of stdin.
#
while test x = x
do
    # Read puts line in '$REPLY' and sets '$?' non-zero
    # iff there is an eof.
    #
    read -r

    if test $? -ne 0
    then
        if test $mode != header
	then
	    # Create fake missing end of file.
	    #
	    echo "ERROR: missing end of file line."
	    has_errors=yes
REPLY="---<>--<>---<>--<>---<>----- end of file"
	else
	    # Real end of file, end loop.
	    #
	    break
	fi
    fi

    case $mode in

    header)
        # For headers, save parts of header.
	#
    	case "$REPLY" in

	From\ *)
	    From="$REPLY"
	    from=
	    date=
	    subject=
	    subject_ok=no
	    ;;

	From:*)
	    from="$REPLY"
	    ;;

	Date:*)
	    date="$REPLY"
	    ;;

	Subject:*)
	    subject="$REPLY"
	    # Set subject_ok according to whether
	    # subject is `get ...'.  This Subject
	    # line is not that of the message proper,
	    # but it that quoted in the message
	    # just before the files.  Thus there is
	    # no ` RE:' in this subject.
	    #
	    SUBJECT="[Ss][Uu][Bb][Jj][Ee][Cc][Tt]"
	    WS="[ 	]*"
	    GET="[Gg][Ee][Tt]"
	    ok=`expr "$REPLY" : \
		"${SUBJECT}:${WS}${GET}" `
	    if test $ok -ne 0
	    then
	    	subject_ok=yes
		subject=`expr "$REPLY" : \
		              "${SUBJECT}:"'\(.*\)$' `
		subject="Subject: RE:$subject"
	    else
	    	subject_ok=no
	    fi
	    ;;

	'---<>--<>---<>--<>---<>-----'*)
	    # Start of file.  Print header of a new
	    # message containing the output of hpcm_
	    # extract.
	    #
	    if test "$From" != ""
	    then echo "$From"; fi
	    if test "$from" != ""
	    then echo "$from"; fi
	    if test "$date" != ""
	    then echo "$date"; fi
	    if test "$subject" != ""
	    then echo "$subject"; fi
	    echo "X-HPCM-Subject:" \
		 "output of hpcm_extract"
	    echo ""
	    mode=look
	    has_errors=no
	    ;;
	esac
    	;;

    extract)
    	case "$REPLY" in
	'---<>--<>---<>--<>---<>-----'*)
	    # End of file being extracted.  Close fd 3.
	    #
	    exec 3>&-
	    echo "\`$file' extracted successfully."
	    mode=look
	    ;;
	*)
	    # Line in file being extacted.
	    #
	    echo "$REPLY" >&3
	    ;;
	esac
    	;;

    diff)
    	case "$REPLY" in
	'---<>--<>---<>--<>---<>-----'*)
	    # End of file being diffed.  Close fd 3.
	    #
	    exec 3<&-
	    if test $diff = yes
	    then
		echo ""
	    	echo "WARNING: received new \`$file'"
		echo "that is different" \
		     "from previous version."
		echo "Left previous version intact."
		echo ""
		has_errors=yes
	    else
		echo "\`$file' matched existing" \
	             "\`$home/$file'."
	    fi
	    mode=look
	    ;;
	*)
	    # Line in file being diffed.
	    #
	    line="$REPLY"
	    read -r <&3
	    if test "$REPLY" != "$line"
	    then
	    	diff=yes
	    fi
	    ;;
	esac
    	;;

    skip)
    	case "$REPLY" in
	'---<>--<>---<>--<>---<>-----'*)
	    # End of file being skipped.
	    #
	    mode=look
	    ;;
	esac
    	;;
    esac

    case $mode in
    look)
        # Line in $REPLY begins with `---<>...'.

        # Extract file name from line.
	#
        file=`expr "$REPLY" : \
	     '---<>--<>---<>--<>---<>-----\(.*\)$' `
	file=`expr "$file" : \
		   '[ 	]*\([^ 	].*\)$' `
	file=`expr "$file" : \
		   '\(.*[^ 	]\)[ 	]*$' `
	case "$file" in
	*:)
	    file=`expr "$file" : \
		       '\(.*\):$' `
	    ;;
	esac

	case "$file<$subject_ok>" in

	"end of files<yes>" )
	    if test $has_errors = no
	    then
	    	echo NO ERRORS in extraction
	    fi
	    echo ""
	    mode=header
	    ;;

	"end of files<no>" )
	    echo BAD SUBJECT: no files extracted
	    echo ""
	    mode=header
	    ;;

	*"<no>" )
	    mode=skip
	    ;;

	"<yes>" )
	    echo WARNING: empty file name
	    has_errors=yes
	    mode=skip
	    ;;

	/* | .* | */.* | -* | */-* )
	    echo WARNING: illegal file name \
	                  '(skipped):' "$file"
	    has_errors=yes
	    mode=skip
	    ;;

	*"<yes>" )

	    # Make directories required by file name.
	    #
	    dirs=""
	    dir=`dirname "$file"`
	    while test "$dir" != "."
	    do
		dirs="$dir $dirs"
		dir=`dirname "$dir"`
	    done

	    for dir in $dirs
	    do
		if test -d "$home/$dir"
		then do_nothing=
		elif mkdir "$home/$dir"
		then
		    echo "\`$home/$dir' made" \
		         "successfully."
		else
		    echo "ERROR: could not make" \
		         "\`$home/$dir'."
		    has_errors=yes
		    break
		fi
	    done

	    if test -r "$home/$file"
	    then
		if exec 3<"$home/$file"
		then
		    mode=diff
		    diff=no
		else
		    echo "ERROR: could not read" \
		         "\`$home/$file'."
		    has_errors=yes
		    mode=skip
		fi
	    elif test ! -e "$home/$file"
	    then
		if exec 3>"$home/$file"
		then
		    mode=extract
		else
		    echo "ERROR: could not write" \
		         "\`$home/$file'."
		    has_errors=yes
		    mode=skip
		fi
	    else
		echo "ERROR: unreadable" \
		     "\`$home/$file' already exists."
		mode=skip
		has_errors=yes
	    fi
	    ;;
	esac
    	;;
    esac
done

exit 0
