# TCL Parameters File for Judging
#
# File:		hpcm_judging.rc
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Oct  3 09:36:51 EDT 2005
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2005/10/03 13:50:11 $
#   $RCSfile: hpcm_judging.rc,v $
#   $Revision: 1.157 $

# Table of Contents:
#
#	About This File
#	Problem .rc Files
#	Scoreboard Parameters
#	Web Page Parameters
#	Scoring Parameters
#	Response Instructions
#	Submission Parameters
#	Logging Parameters
#	Info Parameters
#	Display Parameters
#	Maintenance Parameters
#	Functions that Call the Operating System

# About This File
# ----- ---- ----
#
# An optionally modified copy of this file must be
# placed in (or symbolically linked into) the current
# directory of an executing judging program, or one
# of the ancestors (parent, parent of parent, etc.) of
# that directory (4 ancestors will be searched).
#
# Alternatively instead of copying this file, it may
# be included by a `source' statement in a file of the
# same name which contains subsequent statements that
# modify parameters.  The `source' statement must refer
# to the file sourced by an absolute pathname, since
# the file containing the `source' statement can itself
# be sourced with any descendant directory as the
# current directory.
#
# This file is sourced by code in judging_common.tcl.
# See `Inline Code' in that file.

# Problem .rc Files
# ------- --- -----

# After hpcm_judging.rc is sourced, certain programs
# source the file PPP.rc which they locate in the pro-
# blem solution directory of a particular problem named
# PPP.  In particular the autojudge, extractmail, and auto-
# score programs do this while computing in a problem
# submission directory.  Autojudge links any PPP.rc
# file it finds in the problem solution directory into
# the submission directory, and the other programs find
# that file in the submission directory.  The file may
# not exist, and if it does not, no attempt is made to
# source it.  If the file exists, it must pass a security
# check before it is sourced: it must not be accessible
# by `others'.
#
# Before a PPP.rc file is sourced the following global
# variables are set:
#
#	PROBLEM		Problem name: "PPP".
#	EXTENSION	Extension name including `.'
#			E.g., ".cc", ".java".
#
# Here the `Subject:' field of the submission was
# `submit $PROBLEM$EXTENSION'.  EXTENSION may be "".
# If there is no submission involved, then EXTENSION
# is set to "UNDEFINED", while PROBLEM is set to the
# name of the problem directory.
#
# Some programs source the PPP.rc file from the problem
# directory in order to do administrative work.  These
# may source the PPP.rc file into a local environment
# into which only the global variables the program wants
# to use have been imported.  For example, the makejudg-
# ingdir program does this to access the problem_de-
# scription_files and problem_source_files variables.
#
# As a consequence of the last paragraph, PPP.rc files
# should not read prior values of global variables set
# in hpcm_judging.rc, UNLESS the PPP.rc file makes
# these global before accessing them.  However, PPP.rc
# should never read the values of the variables it is
# trying to set, as these frequently have no values
# when PPP.rc is sourced (they are given default values
# only if PPP.rc does not set them).
#
# If procedures or temporary variables are defined in a
# PPP.rc file, they should begin with the prefix `rc_'
# to avoid conflicts with HPCM global variables.
#
# The following are global variables that particular
# programs expect PPP.rc to set.  Note that PPP.rc is
# not required to set these, and PPP.rc usually does not
# even exist.  The defaults given below are applied if
# PPP.rc does NOT set the global variable.
#
#   scoring_instructions
#
#	This variable controls the kinds of differences
#	between submitted and judge's output files that
#	are allowed.  It is set in hpcm_judging.rc, see
#	below for documentation, and is often reset by
#	PROBLEM.rc.
#
#   problem_description_files
#
#	A list of the .txt, .ps, ... files in the pro-
#	blem directory that describe the problem to the
#	contestant.
#
#	By default this is set to the list of all the
#	files that exist in the problem directory whose
#	names have the form PROBLEM.TTT, where TTT is an
#	extension found in the problem_description_
#	extensions global variable.  E.g., TTT may be
#	".ps" or ".pdf" or ".txt".
#
#   problem_source_files
#
#	A list of files that are sent to the contestant
#	as source files, NOT including the problem
#	description files.
#
#	If any of these files have a name of the form
#	xxx.ISF, they will be sent to the contestant (by
#	autoget and hpcm_extract) under the name xxx.
#	ISF stands for `Initial Source File', and de-
#	notes an initial version of a file the contes-
#	tant will modify and submit.
#
#	The default list includes the Makefile file
#	and any file existing in the problem directory
#	that has extension .ISF.
#
#   problem_required_files
#
#	A list of files the contestant is required to
#	submit.  All these must be included in the sub-
#	mission message.
#
#	The default lists just the $PROBLEM$EXTENSION
#	file if $EXTENSION is not "".  It is an error
#	if $EXTENSION is "" and PROBLEM.rc does not
#	define this global variable.
#
#   problem_optional_files
#
#	A list of files the contestant may optionally
#	submit.  These are optionally included in the
#	submission message.  The default definition
#	of this variable is the empty list.
#
#   problem_make_files
#
#	A list of instructions the autojudge program
#	uses to make files in the problem solution dir-
#	ectory before linking files from that directory
#	to the submission directory (see problem_link_
#	files below).
#
#	Each instruction has the form:
#
#		{ OUT COMMAND IN1 IN2 ... }
#
#	The file OUT is to be made by executing the
#	COMMAND, provided all the files IN1, IN2, ...
#	exist, and either OUT does not exist or it is
#	older than one of the files IN1, IN2, ... .
#	All this is done by autojudge with the problem
#	solution directory as the current directory.
#
#	If no files IN1, IN2, ... are listed, OUT must
#	not exist if COMMAND is to be executed.  If OUT
#	is older than one of the IN1, IN2, ... files,
#	OUT will be deleted before executing COMMAND
#	(so it may be readonly).
#
#	An instruction can be abbreviated to just a file
#       name F, which is the same as the instruction
#       `{ F { make F } }'.
#
#	The COMMAND is passed to the exec_in_directory
#	functions which executes it in sh or csh.  This
#	COMMAND is a character string parsed by a non-
#	TCL shell, and NOT a TCL list.
#
#	The instructions are processed by autojudge in
#	order, so previous instructions can make inputs
#	to later instructions.
#
#	The default value of this variable is the empty
#	list.
#
#	After processing problem_make_files, the auto-
#	judge program will do more file making of this
#	kind depending upon the files it finds in the
#	problem solution directory.  It uses the files
#	F listed in the problem_input_names (see below)
#	for this.  For each such F autojudge executes
#	the instruction
#
#	    F.in {jfilter F.jin F.in} F.jin
#
#	that makes F.in from F.jin if the latter exists.
#	Then if the Scoring_Filter file exists in the
#	problem solution directory (after problem_make_
#	files instructions are executed), autojudge
#	executes the instructions
#
#	    F.fout {Scoring_Filter F.in <F.out >F.fout}
#		   Scoring_Filter F.in F.out
#
#	    F.ftest
#		{Scoring_Filter F.in <F.test >F.ftest}
#		Scoring_Filter F.in F.test
#
#	    F.jfout {jfilter F.jin F.fout F.jfout}
#		    F.jin F.fout
#
#	    F.jftest {jfilter F.jin F.ftest F.jftest}
#		    F.jin F.ftest
#
#	while if there is no Scoring_Filter file auto-
#	judge executes
#
#	    F.jout {jfilter F.jin F.out F.jout}
#		    F.jin F.out
#
#	    F.jtest {jfilter F.jin F.test F.jtest}
#		    F.jin F.test
#
#   problem_link_files
#   problem_optional_link_files
#
#	Lists of link instructions for linking files
#	from the problem solution directory to the pro-
#	blem submission directory.  These are executed
#	by the autojudge program after it makes files in
#	the solution directory as per problem_make_
#	files.
#
#	Each link instruction is itself just a file name
#	or a list of file names.
#
#	If a link instruction is just a file name F, F
#	if F exists in the solution directory it will be
#	linked to the submission directory.
#
#	If a link instruction is a list { F F1 F2 ... }
#	of names, the names F1, F2, ... are checked in
#	the solution directory, and the first that exists
#	is linked to the name F in the submission direc-
#	tory.  If none of the files F1, F2, ... exist
#	in the solution directory, no link will be made.
#
#	The submission files designated in problem_link_
#	files instructions must already exist or have a
#	link created for them, else it is an error.  But
#	the files designated in problem_optional_link_
#	files instructions need not exist or have the
#	instructions make a link for them.
#
#	The default values of these variables are empty
#	lists.  However, after executing the link
#	instructions in these variables, the autojudge
#	program executes the following link instructions
#	of its own:
#
#	    Makefile Makefile$EXTENSION Makefile
#
#	    Scoring_Filter (if it exists)
#
#	For each name F in problem_input_names (see
#	below):
#
#	    F.in
#	    F.test F.out F.test
#	    F.jin			[F.jin]
#	    F.ftest F.fout F.ftest	[SF]
#	    F.jtest F.jout F.jtest	[F.jin,
#					 but not SF]
#	    F.jftest F.jfout F.jftest	[F.jin and SF]
#
#	where the []'ed things must exist for the in-
#	struction to be executed, and SF abbreviates
#	Scoring_Filter.
#
#	Note the default link instruction for Makefile
#	permits different Makefiles for different pro-
#	gramming languages: e.g., Makefile.cc for .cc
#	programs.
#
#   problem_input_names
#
#	List of file names F such that F.in is to be
#	input to the submitted program to test it and
#	produce F.out (and F.err).  By default this is
#	just the list names such that the problem solu-
#	tion directory contains either an F.in or F.jin
#	file, except that $PROBLEM.in is ignored if
#	there are any other files (on the grounds that
#	it is probably a link to another F.in file in
#	this case).
#
#	$PROBLEM should not be included in this list
#	unless it is the only member, as files F.in
#	will be linked to $PROBLEM.in during testing.
#
#	The order of the names in this list is the order
#	the F.in files are used to test the submitted
#	program.  A major use of this variable is to
#	specify this order, as the default value usually
#	suffices if this order does not matter.  The
#	default list is sorted alphanumerically.

# Scoreboard Parameters
# ---------- ----------
#
# All times are in a format that TCL `clock scan'
# can convert.  Most date formats work.

# Correct and incorrect count displays.
#
# If scoreboard_display_correct is `yes', the number of
# correct problems is displayed for each submitter,
# along with the total problem time of the submitter if
# that is known, and submitters are sorted by number of
# correct problems (decreasing order) in the scoreboard.
# If scoreboard_display_correct is `no', the number of
# correct problems and total problem time are NOT dis-
# played for each submitter, and the scoreboard is
# sorted alphabetically by submitter name.
#
# If scoreboard_display_incorrect is `yes', the number
# of submissions for each submitter and problem is
# displayed.  If scoreboard_display_incorrect is `no',
# this number is not displayed.  Other scoreboard
# properties are not affected by this parameter.
#
set scoreboard_display_correct yes
set scoreboard_display_incorrect yes

# Contest start, stop, freeze, and cut times.
#
# The start, stop, and cut times are used in actually
# computing the scoreboard proper (by the `scoreboard'
# program), as follows.
#
# If the start time is not "", "problem", or "team", it
# is a date and time (a legal argument for `clock scan')
# and is the start time of all problems.  Any problem
# which was gotten or first submitted before this start
# time is ignored.
#
# If the start time is "", the start time of a problem
# is unknown.  Instead of printing problem times, the
# scoreboard will print dates of submission.  Instead
# of sorting submitters with the same number of correct
# problems by decreasing total problem time, the sub-
# mitters will be sorted by name alphabetically.
#
# If the start time is "problem", the time a problem is
# gotten is used as the start time for that problem.  If
# the start time equals "team", the time the team got
# its first problem permitted by the scoreboard_problems
# global variable (see below) is the start time for all
# problems for that team.  In both these cases, if the
# first submission regarding a problem is not a get of
# that problem, then the problem is ignored.  Such gets
# happen in email and informal contests, and not in
# formal contests, so the start time of a formal contest
# must be a date and time.
#
# Cut times are used to exclude teams that stopped
# early.  They permit a team to simultaneously enter
# several contests of different durations with the same
# problems.   Each contest has cut times that exclude
# teams that do not make submissions within a certain
# period after the team start time.  More specifically,
# a team is excluded from the contest if it does not
# either make a correct submission at or after the
# `correct cut time' and at or before the `final cut
# time', or make an incorrect submission at or after
# the `incorrect cut time' and at or before the `final
# cut time'.  Cut times can be given as date and time,
# or they can be given as integers which are numbers
# of seconds added to the problem start time.
# 
# A non-"" stop time excludes submissions made after the
# stop time (this is done AFTER the cut time rules have
# been applied).  A stop time can be a date and time, or
# it can be an integer that is added to the start time
# of the problem.
#
# The freeze time is only used as a parameter in score-
# board instructions used by the `makescoreboard' pro-
# gram, and is usually used only for formal contests.
# It may be given in date and time format, or as a
# number of seconds after a start time that is given in
# date and time format.
 
# The default values are for scoreboarding a practice
# facility that operates 24 hours a day, every day and
# allows individuals to tackle one problem at a time.
#
set scoreboard_start_time problem
set scoreboard_freeze_time ""
set scoreboard_stop_time ""
set scoreboard_correct_cut_time ""
set scoreboard_incorrect_cut_time ""
set scoreboard_final_cut_time ""

# The following values are for a typical 5 hour formal
# contest (you should adjust the start time).
#
# set scoreboard_start_time "Jan 1 10:00:00 2000"
# set scoreboard_freeze_time [expr { 4 * 60 * 60 }]
# set scoreboard_stop_time [expr { 5 * 60 * 60 }]
# set scoreboard_correct_cut_time ""
# set scoreboard_incorrect_cut_time ""
# set scoreboard_final_cut_time ""

# The following values are for an informal team 4 hour
# contest in which teams can choose their own starting
# time.  The teams effectively participate in simultan-
# eous 3, 4, and 5 hour contests: a team that gives up
# after 3 hours is deemed to have NOT entered the 4
# and 5 hour contests.  A team has entered the 4 hour
# contest if it makes a correct submission after 3 hours
# but at or before 5 hours and 10 minutes, or if it
# makes an incorrect submission after 3 hours and 10
# minutes but at or before 5 hours and 10 minutes.  The
# final cut time, here 5 hours and 10 minutes, permits
# teams to come back and work on problems the next day
# for practice without affecting the scoreboard.
#
# set scoreboard_start_time team
# set scoreboard_freeze_time ""
# set scoreboard_stop_time [expr { 4 * 60 * 60 }]
# set scoreboard_correct_cut_time \
#     [expr { 3 * 60 * 60 }]
# set scoreboard_incorrect_cut_time \
#     [expr { 3 * 60 * 60 + 10 * 60  }]
# set scoreboard_final_cut_time \
#     [expr { 5 * 60 * 60 + 10 * 60  }]

# Scoreboard name.  Typically just the name of the
# contest.  Used by NAME abbreviation in `scoreboard_
# instructions': see below.
#
set scoreboard_name ""

# The start time and correct submission time of a pro-
# blem, and the penalty of the contest, are used to com-
# pute the problem time.  The penalty is the number of
# SECONDS added to the problem time for each incorrect
# submission for the problem prior to the first correct
# submission for the problem.  It only affects the time
# of a problem that was submitted correctly.
#
set scoreboard_penalty 0
#
# A 20 minute penalty is typical if there is a penalty.
#
# set scoreboard_penalty [expr { 20 * 60 }]

# Logical expressions specifying problems and submit-
# ters.  Each logical expression is a TCL list whose
# elements are operators, parentheses `(' and `)', and
# atoms.  The allowed operators are `!', `&', `^', and
# `|' in highest precedence first order, denoting `not',
# `and', `exclusive-or', and `inclusive-or'.  Operators
# and parentheses MUST be surrounded by whitespace.
 
# The atoms `0' and `1' represent `false' and `true'.
# All other atoms are regular expressions that are
# matched to the ENTIRE problem name or submitter name,
# and are true iff they match.
#
# The problems logical expression is stored in `score-
# board_problems'.  If it is not the empty list, only 
# problems matching it are included in the scoreboard.
# The submitter logical expression is similar and is
# stored in `scoreboard_submitters'.
#
# Some simple examples of logical expressions are:
#
#   ! count	    Match all names but `count'.
#
#   count | pascal  Match only `count' and `pascal'.
#
#   count|pascal    Ditto, but with only one regular
#		    expression atom that contains a
#		    `|', instead of two atoms and a
#		    `|' logical operator.
#
#   bpi[0-9]+	    Match all names of the form
#		    `bpi' followed by one or more
#		    digits.
#
#   bpi.* & ! bpit  Match all names beginning with
#		    `bpi' except the one name
#		    `bpit'.
#
# The regular expressions are TCL regular expressions.
# Note that a regular expression must not as a charac-
# ter string be the same as an operator or parenthesis
# or special atom `0' or `1'.
# 
set scoreboard_problems { }
set scoreboard_submitters { }

 
# Maximum width of scoreboard in columns.
#
set scoreboard_width 80

# Characters used to mark lines if there are more than
# two lines worth of problems.  The first line always
# uses a space character to separate columns; and the
# last line uses underbar characters everywhere space
# characters are used.  If there are N > 2 lines, the
# n'th line for 1 < n < N uses the n-1'st character of
# the following string as a column separator.
#
set scoreboard_markers "|$!#^%@<>"

# List of addresses for `makescoreboard' to email
# scoreboard to.  If scoreboard_instructions includes
# a `SEND' instruction for an OUTPUT file, and
# scoreboard_addresses is a list containing zzz<YYY>,
# then every time the output file is made it will be
# emailed to `zzz<YYY>', so in the account YYY
# .procmailrc file you should put something like:
#
#	:0 b:
#	* ^To:.*zzz
#	| cat >public_html/xxx;\
#	  chmod a+r public_html/xxx
#
# See documentation for `scoreboard_instructions' for
# more details and additional SEND features.
#
set scoreboard_addresses { }

# Interval in seconds between times when the `make-
# scoreboard' program looks at flags and file modi-
# fication times to see if it needs to remake a
# scoreboard.
#
set scoreboard_interval 60
 
# Scoreboard instructions.   These determine which
# scoreboards the `makescoreboard' program will compute
# and how it will compute them.  The syntax is:
#
#	scoreboard_instructions ::=
#	    { scoreboard_instruction* }
#
#	scoreboard_instruction ::=
#	      { OUTPUT filename [start [stop]] }
#	    | { SEND [qualifier [parameter_name]] }
#	    | SEND
#	    | GRANT_ACCESS
#	    | BLANK
#	    | BAR
#	    | { BAR center_text }
#           | { LINE left_text [center_text
#                                   [right_text]] }
#	    | { INPUT filename ... }
#	    | { parameter_name value }
#	    | BOARD
#
#	start ::= "<a date and time>"
#	stop  ::= "<a date and time>"
#	xxx_text ::= "-quoted or {}-quoted string
#
#	parameter_name ::=
#	    <any XXX such that `scoreboard_XXX' is a
#	     global variable after judging directory
#	     hpcm_judging.rc is read>
#
# The scoreboard instructions do the following:
#
#     { OUTPUT filename [start [stop]] }
#		Set the output file name. See below for
#		start and stop.
#
#     { SEND [qualifier [parameter_name]] }
#		Whenever the output file is written,
#		email the file to each address ADR in
#		the list of addresses in the global var-
#		iable `scoreboard_PN', where PN is the
#		parameter_name.  If the qualifier is not
#		empty, the email address actually used
#		is `qualifier<ADR>' when ADR contains
#		no `<', and `qualifier-ADR' when ADR
#		contains a `<'.  If `scoreboard_PN' is
#		empty or does not exist, nothing is
#		done.  PN defaults to `addresses'.
#		Qualifier defaults to "".
#
#     GRANT_ACCESS
#		Whenever the output file is written,
#		it is made readable by everyone.
#
#     BLANK	Include a blank line.
#
#     BAR	Include a ===== bar line.
#
#     { BAR center_text }
#		Include a ===== bar line that has the
#		text centered in the line, with single
#		space characters separating the text
#		from the ===='s.
#
#     { INPUT filename ... }
#		Include a copy of a first readable file
#		in the list of files.  Do nothing of no
#		listed file is readable.
#
#     { LINE left_text [center_text [right_text]] }
#		Include a line that has left_text left
#		justified, center_text centered, and
#		right_text right justified.  The right_
#		text or both the center_ and right_
#		texts can be omitted.  If texts would
#		overlap, two or three lines are in-
#		cluded to avoid overlap.
#
#     { parameter_name value }
#		Set the parameter PN, i.e., the global
#		variable `scoreboard_PN', to the value,
#		where PN is the parameter_name.
#
#     BOARD	Include a scoreboard computed with 
#		previously set parameters.
#
# An output file is not actually written until the next
# OUTPUT command or the end of the instructions. All
# non-absolute file names are relative to the judging
# directory.  The current value of the `scoreboard_
# width' parameter is used by the LINE and BAR instruc-
# tions.
#
# If a non "" start time is given in an OUTPUT instruc-
# tion, that output will not be produced until after
# the given start time.  If a non "" stop time is given,
# in an OUTPUT instruction, that output will not be pro-
# duced if it already exists and has a modification time
# equal to or greater than the stop time.  Setting the
# start and stop times equal will produced an output
# just once after the given time.
#
# The start and stop times of an OUTPUT command, the
# values of a parameter, and the texts of a LINE or BAR
# command can be the special abbreviations TIME, START,
# STOP, FREEZE, and NAME.  TIME is the time when the
# `makescoreboard' program starts executing the score-
# board instructions.  The other abbreviates are the
# values of the `scoreboard_start_time', `scoreboard_
# stop_time', `scoreboard_freeze_time', and `scoreboard_
# name' global variables just before the first score-
# board instruction is executed, but after any arguments
# to `makescoreboard' have been processed.
#
# Note that parameter setting instructions are always
# executed even if the last OUTPUT instruction is not
# active for some reason (start or stop time or output
# being already more recent than inputs).


# Standard scoreboard instructions for an email contest.
# These make a scoreboard in the file
#
#	$judging_instructions/scoreboard.mail
#
# that has the format:
#
#   See notes below.           NAME               TIME
#
#   ==== ===== ===== ===== ===== ===== ===== ===== =====
#	   <scoreboard proper>
#   ==== ===== ===== ===== ===== ===== ===== ===== =====
#
#   <contents of $judging_instructions/scoreboard.notes>
#
#   ==== ===== ===== ===== ===== ===== ===== ===== =====
#
# This file is then emailed to the addresses in the
# scoreboard_addresses global variable.
#
set email_scoreboard_instructions {
    { OUTPUT scoreboard.mail }
    SEND
    { LINE "See notes below." NAME TIME }
    BLANK
    BAR
    BOARD
    BAR
    BLANK
    { INPUT scoreboard.notes }
    BLANK
    BAR
}

# Standard scoreboard instructions for an informal
# contest.  These instructions make a scoreboard
# page in the file:
#
#	$judging_directory/contest/scoreboard.1
#
# World read access is granted to this file, which
# is also sent to any addresses in the scoreboard_
# addresses global variable.  The file has the
# format:
#
#  NAME                                           TIME
#
#   <contents of $judging_instructions/contest/
#			scoreboard.1head>
#
#   ==== ===== ===== ===== ===== ===== ===== ===== =====
#	   <scoreboard proper>
#   ==== ===== ===== ===== ===== ===== ===== ===== =====
#
set informal_scoreboard_instructions {
    { OUTPUT contest/scoreboard.1 }
    GRANT_ACCESS
    SEND
    { LINE NAME "" TIME }
    BLANK
    { INPUT contest/scoreboard.1head }
    BLANK
    BAR
    BOARD
    BAR
}

# Standard scoreboard instructions for a formal contest
# with scoreboard freezing.  These instructions make a
# scoreboard page in the file:
#
#	$judging_directory/contest/scoreboard.1
#
# World read access is granted to this file, which
# is also sent to any addresses in the scoreboard_
# addresses global variable.  The file has the
# format:
#
#  NAME             Public Scoreboard             TIME
#
#   <contents of $judging_instructions/contest/
#	scoreboard.freeze if that file exists>
#
#   <contents of $judging_instructions/contest/
#			scoreboard.1head>
#
#   <contents of $judging_instructions/contest/
#			scoreboard.public>
#
# The file
#
#	$judging_directory/contest/scoreboard.public
#
# has two versions, one computed before the contest
# start time, and one computed between the contest start
# time and the contest freeze time.  Before the contest
# start time it is a plain scoreboard computed with ""
# start time, so dates and not problem times are
# displayed, that includes demo problems and test
# accounts, with the plain scoreboard being prefixed by
# a comment that after the start time problem times will
# be displayed and demos will not be.  After the contest
# start time it is just a plain scoreboard with the
# freeze time as stop time, no demos, and no test
# accounts.
#
# The file
#
#	$judging_directory/contest/scoreboard.freeze
#
# is a notice that the scoreboard is frozen.  This file
# is created at the freeze time, and does not exist
# before then.
#
# All this makes the publicly available scoreboard.
# In addition there are two other scoreboards that are
# only visible to judges.  The file
#
#	$judging_directory/contest/scoreboard.current
#
# is a current scoreboard that is made from the freeze
# time till the stop time.  The file
#
#	$judging_directory/contest/scoreboard.final
#
# is a printable final scoreboard that is made just
# once, soon after the stop time.  Both these have the
# raw scoreboard with the normal stop time followed by a
# copy of the
#
#	$judging_directory/contest/who_where
#
# file.  Both of these are not readable by non-judging
# accounts.
#
set formal_scoreboard_instructions {

    { OUTPUT contest/scoreboard.freeze FREEZE FREEZE }

    BLANK
    { LINE "To heighten suspense, scoreboard updating\
            has been stopped as of:" }
    { LINE "" FREEZE "" }
    { LINE "You will be given a copy of the final\
            scoreboard after winners have been" }
    { LINE "announced at the post contest meeting." }

    { OUTPUT contest/scoreboard.public "" START }

    { start_time "" }
    { stop_time FREEZE }
    { LINE "The demo problem `count' will disappear\
            from the scoreboard once the contest" }
    { LINE "starts.  Until the contest starts, dates of\
            first correct submission are" }
    { LINE "displayed (for demo problems).  After the\
            contest starts, problem times" }
    { LINE "(differences of first correct submission\
            times and contest start time)" }
    { LINE "will be displayed." }
    BAR
    BOARD
    BAR

    { OUTPUT contest/scoreboard.public START FREEZE }

    { start_time START }
    { stop_time FREEZE }
    { problems { ! count } }
    { submitters { ! test-account } }
    BAR
    BOARD
    BAR

    { OUTPUT contest/scoreboard.1 }
    GRANT_ACCESS
    SEND

    { LINE NAME "Public Scoreboard" TIME }
    { INPUT contest/scoreboard.freeze }
    BLANK
    { INPUT contest/scoreboard.1head }
    BLANK
    { INPUT contest/scoreboard.public }

    { OUTPUT contest/scoreboard.current FREEZE STOP }

    { LINE NAME "Current Scoreboard" TIME }
    BLANK
    BAR
    { stop_time STOP }
    BOARD
    BAR
    { INPUT contest/who_where }
    BAR

    { OUTPUT contest/scoreboard.final STOP STOP }

    { LINE NAME "Final Results" "" STOP }
    BLANK
    BAR
    { stop_time STOP }
    BOARD
    BAR
    { INPUT contest/who_where }
    BAR
}

# Set default scoreboard instructions to those for
# the email contest.
#
set scoreboard_instructions \
    $email_scoreboard_instructions

# Scoreboard_mode_array is a map from the scoring_mode
# (see `Scoring Parameters') to a regular expression
# that must match all scorefinder codes used to con-
# struct a scoreboard.  Scorefinder output lines with
# non-matching codes are simply ignored.  Scoreboard_
# mode_array is only changed if the set of possible
# scoring modes is being changed.
#
# Scoreboard_mode_array($scoring_mode) is a TCL regular
# expression that must match the entire code output by
# scorefinder in order for the line containing the code
# to be used in computing a scoreboard.
#
set scoreboard_mode_array(manual) \
    {m(i|c)f.|g}
set scoreboard_mode_array(auto) \
    {(a|m)(i|c)f.|g}
set scoreboard_mode_array(auto+manual) \
    {(a|m)(i|c)(n|f).|g}
set scoreboard_mode_array(manual+auto) \
    {(a|m)(i|c)(n|f).|g}

# Web Page Parameters
# --- ---- ----------

# These parameters control the makeweb program that
# makes a web page containing problem statements and
# optionally solutions.  Makeweb makes a `web' directory
# for the current contest (after the other contest
# directories have been made).  The web directory
# contains an index.html file and other files and
# directories referenced by this index.html file using
# relative URLs.  The web directory is typically copied
# to another place to be put on the WWW.

# Header and title for the web page (the index.html
# file).  If "", no web page should be made.
#
set web_contest_name ""

# If not "", include in index.html a description of how
# to submit a problem via email, and give this as the
# address to which submissions are to be sent.
#
set web_autojudge_address ""

# If not "", include solutions in a private/pppp sub-
# directory of the web directory, where pppp is the
# value of this parameter.  Without knowing the pass-
# word, the solutions subdirectory cannot be accessed,
# as the private directory is made unreadable by the
# public.  Mention of the existence of solutions is
# included in the web directory index.html file, but
# the password is not included.
#
set web_solutions_password ""

# A list of TCL regular expressions such that a file in
# a problem solutions subdirectory is placed in the
# problem's web solutions subdirectory (of private/pppp
# above) if and only if the name of the file in its
# entirety matches one of the regular expressions in
# this list.
#
set web_solutions_files {
    {.*\.c}
    {.*\.cc}
    {.*\.java}
    {.*\.lsp}
    {.*\.in}
    {.*\.test}
}

# If not "", include in index.html a reference to help
# and demo files.  This parameter is the URL of the
# help and demos information and may be relative to the
# web directory.  See hpcm/contestant/help/Makefile
# for a `make web' command that can create a help and
# demos web page.
#
set web_help_URL ""

# If not "", include in index.html a reference to the
# scoreboard.  This parameter is the URL of the score-
# board and may be relative to the web directory.
#
set web_scoreboard_URL ""

# Normally a copy of the `response_mode' variable, this
# includes a description of what will be returned to
# the submitter is it is not "".
#
set web_response_mode ""

# If not "", at the end of index.html place contact
# information for the web page manager at the given
# email address.
#
set web_manager_address ""

# Scoring Parameters
# ------- ----------


# Scoring Mode:
#
#	auto		Automatic scoring only; auto-
#			judge sends the score to the
#			contestant as final.
#	auto+manual	Automatic scoring plus manual
#			review of everything not `Com-
#			pletely Correct'; autojudge
#			sends the score to the contest-
#			ant as final if the score is
#			`Completely Correct', and as
#			to-be-reviewed otherwise.
#	manual		Manual scoring only; auto-
#			judge does not send the score
#			to the contestant.
#
# Note that the definition of scoring mode is completely
# contained in the response instructions below and the
# scoreboard_mode_array above, and can therefore be
# changed by changing just these.
#
set scoring_mode auto

# Maximum number of proofs for each type of difference
# that are recorded in the .score file.
#
set difference_type_proof_limit 100

# .err File Regexps:
#
# Regexp expressions matched to lines in .err file to
# detect limit overruns.  Letter case is ignored.
# The regular expressions match successfully if they
# match any part of a line.
#
set time_limit_regexp {cpu time limit exceeded}
set output_limit_regexp {file size limit exceeded}

# Scoring instructions are a TCL list whose elements
# control how the scorediff program compares the .out
# (.fout, .jout, .jfout) file with the .test (.ftest,
# .jtest, .jftest) file.  By default, scoring instruc-
# tions come from the following variable:
#
set scoring_instructions "space column"
#
# This variable is often changed on a per-problem basis
# by the file PROBLEM.rc.  Scoring instructions can also
# be specified on a per input file basis by the
# *SCORING* parameter in a .jin file.
#
# The following elements can be placed in a scoring
# intructions TCL list:
#
#   whitespace
#       Allow matching whitespace in the two files to be
#       not exactly the same, if each whitespace is
#	within a line and not at the beginning or end of
#	the line.  Such mismatches are automatically
#	allowed if either whitespace is followed by a
#	floating point number.
#
#   beginspace
#	Allow matching whitespace in the two files to be
#	not exactly the same, if each whitespace is at
#	the beginning of a line.  Such mismatches are
#	automatically allowed if either whitespace is
#	followed by a floating point number.
#
#   endspace
#	Allow matching whitespace in the two files to be
#	not exactly the same, if each whitespace is at
#	the end of a line.
#
#   linespace
#	Allow whitespace within blank lines to not
#	match.
#
#   space
#	The union of whitespace, beginspace, endspace,
#	and linespace.
#
#   spacebreak
#	Allow one file to have whitespace (including
#	possibly a line break) where the other file has
#	no whitespace at all.  Consider using nosign or
#	nonumber with this.
#
#   linebreak
#	Allow matching non-empty whitespaces to contain
#	different numbers of line breaks.  Thus one file
#	can have a line break where the other file has
#	none.  If this happens, the whitespace at the
#	beginnings and ends of the lines involved, and
#	within blank lines, need not match.
#
#   integer A R
#	Allow the two files to have matching integers
#	whose absolute difference is as much as A, and
#	whose relative difference is as much as R, where
#	A and R are floating point values.  Numbers
#	whose character strings match exactly are not
#	considered different in this sense.
#
#	See below for the definition of relative differ-
#	ence.
#
#	An integer is a number with no decimal point or
#	exponent.
#
#   float A R
#	Allow the two files to have matching numbers, at
#	least one of which is floating point, whose
#	absolute difference is as much as A, and whose
#	relative difference is as much as R, where A and
#	R are floating point values.  Numbers whose
#	character strings match exactly but for the
#	letter case of any exponent `e' or `E' are not
#	considered different in this sense.
#
#	A floating point number is a number with a deci-
#	mal point or exponent.
#
#	See below for the definition of relative differ-
#	ence.
#
#   decimal
#	Allow two files to have matching numbers that
#	have different numbers of decimal digits, or for
#	which only one of the matching numbers has a
#	decimal point.
#
#   exponent
#	Allow two files to have matching numbers just
#	one of which has an exponent.
#
#   sign
#	Allow two files to have matching numbers just
#	one of which has an explicit sign, or both of
#	which have different explicit signs.
#
#   number A R
#	The union of `integer A R', `float A R',
#	`decimal', `exponent', and `sign'.
#
#   letter-case
#	Allow letters outside of numbers to match if
#	they are the same but for letter case.
#
#   column
#	Allow two files to have matching numbers or
#	words that do not end in the same line column.
#
#	For the purpose of computing character line
#	column positions, tabs are set every 8 columns.
#
#   words-are-format
#	Causes differences in words (any non-numbers) to
#	indicate a formatting error and not an incorrect
#	or incomplete output error.  That is, if all the
#	numbers are correct and in the correct sequence,
#	the score will either be completely correct or
#	formatting error.
#
#	This allows misspelled, omitted, or extra words
#	to be treated as formatting errors, as long as
#	no words are required for correctness.
#
#   nonumber
#	Specifies that all number characters should be
#	treated as word characters, so there are no num-
#	ber tokens.
#
#   nosign
#	Specifies that sign characters preceding numbers
#	should be treated as word characters, so numbers
#	can only include signs in their exponent parts.
#
#   The relative difference of two numbers x and y is
#   defined to be:
#
#                      | x - y |
#                   ----------------
#                   max ( |x|, |y| )
#
#   which has a maximum value of 2.  If x = y = 0, the
#   relative difference of x and y is defined to be 0.

# Response Instructions
# -------- ------------

# Response mode.  One of:
#
#   solution	Return SOLUTION if score is `Completely
#		Correct'.
#   first	Return location of FIRST error if score
#		is not `Completely Correct' and is
#		automatically determined.
#   summary	Return SUMMARY of errors if score is not
#		`Completely Correct' and is automatical-
#		ly determined.
#
#   ""		None of above.
#
#   solution+first	Combinations of above.
#   first+solution	Combinations of above.
#   solution+summary	Combinations of above.
#   summary+solution	Combinations of above.
#
set response_mode ""

# List of global variables that can be referenced in
# the if-expressions of the response instructions.
#
#   manual
#   proposed
#
# are reserved and cannot be used.  Do NOT delete from
# the following list.
#
set response_instructions_globals {
    response_mode
    scoring_mode
    auto_score
    auto_score_marker
    manual_score
    proposed_score
    submitted_problem
    submitted_extension
    submit_qualifier
}

# The maximum number of errors returned by the SUMMARY
# response command for each type of score.
#
set response_instructions_summary_limit 5

# Instructions on how to respond to the submitter when a
# new score is determined are provided in the following
# variable.   Additional instructions can be prepended
# to this global variable value by a problem .rc file.
# The EXIT command (see below ) should be used in any
# prepended instructions whenever the following is not
# supposed to execute.
#
# The response instructions and the scoreboard_mode_
# array together define the possible scoring_mode values
# and their meanings.
#
# See below for a detailed description of response in-
# structions.
#
set response_instructions {

    if { ! $manual && ! $proposed } {
	if { $scoring_mode == "manual" } {
	    NO-REPLY
	    EXIT
	} elseif {    $scoring_mode == "auto" \
	           || $auto_score \
		          == "Completely Correct" } {
	    { LINE "For -PROBLEM- the automatically\
	    	    determined final score is:" }
	    BLANK
	    { LINE "    -AUTO-SCORE-" }
	    FINAL
	} elseif { [lcontain {auto+manual manual+auto} \
			     $scoring_mode] } {

	    { LINE "For -PROBLEM- the automatically\
	    	    determined score is:" }
	    BLANK
	    { LINE "    -AUTO-SCORE-" }
	    BLANK
	    { LINE "However, this score WILL BE\
		    REVIEWED by the human judge\
		    (soon)." }
	    CC
	    NOT-FINAL
	} else {
	    { ERROR "bad scoring mode" }
	}

	if { $auto_score == "Completely Correct" } {
	} elseif { [regexp first $response_mode] } {
	    BLANK
	    BAR
	    FIRST
	    BAR
	} elseif { [regexp summary $response_mode] \
			    } {
	    BLANK
	    BAR
	    SUMMARY
	    BAR
	}

    } elseif { ! $manual && $proposed } {
	FINAL
	if { $scoring_mode == "manual" } {
	    { LINE "For -PROBLEM- your final score\
	    	    is:" }
	    BLANK
	    { LINE "    -PROPOSED-SCORE-" }
	} elseif { [regexp {auto} $scoring_mode] } {

	    if { $scoring_mode == "auto" } {
	    	EDIT
	    }

	    { LINE "For -PROBLEM- your previous\
	            automatic score of:" }
	    BLANK
	    { LINE "    -AUTO-SCORE-" }
	    BLANK

	    if { $proposed_score == $auto_score } {

		{ LINE "has been verified and confirmed\
		        by the human judge!" }
		{ LINE "Thus your FINAL score is:" }
		BLANK
		{ LINE "    -PROPOSED-SCORE-" }
		BLANK
		{ LINE "for this submission." }

	    } else {

		if { $scoring_mode != "auto" } {

		    { LINE "has been OVERRIDDEN by the\
		    	    human judge!" }
		} else {
		    {LINE "has been UNEXPECTEDLY\
			   OVERRIDDEN by the human\
			   judge!" }
		}

		BLANK
		{ LINE "The human judge has assigned\
			the NEW FINAL score:" }
		BLANK
		{ LINE "    -PROPOSED-SCORE-" }
		BLANK
		{ LINE "to this submission." }
	    }
	} else {
	    { ERROR "bad scoring mode" }
	}
    } elseif { $manual && $proposed } {

	FINAL
	EDIT
	{ LINE "For -PROBLEM- your PREVIOUS FINAL\
		manual score of:" }
	BLANK
	{ LINE "    -MANUAL-SCORE-" }
	BLANK

	if { $proposed_score == $manual_score } {
	    { LINE "has been verified and confirmed by\
	    	    the human judge!" }
	} else {
	    { LINE "has been UNEXPECTEDLY OVERRIDDEN by\
	    	    the human judge!" }
	    BLANK
	    { LINE "The human judge has assigned the\
	    	    NEW FINAL score:" }
	    BLANK
	    { LINE "    -PROPOSED-SCORE-" }
	    BLANK
	    {LINE "to this submission." }
	}
    } else {
	{ ERROR "manual score exists but no proposed\
	         score exists" }
    }

    BLANK
    { LINE "See below for submission time." }
    BLANK
    { BAR "this message replies to:" }
    RECEIVED-HEADER

    if { $proposed_score == "Completely Correct" || \
         ( ! $proposed && \
           $manual_score == "Completely Correct" ) || \
         ( ! $proposed && ! $manual && \
           $auto_score == "Completely Correct" ) } {

        if { [regexp solution $response_mode] } {
	    BLANK
	    BAR
	    { LINE "For comparison purposes,\
		    our solution follows." }
	    { LINE "PLEASE do NOT make ANY\
		    solution PUBLIC." }
	    SOLUTION
	}
    }
}

# The `response_instructions' variable value is a TCL
# list consisting of commands and if-statements.  The
# if-statements have the format of TCL if statements:
#
#    	if <expression> <block>
#	elseif <expression> <block>
#	else <block>
#
# where any number of elseif parts may be given and the
# else part is optional.  Note that the words `if',
# `elseif', and `else' are TCL list elements as are the
# expressions and blocks.  Each block is recursively
# interpreted as a TCL list consisting of commands and
# if-statements.  The if-statement expressions can be
# evaluated without evaluating any commands, so the
# sequence of commands that is to be executed can be
# determined and the if-statements can be removed in a
# first pass.
#
# If-statement expressions can be any TCL expr expres-
# sion.  Some of the variables that can be used are:
#
#   $scoring_mode
#	The value of the scoring_mode global variable.
#
#   $response_mode
#	The value of the response_mode global variable.
#
#   $auto_score
#	The value of the non-marker part of the
#	Auto_Score file.
#
#   $auto_score_marker
#	The value of the marker part of the Auto_Score
#	file, changed to a TCL list by replacing `:'s
#	by spaces.  "" if no marker.
#
#   $manual_score
#	The value of the Manual_Score file, or `None'
#	if this file does not exist.  Set to `None' in
#	the autojudge program.
#
#   $proposed_score
#	The score which the person running the manual-
#	reply program has chosen as the final score.
#	Set to `None' if the manualreply program is not
#	being used to set the score.  Always set to
#	`None' in the autojudge program, and never set
#	to `None' in the manualreply program.
#
#   $manual
#	Equals \$manual_score != \"None\".
#
#   $proposed
#	Equals \$proposed_score != \"None\".
#
#   $submitted_problem
#	Problem name from the submit mail `Subject'
#	field.
#
#   $submitted_extension
#	Extension from the submit mail `Subject' field.
#
#   $submit_qualifier
#	Qualifier from the submit mail `Subject' field.
#
# If-statement expressions can only use the variables
# whose names are listed in the `response_instructions_
# globals' variable, except for $manual and $proposed.
# Note that none of these variables can be set by
# response instruction commands, nor should any expres-
# sion change the state of the TCL program when it is
# evaluated (e.g., do NOT use `[catch { set foo 9 }]').
#
# The response instructions commands are executed to
# construct the reply.  The possible commands are:
#
#     FINAL
#     NOT-FINAL 
#     NO-REPLY
#	  Exactly one of these commands must be execut-
#	  ed, to indicate whether a reply is to be sent,
#	  and if it is to be the final reply for the
#	  submission.  If FINAL is executed, a final
#	  reply is sent and Reply_Mail is created; if
#	  NOT-FINAL is executed a reply is sent that is
#	  not final, and no Reply_Mail is created; if
#	  NO-REPLY is executed no reply is sent.  It is
#	  an an error if zero or more than one of these
#	  commands is executed.
#
#     CC
#	  Cc the reply to the `reply_manager' if that
#	  global variable does not have the value "".
#
#     EDIT
#	  This command indicates that the reply composed
#	  by the response instructions should be edited
#	  by a person before being sent.  The manual-
#	  reply program calls the editor if this command
#	  is executed.  It is an error to execute this
#	  command in the autojudge program.  (i.e., when
#	  $proposed is false).
#
#     EXIT
#	  This terminates command execution, and any
#	  commands following this command are ignored.
#
#     { LINES "string" ... }
#     { LINE  "string" }
#	  The strings, each followed by a line feed, are
#	  included in the reply.  Note that the strings
#	  may themselves include line feeds.
#
#	  Several special substrings are substituted for
#	  within each string as follows:
#
#	        -PROBLEM-	 The problem name.
#		-AUTO-SCORE-	 $auto_score value.
#		-MANUAL-SCORE-	 $manual_score value.
#		-PROPOSED-SCORE- $proposed_score value.
#
#     BLANK
#	  Include a blank line in the reply.
#
#     BAR
#	  Inserts a 72 character ----- bar line.
#	  Special substrings are substituted for as
#	  for LINE.
#
#     { BAR "string" }
#	  Inserts ----- bar line that ends with a space
#	  followed by the string.  The total number of
#	  characters in the line is 72.
#
#     { INPUT filename }
#	  Include a copy of the file in the reply.
#
#     RECEIVED-HEADER
#	  Include a copy of the Date, To, From, Reply-
#	  To, and Subject header lines of the
#	  Received_Mail file in the reply.
#
#     RECEIVED-FULL-HEADER
#	  Include a copy of the ENTIRE Received_Mail
#	  message header in the reply.
#
#     RECEIVED-BODY
#	  Include the body of the Received_Mail file in
#	  the reply.  Note that the blank line between
#	  the header and the body of an email is NOT
#	  included in RECEIVED-HEADER, RECEIVED-FULL-
#	  HEADER, or RECEIVED-BODY.
#
#     SOLUTION
#	  Include the solution files in the reply.  Each
#	  file is proceeded by a BAR line containing the
#	  file's name.  The solution files include all
#	  problem_required_files and problem_optional_
#	  files, or the file named in the submission
#	  submission message if problem_required_files
#	  is not set.
#
#     FIRST
#	  Include lines describing the type and position
#	  of the first automatic score determining error
#	  in the reply.
#
#     SUMMARY
#	  Include lines summarizing all automatic score
#	  determining errors in the reply.  See the
#	  variable response_instructions_summary_limit
#	  above.
#
# Response instructions are used by the autojudge and
# manualreply program, which compose score based replies
# to problem submissions.

# Submission Parameters
# ---------- ----------

# Set the following to `yes' if submissions must have
# files in the format:
#
#	HPCM_BEGIN filename
#	..first line of file
#	..second line of file
#	.. . . . more lines of file
#	HPCM_END filename
#
# Set following to `no' if submissions may also have
# files verbatim in the body of the submission message.
# See `extractmail' for details.
#
set format_submissions no

# Some mailers add stuff at the end of a message that
# needs to be ignored.  The following is a regular
# expression that matches whole lines that terminate the
# body of a submission message.  The regular expression
# is case insensitive (it is applied with the regexp
# -nocase option).
#
# Yahoo adds a --------.* line followed by Yahoo stuff.
# OK as long as we do not support languages that use
# `--' to begin comments, like ADA.
#
set message_terminator "--------.*"

# Permitted Content-Transfer-Encoding and Content-Type
# values, as regular expressions.  For multipart
# messages these are for the part.  Leading whitespace
# is stripped before the value is tested by the regular
# expression.  Messages that do not explicitly specify
# these fields have default values 7bit and text/plain.
#
set content_transfer_encoding_values \
    "(7bit|8bit|quoted-printable|base64).*"
set content_type_values "text/plain.*"



# Authentication Switch: yes or no
#
# Usually yes for informal and formal contests and no
# for email contest.  See authentication functions in
# judging_common.tcl for details.
#
set use_authentication no

# Authentication Keys:
#
#     array set authentication_keys {
#		keyname1	key1
#		keyname2	key2
#		keyname3	key3
#		.  .  .  .  .  .  .
#	}
#
# where each keyname and key is any list item.  If
# there is whitespace in a keyname or key enclose
# it in {}'s, as in:
#
#	{feedso's key}	{I'm happy to mEt U}
#
# There should be no beginning or ending whitespace
# to either a key or a keyname.
#
array set authentication_keys {
}

# Allowed Extensions:
#
# TCL list of allowed extensions for submitted programs:
#
set allowed_extensions {.c .cc .java .lsp}

# Allowed Qualifiers:
#
# TCL list of allowed submit qualifiers for submitted
# programs:
#
set allowed_qualifiers { "" in inout }

# Submitter compress function.  Used to compress the
# full submitter email name when displaying the sub-
# mitters name, e.g., on the scoreboard.
#
# For this version the mode is `long' to include a con-
# testant's primary domain name (e.g. `harvard') or
# `short' to not include the @ or anything after that.
#
set submitter_compress_mode long
#set submitter_compress_mode short
proc submitter_compress { submitter } {

    global submitter_compress_mode

    # Long_submitter is submitter with stuff after @
    # compressed so xxxxx.yyy.eee becomes yyy.
    # Short_submitter is submitter with @ and stuff
    # after it removed.

    if { [regexp {^([^@]*)@(|.*\.)([^.]*)\.[^.]*$} \
                 $submitter forget \
		 short_submitter forget2 organization] \
			     } {
	set long_submitter \
	    "$short_submitter@$organization"
    } else {
	regexp {^([^@]*)@} $submitter forget \
	       short_submitter
	set long_submitter $short_submitter
    }

    if { $submitter_compress_mode == "long" } {
	return $long_submitter
    } else {
	return $short_submitter
    }
}


# Reply Mode:
#
#	auto		Automatic reply only; dispatch-
#			mail automatically sends a
#			reply, if autoinfo or autojudge
#			are not invoked.  The reply_
#			manager is cc'ed if that is not
#			""; otherwise the reply indi-
#			cates there will never be a
#			proper reply.
#	auto+manual	Automatic reply if a good auto-
#			matic reply is possible, as with
#			certain errors, and manual reply
#			otherwise.
#
set reply_mode auto

# Reply Manager:
#
# Email address to cc replies to if in `auto' reply_mode
# and no clearly correct automatic reply is possible.
#
set reply_manager ""

# Use GMT for dates in file and directory names.  Other-
# wise the local time zone is used.  Must be a TCL
# boolean (yes, no, 1, or 0).
#
set use_gmt no


# Logging Parameters
# ------- ----------

# Log Mode:		Action on Error:
#
#	manual		Write error to log file; do not
#			send any email.
#	auto+manual	Write error to log file, and
#			send error by email (but not
#			using normal reply mechanism)
#			to submitter/requester.  Manual
#			review should follow.
#	auto		Write error to log file, reply
#			to submitter/requester, and cc
#			to log_manager if that is not
#			"".  Reply email does NOT use
#			normal reply mechanism.
#	none		Error is NOT logged to a file
#			or emailed.
#
# Errors are always printed to the standard error
# output.
#
set log_mode auto

# Log Manager:
#
# Email address to cc log files to if in `auto'
# log_mode.
#
set log_manager ""

# Maximum Logged Errors:
#
# If more errors than this are logged by a single
# program execution, the log mode is automatically
# changed to `none' for that program execution.
#
set log_error_maximum 10


# Info Parameters
# ---- ----------

# info_map(name) if it exists is a list of names which
# replace `name' when a `get name' request is made.
# This list may be empty.
#
# If info_map(name) equals {FORBIDDEN {error_message}}
# then `name' cannot be returned by a `get name' request
# and the message:
#
#	The following file names are forbidden:
#	    name: error_message
#
# is returned in the reply mail.
#
# info_tail_map is just like info_map but maps just the
# tail component of name.
#
array set info_map {
    problems {FORBIDDEN {You are not allowed to get all\
              problems at once in this contest.}}
}

array set info_tail_map {
    CVS {}
    RCS {}
}


# Display Parameters
# ------- ----------

# Window heights.  The window_height is the height of
# the non-blank part of the window, and the window_
# blank_height is the number of blank lines that should
# be above the non-blank part of the window.
#
# WARNING: If window_height is too large, programs such
# as manualreply and lookat may appear to be malfunc-
# tioning because the information they display is being
# scrolled off the top of the screen.
#
set window_blank_height 16
set window_height 24
#
# How long should autodispatch run before we worry that
# it has hung up.  In seconds.
#
set dispatch_too_old 120
#
# Characters to turn highlighting on or off.  For ANSI
# terminals the number in highlight_on can be any of:
#	1 for bold, 7 for reverse video, 31 for red,
#	32 for green, 33 for yellow, 34 for blue,
#	35 for magenta, 36 for cyan, 41-46 to change
#	background instead of character color
#
set highlight_on  "\x1b\[7m"
set highlight_off "\x1b\[0m"


# Maintenance Parameters
# ----------- ----------

# Default list of problem description file extensions:
#
set problem_description_extensions \
    {.txt .html .htm .ps .pdf}

# List of last component names of subdirectories that
# are NOT to be recursively copied into ./contest sub-
# directories by makejudgingdir given a directory item
# `all' option.
#
set directories_not_copied {CVS RCS}



# Functions that Call the Operating System
# --------- ---- ---- --- --------- ------

### In theory all calls to `extended TCL' are here and
### no such calls are in the rest of the HPCM TCL code.
### Its difficult to enforce this rule in practice.

# Function to send mail, as does UNIX `sendmail'.  Takes
# mail message file with correctly set `To:' field and
# sends the message to the addresses listed there.  If
# some of these addresses are in error, this command
# may suffer a catchable error (and the mail may be put
# into ~/dead.letter).
#
proc send_mail { message_file } {
    exec /usr/sbin/sendmail -oi -t < $message_file
}

# Ditto but the message sent is the value of the single
# argument, and is not in a file.
#
proc send_message { message } {
    exec /usr/sbin/sendmail -oi -t << $message
}

# Function to compute the md5sum of a value.
#
proc compute_signature { value } {
    return [lindex [exec md5sum << $value] 0]
}

# Function to translate base64 mimencoded text.  The
# text to be translated is the argument and the trans-
# lated text is the returned value.
#
if { [catch { exec which mewdecode }] } {
    proc translate_base64 { text } {
	return [exec -keepnewline mimencode -u << $text]
    }
} else {
    proc translate_base64 { text } {
	return [exec -keepnewline mewdecode << $text]
    }
}

# Function to create a file.  Returns `yes' if the file
# was created, and `no' if it already exists.  Suffers
# an error if there is some other problem with creating
# the file.  If created, the file will be zero length
# and both readable and writable by the current user.
#
proc create_file { filename } {
    global errorCode errorInfo

    if { [catch { exec lockfile -0 -r 0 $filename } \
                out] } {
	if { [regexp {Sorry, giving up on} $out] } {
	    return no
	} else {
	    error $out $errorCode $errorInfo
	}
    } else {
	chmod u+w $filename
	ftruncate $filename 0
	return yes
    }
}

# Function to create a directory and suffer an error if
# the directory already exists.  If created, the
# directory will be empty, readable, and writable.
#
proc create_directory { dirname } {
    exec mkdir $dirname
}

# Function to symbolically link a file.  The source is
# the existing file name and the target is the new name
# linked to the source.  If no target is given, link the
# file into the current directory.
#
proc link_file { source { target . } } {
    exec ln -s $source $target
}

# Function to copy a file preserving modification date
# and protection settings.  Note that unlike the TCL
# `file copy' command, this function will not copy
# a symbolic link, but will copy the underlying file
# instead.
#
proc copy_file { source target } {
    exec cp -p $source $target
}

# Function to change the permissions of a file or direc-
# tory.
#
# If the file or directory is readable to the current
# user, and the `allow' argument contains an `r' (which
# it does by default), the file or directory is made
# readable by everyone.
#
# If the file or directory is writable to the current
# user, and the `allow' argument contains an `w' (which
# it does NOT by default), the file or directory is made
# writable by everyone.
#
# If the file or directory is executable to the current
# user, and the `allow' argument contains an `x' (which
# it does by default), the file or directory is made
# executable by everyone.
#
proc grant_access { filename { allow rx } } {
    set perm ""
    if { [file readable $filename] \
         && [regexp {r} $allow] } {
	set perm "${perm}r"
    }
    if { [file writable $filename] \
         && [regexp {w} $allow] } {
	set perm "${perm}w"
    }
    if { [file executable $filename] \
         && [regexp {x} $allow] } {
	set perm "${perm}x"
    }
    if { $perm != "" } {
	chmod "a+$perm" $filename
    }
}

# Return global (everyone) permissions of a file as a
# three character string, RWX, where R = r if the file
# is a+r and `-' otherwise, W = w if the file is a+w and
# `-' otherwise, and X = x or X = s if the file is a+x
# and `-' otherwise.  If file is a+x, X = s if the file
# is u+s, and X = x otherwise.
#
proc get_access { filename } {
    if { ! [file exists $filename] } {
    	return "---"
    }

    set mode [file attributes $filename -permissions]
    if { ( $mode & 0444 ) == 0444 } {
    	set R r
    } else {
        set R -
    }
    if { ( $mode & 0222 ) == 0222 } {
    	set W w
    } else {
        set W -
    }
    if { ( $mode & 0111 ) == 0111 } {
	if { ( $mode & 04000 ) == 04000 } {
	    set X s
	} else {
	    set X x
	}
    } else {
        set X -
    }
    return "$R$W$X"
}

# Deny rwx permissions to everyone but owner and
# group for a file or directory, and w permissions
# to everyone but owner.
#
proc deny_access { filename } {
    chmod o-rwx,g-w $filename
}

# Function to view a file.  Change to your favorite
# editor or display program.
#
# This version checks the environment variable
# HPCM_VIEW for an editor.  HPCM_VIEW may be a TCL
# list with an editor name and parameters.  If this
# global variable is not defined, the editor
# defaults to `view'.
#
proc view_file { filename } {

    global env

    if { [info exists env(HPCM_VIEW)] } {
        set editor $env(HPCM_VIEW)
    } else {
        set editor view
    }
    eval exec $editor \
         [list $filename >@ stdout 2>@ stderr]
}

# Function to edit a file.  Change to your favorite
# editor.
#
# This version checks the environment variable
# HPCM_EDIT for an editor.  HPCM_EDIT may be a TCL
# list with an editor name and parameters.  If this
# global variable is not defined, the editor
# defaults to `vi'.
#
proc edit_file { filename } {

    global env

    if { [info exists env(HPCM_EDIT)] } {
        set editor $env(HPCM_EDIT)
    } else {
        set editor vi
    }
    eval exec $editor \
         [list $filename >@ stdout 2>@ stderr]
}

# Function to invoke the `make' program for a given
# `name' on a Makefile in the current directory.
#
# The standard output of `make' is always sent to the
# standard output.  The error output of `make' is
# written to the err_file.
#
proc make_file { name err_file } {
    exec make $name >@ stdout 2> $err_file
}

# Diff two directories and return the output as a
# string.  The output must be like the output of
# `exec diff -r directory1 directory2' with UNIX
# `diff -r'.
#
proc diff_directories { directory1 directory2 } {
    return [exec diff -r $directory1 $directory2]
}

# Diff two files.  Write all output, including error
# output, to a third file, with a header line in that
# file saying what was done.  Errors are ignored as
# far as TCL is concerned (they produce error messages
# in `output').
#
# Like UNIX `diff'.  The option `-b' may be given, and
# is like the `-b' option to UNIX `diff'.
#
proc diff_files { file1 file2 output { options "" } } {
    if { $options == "" } {
        set command "diff"
    } else {
        set command "diff $options"
    }
    write_file $output "===== $command $file1 $file2"
    catch { eval exec $command \
                 [list $file1 $file2 >>& $output] }
}

# Function to call shell.  Change to your favorite
# shell.
#
proc call_shell {} {
    exec csh >@ stdout 2>@ stderr
}

# Function to execute a command in another directory.
# Additional arguments are arguments to TCL exec that
# can reroute IO: e.g., >&@ stdout
#
proc exec_in_directory { directory command args } {
    eval exec csh -c "{cd $directory; $command}" $args
}

# Function to return the current process ID.
#
proc current_pid {} {
    return [id process]
}

# Function to display the state of processes within
# a process tree rooted at a given process.  Return
# value is the display.
#
proc display_process_tree { root_pid } {
    catch { exec pstree -pa $root_pid } out
    if { $out == "" } {
    	set out "No process with PID $root_pid exists"
    }
    return $out
}

# Function that looks at result of display_process_tree
# and returns true iff the root process for the tree
# was found to exist.
# 
proc process_found { display } {
    return [expr { \
        !  [regexp {^No process with PID .* exists} \
		   $display] }]
}

# Function to send signal to process subtree.  Signal
# must be KILL or INT.
#
# Note: we tried to use process groups, but making a
# process into a group leader disconnects the process
# from its stdin when that is a terminal, and that
# made life impossible.
#
proc signal_process_tree { signal root_pid } {
    catch { exec pstree -p $root_pid } out
    regsub -- {-pstree\([0-9]*\)} $out "-pstree" out
    regsub {^[^(]*\(} $out "\{" out
    regsub {\)[^)]*$} $out "\}" out
    regsub -all {\)[^(]*\(} $out "\} \{" out
    set list ""
    foreach pid $out {
        if { [regexp {^[0-9]+$} $pid] } {
	    lappend list $pid
	}
    }
    if { $list != "" } {
	echo kill $signal $list
	kill $signal $list
    }
}

# Function to turn signals into errors.
#
proc make_signals_errors {} {
    if { [info command signal] == "signal" } {
	signal error { HUP INT QUIT ALRM TERM }
    }
}

# Function to cause signals to be ignored.
#
proc make_signals_ignored {} {
    if { [info command signal] == "signal" } {
	signal ignore { HUP INT QUIT ALRM TERM }
    }
}

# Function to turn on signal default action.
#
proc make_signals_default {} {
    if { [info command signal] == "signal" } {
	signal default { HUP INT QUIT ALRM TERM }
    }
}

# Function to disable stdout and stderr (e.g., by
# routing them to /dev/null).
#
proc disable_outputs {} {
    set ch [open /dev/null w]
    dup $ch stdout
    dup $ch stderr
}

# Function to return current account name.
#
proc account_name {} {
    return [id user]
}

# Function to return current host name.
#
proc host_name {} {
    return [id host]
}
