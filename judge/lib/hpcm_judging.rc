# TCL Parameters File for Judging
#
# File:		hpcm_judging.rc
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Sep 13 17:11:19 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/09/13 22:37:05 $
#   $RCSfile: hpcm_judging.rc,v $
#   $Revision: 1.29 $
#

# An optionally modified copy of this file must be
# placed in (or symbolically linked into) the current
# directory of an executing judging program, or one
# of the ancestors (parent, parent of parent, etc.) of
# that directory (3 ancestors will be searched).

# HPCM System Manager: Email address for emergencies;
#		       "" if none.
#
set manager ""

# Scoring Mode:
#
#	auto		automatic scoring only
#	auto+manual	automatic scoring plus manual
#			review of everything not
#			`Completely Correct'
#	manual		manual scoring only
#
set scoring_mode auto

# Reply Mode:
#
#	auto		automatic reply only;
#			no human will attempt reply
#	auto+manual	automatic reply if possible
#			and manual otherwise or in
#			addition
#
set reply_mode auto

# Log Mode:		Action on Error:
#
#	manual		write error to log file
#	auto		write error to log file, reply
#			to submitter/requester and
#			HPCM system manager.
#	none		write all error info to standard
#			output
#
set log_mode auto


# Authentication Switch: yes or no
#
set use_authentication no


# Authentication Keys:
#
#     array set authentication_keys {
#		keyname1	key1
#		keyname2	key2
#		keyname3	key3
#		.  .  .  .  .  .  .
#	}
#
# where each keyname and key is any list item.  If
# there is whitespace in a keyname or keyitem enclose
# it in {}'s, as in:
#
#		{feedso's key}	{I'm happy}
#
# There should be no beginning or ending whitespace
# to a keyname, but a key can be anything.
#
array set authentication_keys {
}


# Regexp expressions matched to lines in .err file to
# detect limit overruns.  Letter case is ignored.
# The regular expressions match successfully if they
# match any part of a line.
#
set time_limit_regexp {cpu time limit exceeded}
set output_limit_regexp {file size limit exceeded}


# Whitespace separated list of allowed extensions for
# submitted programs:
#
set allowed_extensions ".c .cc .java .p"


###### Functions to call operating system programs #####

# Function to send mail, as does UNIX `sendmail'.  Takes
# mail message file with correctly set `To:' field and
# sends the message to the addresses listed there.  If
# some of these addresses are in error, this command
# may suffer a catchable error (and the mail may be put
# into ~/dead.letter).
#
proc send_mail { message_file } {
    exec /usr/sbin/sendmail -oi -t < $message_file
}

# Function to compute the md3sum of a value.
#
proc compute_signature { value } {
    return [lindex [exec md5sum << $value] 0]
}

# Function to create a file.  Returns `yes' if the file
# was created, and `no' if it already exists.  Suffers
# an error if there is some other problem with creating
# the file.  If created, the file will be zero length
# and both readable and writable by the current user.
#
proc create_file { filename } {
    if { [catch { exec lockfile -0 -r 0 $filename } \
                out] } {
	if { [regexp {Sorry, giving up on} out] } {
	    return no
	} else {
	    error $out $errorCode $errorInfo
	}
    } else {
	chmod u+w $filename
	ftruncate $filename 0
	return yes
    }
}

# Function to create a directory and suffer an error if
# the directory already exists.  If created, the
# directory will be empty, readable, and writable.
#
proc create_directory { dirname } {
    exec mkdir $dirname
}

# Function to symbolically link a file.  This is like
# copying, but the modification date on the target
# tracks the date on the source.  If no target is given,
# link the file into the current directory.
#
proc link_file { source { target . } } {
    exec ln -s $source $target
}

# Function to view a file.  Change to your favorite
# editor or display program.
#
proc view_file { filename } {
    exec view $filename >& /dev/tty
}

# Function to edit a file.  Change to your favorite
# editor.
#
proc edit_file { filename } {
    exec vi $filename >& /dev/tty
}

# Function to call shell.  Change to your favorite
# shell.
#
proc call_shell {} {
    exec csh >& /dev/tty
}

# Function to return the current process ID.
#
proc current_pid {} {
    return [id process]
}

# Function to make the current process ID into a
# process group ID, which will be inherited by
# all subprocesses.
#
proc set_current_pgid {} {
    id process group set
}


######### Things usually not changed ############


# File names:
#
set received_file		Received_Mail
set reply_file			Reply_Mail
set reply_history_file		Reply_Mail_History
set no_reply_file		No_Reply
set scoring_instructions_file	Scoring_Instructions
set auto_score_file		Auto_Score
set manual_score_file		Manual_Score
set make_file			Makefile
set dispatch_pid_file		Dispatch_PID


# Default Scoring Instructions:
#
set scoring_instructions_default \
    "whitespace"


# Directory names:
#
set mail_directory \
    $judging_parameters_directory/mail
set solutions_directory \
    $judging_parameters_directory/solutions
set info_directory \
    $judging_parameters_directory/info
set log_directory \
    $judging_parameters_directory/log
