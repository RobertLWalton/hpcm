# TCL Parameters File for Judging
#
# File:		hpcm_judging.rc
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Oct 22 22:53:52 EDT 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/10/23 02:53:26 $
#   $RCSfile: hpcm_judging.rc,v $
#   $Revision: 1.74 $
#

# An optionally modified copy of this file must be
# placed in (or symbolically linked into) the current
# directory of an executing judging program, or one
# of the ancestors (parent, parent of parent, etc.) of
# that directory (4 ancestors will be searched).
#
# Alternatively instead of copying this file, it may
# be included by a `source' statement in a file of the
# same name which contains subsequent statements that
# modify parameters.  The `source' statement must refer
# to the file sourced by an absolute pathname, since
# the file containing the `source' statement can itself
# be sourced with any descendant directory as the
# current directory.

# Scoreboard Parameters.
#

# Contest start and stop times.
#
# If the start_time is "", the time a problem is
# gotten is used as the start time for that problem.
# If the start_time equals "team", the time the team
# got its first problem listed in the scoreboard is
# the start time for all problems for that team.
#
# If the start time is not "" or "team", all submis-
# sions and problem gettings before that time are
# ignored.  If the stop time is not "", all submissions
# after that stop time are ignored.
#
# The default values are for scoreboarding a practice
# facility that operates 24 hours a day, every day.
#
set scoreboard_start_time ""
#   [clock scan "Jan 1 00:00:00 EDT 2000"]
#
set scoreboard_stop_time ""
#   [clock scan "Jan 1 00:00:00 EDT 2030"]

# The start_time and penalty are used to compute the
# time score: penalty is the number of SECONDS of
# penalty for an incorrect submission for a problem
# later gotten correct.
#
set scoreboard_penalty 0

# Logical expressions specifying problems and submit-
# ters.  Each logical expression is a TCL list whose
# elements are operators, parentheses `(' and `)', and
# atoms.  The allowed operators are `!', `&', `^', and
# `|' in highest precedence first order, denoting `not',
# `and', `exclusive-or', and `inclusive-or'.  Operators
# and parentheses MUST be surrounded by whitespace.
#
# The atoms `0' and `1' represent `false' and `true'.
# All other atoms are regular expressions that are
# matched to the ENTIRE problem name or submitter name,
# and are true iff they match.
#
# The problems logical expression is stored in `score-
# board_problems'.  If it is not the empty list, only 
# problems matching it are included in the scoreboard.
# The submitter logical expression is similar and is
# stored in `scoreboard_submitters'.
#
# Some simple examples of logical expressions are:
#
#   ! count	    Match all names but `count'.
#
#   count | pascal  Match only `count' and `pascal'.
#
#   count|pascal    Ditto, but with only one regular
#		    expression atom that contains a
#		    `|', instead of two atoms and a
#		    `|' logical operator.
#
#   bpi[0-9]+	    Match all names of the form
#		    `bpi' followed by one or more
#		    digits.
#
#   bpi.* & ! bpit  Match all names beginning with
#		    `bpi' except the one name
#		    `bpit'.
#
# The regular expressions are TCL regular expressions.
# Note that a regular expression must not as a charac-
# ter string be the same as an operator or parenthesis
# or special atom `0' or `1'.
# 
set scoreboard_problems { }
set scoreboard_submitters { }


# Maximum width of scoreboard in columns.
#
set scoreboard_width 80

# Characters used to mark lines if there are more than
# two lines worth of problems.
#
set scoreboard_markers "|+@#$%&<>"

# List of addresses for `makescoreboard' to email
# scoreboard to.
#
set scoreboard_addresses { }

# Interval in seconds between times when the `make-
# scoreboard' program looks at flags and file modi-
# fication times to see if it needs to remake a
# scoreboard.
#
set scoreboard_interval 60

# Scoreboard instructions.   These determine which
# scoreboards the `makescoreboard' program will compute
# and how it will compute them.  The syntax is:
#
#	scoreboard_instructions ::=
#	    { scoreboard_instruction* }
#
#	scoreboard_instruction ::=
#	      { OUTPUT filename }
#	    | BLANK
#	    | BAR
#           | { LINE left-text [center-text
#                                   [right-text]] }
#	    | { INPUT filename }
#	    | { parameter_name value }
#	    | BOARD
#
#	parameter_name ::=
#	    <any XXX such that `scoreboard_XXX' is a
#	     global variable after judging directory
#	     hpcm_judging.rc is read>
#
# The scoreboard instructions do the following:
#
#     { OUTPUT filename }  Set the output file name.
#     BLANK		   Include a blank line.
#     BAR		   Include a ===== bar line.
#     { INPUT filename }   Include a copy of a file.
#     { LINE left-text [center-text [right-text]] }
#			   Include a line that has
#			   left-text left justified,
#			   center-text centered, and
#			   right-text right justified.
#			   If any -text is DATE, it is
#			   replaced by the current date.
#			   The right-text or both the
#			   center- and right- texts can
#			   be omitted.
#     { parameter_name value }
#			Set the named parameter to the
#			given value for the purposes of
#			computing a board.
#     BOARD		Include a scoreboard computed
#			with the previous parameters.
#
# An output file is not actually written until the next
# OUTPUT command or the end of the instructions.  When
# the output file is written, it is emailed to all the
# addresses in the current `scoreboard_addresses' para-
# meter.  All file names are relative to the judging
# directory.  The current value of the `scoreboard_
# width' parameter is used to right justify text and
# produce the ===== BAR lines.
#
# Standard scoreboard instructions for an email contest:
#
set scoreboard_instructions {
    { OUTPUT scoreboard.mail }
    { LINE "See notes below." "" DATE }
    BLANK
    BAR
    BOARD
    BAR
    BLANK
    { INPUT scoreboard.notes }
}
#
# Standard scoreboard instructions for an informal or
# formal contest:
#
# set scoreboard_instructions {
#     { OUTPUT contest/scoreboard.1 }
#     { LINE contest-name "" DATE }
#     BLANK
#     { INPUT contest/scoreboard.1head }
#     BLANK
#     BAR
#     BOARD
#     BAR
# }


# End of scoreboard parameters.



# Maximum number of proofs for each type of difference
# that are recorded in the .score file.
#
set difference_type_proof_limit 100

# Submitter compress function.  Used to compress the
# full submitter email name when displaying the sub-
# mitters name, e.g., on the scoreboard.
#
# For this version the mode is `long' to include a con-
# testant's primary domain name (e.g. `harvard') or
# `short' to not include the @ or anything after that.
#
set submitter_compress_mode long
#set submitter_compress_mode short
proc submitter_compress { submitter } {

    global submitter_compress_mode

    # Long_submitter is submitter with stuff after @
    # compressed so xxxxx.yyy.eee becomes yyy.
    # Short_submitter is submitter with @ and stuff
    # after it removed.

    if { [regexp {^([^@]*)@.*\.([^.]*)\.[^.]*$} \
                 $submitter forget \
		 short_submitter organization] } {
	set long_submitter \
	    "$short_submitter@$organization"
    } else {
	regexp {^([^@]*)@} $submitter forget \
	       short_submitter
	set long_submitter $short_submitter
    }

    if { $submitter_compress_mode == "long" } {
	return $long_submitter
    } else {
	return $short_submitter
    }
}

# Set the following to `yes' if submissions must have
# files in the format:
#
#	HPCM_BEGIN filename
#	..first line of file
#	..second line of file
#	.. . . . more lines of file
#	HPCM_END filename
#
# Set following to `no' if submissions may also have
# the file as exactly the body of the submission mes-
# sage (the file may not begin with HPCM_BEGIN, any
# initial blank lines in the file are deleted, and
# blank lines may be added to end of the file).
#
set format_submissions no


# Scoring Mode:
#
#	auto		Automatic scoring only; auto-
#			judge sends the score to the
#			contestant as final.
#	auto+manual	Automatic scoring plus manual
#			review of everything not `Com-
#			pletely Correct'; autojudge
#			sends the score to the contest-
#			ant as final if the score is
#			`Completely Correct', and as
#			to-be-reviewed otherwise.
#	manual		Manual scoring only; auto-
#			judge does not send the score
#			to the contestant.
#
set scoring_mode auto

# Reply Mode:
#
#	auto		Automatic reply only; dispatch-
#			mail automatically sends a
#			reply, if autoinfo or autojudge
#			are not invoked.  The reply_
#			manager is cc'ed if that is not
#			""; otherwise the reply indi-
#			cates there will never be a
#			proper reply.
#	auto+manual	Automatic reply if a good auto-
#			matic reply is possible, as with
#			certain errors, and manual reply
#			otherwise.
#
set reply_mode auto

# Reply Manager:
#
# Email address to cc replies to if in `auto' reply_mode
# and no clearly correct automatic reply is possible.
#
set reply_manager ""

# Log Mode:		Action on Error:
#
#	manual		Write error to log file; do not
#			send any email.
#	auto+manual	Write error to log file, and
#			send error by email (but not
#			using normal reply mechanism)
#			to submitter/requester.  Manual
#			review should follow.
#	auto		Write error to log file, reply
#			to submitter/requester, and cc
#			to log_manager if that is not
#			"".  Reply email does NOT use
#			normal reply mechanism.
#	none		Write all error info to standard
#			output.
#
set log_mode auto

# Log Manager:
#
# Email address to send log files to if in `auto'
# log_mode.
#
set log_manager ""

# Maximum Logged Errors:
#
# If more errors than this are logged, the log mode is
# automatically changed to `none'.
#
set log_error_maximum 10


# Info control parameters:
#
# info_map(name) if it exists is a list of names which
# replace `name' when a `get name' request is made.
#
# If info_map(name) equals {FORBIDDEN {error_message}}
# then `name' cannot be returned by a `get name' request
# and the message:
#
#	The following file names are forbidden:
#	    name: error_message
#
# is returned in the reply mail.
#
# info_tail_map is just like info_map but maps just the
# tail component of name.
#
array set info_map {
    problems {FORBIDDEN {You are not allowed to get all\
              problems at once in this contest.}}
}

array set info_tail_map {
    CVS {}
    RCS {}
}


# Manual reply and tracking control parameters:
#
# Window heights.  The window_height is the height of
# the non-blank part of the window, and the window_
# blank_height is the number of blank lines that should
# be above the non-blank part of the window.
#
set window_blank_height 16
set window_height 24
#
# How long should autodispatch run before we worry that
# it has hung up.  In seconds.
#
set dispatch_too_old 120
#
# Characters to turn highlighting on or off.  For ANSI
# terminals the number in highlight_on can be any of:
#	1 for bold, 7 for reverse video, 31 for red,
#	32 for green, 33 for yellow, 34 for blue,
#	35 for magenta, 36 for cyan, 41-46 to change
#	background instead of character color
#
set highlight_on  "\x1b\[1m"
set highlight_off "\x1b\[0m"


# Authentication Switch: yes or no
#
set use_authentication no

# Authentication Keys:
#
#     array set authentication_keys {
#		keyname1	key1
#		keyname2	key2
#		keyname3	key3
#		.  .  .  .  .  .  .
#	}
#
# where each keyname and key is any list item.  If
# there is whitespace in a keyname or key enclose
# it in {}'s, as in:
#
#	{feedso's key}	{I'm happy to mEt U}
#
# There should be no beginning or ending whitespace
# to either a key or a keyname.
#
array set authentication_keys {
}


# .err File Regexps:
#
# Regexp expressions matched to lines in .err file to
# detect limit overruns.  Letter case is ignored.
# The regular expressions match successfully if they
# match any part of a line.
#
set time_limit_regexp {cpu time limit exceeded}
set output_limit_regexp {file size limit exceeded}


# Allowed Extensions:
#
# Whitespace separated list of allowed extensions for
# submitted programs:
#
set allowed_extensions ".c .cc .java .p"


# Default list of problem description file extensions:
#
set problem_description_extensions \
    ".txt .html .htm .ps"


###### Functions to call operating system programs #####

### In theory all calls to `extended TCL' are here and
### no such calls are in the rest of the HPCM TCL code.
### Its difficult to enforce this rule in practice.

# Function to send mail, as does UNIX `sendmail'.  Takes
# mail message file with correctly set `To:' field and
# sends the message to the addresses listed there.  If
# some of these addresses are in error, this command
# may suffer a catchable error (and the mail may be put
# into ~/dead.letter).
#
proc send_mail { message_file } {
    exec /usr/sbin/sendmail -oi -t < $message_file
}

# Ditto but the message sent is the value of the single
# argument, and is not in a file.
#
proc send_message { message } {
    exec /usr/sbin/sendmail -oi -t << $message
}

# Function to compute the md5sum of a value.
#
proc compute_signature { value } {
    return [lindex [exec md5sum << $value] 0]
}

# Function to create a file.  Returns `yes' if the file
# was created, and `no' if it already exists.  Suffers
# an error if there is some other problem with creating
# the file.  If created, the file will be zero length
# and both readable and writable by the current user.
#
proc create_file { filename } {
    global errorCode errorInfo

    if { [catch { exec lockfile -0 -r 0 $filename } \
                out] } {
	if { [regexp {Sorry, giving up on} $out] } {
	    return no
	} else {
	    error $out $errorCode $errorInfo
	}
    } else {
	chmod u+w $filename
	ftruncate $filename 0
	return yes
    }
}

# Function to create a directory and suffer an error if
# the directory already exists.  If created, the
# directory will be empty, readable, and writable.
#
proc create_directory { dirname } {
    exec mkdir $dirname
}

# Function to symbolically link a file.  This is like
# copying, but the modification date on the target
# tracks the date on the source.  If no target is given,
# link the file into the current directory.
#
proc link_file { source { target . } } {
    exec ln -s $source $target
}

# Function to change the permissions of a file or direc-
# tory.
#
# If the file or directory is readable to the current
# user, and the `allow' argument contains an `r' (which
# it does by default), the file or directory is made
# readable by everyone.
#
# If the file or directory is writable to the current
# user, and the `allow' argument contains an `w' (which
# it does NOT by default), the file or directory is made
# writable by everyone.
#
# If the file or directory is executable to the current
# user, and the `allow' argument contains an `x' (which
# it does by default), the file or directory is made
# executable by everyone.
#
proc grant_access { filename { allow rx } } {
    set perm ""
    if { [file readable $filename] \
         && [regexp {r} $allow] } {
	set perm "${perm}r"
    }
    if { [file writable $filename] \
         && [regexp {w} $allow] } {
	set perm "${perm}w"
    }
    if { [file executable $filename] \
         && [regexp {x} $allow] } {
	set perm "${perm}x"
    }
    if { $perm != "" } {
	chmod "a+$perm" $filename
    }
}

# Return global (everyone) permissions of a file as a
# three character string, RWX, where R = r if the file
# is a+r and `-' otherwise, W = w if the file is a+w and
# `-' otherwise, and X = x if the file is a+x and `-'
# otherwise.
#
proc get_access { filename } {
    if { ! [file exists $filename] } {
    	return "---"
    }

    set mode [file attributes $filename -permissions]
    if { ( $mode & 0444 ) == 0444 } {
    	set R r
    } else {
        set R -
    }
    if { ( $mode & 0222 ) == 0222 } {
    	set W w
    } else {
        set W -
    }
    if { ( $mode & 0111 ) == 0111 } {
    	set X x
    } else {
        set X -
    }
    return "$R$W$X"
}

# Deny rwx permissions to everyone but owner and
# group for a file or directory, and w permissions
# to everyone but owner.
#
proc deny_access { filename } {
    chmod o-rwx,g-w $filename
}

# Function to view a file.  Change to your favorite
# editor or display program.
#
proc view_file { filename } {
    exec view $filename >& /dev/tty
}

# Function to edit a file.  Change to your favorite
# editor.
#
proc edit_file { filename } {
    exec vi $filename >& /dev/tty
}

# Function to invoke the `make' program for a given
# `name' on a Makefile in the current directory.
#
# The standard output of `make' is always sent to the
# standard output.  The error output of `make' is
# written to the err_file.
#
proc make_file { name err_file } {
    exec make $name >@ stdout 2> $err_file
}

# Diff two directories and return the output as a
# string.  The output must be like the output of
# `exec diff -r directory1 directory2' with UNIX
# `diff -r'.
#
proc diff_directories { directory1 directory2 } {
    return [exec diff -r $directory1 $directory2]
}

# Diff two files.  Write all output, including error
# output, to a third file, with a header line in that
# file saying what was done.  Errors are ignored as
# far as TCL is concerned (they produce error messages
# in `output').
#
# Like UNIX `diff'.  The option `-b' may be given, and
# is like the `-b' option to UNIX `diff'.
#
proc diff_files { file1 file2 output { options "" } } {
    if { $options == "" } {
        set command "diff"
    } else {
        set command "diff $options"
    }
    write_file $output "===== $command $file1 $file2"
    catch { eval exec $command \
                 [list $file1 $file2 >>& $output] }
}

# Function to call shell.  Change to your favorite
# shell.
#
proc call_shell {} {
    exec csh >& /dev/tty
}

# Function to return the current process ID.
#
proc current_pid {} {
    return [id process]
}

# Function to display the state of processes within
# a process tree rooted at a given process.  Return
# value is the display.
#
proc display_process_tree { root_pid } {
    catch { exec pstree -pa $root_pid } out
    if { $out == "" } {
    	set out "No process with PID $root_pid exists"
    }
    return $out
}

# Function to send signal to process subtree.  Signal
# must be KILL or INT.
#
# Note: we tried to use process groups, but making a
# process into a group leader disconnects the process
# from its stdin when that is a terminal, and that
# made life impossible.
#
proc signal_process_tree { signal root_pid } {
    catch { exec pstree -p $root_pid } out
    regsub -- {-pstree\([0-9]*\)} $out "-pstree" out
    regsub {^[^(]*\(} $out "\{" out
    regsub {\)[^)]*$} $out "\}" out
    regsub -all {\)[^(]*\(} $out "\} \{" out
    set list ""
    foreach pid $out {
        if { [regexp {^[0-9]+$} $pid] } {
	    lappend list $pid
	}
    }
    if { $list != "" } {
	echo kill $signal $list
	kill $signal $list
    }
}

# Function to turn signals into errors.
#
proc make_signals_errors {} {
    if { [info command signal] == "signal" } {
	signal error { HUP INT QUIT ALRM TERM }
    }
}

# Function to cause signals to be ignored.
#
proc make_signals_ignored {} {
    if { [info command signal] == "signal" } {
	signal ignore { HUP INT QUIT ALRM TERM }
    }
}

# Function to turn on signal default action.
#
proc make_signals_default {} {
    if { [info command signal] == "signal" } {
	signal default { HUP INT QUIT ALRM TERM }
    }
}

# Function to return current account name.
#
proc account_name {} {
    return [id user]
}

# Function to return current host name.
#
proc host_name {} {
    return [id host]
}


######### Things usually not changed ############


# File names:
#
set received_file		Received_Mail
set reply_file			Reply_Mail
set reply_history_file		Reply_Mail_History
set no_reply_file		No_Reply
set scoring_instructions_file	Scoring_Instructions
set auto_score_file		Auto_Score
set manual_score_file		Manual_Score
set make_file			Makefile
set dispatch_pid_file		Dispatch_PID
set gotten_file			Gotten
set score_flag_file		Score_Flag
set needs_reply_flag_file	Needs_Reply_Flag
set scoreboard_pid_file		Scoreboard_PID
set scorefinder_output_file	Scorefinder_Output


# Default Scoring Instructions:
#
set scoring_instructions_default \
    "space column"


# Directory names:
#
set mail_directory	$judging_directory/mail
set solutions_directory	$judging_directory/solutions
set info_directory	$judging_directory/info
set log_directory	$judging_directory/log
set flag_directory	$judging_directory/flag
set contest_directory	$judging_directory/contest
set help_directory	$judging_directory/help
