# TCL Parameters File for Judging
#
# File:		hpcm_judging.rc
# Author:	Bob Walton (walton@seas.harvard.edu)
# Date:		Sun Sep 11 21:51:47 EDT 2016
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2014/10/20 07:57:01 $
#   $RCSfile: hpcm_judging.rc,v $
#   $Revision: 1.291 $

# Table of Contents:
#
#	About This File
#	Makecontest Parameters
#	Problem .rc Files
#	Scoreboard Parameters
#	Web Page Parameters
#	Scoring Parameters
#	Response Instructions
#	Submission Parameters
#	Logging Parameters
#	Info Parameters
#	Display Parameters
#	Functions that Call the Operating System

# About This File
# ----- ---- ----
#
# An optionally modified copy of this file must be
# placed in (or symbolically linked into) the current
# directory of an executing judging program, or one
# of the ancestors (parent, parent of parent, etc.) of
# that directory (4 ancestors will be searched).
#
# Alternatively instead of copying this file, it may
# be included by a `source' statement in a file of the
# same name which contains subsequent statements that
# modify parameters.  The `source' statement must refer
# to the file sourced by an absolute pathname, since
# the file containing the `source' statement can itself
# be sourced with any descendant directory as the
# current directory.
#
# For programs intended to run outside a judging
# directory, this file is sourced directly without
# being modified.  The HPCM_STANDALONE variable is set
# to `yes' in this case and `no' otherwise.
#
# This file is sourced by code in judging_common.tcl.
# See `Inline Code' in that file.

# Makecontest Parameters
# ----------- ----------

# These parameters control the making of the contest
# data by the makecontest program.

# Time zone for local time; a -timezone argument to the
# TCL `clock' procedure.
#
set hpcm_timezone :America/New_York

# HPCM directory.  Defaults to $env(HOME)/hpcm, where
# $env(HOME) is the home directory of the current
# account.
#
set hpcm_directory $env(HOME)/hpcm

# Truename (name beginning with /) of the contest direc-
# tory, if known.  If not set, defaults to truename of
# $judging_directory/contest if that is a directory, or
# to judging directory with `judging' replaced by
# `contest' and the final `_PASSWORD' removed.  E.g., if
# the judging directory is /home/xx/judging_yy_zz_87ewrw
# and $judging_directory/contest does not exist, the
# default is /home/xx/contest_yy_zz.
#
# set contest_directory "/home/xx/contest_yy"

# Prototype account (as per SETUP_PROTOTYPE).  If not
# set, this defaults to the account with name *[_-]proto
# and readable files ~/home/setup.tar and ~/home/
# setup.ls, if that account exists and is unique.
#
# set hpcm_prototype_account TBD

# List of addresses of the autojudge.  For contests with
# a local account, the `To:' address in ./contest/
# secure/hpcm_sendmail.rc is set to the first address in
# this list when hpcm_sendmail.rc is created, or if this
# list is empty, the `To:' address is created automati-
# cally.
#
# The addresses in this list with the `To:' address from
# any ./contest/secure/hpcm_sendmail.rc appended have
# the format `PASSWORD<...>' # where `<...>' is arbitr-
# ary.  The -procmailrc option to makecontest adjusts
# ~/.procmailrc to have one the dispatching entry for
# each PASSWORD given (a PASSWORD may be given more than
# once but will have only one entry) and the current
# judging directory (entries for other judging director-
# ies are not affected), and writes the first entry on
# the list to ./Contest_Address.
#
set autojudge_addresses {}

# Value of help/this_contest.  Copied into help/this_
# contest and help/this_contest_parameter whenever these
# files do not exist, or when they do exists, are equal,
# and do not equal the value of this variable.
#
# Must begin with a blank line and end with a complete
# line, including line feed.
#
# A header line with contest name and date is added
# automatically.
#
set this_contest "
THIS CONTEST
"

# Default arguments to makecontest.  These are used if
# and only if zero arguments are given directly to the
# makecontest program.  See below for definition of the
# arguments.
#
set makecontest_arguments "
    -formal \
    $judging_directory/help/index, \
	=help/ \
    $hpcm_directory/contestant/help/help_index, \
	common/=help/, \
	contest/=help/, \
	    untimed_practice:include, \
	    general:include, \
	    language:include \
    $hpcm_directory/problem_library/demos_index, \
	demos/io/=demos/, \
	demos/algorithms/=demos/, \
	    demo:include, \
    $hpcm_directory/problem_library/index, \
	public/=problems/, \
	    bospre2000:include
"
#
# The first argument, -formal, tells the type of the
# contest.  The rest of the arguments are a series of
# entries each concerning an index file.  For example,
# the entry:
#
#    $hpcm_directory/contestant/help/help_index, \
#	common/=help/, \
#	contest/=help/, \
#	    untimed_practice:include, \
#	    general:include, \
#	    language:include
#
# concerns the index file whose name is $hpcm_directory/
# contestant/help/help_index.  You should look at this
# file.  Each item in this file begins with a line of
# the format:
#
#	*** name option ...
#
# The instruction `common/=help/' says replace the
# initial substring `common/' with `help/' in the item
# name to make the final file name in the `info' direc-
# tory for email contests or `contest' directory for
# local contests.  The instruction `general:include'
# says replace the option `general' in the index file
# item by the option `include'.  After all replacements
# are made in the first line of the item, the item is
# used if and only if it has the `include' option.  And
# if used, the item represents a file or subdirectory
# in one of the three contest directories `help/',
# `demos/', or `problems/'.
#
# Index file names must begin with $hpcm_directory,
# $judging_directory, or $env(HOME), so the index files
# can be located if $judging_directory or any of its
# descendant directories is current.  $env(HOME) is the
# home directory of the current account.
#
# Note that in `$judging_directory/help/index' above
# (not the same as `$hpcm_directory/contestant/help/
# help_index') the items already have the `include'
# option.  `$judging_directory/help/index' is used to
# start the contestants `help/index' file and provide a
# `this_contest' item for the file `help/this_contest'.
#
# Each index file entry consists of a series of argu-
# ments to makecontest, all but the last of which end in
# `,'.  The last argument of the index file entry does
# NOT end in `,', and the argument after that begins the
# next entry.
#
# The first argument of an entry is the index file name
# and the other arguments are replacement instructions,
# with `=' for name replacements, and `:' for option
# replacements.  For more details, see the documentation
# of makecontest (run `makecontest -doc').

# The contest_commands global variable lists commands
# that are created and installed in the ./contest/
# secure/bin directory with wrappers in contest direc-
# tory.  These commands take no arguments and are
# filters into which postscript files are generally
# piped for printing.  Other such filtering uses are
# possible.
#
# This variable value is a list of items, where each
# item has one of the formats:
#	    
#	{ NAME sh COMMAND }
#	    Executing NAME executes COMMAND as in
#	    "exec $COMMAND" executed by /bin/sh.
#
#	{ NAME ssh ACCOUNT REMOTE-COMMAND [OPTIONS] }
#	    Executing NAME executes ssh which in turn
#	    executes REMOTE-COMMAND in ACCOUNT.
#	    The public/private key pair
#		./contest/secure/bin/NAME_identity.pub
#		./contest/secure/bin/NAME_identity
#	    is created by makecontest and the private
#	    key is used by the ssh -i option.  The
#	    file
#		./contest/secure/bin/
#			  NAME_authorized_keys
#	    is created by makecontest to be appended
#	    to the ~/.ssh/authorized_keys file in
#	    ACCOUNT.  ACCOUNT must be an account name
#	    in ssh format.  REMOTE-COMMAND may have
#	    whitespace but no "s.  OPTIONS are the
#	    options passed to ssh: they are by default:
#
#		    "-o PasswordAuthentication=no\
#		     -T -x -i PRIVATEKEY"
#
#	    The string PRIVATEKEY in OPTIONS is replaced
#	    by the full name (truename) of the private
#	    key file.
#
#	{ NAME email ADDRESS [REGEXP REMOTE-COMMAND] }
#	    Executing NAME executes hpcm_remote_sendmail
#	    with the given destination address.  ADDRESS
#	    may have spaces and "s but may NOT contain
#	    's.  If REGEXP and REMOTE-COMMAND are
#	    given, makecontest creates the file
#		./contest/secure/bin/NAME_procmailrc
#	    which when appended to the .procmailrc file
#	    in the email receiver will filter email
#	    whose `To' address matches REGEXP through
#	    the REMOTE-COMMAND.  REGEXP is an egrep(1)
#	    regular expression.  The procmail entry will
#	    cause the BODY of incoming email to be input
#	    to REMOTE-COMMAND, which should be shell
#	    executable.
#
# REMOTE-COMMANDS must be executable by whatever shell
# is in use in the remote account (e.g., /bin/sh or
# /bin/csh, etc.).
#
# Some examples are:
#
#	{ remote ssh me@mine.com {lpr -P my-printer} }
#	{ me email {"printme"<me@mine.com>}
#            printme {lpr -P my-printer}}
#	{ local sh {lpr -P my-printer} }
#
# For any of the above makecontest creates the file
#
#	./contest/secure/bin/NAME
#
# which when executed does what is indicated above, and
# creates the file
#
#	./contest/NAME
#
# which is a wrapper that when execute changes the real
# UID to the judge's account and then executes
# ./contest/secure/bin/NAME.  ./contest/NAME is given
# a+x,u+s permissions.  Files within ./contest/secure
# are denied all permissions but user permissions.
#
# Pre-existing files will not be altered by makecontest.
# In particular, ./contest/secure/bin/NAME may be edited
# after it has been initially made.
#
set contest_commands {}

# The judging_commands global variable is just like the
# contest_commands global variable, except it uses the
# `./secure' subdirectory of the judging directory in
# place of ./contest/secure, and it makes no wrappers.
# The usual use is sending scoreboards to remote web
# pages.  An example REMOTE-COMMAND usable for copying a
# scoreboard to a web page named SSS is:
#
#	{head -1000 >public_html/SSS;\
#	 chmod 644 public_html/SSS}
#
set judging_commands {}


# Problem .rc Files
# ------- --- -----

# After hpcm_judging.rc is sourced, certain programs
# source the file PROBLEM.rc which they locate in the
# problem solution directory of a particular problem
# named `PROBLEM'.  In particular the autojudge,
# extractmail, and manualreply programs do this while
# computing in a problem submission directory.
# Autojudge links any PROBLEM.rc file it finds in the
# problem solution directory into the submission direc-
# tory, and the other programs find that file in the
# submission directory.  The file may not exist, and if
# it does not, no attempt is made to source it.  If the
# file exists, it must pass a security check before it
# is sourced: it must not be accessible by `others'.
#
# Whenever PROBLEM.rc is sourced, PROBLEM is looked up
# in the problem_rc array, and if a value is found, it
# is evaluated by `eval' immediately after PROBLEM.rc is
# sourced.  This allows the contest hpcm_judging.rc file
# to override or supplement PROBLEM.rc file settings.
#
# array set problem_rc {
#    PROBLEM { script }
# }
array set problem_rc {}
#
# Some programs source the PROBLEM.rc file from the pro-
# blem directory in order to do administrative work.
# These may source the PROBLEM.rc file into a local en-
# vironment into which only the global variables the
# program wants to use have been imported.  For example,
# the makecontest program does this to access the
# problem_description_files, problem_source_files, and
# problem_print_files, and similar variables described
# below.
#
# Before a PROBLEM.rc file is sourced the following
# global variables are set:
#
#	PROBLEM		Problem name: "PROBLEM".
#
# If the PROBLEM.rc file is being sourced in a sub-
# mission directory, the following is set:
#
#	EXTENSION	Extension name including `.'
#			E.g., ".cc", ".java".
#
# Here the `Subject:' field of the submission was
# `submit $PROBLEM$EXTENSION [qualifier]'.  EXTENSION
# may be "".
#
# If instead the PROBLEM.rc file is being sourced by
# makecontest in order to set up contest data, the
# following are set:
#
#	EXTENSION	Set to "UNDEFINED".
#
#	OPTIONS		Set to makecontest index item
#			options (see documentation of
#			makecontest).
#
# Because a PROBLEM.rc file may be sourced into a local
# environment, PROBLEM.rc files should not read prior
# values of global variables set in hpcm_judging.rc,
# UNLESS the PROBLEM.rc file itself makes these global
# before accessing them.  Also, some variables that
# PROBLEM.rc files set are NOT given values by hpcm_
# judging.rc (they are given default values only if
# PROBLEM.rc does not set them), and these must not be
# read by PROBLEM.rc without checking first to see if
# they exist.
#
# If procedures or temporary variables are defined in a
# PROBLEM.rc file, they should begin with the prefix
# `rc_' to avoid conflicts with HPCM global procedures
# or variables.
#
# The following are global variables that particular
# programs expect PROBLEM.rc to set.  Note that
# PROBLEM.rc is not required to set these, and
# PROBLEM.rc usually does not even exist.  The defaults
# given below are applied if PROBLEM.rc does NOT set the
# global variable.  Some of these defaults are values
# set by this hpcm_judging.rc file, and some are applied
# only if no value is set by hpcm_judging.rc or
# PROBLEM.rc.
#
# Note that in the defaults below, \\ is read as \.
#
#   scoring_instructions
#
#	This variable controls the kinds of differences
#	between submitted and judge's output files that
#	are allowed.  See `Scoring Parameters'.
#	Default:
#
	    set scoring_instructions "space column"
#
#   problem_description_files
#
#	A list of regular expressions, such that a file
#	whose last name component matches ANY of these
#	expressions is a problem description file,
#	unless one of the name components matches SOME
#	regular expression from problem_excluded_files.
#	Default:
#
	    set problem_description_files \
		{.*\\.txt .*\\.html .*\\.htm
		 .*\\.ps .*\\.pdf}
#
#   problem_source_files
#
#	A list of regular expressions, such that a file
#	whose last name component matches ANY of these
#	expressions is a problem source file, unless one
#	of the name components matches SOME regular
#	expression from problem_excluded_files, and
#	unless it is a problem description file.
#
#	Default:
#
	    set problem_source_files \
	        {Makefile.* \
		 sample.*\\.in sample.*\\.test \
		 .*\\.ISF}
#
#	Note that if the `all' option is given for an
#	index item, this is changed to {.*} so it
#	matches all files.
#
#	Note that if any source file has a name of the
#	form xxx.ISF, a writable copy will be made for
#	the contestant (by hpcm_get or by autoinfo and
#	hpcm_extract) under the name xxx.  ISF stands
#	for `Initial Source File', and denotes an
#	initial version of a file the contestant will
#	modify and submit.
#
#   problem_binary_source_files
#
#	Source files like those listed in problem_
#	source_files, except these are binary executable
#	files.  They must be handled differently by
#	makecontest -info which encodes them as .BIN
#	files that autoinfo and hpcm_extract transmit
#	as executable binaries.
#
#	Default:
#
	    set problem_binary_source_files {}
#
#   problem_data_source_files
#
#	Source files like those listed in problem_
#	source_files, except these are binary but NOT
#	executable files.  They must be handled differ-
#	ently by makecontest -info which encodes them
#	as .DAT files that autoinfo and hpcm_extract
#	transmit as non-executable binaries.
#
#	Default:
#
	    set problem_data_source_files {}
#
#   problem_solution_files
#
#	A list of regular expressions, such that a file
#	whose last name component matches ANY of these
#	expressions is a problem solution file, unless
#	one of the name components matches SOME regular
#	expression from problem_excluded_files.  Solu-
#	tion files are sometimes put on the web after a
#	contest.
#
#	Default:
#
	    set problem_solution_files \
		{.*\\.c .*\\.cc .*\\.java .*\\.lsp
		 .*\\.in .*\\.test .*\\.data }
#
#   problem_excluded_files
#
#	A list of regular expressions, such that a file
#	ANY of whose name components matches ANY of
#	these expressions is NOT a problem source file,
#	problem description file, or problem solution
#	file.  Default:
#
	    set problem_excluded_files \
		{CVS RCS .*\\.rc
		 .*\\.jin .*\\.jout .*\\.jtest
		 .*\\.jfout .*\\.jftest
		 .*\\.jdebug }
#
#   problem_test_files
#
#	A list of file names, NOT regular expressions.
#	These are the files to be tested as solutions
#       by testproblems if they have one of the exten-
#	sions being tested (e.g., cc, java).  If not
#	set, this defaults to all file names of the form
#	PROBLEM*.EXT where EXT is one of the extensions
#	being tested.
#
#   problem_print_files
#
#	A list of file names, NOT regular expressions.
#	These are the files to be printed and given to
#	contestants in order to define the problem.  By
#	default (i.e., if this variable is left undef-
#	ined) this is the sorted list of description
#	files of the problem, as determined by problem_
#	description_files and problem_excluded_files.
#
#	If this list is defined, its order is the order
#	in which the files are printed.  This global
#	variable is most often defined for demonstration
#	problems.
#
#	Default: undefined.
#
#   problem_required_files
#
#	A list of files the contestant is required to
#	submit.  All these must be included in the sub-
#	mission message.
#
#	The default, which is invoked only if this
#	variable is left unset and $EXTENSION is not "",
#	lists just the $PROBLEM$EXTENSION file.  It is
#	an error if $EXTENSION is "" and PROBLEM.rc does
#	not define this global variable.
#
#   problem_optional_files
#
#	A list of files the contestant may optionally
#	submit.  These are optionally included in the
#	submission message.  If this variable is not
#	set, it defaults to the empty list.
#
#   problem_input_names
#
#	List of file names N such that N.in is to be
#	input to the submitted program to test it and
#	produce N.out (and N.err).
#
#	If this variable is not set, it defaults to the
#	list names such that the problem solution direc-
#	tory contains either an N.in or N.jin file,
#	except that $PROBLEM.in is ignored if there are
#	any other files (on the grounds that it is pro-
#	bably a link to another N.in file in this case).
#
#	$PROBLEM should not be included in this list
#	unless it is the only member, as files N.in
#	will be linked to $PROBLEM.in during testing.
#
#	The order of the names in this list is the order
#	the N.in files are used to test the submitted
#	program.  A major use of this variable is to
#	specify this order, as the default value usually
#	suffices if this order does not matter.  The
#	default list is sorted alphanumerically.
#
#   problem_make_files
#
#	A list of instructions the autojudge program
#	uses to make files in the problem solution dir-
#	ectory before linking files from that directory
#	to the submission directory (see problem_link_
#	files below).
#
#	Each instruction has the form:
#
#		{ OUT COMMAND IN1 IN2 ... }
#
#	The file OUT is to be made by executing the
#	COMMAND, provided all the files IN1, IN2, ...
#	exist, and either OUT does not exist or it is
#	older than one of the files IN1, IN2, ... .
#	All this is done by autojudge with the problem
#	solution directory as the current directory.
#
#	If no files IN1, IN2, ... are listed, OUT must
#	not exist if COMMAND is to be executed.  If OUT
#	is older than one of the IN1, IN2, ... files,
#	OUT will be deleted before executing COMMAND
#	(so it may be readonly).
#
#	An instruction can be abbreviated to just a file
#       name F, which is the same as the instruction
#       `{ F { make F } }'.
#
#	The COMMAND is passed to the exec_in_directory
#	function which executes it in sh or csh (see
#	the definition of this function later in this
#	file).  This COMMAND is a character string
#	parsed by a non-TCL shell, and NOT a TCL list.
#
#	The instructions are processed by autojudge in
#	order, so previous instructions can make inputs
#	to later instructions.
#
#	If this variable is not set, it defaults to the
#	empty list.
#
#	After processing problem_make_files, the auto-
#	judge program will do more file making of this
#	kind depending upon the files it finds in the
#	problem solution directory.  It uses the names
#	N listed in the problem_input_names (see above)
#	for this.  For each such N autojudge executes
#	the instruction
#
#	    N.in {jfilter N.jin N.in} N.jin
#
#	that makes N.in from N.jin if the latter exists.
#	Then if the Scoring_Filter file exists in the
#	problem solution directory (after problem_make_
#	files instructions are executed), autojudge
#	executes the instructions
#
#	    N.fout {Scoring_Filter N.in <N.out >N.fout}
#		   Scoring_Filter N.in N.out
#
#	    N.ftest
#		{Scoring_Filter N.in <N.test >N.ftest}
#		Scoring_Filter N.in N.test
#
#	    N.jfout {jfilter N.jin N.fout N.jfout}
#		    N.jin N.fout
#
#	    N.jftest {jfilter N.jin N.ftest N.jftest}
#		    N.jin N.ftest
#
#	while if there is no Scoring_Filter file auto-
#	judge executes
#
#	    N.jout {jfilter N.jin N.out N.jout}
#		    N.jin N.out
#
#	    N.jtest {jfilter N.jin N.test N.jtest}
#		    N.jin N.test
#
#	Note that N.fout, N.jfout, and N.jout are used
#	only if they exist (which is rare) by problem_
#	link_files below to supercede N.ftest, N.jftest,
#	and/or N.jtest.
#
#   problem_link_files
#   problem_optional_link_files
#
#	Lists of link instructions for linking files
#	from the problem solution directory to the pro-
#	blem submission directory.  These are executed
#	by the autojudge program after it makes files in
#	the solution directory as per problem_make_
#	files.
#
#	Each link instruction is itself just a file name
#	or a list of file names.
#
#	If a link instruction is just a file name F, and
#	if F exists in the solution directory, F will be
#	linked to the submission directory.
#
#	If a link instruction is a list { F F1 F2 ... }
#	of names, the names F1, F2, ... are checked in
#	the solution directory, and the first that
#	exists is linked to the name F in the submission
#	directory.  If none of the files F1, F2, ...
#	exist in the solution directory, no link will be
#	made.
#
#	Files designated in problem_link_files instruc-
#	tions must already exist or have a link created
#	for them, else it is an error.  Files designated
#	in problem_optional_link_files instructions need
#	not exist or have the instructions make a link
#	for them.
#
#	If these variables are not set, they default to
#	the empty list.  However, after executing any
# 	link instructions in these variables, the auto-
#	judge program executes the following link in-
#	structions of its own:
#
#	    Makefile Makefile_EXT Makefile
#
#	    Scoring_Filter [if Scoring_Filter exists]
#
#	where EXT is EXTENSION minus the initial `.'.
#	For each name N in problem_input_names (see
#	above):
#
#	    N.in
#	    N.test N.out N.test_EXT N.test
#	    N.jin			        [N.jin]
#	    N.ftest N.fout N.ftest_EXT N.ftest	[SF]
#	    N.jtest N.jout N.jtest_EXT N.jtest	[N.jin,
#					         but not
#						 SF]
#	    N.jftest N.jfout N.jftest_EXT \	[N.jin
#			     N.jftest		 and SF]
#
#	where the []'ed things must exist for the in-
#	struction to be executed, and SF abbreviates
#	Scoring_Filter.
#
#	Note the default link instruction for Makefile
#	permits different Makefiles for different pro-
#	gramming languages: e.g., Makefile_cc for .cc
#	programs.
#
#   problem_copy_files
#   problem_optional_copy_files
#
#	Just like problem_link_files and problem_
#       optional_link_files except that files are copied
#	instead of linked.  This is done so the files
#	will be in the submission directory where hpcm_
#	sandbox can access them; hpcm_sandbox does not
#	have permission to access the solution direc-
#	tory.
#
#	If these variables are not set, they default to
#	the empty list.

# Scoreboard Parameters
# ---------- ----------
#
# All times are in a format that TCL `clock scan'
# can convert.  Most date formats work.

# Modes.
#
# Scoreboard_unsolved_mode determines how problems that
# have not been solved are displayed.  The possible
# values are:
#
#   count	If no incorrect submissions, `......'.
#   		If N incorrect submissions, `..../N'.
#
#   qualifier	If no incorrect submissions, `......'.
#   		If incorrect submissions, `IiOoX' where
#   		I is the number of `in' submissions, O
#   		the number of `inout' submissions, and X
#   		the number of unqualified submissions.
#
set scoreboard_unsolved_mode count

# Scoreboard_solved_mode determines how solved problems
# are displayed.  The possible values are:
#
#   date	Date of first correct submission and
#   		number of submissions.
#
#   time	Time of first correct submission and
#		number of submissions.
#
#   score	Problem score and number of submissions.
#
set scoreboard_solved_mode date

# Scoreboard_sort_mode determines how account total
# scores are displayed and accounts are sorted on score-
# board.  The possible values are as follows, where P is
# the number of problems correct:
#
#   submitter	Submitters are unranked and are sorted
#   		alphabetically by name.
#
#   time	P/TTTT is displayed for each submitter
#   		where TTTT is the total time and
#   		the sort is highest P first, and then
#   		lowest TTTT first.
#   		
#   problems	P is displayed for each submitter and
#   		sort is highest P first, then alphabeti-
#   		cally by submitter name.
#   		
#   score	SSSSSS.SS, the total score, is display-
#		ed, and sort is on the SSSSSS.SS value.
#
#   problems/score
#		P/SSSSSS.SS is displayed, and sort is on
#		P first and SSSSSS.SS second.
#
#   score/problems
#		SSSSSS.SS/P is displayed, and sort is on
#		SSSSSS.SS first and P second.
#
set scoreboard_sort_mode problems

# Finish permission: yes or no
#
# If yes, causes the scoreboard to respect requests from
# the hpcm_finish command to declare a submitter to be
# finished.
#
set scoreboard_allow_finish no
# set scoreboard_allow_finish yes

# The following is the list of factors that are used
# to compute problem scores.
#
#   scoreboard_factor("")
#   scoreboard_factor(in)
#   scoreboard_factor(inout)
#       Multipliers for incorrect submissions with no
#       qualifier, in qualifier, inout qualifier,
#       respectively.  These need not exist if they
#       are not to be used (to compute the score they
#	default to 1.0 but the score may not be used).
#
#   scoreboard_max_score(PROBLEM)
#       For each problem, the maximum score.  If this
#       does not exist, 100.0 is assumed.

# Contest start, stop, freeze, and cut times.
#
# The start, stop, and cut times are used in actually
# computing the scoreboard table (by the `judge/bin/
# scoretable' program using judge/lib/scoreboard_
# common.tcl), as follows.
#
# If the start time is not "", "problem", or "team", it
# is a date and time (a legal argument for `clock scan')
# and is the start time of all problems.  Any problem
# which was gotten or first submitted before this start
# time is ignored.
#
# If the start time is "", the start time of a problem
# is unknown, and the time of the problem is unknown,
# so that `time' cannot be used as a scoreboard_solved_
# mode or scoreboard_sort_mode value.
#
# If the start time is "problem", the time a problem is
# gotten is used as the start time for that problem.  If
# the start time equals "team", the time the team got
# its first problem permitted by the scoreboard_problems
# global variable (see below) is the start time for all
# problems for that team.  In both these cases, if the
# first submission regarding a problem is not a get of
# that problem, then the problem is ignored.  Such gets
# happen in contests where the problem directories are
# subdirectories of judging_directory/info/problems (as
# per the makecontest -info option) but not of $judging_
# directory/contest/problems (i.e., the makecontest
# -problems option is NOT used).  So a start time of
# "problem" or "team" must be used with the makecontest
# option -info but WITHOUT the makecontest -problems
# option.  Conversely, if the makecontest -problems
# option is used, the start time must be either "" or
# a date and time.
#
# Cut times are used to exclude teams that stopped
# early.  They permit a team to simultaneously enter
# several contests of different durations with the same
# problems.   Each contest has cut times that exclude
# teams that do not make submissions within a certain
# period after the team start time.  More specifically,
# a team is excluded from the contest if it does not
# either make a correct submission at or after the
# `correct cut time' and at or before the `final cut
# time', or make an incorrect submission at or after
# the `incorrect cut time' and at or before the `final
# cut time'.  Cut times can be given as date and time,
# or they can be given as integers which are numbers
# of seconds added to the problem start time.
# 
# A non-"" stop time excludes submissions made after the
# stop time (this is done AFTER the cut time rules have
# been applied).  A stop time can be a date and time, or
# it can be an integer that is added to the start time
# of the problem.
#
# The freeze time is only used as a parameter in score-
# board instructions used by the `makescoreboard' pro-
# gram, and is usually used only for formal contests.
# It may be given in date and time format, or as a
# number of seconds after a start time that is given in
# date and time format.
 
# The default values are for scoreboarding a practice
# facility that operates 24 hours a day, every day and
# has an untimed scoreboard.
#
set scoreboard_start_time ""
set scoreboard_freeze_time ""
set scoreboard_stop_time ""
set scoreboard_correct_cut_time ""
set scoreboard_incorrect_cut_time ""
set scoreboard_final_cut_time ""

# See sample values in
#
#   hpcm/contests/acm_contest/hpcm_judging.rc
#   hpcm/contests/timed_practice/hpcm_judging.rc
#   hpcm/contests/untimed_practice/hpcm_judging.rc
#   hpcm/contests/algorithm_festival/hpcm_judging.rc

# The scoreboard can be shutdown or reconfigured
# at the scoreboard_shutdown_time if that is not "".
# When this time arrives, the makescoreboard program
# deletes the Scoreboard_PID file, executes the
# scoreboard_shutdown procedure, and exits.
# 
set scoreboard_shutdown_time ""
proc scoreboard_shutdown {} {}

# Scoreboard name.  Typically just the name of the
# contest.  Used by NAME abbreviation in `scoreboard_
# instructions': see below.
#
set scoreboard_name ""

# The start time and correct submission time of a pro-
# blem, and the penalty of the contest, are used to com-
# pute the problem time.  The penalty is the number of
# SECONDS added to the problem time for each incorrect
# submission for the problem prior to the first correct
# submission for the problem.  It only affects the time
# of a problem that was submitted correctly.
#
set scoreboard_penalty 0
#
# A 20 minute penalty is typical if there is a penalty.
#
# set scoreboard_penalty [expr { 20 * 60 }]

# Logical expressions specifying problems and submit-
# ters.  Each logical expression is a TCL list whose
# elements are operators, parentheses `(' and `)', and
# atoms.  The allowed operators are `!', `&', `^', and
# `|' in highest precedence first order, denoting `not',
# `and', `exclusive-or', and `inclusive-or'.  Operators
# and parentheses MUST be surrounded by whitespace.
# 
# The atoms `0' and `1' represent `false' and `true'.
# All other atoms are regular expressions that are
# matched to the ENTIRE problem name or submitter name,
# and are true iff they match.
#
# The problems logical expression is stored in `score-
# board_problems'.  If it is not the empty list, only 
# problems matching it are included in the scoreboard.
# The submitter logical expression is similar and is
# stored in `scoreboard_submitters'.
#
# Some simple examples of logical expressions are:
#
#   ! count	    Match all names but `count'.
#
#   count | pascal  Match only `count' and `pascal'.
#
#   count|pascal    Ditto, but with only one regular
#		    expression atom that contains a
#		    `|', instead of two atoms and a
#		    `|' logical operator.
#
#   bpi[0-9]+	    Match all names of the form
#		    `bpi' followed by one or more
#		    digits.
#
#   bpi.* & ! bpit  Match all names beginning with
#		    `bpi' except the one name
#		    `bpit'.
#
# The regular expressions are TCL regular expressions.
# Note that a regular expression must not as a charac-
# ter string be the same as an operator or parenthesis
# or special atom `0' or `1'.
# 
set scoreboard_problems { }
set scoreboard_submitters { }

# Get list of demonstration problems if demos_solution_
# files is readable, or empty list otherwise.
#
proc get_demo_problems {} {
    global judging_directory
    set dsf $judging_directory/demos_solution_files
    if { [file readable $dsf] } {
	return [get_problems_from_file $dsf]
    } else {
	return {}
    }
}
 
# Maximum width of scoreboard in columns.
#
set scoreboard_width 80

# Characters used to mark lines in the scoreboard table
# if there are more than two lines worth of problems.
# The first line always uses a space character to sepa-
# rate columns; and the last line uses underbar charac-
# ters everywhere space characters are used.  If there
# are N > 2 lines, the n'th line for 1 < n < N uses the
# n-1'st character of the following string as a column
# separator.
#
set scoreboard_markers "|$!#^%@<>"

# List of items to be added to judging_commands that
# create filters to which the scoreboard is to be
# sent.  See judging_commands for documentation.
#
# Scoreboard_commands differ from judging_commands in
# that omitted REMOTE-COMMANDs default to:
#
#     "head -c 10000 >./public_html/PAGE;\
#      chmod 644 ./public_html/PAGE"
#
set scoreboard_commands {}

# Interval in seconds between times when the `make-
# scoreboard' program looks at flags and file modi-
# fication times to see if it needs to remake a
# scoreboard.
#
set scoreboard_interval 60
 
# Scoreboard instructions.   These determine which
# scoreboards the `makescoreboard' program will compute
# and how it will compute them.  The syntax is:
#
#	scoreboard_instructions ::=
#	    scoreboard_block
#
#	scoreboard_block ::= { scoreboard_subblock* }
#
#	scoreboard_subblock ::=
#	      scoreboard_instruction
#	    | scoreboard_if_statement
#	    | scoreboard_comment
#
#	scoreboard_comment ::= {#<any-text>#}
#
#	scoreboard_if_statement ::=
#	      if <expression> <scoreboard_block>
#	      { elseif <expression>
#		       <scoreboard_block> }*
#	      [ else <scoreboard_block> ]
#
#	scoreboard_instruction ::=
#	      { OUTPUT filename [start [stop]] }
#	    | { SEND [parameter_name] }
#	    | SEND
#	    | GRANT_ACCESS
#	    | BLANK
#	    | BAR
#	    | { BAR center_text }
#           | { LINE left_text [center_text
#                                   [right_text]] }
#	    | { INPUT filename ... }
#	    | { parameter_name value }
#	    | BOARD
#	    | { ERROR error_message }
#
#	start ::= "<a date and time>"
#	stop  ::= "<a date and time>"
#	xxx_text ::= "-quoted or {}-quoted string
#
#	parameter_name ::=
#	    <any XXX such that `scoreboard_XXX' is a
#	     global variable after judging directory
#	     hpcm_judging.rc is read>
#
# If_statement expressions may reference any global
# variable beginning with `scoreboard_'.  If statement
# expressions are evaluated before anything else is
# done, and should not set any global variables or write
# files.
#
# The scoreboard instructions are executed in order and
# do the following:
#
#     { OUTPUT filename [start [stop]] }
#		Starts an output file.  Other commands
#		effect the current output file.  See
#		below for start and stop.
#
#     { SEND [parameter_name] }
#		Whenever the current output file is
#		written, pipe the file to ./secure/bin/C
#		for each C listed in the global variable
#		`scoreboard_PN', where PN is the
#		parameter_name.  The values of C should
#		be NAMEs from items in the `scoreboard_
#		commands' global variable.  If `score-
#		board_PN' is empty or does not exist,
#		nothing is done.
#
#		If parameter_name is omitted, all NAMEs
#		of items in `scoreboard_commands' are
#		used as values of C; see `scoreboard_
#		commands' for more details.
#
#     GRANT_ACCESS
#		Whenever the current output file is
#		written, it is made readable by every-
#		one.
#
#     BLANK	Include a blank line.
#
#     BAR	Include a ===== bar line.
#
#     { BAR center_text }
#		Include a ===== bar line that has the
#		text centered in the line, with single
#		space characters separating the text
#		from the ===='s.
#
#     { INPUT filename ... }
#		Include a copy of a first readable file
#		in the list of files.  Do nothing of no
#		listed file is readable.
#
#     { LINE left_text [center_text [right_text]] }
#		Include a line that has left_text left
#		justified, center_text centered, and
#		right_text right justified.  The right_
#		text or both the center_ and right_
#		texts can be omitted.  If texts would
#		overlap, two or three lines are in-
#		cluded to avoid overlap.
#
#     { parameter_name value }
#		Set the parameter PN, i.e., the global
#		variable `scoreboard_PN', to the value,
#		where PN is the parameter_name.
#
#     BOARD	Include a scoreboard table computed with
#		previously set parameters.
#
#     { ERROR error_message }
#		Causes a system error with the given
#		error message.
#
# An output file is not actually written until the next
# OUTPUT command or the end of the instructions. All
# non-absolute file names are relative to the judging
# directory.  The current value of the `scoreboard_
# width' parameter is used by the LINE and BAR instruc-
# tions.
#
# If a non "" start time is given in an OUTPUT instruc-
# tion, that output will not be produced until after
# the given start time.  If a non "" stop time is given,
# in an OUTPUT instruction, that output will not be pro-
# duced if it already exists and has a modification time
# equal to or greater than the stop time.  Setting the
# start and stop times equal will produced an output
# just once after the given time.
#
# The start and stop times of an OUTPUT command, the
# values of a parameter, and the texts of a LINE or BAR
# command can be the following special abbreviations:
#
set scoreboard_abbreviation(NAME) name
set scoreboard_abbreviation(TIME) time
set scoreboard_abbreviation(START) start_time
set scoreboard_abbreviation(STOP) stop_time
set scoreboard_abbreviation(FREEZE) freeze_time
#
# which means, for example, that NAME abbreviates the
# value of `scoreboard_name'.  Additional abbreviations
# may be added to this map.  `scoreboard_time' is the
# time when the `makescoreboard' program starts execut-
# ing the scoreboard instructions.
#
# These values can also have the form of an abbreviation
# whose value is a time + or - an integer number of
# seconds.  E.g., "STOP+300" denotes the STOP time plus
# 300 seconds (5 minutes).  The value must be an abbre-
# viation followed immediately by a + or - sign followed
# immediately by one or more digits.
#
# Note that changes to parameters made by parameter set-
# ting instructions are undone by the next OUTPUT
# instruction.
#
# For sample scoreboard_instructions value see
#
#   hpcm/contests/acm_contest/hpcm_judging.rc
#   hpcm/contests/timed_practice/hpcm_judging.rc
#   hpcm/contests/untimed_practice/hpcm_judging.rc
#   hpcm/contests/algorithm_festival/hpcm_judging.rc

# Scoreboard_mode_array is a map from the scoring_mode
# (see `Scoring Parameters') to a regular expression
# that must match all scorefinder codes used to con-
# struct a scoreboard.  Scorefinder output lines with
# non-matching codes are simply ignored.  Scoreboard_
# mode_array is only changed if the set of possible
# scoring modes is being changed.
#
# Scoreboard_mode_array($scoring_mode) is a TCL regular
# expression that must match the entire code output by
# scorefinder in order for the line containing the code
# to be used in computing a scoreboard.
#
set scoreboard_mode_array(manual) \
    {m(i|c)f.|g}
set scoreboard_mode_array(auto) \
    {(a|m)(i|c)f.|g}
set scoreboard_mode_array(auto+manual) \
    {(a|m)(i|c)(n|f).|g}
set scoreboard_mode_array(manual+auto) \
    {(a|m)(i|c)(n|f).|g}

# scoreboard_test_time, if not "", is taken as the
# current time of day in place of [clock seconds] by the
# scoreboard producing software.  This is for testing
# this software.  It is also used by the is_later
# function which in turn is used in contest specific
# hpcm_judging.rc files to change the behavior of the
# scoreboard after a specified time.
#
set scoreboard_test_time ""

# Web Page Parameters
# --- ---- ----------

# These parameters control the makeweb program that
# makes a web page containing problem statements and
# optionally solutions.  Makeweb makes a web directory
# for the current contest (after the other contest
# directories have been made).  The web directory
# contains an index.html file and other files and
# directories referenced by this index.html file using
# relative URLs.  The web directory is typically copied
# to another place to be put on the WWW.

# Name of web directory.  If set to "", defaults to 
# $judging_directory/web.
#
set web_directory ""

# Title for the web page (the index.html file).  If "",
# no web pages should be made.  Can be set to contest
# name.
#
set web_title ""

# Attributes for the <BODY> tag.  If "", a default is
# constructed that defines the colors of used and unused
# links (VLINK and LINK attributes).
#
set web_body_attributes ""

# Set the following to "yes" to produce the $web_
# directory/problems web page that includes descriptions
# of the problems.  Set to "protect" to do the same
# but make the problems inaccessible; it can be made
# accessible by following instructions given in a
# comment in the web_directory page.  Set to "no" to
# not make any $web_directory/problems web page, in
# which case web_problems_URL will be used to locate
# the problem descriptions if that is not "".
#
set web_problems no
set web_problems_URL ""

# If not "", include solutions in a private/pppp sub-
# directory of the web directory, where pppp is the
# value of this parameter.  Without knowing the pass-
# word, the solutions subdirectory cannot be accessed,
# as the private directory is made unreadable by the
# public.  Mention of the existence of solutions is
# included in the web directory index.html file, but
# the password is not included.
#
set web_solutions_password ""

# If not "", include in index.html a reference to this
# as the e-mail address of the autojudge.
#
set web_autojudge_address ""

# If not "", include in index.html a reference to this
# page where there is a `Contest Description'.  May be
# relative to the web directory.  Typical values are
# "help/contest/acm_contest" and "help/contest/untimed_
# practice" if web_help_URL below has the value "help".
#
set web_description_URL ""

# If not "", include in index.html a reference to help
# and demo files.  This parameter is the URL of the
# help and demos information and may be relative to the
# web directory.  See hpcm/contestant/help/Makefile
# for a `make web' command that can create a help and
# demos web page.
#
set web_help_URL ""

# If not "", include in index.html a reference to the
# scoreboard.  This parameter is the URL of the score-
# board and may be relative to the web directory.
#
set web_scoreboard_URL ""

# If not "", at the end of index.html place contact
# information for the web page manager at the given
# email address.
#
set web_manager_address ""

# There are three web pages:
#
#     $web_directory	
#         Produced if web_title is not ""
#
#     $web_directory/problems
#         Produced if web_title is not "" and
#	  web_problems is not "no".
#
#     $web_directory/private/$web_solutions_password
#         Produced if web_title is not "" and web_
#         solutions_password is not "".
#
# Each has a title made from web_title, a header that
# is made automatically from web_title if given as "",
# and a prefix that immediately follows the header.
# The web_directory page also has a postfix given
# at the end of the page just before the line that
# specifies the web_manager as a contact.

set web_header ""
set web_prefix ""
set web_postfix ""
set web_problems_header ""
set web_problems_prefix ""
set web_solutions_header ""
set web_solutions_prefix ""

# The main web page has the format (roughly):
#
#   web_header
#   web_prefix
#   <UL>
#	web_prefix_list_elements
#	Autojudge Address
#	Contest Description
#	Help and Demos Files
#	Problem Descriptions and Sample Input/Output
#	Scoreboard
#	Solutions
#	web_postfix_list_elements
#   </UL>
#   web_postfix
#       Contact: web_manager
#
set web_list_prefix_elements ""
set web_list_postfix_elements ""

# Scoring Parameters
# ------- ----------


# Scoring Mode:
#
#	auto		Automatic scoring only; auto-
#			judge sends the score to the
#			contestant as final.
#	auto+manual	Automatic scoring plus manual
#			review of everything not `Com-
#			pletely Correct'; autojudge
#			sends the score to the contest-
#			ant as final if the score is
#			`Completely Correct', and as
#			to-be-reviewed otherwise.
#	manual		Manual scoring only; auto-
#			judge does not send the score
#			to the contestant.
#
# Note that the definition of scoring mode is completely
# contained in the response instructions below and the
# scoreboard_mode_array above, and can therefore be
# changed by changing just these.
#
set scoring_mode auto

# Maximum number of proofs for each type of difference
# that are recorded in the .score file.
#
set difference_type_proof_limit 100

# .err File Regexps:
#
# Regexp expressions matched to lines in .err file to
# detect limit overruns.  Letter case is ignored.
# The regular expressions match successfully if they
# match any part of a line.
#
set time_limit_regexp {cpu time limit exceeded}
set output_limit_regexp {file size limit exceeded}

# Scoring instructions are a TCL list whose elements
# control how the scorediff program compares the .out
# (.fout, .jout, .jfout) file with the .test (.ftest,
# .jtest, .jftest) file.  By default, scoring instruc-
# tions come from the following variable:
#
#	set scoring_instructions "space column"
#
# (This variable is set in `Problem .rc Files' above.)
#
# This variable is often changed on a per-problem basis
# by the file PROBLEM.rc.  Scoring instructions can also
# be specified on a per input file basis by the
# *SCORING* parameter in a .jin file.
#
# The scoring_instructions variable is a TCL list that
# can contain the following elements:
#
#   whitespace
#       Allow matching whitespace in the two files to be
#       not exactly the same, if each whitespace is
#	within a line and not at the beginning or end of
#	the line.  Such mismatches are automatically
#	allowed if either whitespace is followed by a
#	floating point number.
#
#   beginspace
#	Allow matching whitespace in the two files to be
#	not exactly the same, if each whitespace is at
#	the beginning of a line.  Such mismatches are
#	automatically allowed if either whitespace is
#	followed by a floating point number.
#
#   endspace
#	Allow matching whitespace in the two files to be
#	not exactly the same, if each whitespace is at
#	the end of a line.
#
#   linespace
#	Allow whitespace within blank lines to not
#	match.
#
#   space
#	The union of whitespace, beginspace, endspace,
#	and linespace.
#
#   spacebreak
#	Allow one file to have whitespace (including
#	possibly a line break) where the other file has
#	no whitespace at all.  Consider using nosign or
#	nonumber with this.
#
#   linebreak
#	Allow matching non-empty whitespaces to contain
#	different numbers of line breaks.  Thus one file
#	can have a line break where the other file has
#	none.  If this happens, the whitespace at the
#	beginnings and ends of the lines involved, and
#	within blank lines, need not match.
#
#   integer A R
#	Allow the two files to have matching integers
#	whose absolute difference is as much as A, OR
#	whose relative difference is as much as R, where
#	A and R are floating point values.  Numbers
#	whose character strings match exactly are not
#	considered different in this sense.
#
#	Either A or R may be negative or just `-' to
#	effectively disable the absolute or relative
#	test.
#
#	See below for the definition of relative differ-
#	ence.
#
#	An integer is a number with no decimal point or
#	exponent.
#
#   float A R
#	Allow the two files to have matching numbers, at
#	least one of which is floating point, whose
#	absolute difference is as much as A, OR whose
#	relative difference is as much as R, where A and
#	R are floating point values.  Numbers whose
#	character strings match exactly but for the
#	letter case of any exponent `e' or `E' are not
#	considered different in this sense.
#
#	Either A or R may be negative or just `-' to
#	effectively disable the absolute or relative
#	test.
#
#	A floating point number is a number with a deci-
#	mal point or exponent.
#
#	See below for the definition of relative differ-
#	ence.
#
#   decimal
#	Allow two files to have matching numbers that
#	have different numbers of decimal digits, or for
#	which only one of the matching numbers has a
#	decimal point.
#
#   exponent
#	Allow two files to have matching numbers just
#	one of which has an exponent.
#
#   sign
#	Allow two files to have matching numbers just
#	one of which has an explicit sign, or both of
#	which have different explicit signs.
#
#   number A R
#	The union of `integer A R', `float A R',
#	`decimal', `exponent', and `sign'.
#
#   letter-case
#	Allow letters outside of numbers to match if
#	they are the same but for letter case.
#
#   column
#	Allow two files to have matching numbers or
#	words that do not end in the same line column.
#
#	For the purpose of computing character line
#	column positions, tabs are set every 8 columns.
#
#   words-are-format
#	Causes differences in words (any non-numbers) to
#	indicate a formatting error and not an incorrect
#	or incomplete output error.  That is, if all the
#	numbers are correct and in the correct sequence,
#	the score will either be completely correct or
#	formatting error.
#
#	This allows misspelled, omitted, or extra words
#	to be treated as formatting errors, as long as
#	no words are required for correctness.
#
#   nonumber
#	Specifies that all number characters should be
#	treated as word characters, so there are no num-
#	ber tokens.
#
#   nosign
#	Specifies that sign characters preceding numbers
#	should be treated as word characters, so numbers
#	can only include signs in their exponent parts.
#
#   The relative difference of two numbers x and y is
#   defined to be:
#
#                      | x - y |
#                   ----------------
#                   max ( |x|, |y| )
#
#   which has a maximum value of 2.  If x = y = 0, the
#   relative difference of x and y is defined to be 0.

# Response Instructions
# -------- ------------

# Response mode.  Some of the following separated by
# `+'s, but without ANY whitespace.
#
#   cerr	Return the compiler error file, i.e.,
#		the .cerr file, if the score is `Syntax
#		Error', regardless of submit qualifier
#		or how the score is determined.
#
#   solution	Return the judge's solution files, if
#		score is `Completely Correct' and the
#		submit qualifier was `solution', regard-
#		less of how the score is determined.
#
#   in		Return the test case input for the first
#		judge test case on which the submission
#		failed, if the score is automatically
#		determined, is not `Completely Correct',
#		and the submit qualifier is `in'.
#
#   inout	Ditto for test case input and output and
#		the `inout' submit qualifier.
#
#   ""		None of above.
#
# Except for `cerr', these just enable the submission
# qualifiers with the same name.  E.g., a response mode
# of `in+inout+solution' enables the submission quali-
# fiers `in', `inout', and `solution'.
#
set response_mode ""

# Email addresses to which the CC response command cc's
# responses if it is not "".  Other programs that do not
# use response commands also cc any responses to the
# submitter to these addresses.
#
# This is a list of the format
#
#   { { regexp1 address1 } { regexp2 address2 } ... }
#
# such that email sent from a directory named
# `date-<<submitter>>-submission' will be cc'ed to
# addressI if `submitter' matches regexpI.  More than
# one  may match.  AddressI may contain spaces if it
# is quoted, and may contain multiple email addresses
# separated by commas.
#
set response_manager_map ""

# The following maps submitted extensions to lists of
# solution extensions.  The listed solution extensions
# are tried in order by the SOLUTION response command,
# and the first extension giving a readable file is
# used.  Normally the submitted extension is listed
# first.
#
array set solution_ext_map {
    .c {.c .cc .java .lsp}
    .cc {.cc .c .java .lsp}
    .java {.java .cc .c .lsp}
    .lsp {.lsp .java .cc .c}
}

# List of global variables that can be referenced in
# the if-expressions of the response instructions.
#
#   manual
#   proposed
#
# are reserved and cannot be used.  Do NOT delete from
# the following list.
#
set response_instructions_globals {
    response_mode
    scoring_mode
    auto_score
    auto_score_marker
    manual_score
    proposed_score
    submitted_problem
    submitted_extension
    submit_qualifier
    response_qualifier
}

# Instructions on how to respond to the submitter when a
# new score is determined are provided in the following
# variable.   Additional instructions can be prepended
# to this global variable value by a problem .rc file.
# The EXIT command (see below ) should be used in any
# prepended instructions whenever the following is not
# supposed to execute.
#
# The response instructions and the scoreboard_mode_
# array together define the possible scoring_mode values
# and their meanings.
#
# See below for a detailed description of response in-
# structions.
#
set response_instructions {

    if { ! $manual && ! $proposed } {

        {# Come here if autojudge running. #}

	{# Output the score from the autojudge. #}

	if { $scoring_mode == "manual" } {
	    NO-REPLY
	    EXIT
	} elseif { $scoring_mode == "auto" } {
	    { LINE "For -PROBLEM- the automatically\
	    	    determined final score is:" }
	    BLANK
	    { LINE "    -AUTO-SCORE-" }
	    CC
	    FINAL
	} elseif {     $auto_score \
		   == "Completely Correct" } {
	    { LINE "For -PROBLEM- the automatically\
	    	    determined final score is:" }
	    BLANK
	    { LINE "    -AUTO-SCORE-" }
	    FINAL
	} elseif { [lcontain {auto+manual manual+auto} \
			     $scoring_mode] } {

	    { LINE "For -PROBLEM- the automatically\
	    	    determined score is:" }
	    BLANK
	    { LINE "    -AUTO-SCORE-" }
	    BLANK
	    { LINE "However, this score WILL BE\
		    REVIEWED by the human judge\
		    (soon)." }
	    NOT-FINAL
	} else {
	    { ERROR "bad scoring mode" }
	}

	{# Output in, inout, info from the autojudge. #}

	if { $response_qualifier == "" } {
	} elseif { ! [lcontain \
	                [split $response_mode +] \
			$response_qualifier] } {
	    { ERROR "response_qualifier is not in\
	             response_mode" }
	} elseif {       $auto_score \
		      != "Completely Correct" \
		   && [lcontain {in inout} \
			 $response_qualifier] } {

	    BLANK
	    if { [lcontain {in inout} \
	                   $response_qualifier] } {
		IN
	    }

	    if { $response_qualifier == "inout" } {
		OUT
	    }
	    BAR
	}

    } elseif { ! $manual && $proposed } {

        {# Come here if manualreply is being used to
	   set the manual score = proposed score. #}

	FINAL
	if { $scoring_mode == "manual" } {
	    { LINE "For -PROBLEM- your final score\
	    	    is:" }
	    BLANK
	    { LINE "    -PROPOSED-SCORE-" }
	} elseif { [regexp {auto} $scoring_mode] } {

	    if { $scoring_mode == "auto" } {
	    	EDIT
	    }

	    { LINE "For -PROBLEM- your previous\
	            automatic score of:" }
	    BLANK
	    { LINE "    -AUTO-SCORE-" }
	    BLANK

	    if { $proposed_score == $auto_score } {

		{ LINE "has been verified and confirmed\
		        by the human judge!" }
		{ LINE "Thus your FINAL score is:" }
		BLANK
		{ LINE "    -PROPOSED-SCORE-" }
		BLANK
		{ LINE "for this submission." }

	    } else {

		if { $scoring_mode != "auto" } {

		    { LINE "has been OVERRIDDEN by the\
		    	    human judge!" }
		} else {
		    {LINE "has been UNEXPECTEDLY\
			   OVERRIDDEN by the human\
			   judge!" }
		}

		BLANK
		{ LINE "The human judge has assigned\
			the NEW FINAL score:" }
		BLANK
		{ LINE "    -PROPOSED-SCORE-" }
		BLANK
		{ LINE "to this submission." }
	    }
	} else {
	    { ERROR "bad scoring mode" }
	}
    } elseif { $manual && $proposed } {

        {# Come here if manualreply is being used to
	   override a previous manual score, using
	   proposed score as the new score, or
	   manualreply is being used to verify the
	   previous score (we EDIT in either case). #}

	FINAL
	EDIT
	{ LINE "For -PROBLEM- your PREVIOUS FINAL\
		manual score of:" }
	BLANK
	{ LINE "    -MANUAL-SCORE-" }
	BLANK

	if { $proposed_score == $manual_score } {
	    { LINE "has been verified and confirmed by\
	    	    the human judge!" }
	} else {
	    { LINE "has been UNEXPECTEDLY OVERRIDDEN by\
	    	    the human judge!" }
	    BLANK
	    { LINE "The human judge has assigned the\
	    	    NEW FINAL score:" }
	    BLANK
	    { LINE "    -PROPOSED-SCORE-" }
	    BLANK
	    {LINE "to this submission." }
	}
    } else {
	{ ERROR "manual score exists but no proposed\
	         score exists" }
    }

    {# Add compiler error output if score is to be
       `Syntax Error' and cerr is in response_mode. #}

    if { $proposed_score == "Syntax Error" || \
         ( ! $proposed && \
           $manual_score == "Syntax Error" ) || \
         ( ! $proposed && ! $manual && \
           $auto_score == "Syntax Error" ) } {

        if { [regexp cerr $response_mode] } {
	    BLANK
	    { LINE "The compiler error output\
		    follows." }
	    BAR
	    CERR
	    BAR
	}
    }

    BLANK
    { LINE "See below for submission time." }
    BLANK
    { BAR "this message replies to:" }
    RECEIVED-HEADER

    {# Add solution if score is to be `Completely
       Correct' and solution is qualifier and also
       in response_mode. #}

    if { $proposed_score == "Completely Correct" || \
         ( ! $proposed && \
           $manual_score == "Completely Correct" ) || \
         ( ! $proposed && ! $manual && \
           $auto_score == "Completely Correct" ) } {

        if {    $response_qualifier == "solution" \
	     && [regexp solution $response_mode] } {
	    BLANK
	    BAR
	    { LINE "For comparison purposes,\
		    our solution follows." }
	    { LINE "PLEASE do NOT make ANY\
		    solution PUBLIC." }
	    SOLUTION
	}
    }
}

# The `response_instructions' variable value is a TCL
# list consisting of commands and if-statements.  The
# if-statements have the format of TCL if statements:
#
#    	if <expression> <block>
#	elseif <expression> <block>
#	else <block>
#
# where any number of elseif parts may be given and the
# else part is optional.  Note that the words `if',
# `elseif', and `else' are TCL list elements as are the
# expressions and blocks.  Each block is recursively
# interpreted as a TCL list consisting of commands and
# if-statements.  The if-statement expressions can be
# evaluated without evaluating any commands, so the
# sequence of commands that is to be executed can be
# determined and the if-statements can be removed in a
# first pass.
#
# If-statement expressions can be any TCL expr expres-
# sion.  Some of the variables that can be used are:
#
#   $scoring_mode
#	The value of the scoring_mode global variable.
#
#   $response_mode
#	The value of the response_mode global variable.
#
#   $auto_score
#	The value of the non-marker part of the
#	Auto_Score file.
#
#   $auto_score_marker
#	The value of the marker part of the Auto_Score
#	file, changed to a TCL list by replacing `:'s
#	by spaces.  "" if no marker.
#
#   $manual_score
#	The value of the Manual_Score file, or `None'
#	if this file does not exist.  Set to `None' in
#	the autojudge program.
#
#   $proposed_score
#	The score which the person running the manual-
#	reply program has chosen as the final score.
#	Set to `None' if the manualreply program is not
#	being used to set the score.  Always set to
#	`None' in the autojudge program, and never set
#	to `None' in the manualreply program.
#
#   $manual
#	Equals $manual_score != "None".
#
#   $proposed
#	Equals $proposed_score != "None".
#
#   $submitted_problem
#	Problem name from the submit mail `Subject'
#	field.
#
#   $submitted_extension
#	Extension from the submit mail `Subject' field.
#
#   $submit_qualifier
#	Qualifier from the submit mail `Subject' field.
#	But usually response_qualifier is used instead.
#
#   $response_qualifier
#	Equals submit_qualifier unless this is "",
#	in which case equals default_correct_qualifier
#       if auto_score is "Completely Correct" or
#	default_incorrect_qualifier otherwise.
#
# If-statement expressions can only use the variables
# whose names are listed in the `response_instructions_
# globals' variable, except for $manual and $proposed.
# Note that none of these variables can be set by
# response instruction commands, nor should any expres-
# sion change the state of the TCL program when it is
# evaluated (e.g., do NOT use `[catch { set foo 9 }]').
#
# The response instructions commands are executed to
# construct the reply.  The possible commands are:
#
#     FINAL
#     NOT-FINAL 
#     NO-REPLY
#	  Exactly one of these commands must be execut-
#	  ed, to indicate whether a reply is to be sent,
#	  and if it is to be the final reply for the
#	  submission.  If FINAL is executed, a final
#	  reply is sent and Reply_Mail is created; if
#	  NOT-FINAL is executed a reply is sent that is
#	  not final, and no Reply_Mail is created; if
#	  NO-REPLY is executed no reply is sent.  It is
#	  an an error if zero or more than one of these
#	  commands is executed.
#
#     CC
#	  Cc the reply according to the `response_
#	  manager_map' value.
#
#     EDIT
#	  This command indicates that the reply composed
#	  by the response instructions should be edited
#	  by a person before being sent.  The manual-
#	  reply program calls the editor if this command
#	  is executed.  It is an error to execute this
#	  command in the autojudge program.  (i.e., when
#	  $proposed is false).
#
#     EXIT
#	  This terminates command execution, and any
#	  commands following this command are ignored.
#
#     { LINES "string" ... }
#     { LINE  "string" }
#	  The strings, each followed by a line feed, are
#	  included in the reply.  Note that the strings
#	  may themselves include line feeds.
#
#	  Several special substrings are substituted for
#	  within each string as follows:
#
#	    -PROBLEM-	        The problem name.
#	    -AUTO-SCORE-	$auto_score value.
#	    -MANUAL-SCORE-	$manual_score value.
#	    -PROPOSED-SCORE-    $proposed_score value.
#	    -SUBMIT-QUALIFIER-  $submit_qualifier value.
#
#     BLANK
#	  Include a blank line in the reply.
#
#     BAR
#	  Inserts a 72 character ----- bar line.
#
#     { BAR "string" }
#	  Inserts ----- bar line that ends with a space
#	  followed by the string.  The total number of
#	  characters in the line is 72.  Special sub-
#	  strings are substituted for as for LINE.
#
#     { INPUT filename }
#	  Include a copy of the file in the reply.
#
#     RECEIVED-HEADER
#	  Include a copy of the Date, To, From, Reply-
#	  To, and Subject header lines of the Received_
#	  Mail file in the reply.  Note the X-HPCM-
#	  Reply-To and X-HPCM-Date lines are NOT used
#	  to compute these.
#
#     RECEIVED-FULL-HEADER
#	  Include a copy of the ENTIRE Received_Mail
#	  message header in the reply.
#
#     RECEIVED-BODY
#	  Include the body of the Received_Mail file in
#	  the reply.  Note that the blank line between
#	  the header and the body of an email is NOT
#	  included in RECEIVED-HEADER, RECEIVED-FULL-
#	  HEADER, or RECEIVED-BODY.
#
#     CERR
#	  Include the compiler error .cerr file in the
#	  reply.
#
#     IN
#	  If the first judge's test case that failed
#	  comes from input derived from the xxxx.jin
#	  file, include the input for this test case
#	  preceded by a BAR line containing xxxx and
#	  the group and case numbers of the failed test
#	  case.  If the input was not derived from an
#	  .jin file, include the entire xxxx.in file
#	  that provided the input, preceded by a BAR
#	  line naming the xxxx.in file.
#
#     OUT
#	  Ditto for judge's output (.test) files.
#
#     SOLUTION
#	  Include the solution files in the reply.  Each
#	  file is proceeded by a BAR line containing the
#	  file's name.  The solution files include all
#	  problem_required_files, or if this variable
#	  does not exist, the first readable file with
#	  the problem name as root name and with an
#         extension listed in solution_ext_map(ext)
#	  where ext is the submitted extension, or if
#         this variable does not exist, with extension
#	  ext.  In all cases any problem_optional_files
#         are added to the solution files.
#
# Response instructions are used by the autojudge and
# manualreply program, which compose score based replies
# to problem submissions.

# Submission Parameters
# ---------- ----------

# Set the following to `yes' if submissions must have
# files in the format:
#
#	HPCM_BEGIN filename
#	..first line of file
#	..second line of file
#	.. . . . more lines of file
#	HPCM_END filename
#
# Set following to `no' if submissions may also have
# files verbatim in the body of the submission message.
# See `extractmail' for details.
#
set format_submissions no

# Some mailers add stuff at the end of a message that
# needs to be ignored.  The following is a regular
# expression that matches whole lines that terminate the
# body of a submission message.  The regular expression
# is case insensitive (it is applied with the regexp
# -nocase option).
#
# Yahoo adds a --------.* line followed by Yahoo stuff.
# OK as long as we do not support languages that use
# `--' to begin comments, like ADA.
#
set message_terminator "--------.*"

# Permitted Content-Transfer-Encoding and Content-Type
# values, as regular expressions.  For multipart
# messages these are for the part.  Leading whitespace
# is stripped before the value is tested by the regular
# expression.  Messages that do not explicitly specify
# these fields have default values 7bit and text/plain.
#
set content_transfer_encoding_values \
    "(7bit|8bit|quoted-printable|base64).*"
set content_type_values "text/(plain|x-.*).*"



# Authentication Switch: yes or no
#
# Usually yes for informal and formal contests and no
# for email contest.  See authentication functions in
# judging_common.tcl for details.
#
set use_authentication no

# Authentication Keys:
#
#     array set authentication_keys {
#		keyname1	key1
#		keyname2	key2
#		keyname3	key3
#		.  .  .  .  .  .  .
#	}
#
# where each keyname and key is any list item.  If
# there is whitespace in a keyname or key enclose
# it in {}'s, as in:
#
#	{feedso's key}	{I'm happy to mEt U}
#
# There should be no beginning or ending whitespace
# to either a key or a keyname.
#
array set authentication_keys {
}

# Allowed Extensions:
#
# TCL list of allowed extensions for submitted programs:
#
# All supported languages:
#
set allowed_extensions {.c .cc .java .lsp}

# Allowed Qualifiers:
#
# TCL list of allowed submit qualifiers for submitted
# programs:
#
set allowed_qualifiers { "" }

# Qualifiers for unqualified correct or incorrect
# submissions:
#
set default_correct_qualifier ""
set default_incorrect_qualifier ""

# Submitter compress function.  Used to compress the
# full submitter email name when displaying the sub-
# mitters name, e.g., on the scoreboard.
#
# For this version the mode is `long' to include a con-
# testant's primary domain name (e.g. `harvard') or
# `short' to not include the @ or anything after that.
#
# WARNING: Avoid `long' if scoreboard is to be posted
# on the web, so as not to violate the security of
# contestants by announcing their email addresses.
#
# But regardless of mode, if $submitter_compress_map(
# submitter) is set, its value is returned as the
# result.
#
# set submitter_compress_mode long
set submitter_compress_mode short
proc submitter_compress { submitter } {

    global submitter_compress_mode \
           submitter_compress_map

    if { [info exists \
               submitter_compress_map($submitter)] } {
        return $submitter_compress_map($submitter)
    }

    # Long_submitter is submitter with stuff after @
    # compressed so xxxxx.yyy.eee becomes yyy.
    # Short_submitter is submitter with @ and stuff
    # after it removed.

    if { [regexp {^([^@]*)@(|.*\.)([^.]*)\.[^.]*$} \
                 $submitter forget \
		 short_submitter forget2 organization] \
			     } {
	set long_submitter \
	    "$short_submitter@$organization"
    } elseif { [regexp {^([^@]*)@} $submitter forget \
	               short_submitter] } {
	set long_submitter $short_submitter
    } else {
        set long_submitter $submitter
        set short_submitter $submitter
    }

    if { $submitter_compress_mode == "long" } {
	return $long_submitter
    } else {
	return $short_submitter
    }
}


# Reply Mode:
#
#	auto		Automatic reply only; dispatch-
#			mail automatically sends a
#			reply, if autoinfo or autojudge
#			are not invoked.  response_
#			manager_map is used to generate
#			cc addresses; if there are none,
#			the reply indicates there will
#			never be a proper reply.
#	auto+manual	Automatic reply if a good auto-
#			matic reply is possible, as with
#			certain errors, and manual reply
#			otherwise.
#
set reply_mode auto

# Use GMT for dates in file and directory names.  Other-
# wise the local time zone is used.  Must be `yes' or
# `no'.
#
set use_gmt no


# Logging Parameters
# ------- ----------

# Log Mode:		Action on Error:
#
#	manual		Write error to log file; do not
#			send any email.
#	auto+manual	Write error to log file, and
#			send error by email (but not
#			using normal reply mechanism)
#			to submitter/requester.  Manual
#			review should follow.
#	auto		Write error to log file, reply
#			to submitter/requester, and cc
#			to log_manager if that is not
#			"".  Reply email does NOT use
#			normal reply mechanism.
#
# Errors are always printed to the standard error
# output.
#
set log_mode auto

# Log Manager:
#
# Email address to cc log files to if in `auto'
# log_mode.
#
set log_manager ""

# Maximum Logged Errors:
#
# If more errors than this are logged by a single
# program execution, the log mode is automatically
# changed to `none' for that program execution.
#
set log_error_maximum 10


# Info Parameters
# ---- ----------

# info_map(name) if it exists is a list of names which
# replace `name' when a `get name' request is made.
# This list may be empty.  The names in the list are
# looked up recursively in info_map.
#
# If info_map(name) equals {FORBIDDEN {error_message}}
# then `name' cannot be returned by a `get name' request
# and the message:
#
#	The following file names are forbidden:
#	    name: error_message
#
# is returned in the reply mail.
#
# array set info_map {
#     problems {FORBIDDEN {You are not allowed to get\
#               all problems at once in this contest.}}
# }


# Display Parameters
# ------- ----------

# Window heights.  The window_height is the height of
# the non-blank part of the window, and the window_
# blank_height is the number of blank lines that are
# be above the non-blank part of the window to clear
# the screen.
#
# WARNING: If window_height is too large, programs such
# as manualreply and lookat may appear to be malfunc-
# tioning because the information they display is being
# scrolled off the top of the screen.
#
set window_blank_height 16
set window_height 24

# Characters to turn highlighting on or off.  For ANSI
# terminals the number in highlight_on can be any of:
#	1 for bold, 7 for reverse video, 31 for red,
#	32 for green, 33 for yellow, 34 for blue,
#	35 for magenta, 36 for cyan, 41-46 to change
#	background instead of character color
#
set highlight_on  "\x1b\[7m"
set highlight_off "\x1b\[0m"

# How long should autodispatch run before we worry that
# it has hung up.  In seconds.
#
set dispatch_too_old 120

# Functions that Call the Operating System
# --------- ---- ---- --- --------- ------

### In theory all calls to `extended TCL' are here and
### no such calls are in the rest of the HPCM TCL code.
### Its difficult to enforce this rule in practice.

# These functions use the following UNIX environment
# variables.  Here $X denotes the value of environment
# variable X (actually $env(X) in TCL).  There are
# defaults if the variables are not set.
#
#    HPCM_VIEW		A TCL list such that
#			    $HPCM_VIEW filename
#			is executed to edit a file
#			in read-only mode.  Default:
#			"view".
#
#    HPCM_EDIT		A TCL list such that
#			    $HPCM_EDIT filename
#			is executed to edit a file.
#			Default: "vi".
#
#    HPCM_SHELL		A TCL list such that
#			    $HPCM_SHELL
#			is executed to execute a shell
#			in the current directory.
#			Default: "sh".

# Function to send mail, as does UNIX `sendmail'.  Takes
# mail message file with correctly set `To:' field and
# sends the message to the addresses listed there.  If
# some of these addresses are in error, this command
# may suffer a catchable error (and the mail may be put
# into ~/dead.letter).
#
proc send_mail { message_file } {
    exec /usr/sbin/sendmail -oi -t < $message_file
}

# Ditto but the message sent is the value of the single
# argument, and is not in a file.
#
proc send_message { message } {
    exec /usr/sbin/sendmail -oi -t << $message
}

# Function to call ssh-keygen to generate a private key
# in `file' and a public key in `file.pub'.  The private
# key is NOT password protected.
#
proc ssh_keygen { file } {
    exec ssh-keygen -t rsa -N "" -f $file
}

# Function to call
#
#	ssh -i identity_file account << message
#
# to copy the message to account.  Note that what is
# sent is the value of the message argument, NOT the
# contents of some file.  Account must be set up in
# advance with a ~/.ssh/authorized_keys entry containing
# a line equal to identity_file.pub prefixed with
#
#	command="COMMAND"
#
# where COMMAND is what would be used in
#
#	ssh -i identity_file account COMMAND << message
#
# to receive the message (escape "'s in COMMAND with
# \'s).
#
# Note: It is necessary to suppress SSH_AUTH_SOCK while
# executing the above, or else some other ~/.ssh/
# authorized_keys entry may intercept the connection.
#
# -T option is needed to suppress writing a warning
# message to stderr regarding the pseudo-terminal.
# -x option suppresses X windows forwarding and warnings
# about Xauthority difficulties.
#
proc ssh_copy_message \
	{ identity_file account message } {
    exec sh -c "unset SSH_AUTH_SOCK;\
                ssh -o PasswordAuthentication=no -T -x \
		    -i $identity_file $account" \
	 << $message
}

# Function to compute the md5sum of a value.
#
proc compute_signature { value } {
    return [lindex [exec md5sum << $value] 0]
}

# Function to translate base64 mimencoded text.  The
# text to be translated is the argument and the trans-
# lated text is the returned value.
#
if { [catch { exec which base64 }] } {
    proc translate_base64 { text } {
	return [exec -keepnewline mimencode -u << $text]
    }
} else {
    proc translate_base64 { text } {
	return [exec -keepnewline base64 -di << $text]
    }
}

# Function to return the absolute true name of a direc-
# tory, which is defined as the `pwd' value when the
# directory is the current directory (thus there are no
# symbolic links).  It is an error if the argument does
# not name a directory.
#
proc truename { dirname } {
    if { ! [file isdirectory $dirname] } {
        error "$dirname is not a directory"
    }
    set wd [pwd]
    cd $dirname
    set name [exec pwd -P]
    cd $wd
    return $name
}

# Function to compare two files, returning true if the
# files are equal, false if they are not equal.
#
proc compare_files { source target } {
    global errorCode errorInfo
    if { [catch { exec cmp $source $target } \
    		message] } {
        if { [regexp {CHILDSTATUS.* 1$} $errorCode] } {
	    return 0
	} else {
	    error $message $errorInfo $errorCode
	}
    }
    return 1
}

# Function to create a file.  Returns `yes' if the file
# was created, and `no' if it already exists.  Suffers
# an error if there is some other problem with creating
# the file.  If created, the file will be zero length
# and both readable and writable by the current user.
#
proc create_file { filename } {
    global errorCode errorInfo

    if { [catch { exec lockfile -0 -r 0 $filename } \
                out] } {
	if { [regexp {Sorry, giving up on} $out] } {
	    return no
	} else {
	    error $out $errorCode $errorInfo
	}
    } else {
	file attributes $filename -permissions u+w
	# Truncate file
	close [open $filename w]
	return yes
    }
}

# Function to create a directory and suffer an error if
# the directory already exists.  If created, the
# directory will be empty, readable, and writable.
#
proc create_directory { dirname } {
    exec mkdir $dirname
}

# Function to symbolically link a file.  The source is
# the existing file name and the target is the new name
# linked to the source.  If no target is given, link the
# file into the current directory.
#
# But if target is already a link equal to source,
# nothing is done.
#
proc link_file { source target } {
    if { [catch { set name [file link $target] }] \
         || \
	 $name != $source } {
	exec ln -s $source $target
    }
}

# Function to copy a file preserving modification date
# and protection settings.  Note that unlike the TCL
# `file copy' command, this function will NOT copy
# a symbolic link, but will copy the underlying file
# instead.
#
# But if source and target are already files (AFTER
# following links) and their contents are equal, nothing
# is done (NOTE: equality of permissions is NOT
# checked.)
#
proc copy_file { source target } {
    if { ! [file isfile $target] \
         || \
	 ! [file isfile $source] \
	 || \
	 ! [compare_files $source $target] } {
	exec cp -p $source $target
    }
}

# Function to copy a file encoding it in base64.
#
# NOTE: no check is made to see if target already
# exists and equals base64 encoded source.
#
proc encode_file { source target } {

    if { [catch { exec which base64 }] } {
	proc encode_file { source target } {
	    exec mimencode < $source > $target
	}
    } else {
	proc encode_file { source target } {
	    exec base64 < $source > $target
	}
    }
    encode_file $source $target
}

# Function to copy a directory and its contents preser-
# ving modification dates and protection settings.  Note
# that unlike the copy_file command, this function will
# NOT copy the underlying file of a symbolic link, but
# will copy the link instead.
#
proc copy_directory { source target } {
    exec cp -rpP $source $target
}

# Make an archive (e.g. tar) of a directory.  Given
# a directory whose truename is D, make D.tar.
#
proc archive_directory { dirname } {
    set dirname [truename $dirname]
    file delete -force $dirname.tar
    exec sh -c "cd $dirname;\
                tar cf $dirname.tar --exclude .. * .?*"
}

# Give a file r, w, x, or s permissions for its user.
# s and x permission together make a file executable
# set-user-id.
#
proc grant_user_access { filename permissions } {
    if { $permissions != "" } {
	file attributes $filename \
	                -permissions "u+$permissions"
    }
}

# Function to change the permissions of a file or direc-
# tory.
#
# If the file or directory is readable to the current
# user, and the `allow' argument contains an `r' (which
# it does by default), the file or directory is made
# readable by everyone.
#
# If the file or directory is writable to the current
# user, and the `allow' argument contains an `w' (which
# it does NOT by default), the file or directory is made
# writable by everyone.
#
# If the file or directory is executable to the current
# user, and the `allow' argument contains an `x' (which
# it does by default), the file or directory is made
# executable by everyone.
#
proc grant_access { filename { allow rx } } {
    set perm ""
    if { [file readable $filename] \
         && [regexp {r} $allow] } {
	set perm "${perm}r"
    }
    if { [file writable $filename] \
         && [regexp {w} $allow] } {
	set perm "${perm}w"
    }
    if { [file executable $filename] \
         && [regexp {x} $allow] } {
	set perm "${perm}x"
    }
    if { $perm != "" } {
	file attributes $filename -permissions "a+$perm"
    }
}

# Return global (everyone) permissions of a file as a
# three character string, RWX, where R = r if the file
# is a+r and `-' otherwise, W = w if the file is a+w and
# `-' otherwise, and X = x or X = s if the file is a+x
# and `-' otherwise.  If file is a+x, X = s if the file
# is u+s, and X = x otherwise.
#
proc get_access { filename } {
    if { ! [file exists $filename] } {
    	return "---"
    }

    set mode [file attributes $filename -permissions]
    if { ( $mode & 0444 ) == 0444 } {
    	set R r
    } else {
        set R -
    }
    if { ( $mode & 0222 ) == 0222 } {
    	set W w
    } else {
        set W -
    }
    if { ( $mode & 0111 ) == 0111 } {
	if { ( $mode & 04000 ) == 04000 } {
	    set X s
	} else {
	    set X x
	}
    } else {
        set X -
    }
    return "$R$W$X"
}

# Deny rwx permissions to everyone but owner and
# group for a file or directory, and w permissions
# to everyone but owner.
#
proc deny_access { filename } {
    file attributes $filename -permissions o-rwx,g-w
}

# Deny rwx permissions to everyone but owner.
#
proc deny_group_access { filename } {
    file attributes $filename -permissions o-rwx,g-rwx
}

# Function to view a file.  Change to your favorite
# editor or display program.
#
# This version checks the environment variable
# HPCM_VIEW for an editor.  HPCM_VIEW may be a TCL
# list with an editor name and parameters.  If this
# global variable is not defined, the editor
# defaults to `view'.
#
proc view_file { filename } {

    global env

    if { [info exists env(HPCM_VIEW)] } {
        set editor $env(HPCM_VIEW)
    } else {
        set editor view
    }
    eval exec $editor \
         [list $filename >@ stdout 2>@ stderr]
}

# Function to edit a file.  Change to your favorite
# editor.
#
# This version checks the environment variable
# HPCM_EDIT for an editor.  HPCM_EDIT may be a TCL
# list with an editor name and parameters.  If this
# global variable is not defined, the editor
# defaults to `vi'.
#
proc edit_file { filename } {

    global env

    if { [info exists env(HPCM_EDIT)] } {
        set editor $env(HPCM_EDIT)
    } else {
        set editor vi
    }
    eval exec $editor \
         [list $filename >@ stdout 2>@ stderr]
}

# Function to call shell.  Change to your favorite
# shell.
#
# This version checks the environment variable
# HPCM_SHELL for a shell.  HPCM_SHELL may be a TCL
# list with a shell name and parameters.  If this
# global variable is not defined, the shell
# defaults to `sh'.
#
proc call_shell {} {

    global env

    if { [info exists env(HPCM_SHELL)] } {
        set shell $env(HPCM_SHELL)
    } else {
        set shell sh
    }
    eval exec $shell [list >@ stdout 2>@ stderr]
}

# Function to invoke the `make' program for a given
# `name' on a Makefile in the current directory.
#
# The standard output of `make' is always sent to the
# standard output.  The error output of `make' is
# written to the err_file.
#
proc make_file { name err_file } {
    exec make $name >@ stdout 2> $err_file
}

# Diff two directories and return the output as a
# string.  The output must be like the output of
# `exec diff -r directory1 directory2' with UNIX
# `diff -r'.
#
proc diff_directories { directory1 directory2 } {
    return [exec diff -r $directory1 $directory2]
}

# Diff two files.  Append all output, including error
# output, to a third file, with a header line in that
# file saying what was done.  Errors are ignored as
# far as TCL is concerned (they produce error messages
# in `output').
#
# Like UNIX `diff'.  The option `-b' may be given, and
# is like the `-b' option to UNIX `diff'.
#
proc diff_files { file1 file2 output { options "" } } {
    if { $options == "" } {
        set command "diff"
    } else {
        set command "diff $options"
    }
    write_file $output "===== $command $file1 $file2"
    catch { eval exec $command \
                 [list $file1 $file2 >>& $output] }
}

# In a directory, given a file whose lines have format
#
# 	MD5SUM	FILENAME
#
# where the FILENAMEs are relative to the directory,
# check that each file exists and has the given MD5 sum.
# If yes, return "".  Otherwise return error message
# lines.
#
proc check_md5sums { directory file } {
    catch { exec_in_directory $directory \
              "md5sum -c --quiet $file" } out
    return $out
}

# Function to execute a command in another directory.
# The command is a string passed to sh.  Additional
# arguments are arguments to TCL exec that can reroute
# IO: e.g., >&@ stdout
#
proc exec_in_directory { directory command args } {
    eval exec sh -c "\"(cd $directory; $command)\"" \
         $args
}

# Execute in background, redirecting all input/output
# to /dev/null or equivalent.  Return the child PID.
#
proc exec_in_background { args } {
    return [eval exec $args < /dev/null >& /dev/null &]
}

# Function to return the current process ID.
#
proc current_pid {} {
    return [pid]
}

# Function to display the state of processes within
# a process tree rooted at a given process.  Return
# value is the display.
#
proc display_process_tree { root_pid } {
    catch { exec pstree -pa $root_pid } out
    if { $out == "" } {
    	set out "No process with PID $root_pid exists"
    }
    return $out
}

# Function that looks at result of display_process_tree
# and returns true iff the root process for the tree
# was found to exist.
# 
proc process_found { display } {
    return [expr { \
        !  [regexp {^No process with PID .* exists} \
		   $display] }]
}

# Function to send signal to process subtree.  Signal
# must be KILL or INT.
#
# Note: we tried to use process groups, but making a
# process into a group leader disconnects the process
# from its stdin when that is a terminal, and that
# made life impossible.
#
proc signal_process_tree { signal root_pid } {
    catch { exec pstree -p $root_pid } out
    regsub -- {-pstree\([0-9]*\)} $out "-pstree" out
    regsub {^[^(]*\(} $out "\{" out
    regsub {\)[^)]*$} $out "\}" out
    regsub -all {\)[^(]*\(} $out "\} \{" out
    set list ""
    foreach pid $out {
        if { [regexp {^[0-9]+$} $pid] } {
	    lappend list $pid
	}
    }
    if { $list != "" } {
	puts "kill -$signal $list"
	eval kill $signal $list
    }
}

# Function to send a kill signal.
#
proc kill { signal args } {
    catch { eval exec kill -$signal $args } out
    if { $out != "" } { puts $out }
}

# Function to sleep for s seconds.
#
proc sleep { s } {
    exec sleep $s
}

# Function to turn signals into errors.
#
proc make_signals_errors {} {
    if { [info command signal] == "signal" } {
	signal error { HUP INT QUIT ALRM TERM }
    }
}

# Function to cause signals to be ignored.
#
proc make_signals_ignored {} {
    if { [info command signal] == "signal" } {
	signal ignore { HUP INT QUIT ALRM TERM }
    }
}

# Function to turn on signal default action.
#
proc make_signals_default {} {
    if { [info command signal] == "signal" } {
	signal default { HUP INT QUIT ALRM TERM }
    }
}

# Function to return current account name.
#
proc account_name {} {
    global tcl_platform
    return $tcl_platform(user)
}

# Function to return current host name.
#
proc host_name {} {
    return [info hostname]
}

# Function to return home directory of account.  Returns
# "" if the account or directory does not exist.
#
proc account_home_directory { account } {
    set dir /home/$account
    if { [file isdirectory $dir] } {
        return $dir
    } else {
        return ""
    }
}

# Function to return home directories of all accounts
# whose names match a given glob expression.  Some
# superfluous names may be returned; this is currently
# only used to find *[_-]proto accounts.
#
proc account_home_directories { glob } {
    return [glob -nocomplain /home/$glob]
}
