# TCL Parameters File for Judging
#
# File:		hpcm_judging.rc
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Oct  2 09:34:36 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/10/02 17:17:28 $
#   $RCSfile: hpcm_judging.rc,v $
#   $Revision: 1.40 $
#

# An optionally modified copy of this file must be
# placed in (or symbolically linked into) the current
# directory of an executing judging program, or one
# of the ancestors (parent, parent of parent, etc.) of
# that directory (4 ancestors will be searched).

# Scoreboard Parameters.
#
# List of problems, list of submitters, start_time,
# stop_time, penalty.  Times are in seconds.  Each list
# is thought of as an allow list: listed problems or
# submitters are allowed.  If the lists are empty, all
# problems or submitters are allowed.  There are also
# associated deny lists: problems or submitters in the
# deny lists are denied, even if they are allowed by the
# allow lists.
#
# The start_time and penalty are used to compute the
# time score: penalty is the number of seconds of
# penalty for an incorrect submission for a problem
# later gotten correct.
#
# If the start_time is "", the time a problem is
# gotten is used as the start time for that problem.
# If the start_time equals "team", the time the team
# got its first problem listed in the scoreboard is
# the start time for all problems for that team.
#
# If the start time is not "" or "team", all submis-
# sions and problem gettings before that time are
# ignored.  If the stop time is not "", all submissions
# after that stop time are ignored.
#
# The default values are for scoreboarding a practice
# facility that operates 24 hours a day, every day.
# 
set scoreboard_problems {
    }

set scoreboard_problems_deny {
    }

set scoreboard_submitters {
    }

set scoreboard_submitters_deny {
    }

set scoreboard_start_time ""
#   [clock scan "Jan 1 00:00:00 EDT 2000"]

set scoreboard_stop_time ""
#   [clock scan "Jan 1 00:00:00 EDT 2030"]

set scoreboard_penalty 0


# Scoring Mode:
#
#	auto		automatic scoring only
#	auto+manual	automatic scoring plus manual
#			review of everything not
#			`Completely Correct'
#	manual		manual scoring only
#
set scoring_mode auto

# Reply Mode:
#
#	auto		automatic reply only;
#			no human will attempt reply
#	auto+manual	automatic reply if possible
#			and manual otherwise or in
#			addition
#
set reply_mode auto

# Reply Manager:
#
# Email address to cc replies to if in `auto' reply_mode
# and no clearly correct automatic reply is possible.
#
set reply_manager ""

# Log Mode:		Action on Error:
#
#	manual		write error to log file
#	auto+manual	write error to log file, reply
#			to submitter/requester
#	auto		write error to log file, reply
#			to submitter/requester and
#			HPCM log manager.
#	none		write all error info to standard
#			output
#
set log_mode auto

# Log Manager:
#
# Email address to send log files to if in `auto'
# log_mode.
#
set log_manager ""

# Maximum Logged Errors:
#
# If more errors than this are logged, the log mode is
# automatically changed to `none'.
#
set log_error_maximum 10


# Reply control parameters:
#
# Window heights.  The window_height is the height of
# the non-blank part of the window, and the window_
# blank_height is the number of blank lines that should
# be above the non-blank part of the window.
#
set window_blank_height 16
set window_height 24
#
# How long should autodispatch run before we worry that
# it has hung up.  In seconds.
#
set dispatch_too_old 120



# Authentication Switch: yes or no
#
set use_authentication no

# Authentication Keys:
#
#     array set authentication_keys {
#		keyname1	key1
#		keyname2	key2
#		keyname3	key3
#		.  .  .  .  .  .  .
#	}
#
# where each keyname and key is any list item.  If
# there is whitespace in a keyname or keyitem enclose
# it in {}'s, as in:
#
#		{feedso's key}	{I'm happy}
#
# There should be no beginning or ending whitespace
# to a keyname, but a key can be anything.
#
array set authentication_keys {
}


# .err File Regexps:
#
# Regexp expressions matched to lines in .err file to
# detect limit overruns.  Letter case is ignored.
# The regular expressions match successfully if they
# match any part of a line.
#
set time_limit_regexp {cpu time limit exceeded}
set output_limit_regexp {file size limit exceeded}


# Allowed Extensions:
#
# Whitespace separated list of allowed extensions for
# submitted programs:
#
set allowed_extensions ".c .cc .java .p"


###### Functions to call operating system programs #####

# Function to send mail, as does UNIX `sendmail'.  Takes
# mail message file with correctly set `To:' field and
# sends the message to the addresses listed there.  If
# some of these addresses are in error, this command
# may suffer a catchable error (and the mail may be put
# into ~/dead.letter).
#
proc send_mail { message_file } {
    exec /usr/sbin/sendmail -oi -t < $message_file
}

# Function to compute the md3sum of a value.
#
proc compute_signature { value } {
    return [lindex [exec md5sum << $value] 0]
}

# Function to create a file.  Returns `yes' if the file
# was created, and `no' if it already exists.  Suffers
# an error if there is some other problem with creating
# the file.  If created, the file will be zero length
# and both readable and writable by the current user.
#
proc create_file { filename } {
    global errorCode errorInfo

    if { [catch { exec lockfile -0 -r 0 $filename } \
                out] } {
	if { [regexp {Sorry, giving up on} $out] } {
	    return no
	} else {
	    error $out $errorCode $errorInfo
	}
    } else {
	chmod u+w $filename
	ftruncate $filename 0
	return yes
    }
}

# Function to create a directory and suffer an error if
# the directory already exists.  If created, the
# directory will be empty, readable, and writable.
#
proc create_directory { dirname } {
    exec mkdir $dirname
}

# Function to symbolically link a file.  This is like
# copying, but the modification date on the target
# tracks the date on the source.  If no target is given,
# link the file into the current directory.
#
proc link_file { source { target . } } {
    exec ln -s $source $target
}

# Function to change the permissions of a file or direc-
# tory.
#
# If the file or directory is readable to the current
# user, and the `allow' argument contains an `r' (which
# it does by default), the file or directory is made
# readable by everyone.
#
# If the file or directory is executable to the current
# user, and the `allow' argument contains an `x' (which
# it does by default), the file or directory is made
# executable by everyone.
#
proc grant_access { filename { allow rx } } {
    set perm ""
    if { [file readable $filename] \
         && [regexp {r} $allow] } {
	set perm "${perm}r"
    }
    if { [file executable $filename] \
         && [regexp {x} $allow] } {
	set perm "${perm}x"
    }
    if { $perm != "" } {
	chmod "a+$perm" $filename
    }
}


# Function to view a file.  Change to your favorite
# editor or display program.
#
proc view_file { filename } {
    exec view $filename >& /dev/tty
}

# Function to edit a file.  Change to your favorite
# editor.
#
proc edit_file { filename } {
    exec vi $filename >& /dev/tty
}

# Function to call shell.  Change to your favorite
# shell.
#
proc call_shell {} {
    exec csh >& /dev/tty
}

# Function to return the current process ID.
#
proc current_pid {} {
    return [id process]
}

# Function to display the state of processes within
# a process tree rooted at a given process.  Return
# value is the display.
#
proc display_process_tree { root_pid } {
    catch { exec pstree -pa $root_pid } out
    if { $out == "" } {
    	set out "No process with PID $root_pid exists"
    }
    return $out
}

# Function to send signal to process subtree.  Signal
# must be KILL or INT.
#
# Note: we tried to use process groups, but making a
# process into a group leader disconnects the process
# from its stdin when that is a terminal, and that
# made life impossible.
#
proc signal_process_tree { signal root_pid } {
    catch { exec pstree -p $root_pid } out
    regsub -- {-pstree\([0-9]*\)} $out "-pstree" out
    regsub {^[^(]*\(} $out "\{" out
    regsub {\)[^)]*$} $out "\}" out
    regsub {\)[^(]*\(} $out "\} \{" out
    set list ""
    foreach pid $out {
        if { [regexp {^[0-9]+$} $pid] } {
	    lappend list $pid
	}
    }
    if { $list != "" } {
	eval echo kill $signal $list
	eval kill $signal $list
    }
}


######### Things usually not changed ############


# File names:
#
set received_file		Received_Mail
set reply_file			Reply_Mail
set reply_history_file		Reply_Mail_History
set no_reply_file		No_Reply
set scoring_instructions_file	Scoring_Instructions
set auto_score_file		Auto_Score
set manual_score_file		Manual_Score
set make_file			Makefile
set dispatch_pid_file		Dispatch_PID
set gotten_file			Gotten
set score_flag_file		Score_Flag
set needs_reply_flag_file	Needs_Reply_Flag


# Default Scoring Instructions:
#
set scoring_instructions_default \
    "whitespace"


# Directory names:
#
set mail_directory \
    $judging_parameters_directory/mail
set solutions_directory \
    $judging_parameters_directory/solutions
set info_directory \
    $judging_parameters_directory/info
set log_directory \
    $judging_parameters_directory/log
set flag_directory \
    $judging_parameters_directory/flag
set contest_directory \
    $judging_parameters_directory/contest
