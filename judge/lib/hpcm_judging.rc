# TCL Parameters File for Judging
#
# File:		hpcm_judging.rc
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Sep 25 06:14:48 EDT 2005
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2005/09/25 15:26:31 $
#   $RCSfile: hpcm_judging.rc,v $
#   $Revision: 1.149 $

# Table of Contents:
#
#	About This File
#	Problem .rc Files
#	Scoreboard Parameters
#	Web Page Parameters
#	Scoring Parameters
#	Response Instructions
#	Submission Parameters
#	Logging Parameters
#	Info Parameters
#	Display Parameters
#	Maintenance Parameters
#	Functions that Call the Operating System
#	Parameters Not Usually Changed

# About This File
# ----- ---- ----
#
# An optionally modified copy of this file must be
# placed in (or symbolically linked into) the current
# directory of an executing judging program, or one
# of the ancestors (parent, parent of parent, etc.) of
# that directory (4 ancestors will be searched).
#
# Alternatively instead of copying this file, it may
# be included by a `source' statement in a file of the
# same name which contains subsequent statements that
# modify parameters.  The `source' statement must refer
# to the file sourced by an absolute pathname, since
# the file containing the `source' statement can itself
# be sourced with any descendant directory as the
# current directory.
#
# This file is sourced by code in judging_common.tcl.
# See `Inline Code' in that file.

# Problem .rc Files
# ------- --- -----

# After hpcm_judging.rc is sourced, certain programs
# source the file PPP.rc which they locate in the pro-
# blem solution directory of a particular problem named
# PPP.  In particular the autojudge, extract, and auto-
# score programs do this while computing in a problem
# submission directory.  Autojudge links any PPP.rc
# file it finds in the problem solution directory into
# the submission directory, and the other programs find
# that file in the submission directory.  The file may
# not exist, and if it does not, no attempt is made to
# source it.
#
# Before a PPP.rc file is sourced the following global
# variables are set:
#
#	PROBLEM		Problem name: "PPP".
#	EXTENSION	Extension name including `.'
#			E.g., ".cc", ".java".
#
# Here the `Subject:' field of the submission was
# `submit $PROBLEM$EXTENSION'.  EXTENSION may be "".
# If there is no submission involved, then EXTENSION
# is set to "UNDEFINED", while PROBLEM is set to the
# name of the problem directory.
#
# Some programs source the PPP.rc file from the problem
# directory in order to do administrative work.  These
# may source the PPP.rc file into a local environment
# into which only the global variables the program wants
# to use hvae been imported.  For example, the makejudg-
# ingdir program does this to access the problem_de-
# scription_files and problem_source_files variables.
#
# As a consequence of the last paragraph, PPP.rc files
# should not read prior values of global variables set
# in hpcm_judging.rc, UNLESS the PPP.rc file makes
# these global before accessing them.  PPP.rc files may
# `set' and `lappend' to hpcm_judging.rc global vari-
# ables, as this will be harmless if the variables are
# not actually global.  To make things easier, the
# procedure `lprepend' is defined by HPCM.  It will
# prepend to a list in a variable, and treat a previous-
# ly undefined variable as if it were set to an empty
# list.
#
# If procedures or temporary variables are defined in a
# PPP.rc file, they should begin with the prefix `rc_'
# to avoid conflicts with HPCM global variables.
#
# The following are global variables defined by
# particular programs before they source PPP.rc.  These
# may be redefined by PPP.rc, but they are not defined
# by hpcm_judging.rc because in most cases they need to
# know the value of $PROBLEM.  For each of these an
# initial value is given which is set by the program
# that sources PPP.rc before sourcing PPP.rc.
#
#   problem_description_files	" $PROBLEM$TTT "
#
#	A list of the .txt, .ps, ... files in the pro-
#	blem directory that describe the problem to the
#	contestant.  Here TTT is an extension found in
#	the problem_description_extensions global
#	variable such that the file PROBLEM.TTT exists;
#	E.g., TTT may be ".ps" or ".pdf" or ".txt".
#	If more than one such extension is found, more
#	than one description file is listed.
#
#   problem_source_files	" Makefile "
#
#	A list of files that are sent to the contestant
#	as source files.
#
#	If any of these files have a name of the form
#	xxx.ISF, they will be sent to the contestant (by
#	autoget and hpcm_extract) under the name xxx.
#	ISF stands for `Initial Source File', and de-
#	notes an initial version of a file the contes-
#	tant will modify and submit.
#
#   problem_required_files
#	" $PROBLEM$EXTENSION "  if EXTENSION is not ""
#	" "			if EXTENSION is ""
#
#	A list of files the contestant is required to
#	submit.  All these must be included in the sub-
#	mission message.
#
#   problem_optional_files	" "
#
#	A list of files the contestant may optionally
#	submit.  These are optionally included in the
#	submission message.
#
#   problem_make_files
#	" { $PROBLEM.fout
#	    {Scoring_Filter < $PROBLEM.out 
#			    > $PROBLEM.fout }
#           Scoring_Filter $PROBLEM.out }
#	  { $PROBLEM.ftest
#	    {Scoring_Filter < $PROBLEM.test 
#			    > $PROBLEM.ftest }
#           Scoring_Filter $PROBLEM.test }
#       "
#
#	A list of instructions the autojudge program
#	uses to make files in the problem solution dir-
#	ectory before linking files from that directory
#	to the submission directory (see problem_link_
#	files below).
#
#	Each instruction has the form:
#
#		{ OUT COMMAND IN1 IN2 ... }
#
#	The file OUT is to be made by executing the
#	COMMAND, provided all the files IN1, IN2, ...
#	exist, and either OUT does not exist or it is
#	older than one of the files IN1, IN2, ... .
#	All this is done by autojudge with the problem
#	solution directory as the current directory.
#
#	If no files IN1, IN2, ... are listed, OUT must
#	not exist.  If OUT is older than one of the
#	IN1, IN2, ... files, OUT will be deleted before
#	executing COMMAND (so it may be readonly).
#
#	An instruction can be abbreviated to just a file
#       name F, which is the same as the instruction
#       `{ F { make F } }'.
#
#	The COMMAND is passed to the exec_in_directory
#	functions which executes it in sh or csh.
#
#	The instructions are processed by autojudge in
#	order, so previous instructions can make inputs
#	to later instructions.
#
#	The initial value will make .fout and .ftest
#	files in the solution directory.  If a PPP.rc
#	file executes
#
#	    lprepend problem_make_files Scoring_Filter
#
#	then Scoring_Filter will be compiled first, and
#	subsequently will be used to make $PROBLEM.fout
#	if $PROBLEM.out exists, and $PROBLEM.ftest
#	assuming $PROBLEM.test exists.
#
#   problem_link_files
#       " { Makefile Makefile$EXTENSION Makefile }
#	  $PROBLEM.in
#	  { $PROBLEM.test $PROBLEM.out $PROBLEM.test }
#       "
#
#	A list of files that must be linked from the
#	problem solution directory to the problem sub-
#	mission directory by autojudge, after making
#	the files in problem_make_files.
#
#	If just a file name F is listed, F in the
#	solution directory must exist and will be
#	linked to the submission directory.
#
#	If a list of names { F F1 F2 ... } is given, the
#	names F1, F2, ... are checked in the solution
#	directory, and the first that exists is linked
#	to the name F in the submission directory.  At
#	least one of F1, F2, ... must exist.
#
#   problem_optional_link_files
#       " Scoring_Filter
#	  { $PROBLEM.ftest $PROBLEM.fout $PROBLEM.ftest }
#	"
#
#	Ditto, but if no solution file is found to link
#	for a particular file, there is no error. 

# Scoreboard Parameters
# ---------- ----------
#
# All times are in a format that TCL `clock scan'
# can convert.  Most date formats work.

# Correct and incorrect count displays.
#
# If scoreboard_display_correct is `yes', the number of
# correct problems is displayed for each submitter,
# along with the total problem time of the submitter if
# that is known, and submitters are sorted by number of
# correct problems (decreasing order) in the scoreboard.
# If scoreboard_display_correct is `no', the number of
# correct problems and total problem time are NOT dis-
# played for each submitter, and the scoreboard is
# sorted alphabetically by submitter name.
#
# If scoreboard_display_incorrect is `yes', the number
# of submissions for each submitter and problem is
# displayed.  If scoreboard_display_incorrect is `no',
# this number is not displayed.  Other scoreboard
# properties are not affected by this parameter.
#
set scoreboard_display_correct yes
set scoreboard_display_incorrect yes

# Contest start, stop, freeze, and cut times.
#
# The start, stop, and cut times are used in actually
# computing the scoreboard proper (by the `scoreboard'
# program), as follows.
#
# If the start time is not "", "problem", or "team", it
# is a date and time (a legal argument for `clock scan')
# and is the start time of all problems.  Any problem
# which was gotten or first submitted before this start
# time is ignored.
#
# If the start time is "", the start time of a problem
# is unknown.  Instead of printing problem times, the
# scoreboard will print dates of submission.  Instead
# of sorting submitters with the same number of correct
# problems by decreasing total problem time, the sub-
# mitters will be sorted by name alphabetically.
#
# If the start time is "problem", the time a problem is
# gotten is used as the start time for that problem.  If
# the start time equals "team", the time the team got
# its first problem permitted by the scoreboard_problems
# global variable (see below) is the start time for all
# problems for that team.  In both these cases, if the
# first submission regarding a problem is not a get of
# that problem, then the problem is ignored.  Such gets
# happen in email and informal contests, and not in
# formal contests, so the start time of a formal contest
# must be a date and time.
#
# Cut times are used to exclude teams that stopped
# early.  They permit a team to simultaneously enter
# several contests of different durations with the same
# problems.   Each contest has cut times that exclude
# teams that do not make submissions within a certain
# period after the team start time.  More specifically,
# a team is excluded from the contest if it does not
# either make a correct submission at or after the
# `correct cut time' and at or before the `final cut
# time', or make an incorrect submission at or after
# the `incorrect cut time' and at or before the `final
# cut time'.  Cut times can be given as date and time,
# or they can be given as integers which are numbers
# of seconds added to the problem start time.
# 
# A non-"" stop time excludes submissions made after the
# stop time (this is done AFTER the cut time rules have
# been applied).  A stop time can be a date and time, or
# it can be an integer that is added to the start time
# of the problem.
#
# The freeze time is only used as a parameter in score-
# board instructions used by the `makescoreboard' pro-
# gram, and is usually used only for formal contests.
# It may be given in date and time format, or as a
# number of seconds after a start time that is given in
# date and time format.
 
# The default values are for scoreboarding a practice
# facility that operates 24 hours a day, every day and
# allows individuals to tackle one problem at a time.
#
set scoreboard_start_time problem
set scoreboard_freeze_time ""
set scoreboard_stop_time ""
set scoreboard_correct_cut_time ""
set scoreboard_incorrect_cut_time ""
set scoreboard_final_cut_time ""

# The following values are for a typical 5 hour formal
# contest (you should adjust the start time).
#
# set scoreboard_start_time "Jan 1 10:00:00 2000"
# set scoreboard_freeze_time [expr { 4 * 60 * 60 }]
# set scoreboard_stop_time [expr { 5 * 60 * 60 }]
# set scoreboard_correct_cut_time ""
# set scoreboard_incorrect_cut_time ""
# set scoreboard_final_cut_time ""

# The following values are for an informal team 4 hour
# contest in which teams can choose their own starting
# time.  The teams effectively participate in simultan-
# eous 3, 4, and 5 hour contests: a team that gives up
# after 3 hours is deemed to have NOT entered the 4
# and 5 hour contests.  A team has entered the 4 hour
# contest if it makes a correct submission after 3 hours
# but at or before 5 hours and 10 minutes, or if it
# makes an incorrect submission after 3 hours and 10
# minutes but at or before 5 hours and 10 minutes.  The
# final cut time, here 5 hours and 10 minutes, permits
# teams to come back and work on problems the next day
# for practice without affecting the scoreboard.
#
# set scoreboard_start_time team
# set scoreboard_freeze_time ""
# set scoreboard_stop_time [expr { 4 * 60 * 60 }]
# set scoreboard_correct_cut_time \
#     [expr { 3 * 60 * 60 }]
# set scoreboard_incorrect_cut_time \
#     [expr { 3 * 60 * 60 + 10 * 60  }]
# set scoreboard_final_cut_time \
#     [expr { 5 * 60 * 60 + 10 * 60  }]

# Scoreboard name.  Typically just the name of the
# contest.  Used by NAME abbreviation in `scoreboard_
# instructions': see below.
#
set scoreboard_name ""

# The start time and correct submission time of a pro-
# blem, and the penalty of the contest, are used to com-
# pute the problem time.  The penalty is the number of
# SECONDS added to the problem time for each incorrect
# submission for the problem prior to the first correct
# submission for the problem.  It only affects the time
# of a problem that was submitted correctly.
#
set scoreboard_penalty 0
#
# A 20 minute penalty is typical if there is a penalty.
#
# set scoreboard_penalty [expr { 20 * 60 }]

# Logical expressions specifying problems and submit-
# ters.  Each logical expression is a TCL list whose
# elements are operators, parentheses `(' and `)', and
# atoms.  The allowed operators are `!', `&', `^', and
# `|' in highest precedence first order, denoting `not',
# `and', `exclusive-or', and `inclusive-or'.  Operators
# and parentheses MUST be surrounded by whitespace.
 
# The atoms `0' and `1' represent `false' and `true'.
# All other atoms are regular expressions that are
# matched to the ENTIRE problem name or submitter name,
# and are true iff they match.
#
# The problems logical expression is stored in `score-
# board_problems'.  If it is not the empty list, only 
# problems matching it are included in the scoreboard.
# The submitter logical expression is similar and is
# stored in `scoreboard_submitters'.
#
# Some simple examples of logical expressions are:
#
#   ! count	    Match all names but `count'.
#
#   count | pascal  Match only `count' and `pascal'.
#
#   count|pascal    Ditto, but with only one regular
#		    expression atom that contains a
#		    `|', instead of two atoms and a
#		    `|' logical operator.
#
#   bpi[0-9]+	    Match all names of the form
#		    `bpi' followed by one or more
#		    digits.
#
#   bpi.* & ! bpit  Match all names beginning with
#		    `bpi' except the one name
#		    `bpit'.
#
# The regular expressions are TCL regular expressions.
# Note that a regular expression must not as a charac-
# ter string be the same as an operator or parenthesis
# or special atom `0' or `1'.
# 
set scoreboard_problems { }
set scoreboard_submitters { }

 
# Maximum width of scoreboard in columns.
#
set scoreboard_width 80

# Characters used to mark lines if there are more than
# two lines worth of problems.  The first line always
# uses a space character to separate columns; and the
# last line uses underbar characters everywhere space
# characters are used.  If there are N > 2 lines, the
# n'th line for 1 < n < N uses the n-1'st character of
# the following string as a column separator.
#
set scoreboard_markers "|$!#^%@<>"

# List of addresses for `makescoreboard' to email
# scoreboard to.  If scoreboard_instructions includes
# a `SEND' instruction for an OUTPUT file, and
# scoreboard_addresses is a list containing zzz<YYY>,
# then every time the output file is made it will be
# emailed to `zzz<YYY>', so in the account YYY
# .procmailrc file you should put something like:
#
#	:0 b:
#	* ^To:.*zzz
#	| cat >public_html/xxx;\
#	  chmod a+r public_html/xxx
#
# See documentation for `scoreboard_instructions' for
# more details and additional SEND features.
#
set scoreboard_addresses { }

# Interval in seconds between times when the `make-
# scoreboard' program looks at flags and file modi-
# fication times to see if it needs to remake a
# scoreboard.
#
set scoreboard_interval 60
 
# Scoreboard instructions.   These determine which
# scoreboards the `makescoreboard' program will compute
# and how it will compute them.  The syntax is:
#
#	scoreboard_instructions ::=
#	    { scoreboard_instruction* }
#
#	scoreboard_instruction ::=
#	      { OUTPUT filename [start [stop]] }
#	    | { SEND [qualifier [parameter_name]] }
#	    | SEND
#	    | GRANT_ACCESS
#	    | BLANK
#	    | BAR
#	    | { BAR center_text }
#           | { LINE left_text [center_text
#                                   [right_text]] }
#	    | { INPUT filename ... }
#	    | { parameter_name value }
#	    | BOARD
#
#	start ::= "<a date and time>"
#	stop  ::= "<a date and time>"
#	xxx_text ::= "-quoted or {}-quoted string
#
#	parameter_name ::=
#	    <any XXX such that `scoreboard_XXX' is a
#	     global variable after judging directory
#	     hpcm_judging.rc is read>
#
# The scoreboard instructions do the following:
#
#     { OUTPUT filename [start [stop]] }
#		Set the output file name. See below for
#		start and stop.
#
#     { SEND [qualifier [parameter_name]] }
#		Whenever the output file is written,
#		email the file to each address ADR in
#		the list of addresses in the global var-
#		iable `scoreboard_PN', where PN is the
#		parameter_name.  If the qualifier is not
#		empty, the email address actually used
#		is `qualifier<ADR>' when ADR contains
#		no `<', and `qualifier-ADR' when ADR
#		contains a `<'.  If `scoreboard_PN' is
#		empty or does not exist, nothing is
#		done.  PN defaults to `addresses'.
#		Qualifier defaults to "".
#
#     GRANT_ACCESS
#		Whenever the output file is written,
#		it is made readable by everyone.
#
#     BLANK	Include a blank line.
#
#     BAR	Include a ===== bar line.
#
#     { BAR center_text }
#		Include a ===== bar line that has the
#		text centered in the line, with single
#		space characters separating the text
#		from the ===='s.
#
#     { INPUT filename ... }
#		Include a copy of a first readable file
#		in the list of files.  Do nothing of no
#		listed file is readable.
#
#     { LINE left_text [center_text [right_text]] }
#		Include a line that has left_text left
#		justified, center_text centered, and
#		right_text right justified.  The right_
#		text or both the center_ and right_
#		texts can be omitted.  If texts would
#		overlap, two or three lines are in-
#		cluded to avoid overlap.
#
#     { parameter_name value }
#		Set the parameter PN, i.e., the global
#		variable `scoreboard_PN', to the value,
#		where PN is the parameter_name.
#
#     BOARD	Include a scoreboard computed with 
#		previously set parameters.
#
# An output file is not actually written until the next
# OUTPUT command or the end of the instructions. All
# non-absolute file names are relative to the judging
# directory.  The current value of the `scoreboard_
# width' parameter is used by the LINE and BAR instruc-
# tions.
#
# If a non "" start time is given in an OUTPUT instruc-
# tion, that output will not be produced until after
# the given start time.  If a non "" stop time is given,
# in an OUTPUT instruction, that output will not be pro-
# duced if it already exists and has a modification time
# equal to or greater than the stop time.  Setting the
# start and stop times equal will produced an output
# just once after the given time.
#
# The start and stop times of an OUTPUT command, the
# values of a parameter, and the texts of a LINE or BAR
# command can be the special abbreviations TIME, START,
# STOP, FREEZE, and NAME.  TIME is the time when the
# `makescoreboard' program starts executing the score-
# board instructions.  The other abbreviates are the
# values of the `scoreboard_start_time', `scoreboard_
# stop_time', `scoreboard_freeze_time', and `scoreboard_
# name' global variables just before the first score-
# board instruction is executed, but after any arguments
# to `makescoreboard' have been processed.
#
# Note that parameter setting instructions are always
# executed even if the last OUTPUT instruction is not
# active for some reason (start or stop time or output
# being already more recent than inputs).


# Standard scoreboard instructions for an email contest.
# These make a scoreboard in the file
#
#	$judging_instructions/scoreboard.mail
#
# that has the format:
#
#   See notes below.           NAME               TIME
#
#   ==== ===== ===== ===== ===== ===== ===== ===== =====
#	   <scoreboard proper>
#   ==== ===== ===== ===== ===== ===== ===== ===== =====
#
#   <contents of $judging_instructions/scoreboard.notes>
#
#   ==== ===== ===== ===== ===== ===== ===== ===== =====
#
# This file is then emailed to the addresses in the
# scoreboard_addresses global variable.
#
set email_scoreboard_instructions {
    { OUTPUT scoreboard.mail }
    SEND
    { LINE "See notes below." NAME TIME }
    BLANK
    BAR
    BOARD
    BAR
    BLANK
    { INPUT scoreboard.notes }
    BLANK
    BAR
}

# Standard scoreboard instructions for an informal
# contest.  These instructions make a scoreboard
# page in the file:
#
#	$judging_directory/contest/scoreboard.1
#
# World read access is granted to this file, which
# is also sent to any addresses in the scoreboard_
# addresses global variable.  The file has the
# format:
#
#  NAME                                           TIME
#
#   <contents of $judging_instructions/contest/
#			scoreboard.1head>
#
#   ==== ===== ===== ===== ===== ===== ===== ===== =====
#	   <scoreboard proper>
#   ==== ===== ===== ===== ===== ===== ===== ===== =====
#
set informal_scoreboard_instructions {
    { OUTPUT contest/scoreboard.1 }
    GRANT_ACCESS
    SEND
    { LINE NAME "" TIME }
    BLANK
    { INPUT contest/scoreboard.1head }
    BLANK
    BAR
    BOARD
    BAR
}

# Standard scoreboard instructions for a formal contest
# with scoreboard freezing.  These instructions make a
# scoreboard page in the file:
#
#	$judging_directory/contest/scoreboard.1
#
# World read access is granted to this file, which
# is also sent to any addresses in the scoreboard_
# addresses global variable.  The file has the
# format:
#
#  NAME             Public Scoreboard             TIME
#
#   <contents of $judging_instructions/contest/
#	scoreboard.freeze if that file exists>
#
#   <contents of $judging_instructions/contest/
#			scoreboard.1head>
#
#   <contents of $judging_instructions/contest/
#			scoreboard.public>
#
# The file
#
#	$judging_directory/contest/scoreboard.public
#
# has two versions, one computed before the contest
# start time, and one computed between the contest start
# time and the contest freeze time.  Before the contest
# start time it is a plain scoreboard computed with ""
# start time, so dates and not problem times are
# displayed, that includes demo problems and test
# accounts, with the plain scoreboard being prefixed by
# a comment that after the start time problem times will
# be displayed and demos will not be.  After the contest
# start time it is just a plain scoreboard with the
# freeze time as stop time, no demos, and no test
# accounts.
#
# The file
#
#	$judging_directory/contest/scoreboard.freeze
#
# is a notice that the scoreboard is frozen.  This file
# is created at the freeze time, and does not exist
# before then.
#
# All this makes the publicly available scoreboard.
# In addition there are two other scoreboards that are
# only visible to judges.  The file
#
#	$judging_directory/contest/scoreboard.current
#
# is a current scoreboard that is made from the freeze
# time till the stop time.  The file
#
#	$judging_directory/contest/scoreboard.final
#
# is a printable final scoreboard that is made just
# once, soon after the stop time.  Both these have the
# raw scoreboard with the normal stop time followed by a
# copy of the
#
#	$judging_directory/contest/who_where
#
# file.  Both of these are not readable by non-judging
# accounts.
#
set formal_scoreboard_instructions {

    { OUTPUT contest/scoreboard.freeze FREEZE FREEZE }

    BLANK
    { LINE "To heighten suspense, scoreboard updating\
            has been stopped as of:" }
    { LINE "" FREEZE "" }
    { LINE "You will be given a copy of the final\
            scoreboard after winners have been" }
    { LINE "announced at the post contest meeting." }

    { OUTPUT contest/scoreboard.public "" START }

    { start_time "" }
    { stop_time FREEZE }
    { LINE "The demo problem `count' will disappear\
            from the scoreboard once the contest" }
    { LINE "starts.  Until the contest starts, dates of\
            first correct submission are" }
    { LINE "displayed (for demo problems).  After the\
            contest starts, problem times" }
    { LINE "(differences of first correct submission\
            times and contest start time)" }
    { LINE "will be displayed." }
    BAR
    BOARD
    BAR

    { OUTPUT contest/scoreboard.public START FREEZE }

    { start_time START }
    { stop_time FREEZE }
    { problems { ! count } }
    { submitters { ! test-account } }
    BAR
    BOARD
    BAR

    { OUTPUT contest/scoreboard.1 }
    GRANT_ACCESS
    SEND

    { LINE NAME "Public Scoreboard" TIME }
    { INPUT contest/scoreboard.freeze }
    BLANK
    { INPUT contest/scoreboard.1head }
    BLANK
    { INPUT contest/scoreboard.public }

    { OUTPUT contest/scoreboard.current FREEZE STOP }

    { LINE NAME "Current Scoreboard" TIME }
    BLANK
    BAR
    { stop_time STOP }
    BOARD
    BAR
    { INPUT contest/who_where }
    BAR

    { OUTPUT contest/scoreboard.final STOP STOP }

    { LINE NAME "Final Results" "" STOP }
    BLANK
    BAR
    { stop_time STOP }
    BOARD
    BAR
    { INPUT contest/who_where }
    BAR
}

# Set default scoreboard instructions to those for
# the email contest.
#
set scoreboard_instructions \
    $email_scoreboard_instructions

# Scoreboard_mode_array is a map from the scoring_mode
# (see `Scoring Parameters') to a regular expression
# that must match all scorefinder codes used to con-
# struct a scoreboard.  Scorefinder output lines with
# non-matching codes are simply ignored.  Scoreboard_
# mode_array is only changed if the set of possible
# scoring modes is being changed.
#
# Scoreboard_mode_array($scoring_mode) is a TCL regular
# expression that must match the entire code output by
# scorefinder in order for the line containing the code
# to be used in computing a scoreboard.
#
set scoreboard_mode_array(manual) \
    {m(i|c)f|g}
set scoreboard_mode_array(auto) \
    {(a|m)(i|c)f|g}
set scoreboard_mode_array(auto+manual) \
    {(a|m)(i|c)(n|f)|g}
set scoreboard_mode_array(manual+auto) \
    {(a|m)(i|c)(n|f)|g}

# Web Page Parameters
# --- ---- ----------

# These parameters control the makeweb program that
# makes a web page containing problem statements and
# optionally solutions.  Makeweb makes a `web' directory
# for the current contest (after the other contest
# directories have been made).  The web directory
# contains an index.html file and other files and
# directories referenced by this index.html file using
# relative URLs.  The web directory is typically copied
# to another place to be put on the WWW.

# Header and title for the web page (the index.html
# file).  If "", no web page should be made.
#
set web_contest_name ""

# If not "", include in index.html a description of how
# to submit a problem via email, and give this as the
# address to which submissions are to be sent.
#
set web_autojudge_address ""

# If not "", include solutions in a private/pppp sub-
# directory of the web directory, where pppp is the
# value of this parameter.  Without knowing the pass-
# word, the solutions subdirectory cannot be accessed,
# as the private directory is made unreadable by the
# public.  Mention of the existence of solutions is
# included in the web directory index.html file, but
# the password is not included.
#
set web_solutions_password ""

# A list of TCL regular expressions such that a file in
# a problem solutions subdirectory is placed in the
# problem's web solutions subdirectory (of private/pppp
# above) if and only if the name of the file in its
# entirety matches one of the regular expressions in
# this list.
#
set web_solutions_files {
    {.*\.c}
    {.*\.cc}
    {.*\.java}
    {.*\.lsp}
    {.*\.in}
    {.*\.test}
}

# If not "", include in index.html a reference to help
# and demo files.  This parameter is the URL of the
# help and demos information and may be relative to the
# web directory.  See hpcm/contestant/help/Makefile
# for a `make web' command that can create a help and
# demos web page.
#
set web_help_URL ""

# If not "", include in index.html a reference to the
# scoreboard.  This parameter is the URL of the score-
# board and may be relative to the web directory.
#
set web_scoreboard_URL ""

# Normally a copy of the `response_mode' variable, this
# includes a description of what will be returned to
# the submitter is it is not "".
#
set web_response_mode ""

# If not "", at the end of index.html place contact
# information for the web page manager at the given
# email address.
#
set web_manager_address ""

# Scoring Parameters
# ------- ----------


# Scoring Instructions: see autoscore.  This is often
# changed on a per-problem basis by the file PROBLEM.rc
# in the PROBLEM directory.
#
set scoring_instructions "space column"

# Scoring Mode:
#
#	auto		Automatic scoring only; auto-
#			judge sends the score to the
#			contestant as final.
#	auto+manual	Automatic scoring plus manual
#			review of everything not `Com-
#			pletely Correct'; autojudge
#			sends the score to the contest-
#			ant as final if the score is
#			`Completely Correct', and as
#			to-be-reviewed otherwise.
#	manual		Manual scoring only; auto-
#			judge does not send the score
#			to the contestant.
#
# Note that the definition of scoring mode is completely
# contained in the response instructions below and the
# scoreboard_mode_array above, and can therefore be
# changed by changing just these.
#
set scoring_mode auto

# Maximum number of proofs for each type of difference
# that are recorded in the .score file.
#
set difference_type_proof_limit 100

# .err File Regexps:
#
# Regexp expressions matched to lines in .err file to
# detect limit overruns.  Letter case is ignored.
# The regular expressions match successfully if they
# match any part of a line.
#
set time_limit_regexp {cpu time limit exceeded}
set output_limit_regexp {file size limit exceeded}


# Response Instructions
# -------- ------------

# Response mode.  One of:
#
#   solution	Return SOLUTION if score is `Completely
#		Correct'.
#   first	Return location of FIRST error if score
#		is not `Completely Correct' and is
#		automatically determined.
#   summary	Return SUMMARY of errors if score is not
#		`Completely Correct' and is automatical-
#		ly determined.
#
#   ""		None of above.
#
#   solution+first	Combinations of above.
#   first+solution	Combinations of above.
#   solution+summary	Combinations of above.
#   summary+solution	Combinations of above.
#
set response_mode ""

# List of global variables that can be referenced in
# the if-expressions of the response instructions.
#
#   manual
#   proposed
#
# are reserved and cannot be used.  Do NOT delete from
# the following list.
#
set response_instructions_globals {
    response_mode
    scoring_mode
    auto_score
    manual_score
    proposed_score
}

# The maximum number of errors returned by the SUMMARY
# response command for each type of score.
#
set response_instructions_summary_limit 5

# Instructions on how to respond to the submitter when a
# new score is determined are provided in the following
# variable.   Additional instructions can be prepended
# to this global variable value by a problem .rc file.
# The EXIT command (see below ) should be used in any
# prepended instructions whenever the following is not
# supposed to execute.
#
# The response instructions and the scoreboard_mode_
# array together define the possible scoring_mode values
# and their meanings.
#
# See below for a detailed description of response in-
# structions.
#
set response_instructions {

    if { ! $manual && ! $proposed } {
	if { $scoring_mode == "manual" } {
	    NO-REPLY
	    EXIT
	} elseif {    $scoring_mode == "auto" \
	           || $auto_score \
		          == "Completely Correct" } {
	    { LINE "For -PROBLEM- the automatically\
	    	    determined final score is:" }
	    BLANK
	    { LINE "    -AUTO-SCORE-" }
	    FINAL
	} elseif { [lcontain {auto+manual manual+auto} \
			     $scoring_mode] } {

	    { LINE "For -PROBLEM- the automatically\
	    	    determined score is:" }
	    BLANK
	    { LINE "    -AUTO-SCORE-" }
	    BLANK
	    { LINE "However, this score WILL BE\
		    REVIEWED by the human judge\
		    (soon)." }
	    CC
	    NOT-FINAL
	} else {
	    { ERROR "bad scoring mode" }
	}

	if { $auto_score == "Completely Correct" } {
	} elseif { [regexp first $response_mode] } {
	    BLANK
	    BAR
	    FIRST
	    BAR
	} elseif { [regexp summary $response_mode] \
			    } {
	    BLANK
	    BAR
	    SUMMARY
	    BAR
	}

    } elseif { ! $manual && $proposed } {
	FINAL
	if { $scoring_mode == "manual" } {
	    { LINE "For -PROBLEM- your final score\
	    	    is:" }
	    BLANK
	    { LINE "    -PROPOSED-SCORE-" }
	} elseif { [regexp {auto} $scoring_mode] } {

	    if { $scoring_mode == "auto" } {
	    	EDIT
	    }

	    { LINE "For -PROBLEM- your previous\
	            automatic score of:" }
	    BLANK
	    { LINE "    -AUTO-SCORE-" }
	    BLANK

	    if { $proposed_score == $auto_score } {

		{ LINE "has been verified and confirmed\
		        by the human judge!" }
		{ LINE "Thus your FINAL score is:" }
		BLANK
		{ LINE "    -PROPOSED-SCORE-" }
		BLANK
		{ LINE "for this submission." }

	    } else {

		if { $scoring_mode != "auto" } {

		    { LINE "has been OVERRIDDEN by the\
		    	    human judge!" }
		} else {
		    {LINE "has been UNEXPECTEDLY\
			   OVERRIDDEN by the human\
			   judge!" }
		}

		BLANK
		{ LINE "The human judge has assigned\
			the NEW FINAL score:" }
		BLANK
		{ LINE "    -PROPOSED-SCORE-" }
		BLANK
		{ LINE "to this submission." }
	    }
	} else {
	    { ERROR "bad scoring mode" }
	}
    } elseif { $manual && $proposed } {

	FINAL
	EDIT
	{ LINE "For -PROBLEM- your PREVIOUS FINAL\
		manual score of:" }
	BLANK
	{ LINE "    -MANUAL-SCORE-" }
	BLANK

	if { $proposed_score == $manual_score } {
	    { LINE "has been verified and confirmed by\
	    	    the human judge!" }
	} else {
	    { LINE "has been UNEXPECTEDLY OVERRIDDEN by\
	    	    the human judge!" }
	    BLANK
	    { LINE "The human judge has assigned the\
	    	    NEW FINAL score:" }
	    BLANK
	    { LINE "    -PROPOSED-SCORE-" }
	    BLANK
	    {LINE "to this submission." }
	}
    } else {
	{ ERROR "manual score exists but no proposed\
	         score exists" }
    }

    BLANK
    { LINE "See below for submission time." }
    BLANK
    { BAR "this message replies to:" }
    RECEIVED-HEADER

    if { $proposed_score == "Completely Correct" || \
         ( ! $proposed && \
           $manual_score == "Completely Correct" ) || \
         ( ! $proposed && ! $manual && \
           $auto_score == "Completely Correct" ) } {

        if { [regexp solution $response_mode] } {
	    BLANK
	    BAR
	    { LINE "For comparison purposes,\
		    our solution follows." }
	    { LINE "PLEASE do NOT make ANY\
		    solution PUBLIC." }
	    SOLUTION
	}
    }
}

# The `response_instructions' variable value is a TCL
# list consisting of commands and if-statements.  The
# if-statements have the format of TCL if statements:
#
#    	if <expression> <block>
#	elseif <expression> <block>
#	else <block>
#
# where any number of elseif parts may be given and the
# else part is optional.  Note that the words `if',
# `elseif', and `else' are TCL list elements as are the
# expressions and blocks.  Each block is recursively
# interpreted as a TCL list consisting of commands and
# if-statements.  The if-statement expressions can be
# evaluated without evaluating any commands, so the
# sequence of commands that is to be executed can be
# determined and the if-statements can be removed in a
# first pass.
#
# If-statement expressions can be any TCL expr expres-
# sion.  Some of the variables that can be used are:
#
#   $scoring_mode
#	The value of the scoring_mode global variable.
#
#   $auto_score
#	The value of the $auto_score_file file.
#
#   $manual_score
#	The value of the $manual_score_file file, or
#	`None' if this file does not exist.  Always set
#	to `None' in the autojudge program.
#
#   $proposed_score
#	The score which the person running the manual-
#	reply program has chosen as the final score.
#	Set to `None' if the manualreply program is not
#	being used to set the score.  Always set to
#	`None' in the autojudge program, and never set
#	to `None' in the manualreply program.
#
#   $manual
#	Equals \$manual_score != \"None\".
#
#   $proposed
#	Equals \$proposed_score != \"None\".
#
# If-statement expressions can only use the variables
# whose names are listed in the `response_instructions_
# globals' variable, except for $manual and $proposed.
# Note that none of these variables can be set by
# response instruction commands, nor should any expres-
# sion change the state of the TCL program when it is
# evaluated (e.g., do NOT use `[catch { set foo 9 }]').
#
# The response instructions commands are executed to
# construct the reply.  The possible commands are:
#
#     FINAL
#     NOT-FINAL 
#     NO-REPLY
#	  Exactly one of these commands must be execut-
#	  ed, to indicate whether a reply is to be sent,
#	  and if it is to be the final reply for the
#	  submission.  If FINAL is executed, a final
#	  reply is sent and $reply_file is created; if
#	  NOT-FINAL is executed a reply is sent that is
#	  not final, and no $reply_file is created; if
#	  NO-REPLY is executed no reply is sent.  It is
#	  an an error if zero or more than one of these
#	  commands is executed.
#
#     CC
#	  Cc the reply to the `reply_manager' if that
#	  global variable does not have the value "".
#
#     EDIT
#	  This command indicates that the reply composed
#	  by the response instructions should be edited
#	  by a person before being sent.  The manual-
#	  reply program calls the editor if this command
#	  is executed.  It is an error to execute this
#	  command in the autojudge program.  (i.e., when
#	  $proposed is false).
#
#     EXIT
#	  This terminates command execution, and any
#	  commands following this command are ignored.
#
#     { LINES "string" ... }
#     { LINE  "string" }
#	  The strings, each followed by a line feed, are
#	  included in the reply.  Note that the strings
#	  may themselves include line feeds.
#
#	  Several special substrings are substituted for
#	  within each string as follows:
#
#	        -PROBLEM-	 The problem name.
#		-AUTO-SCORE-	 $auto_score value.
#		-MANUAL-SCORE-	 $manual_score value.
#		-PROPOSED-SCORE- $proposed_score value.
#
#     BLANK
#	  Include a blank line in the reply.
#
#     BAR
#	  Inserts a 72 character ----- bar line.
#	  Special substrings are substituted for as
#	  for LINE.
#
#     { BAR "string" }
#	  Inserts ----- bar line that ends with a space
#	  followed by the string.  The total number of
#	  characters in the line is 72.
#
#     { INPUT filename }
#	  Include a copy of the file in the reply.
#
#     RECEIVED-HEADER
#	  Include a copy of the Date, To, From, Reply-
#	  To, and Subject header lines of the
#	  $received_file file in the reply.
#
#     RECEIVED-FULL-HEADER
#	  Include a copy of the ENTIRE $received_file
#	  message header in the reply.
#
#     RECEIVED-BODY
#	  Include the body of the $received_file file in
#	  the reply.  Note that the blank line between
#	  the header and the body of an email is NOT
#	  included in RECEIVED-HEADER, RECEIVED-FULL-
#	  HEADER, or RECEIVED-BODY.
#
#     SOLUTION
#	  Include the solution files in the reply.  Each
#	  file is proceeded by a BAR line containing the
#	  file's name.  The solution files include all
#	  the -REQUIRED- and -OPTIONAL- files in any
#	  problem `$files_file' file, or the file named
#	  in the submission message if there is no
#	  `$files_file' file.
#
#     FIRST
#	  Include lines describing the type and position
#	  of the first automatic score determining error
#	  in the reply.
#
#     SUMMARY
#	  Include lines summarizing all automatic score
#	  determining errors in the reply.  See the
#	  variable response_instructions_summary_limit
#	  above.
#
# Response instructions are used by the autojudge and
# manualreply program, which compose score based replies
# to problem submissions.

# Submission Parameters
# ---------- ----------

# Set the following to `yes' if submissions must have
# files in the format:
#
#	HPCM_BEGIN filename
#	..first line of file
#	..second line of file
#	.. . . . more lines of file
#	HPCM_END filename
#
# Set following to `no' if submissions may also have
# files verbatim in the body of the submission message.
# See `extractmail' for details.
#
set format_submissions no

# Some mailers add stuff at the end of a message that
# needs to be ignored.  The following is a regular
# expression that matches whole lines that terminate the
# body of a submission message.  The regular expression
# is case insensitive (it is applied with the regexp
# -nocase option).
#
# Yahoo adds a --------.* line followed by Yahoo stuff.
# OK as long as we do not support languages that use
# `--' to begin comments, like ADA.
#
set message_terminator "--------.*"

# Permitted Content-Transfer-Encoding and Content-Type
# values, as regular expressions.  For multipart
# messages these are for the part.  Leading whitespace
# is stripped before the value is tested by the regular
# expression.  Messages that do not explicitly specify
# these fields have default values 7bit and text/plain.
#
set content_transfer_encoding_values \
    "(7bit|8bit|quoted-printable|base64).*"
set content_type_values "text/plain.*"



# Authentication Switch: yes or no
#
# Usually yes for informal and formal contests and no
# for email contest.  See authentication functions in
# judging_common.tcl for details.
#
set use_authentication no

# Authentication Keys:
#
#     array set authentication_keys {
#		keyname1	key1
#		keyname2	key2
#		keyname3	key3
#		.  .  .  .  .  .  .
#	}
#
# where each keyname and key is any list item.  If
# there is whitespace in a keyname or key enclose
# it in {}'s, as in:
#
#	{feedso's key}	{I'm happy to mEt U}
#
# There should be no beginning or ending whitespace
# to either a key or a keyname.
#
array set authentication_keys {
}

# Allowed Extensions:
#
# TCL list of allowed extensions for submitted programs:
#
set allowed_extensions {.c .cc .java .lsp}

# Submitter compress function.  Used to compress the
# full submitter email name when displaying the sub-
# mitters name, e.g., on the scoreboard.
#
# For this version the mode is `long' to include a con-
# testant's primary domain name (e.g. `harvard') or
# `short' to not include the @ or anything after that.
#
set submitter_compress_mode long
#set submitter_compress_mode short
proc submitter_compress { submitter } {

    global submitter_compress_mode

    # Long_submitter is submitter with stuff after @
    # compressed so xxxxx.yyy.eee becomes yyy.
    # Short_submitter is submitter with @ and stuff
    # after it removed.

    if { [regexp {^([^@]*)@(|.*\.)([^.]*)\.[^.]*$} \
                 $submitter forget \
		 short_submitter forget2 organization] \
			     } {
	set long_submitter \
	    "$short_submitter@$organization"
    } else {
	regexp {^([^@]*)@} $submitter forget \
	       short_submitter
	set long_submitter $short_submitter
    }

    if { $submitter_compress_mode == "long" } {
	return $long_submitter
    } else {
	return $short_submitter
    }
}


# Reply Mode:
#
#	auto		Automatic reply only; dispatch-
#			mail automatically sends a
#			reply, if autoinfo or autojudge
#			are not invoked.  The reply_
#			manager is cc'ed if that is not
#			""; otherwise the reply indi-
#			cates there will never be a
#			proper reply.
#	auto+manual	Automatic reply if a good auto-
#			matic reply is possible, as with
#			certain errors, and manual reply
#			otherwise.
#
set reply_mode auto

# Reply Manager:
#
# Email address to cc replies to if in `auto' reply_mode
# and no clearly correct automatic reply is possible.
#
set reply_manager ""

# Use GMT for dates in file and directory names.  Other-
# wise the local time zone is used.  Must be a TCL
# boolean (yes, no, 1, or 0).
#
set use_gmt no


# Logging Parameters
# ------- ----------

# Log Mode:		Action on Error:
#
#	manual		Write error to log file; do not
#			send any email.
#	auto+manual	Write error to log file, and
#			send error by email (but not
#			using normal reply mechanism)
#			to submitter/requester.  Manual
#			review should follow.
#	auto		Write error to log file, reply
#			to submitter/requester, and cc
#			to log_manager if that is not
#			"".  Reply email does NOT use
#			normal reply mechanism.
#	none		Error is NOT logged to a file
#			or emailed.
#
# Errors are always printed to the standard error
# output.
#
set log_mode auto

# Log Manager:
#
# Email address to cc log files to if in `auto'
# log_mode.
#
set log_manager ""

# Maximum Logged Errors:
#
# If more errors than this are logged by a single
# program execution, the log mode is automatically
# changed to `none' for that program execution.
#
set log_error_maximum 10


# Info Parameters
# ---- ----------

# info_map(name) if it exists is a list of names which
# replace `name' when a `get name' request is made.
# This list may be empty.
#
# If info_map(name) equals {FORBIDDEN {error_message}}
# then `name' cannot be returned by a `get name' request
# and the message:
#
#	The following file names are forbidden:
#	    name: error_message
#
# is returned in the reply mail.
#
# info_tail_map is just like info_map but maps just the
# tail component of name.
#
array set info_map {
    problems {FORBIDDEN {You are not allowed to get all\
              problems at once in this contest.}}
}

array set info_tail_map {
    CVS {}
    RCS {}
}


# Display Parameters
# ------- ----------

# Window heights.  The window_height is the height of
# the non-blank part of the window, and the window_
# blank_height is the number of blank lines that should
# be above the non-blank part of the window.
#
# WARNING: If window_height is too large, programs such
# as manualreply and lookat may appear to be malfunc-
# tioning because the information they display is being
# scrolled off the top of the screen.
#
set window_blank_height 16
set window_height 24
#
# How long should autodispatch run before we worry that
# it has hung up.  In seconds.
#
set dispatch_too_old 120
#
# Characters to turn highlighting on or off.  For ANSI
# terminals the number in highlight_on can be any of:
#	1 for bold, 7 for reverse video, 31 for red,
#	32 for green, 33 for yellow, 34 for blue,
#	35 for magenta, 36 for cyan, 41-46 to change
#	background instead of character color
#
set highlight_on  "\x1b\[7m"
set highlight_off "\x1b\[0m"


# Maintenance Parameters
# ----------- ----------

# Default list of problem description file extensions:
#
set problem_description_extensions \
    {.txt .html .htm .ps .pdf}

# List of last component names of subdirectories that
# are NOT to be recursively copied into ./contest sub-
# directories by makejudgingdir given a directory item
# `all' option.
#
set directories_not_copied {CVS RCS}



# Functions that Call the Operating System
# --------- ---- ---- --- --------- ------

### In theory all calls to `extended TCL' are here and
### no such calls are in the rest of the HPCM TCL code.
### Its difficult to enforce this rule in practice.

# Function to send mail, as does UNIX `sendmail'.  Takes
# mail message file with correctly set `To:' field and
# sends the message to the addresses listed there.  If
# some of these addresses are in error, this command
# may suffer a catchable error (and the mail may be put
# into ~/dead.letter).
#
proc send_mail { message_file } {
    exec /usr/sbin/sendmail -oi -t < $message_file
}

# Ditto but the message sent is the value of the single
# argument, and is not in a file.
#
proc send_message { message } {
    exec /usr/sbin/sendmail -oi -t << $message
}

# Function to compute the md5sum of a value.
#
proc compute_signature { value } {
    return [lindex [exec md5sum << $value] 0]
}

# Function to translate base64 mimencoded text.  The
# text to be translated is the argument and the trans-
# lated text is the returned value.
#
if { [catch { exec which mewdecode }] } {
    proc translate_base64 { text } {
	return [exec -keepnewline mimencode -u << $text]
    }
} else {
    proc translate_base64 { text } {
	return [exec -keepnewline mewdecode << $text]
    }
}

# Function to create a file.  Returns `yes' if the file
# was created, and `no' if it already exists.  Suffers
# an error if there is some other problem with creating
# the file.  If created, the file will be zero length
# and both readable and writable by the current user.
#
proc create_file { filename } {
    global errorCode errorInfo

    if { [catch { exec lockfile -0 -r 0 $filename } \
                out] } {
	if { [regexp {Sorry, giving up on} $out] } {
	    return no
	} else {
	    error $out $errorCode $errorInfo
	}
    } else {
	chmod u+w $filename
	ftruncate $filename 0
	return yes
    }
}

# Function to create a directory and suffer an error if
# the directory already exists.  If created, the
# directory will be empty, readable, and writable.
#
proc create_directory { dirname } {
    exec mkdir $dirname
}

# Function to symbolically link a file.  The source is
# the existing file name and the target is the new name
# linked to the source.  If no target is given, link the
# file into the current directory.
#
proc link_file { source { target . } } {
    exec ln -s $source $target
}

# Function to copy a file preserving modification date
# and protection settings.  Note that unlike the TCL
# `file copy' command, this function will not copy
# a symbolic link, but will copy the underlying file
# instead.
#
proc copy_file { source target } {
    exec cp -p $source $target
}

# Function to change the permissions of a file or direc-
# tory.
#
# If the file or directory is readable to the current
# user, and the `allow' argument contains an `r' (which
# it does by default), the file or directory is made
# readable by everyone.
#
# If the file or directory is writable to the current
# user, and the `allow' argument contains an `w' (which
# it does NOT by default), the file or directory is made
# writable by everyone.
#
# If the file or directory is executable to the current
# user, and the `allow' argument contains an `x' (which
# it does by default), the file or directory is made
# executable by everyone.
#
proc grant_access { filename { allow rx } } {
    set perm ""
    if { [file readable $filename] \
         && [regexp {r} $allow] } {
	set perm "${perm}r"
    }
    if { [file writable $filename] \
         && [regexp {w} $allow] } {
	set perm "${perm}w"
    }
    if { [file executable $filename] \
         && [regexp {x} $allow] } {
	set perm "${perm}x"
    }
    if { $perm != "" } {
	chmod "a+$perm" $filename
    }
}

# Return global (everyone) permissions of a file as a
# three character string, RWX, where R = r if the file
# is a+r and `-' otherwise, W = w if the file is a+w and
# `-' otherwise, and X = x or X = s if the file is a+x
# and `-' otherwise.  If file is a+x, X = s if the file
# is u+s, and X = x otherwise.
#
proc get_access { filename } {
    if { ! [file exists $filename] } {
    	return "---"
    }

    set mode [file attributes $filename -permissions]
    if { ( $mode & 0444 ) == 0444 } {
    	set R r
    } else {
        set R -
    }
    if { ( $mode & 0222 ) == 0222 } {
    	set W w
    } else {
        set W -
    }
    if { ( $mode & 0111 ) == 0111 } {
	if { ( $mode & 04000 ) == 04000 } {
	    set X s
	} else {
	    set X x
	}
    } else {
        set X -
    }
    return "$R$W$X"
}

# Deny rwx permissions to everyone but owner and
# group for a file or directory, and w permissions
# to everyone but owner.
#
proc deny_access { filename } {
    chmod o-rwx,g-w $filename
}

# Function to view a file.  Change to your favorite
# editor or display program.
#
# This version checks the environment variable
# HPCM_VIEW for an editor.  HPCM_VIEW may be a TCL
# list with an editor name and parameters.  If this
# global variable is not defined, the editor
# defaults to `view'.
#
proc view_file { filename } {

    global env

    if { [info exists env(HPCM_VIEW)] } {
        set editor $env(HPCM_VIEW)
    } else {
        set editor view
    }
    eval exec $editor \
         [list $filename >@ stdout 2>@ stderr]
}

# Function to edit a file.  Change to your favorite
# editor.
#
# This version checks the environment variable
# HPCM_EDIT for an editor.  HPCM_EDIT may be a TCL
# list with an editor name and parameters.  If this
# global variable is not defined, the editor
# defaults to `vi'.
#
proc edit_file { filename } {

    global env

    if { [info exists env(HPCM_EDIT)] } {
        set editor $env(HPCM_EDIT)
    } else {
        set editor vi
    }
    eval exec $editor \
         [list $filename >@ stdout 2>@ stderr]
}

# Function to invoke the `make' program for a given
# `name' on a Makefile in the current directory.
#
# The standard output of `make' is always sent to the
# standard output.  The error output of `make' is
# written to the err_file.
#
proc make_file { name err_file } {
    exec make $name >@ stdout 2> $err_file
}

# Diff two directories and return the output as a
# string.  The output must be like the output of
# `exec diff -r directory1 directory2' with UNIX
# `diff -r'.
#
proc diff_directories { directory1 directory2 } {
    return [exec diff -r $directory1 $directory2]
}

# Diff two files.  Write all output, including error
# output, to a third file, with a header line in that
# file saying what was done.  Errors are ignored as
# far as TCL is concerned (they produce error messages
# in `output').
#
# Like UNIX `diff'.  The option `-b' may be given, and
# is like the `-b' option to UNIX `diff'.
#
proc diff_files { file1 file2 output { options "" } } {
    if { $options == "" } {
        set command "diff"
    } else {
        set command "diff $options"
    }
    write_file $output "===== $command $file1 $file2"
    catch { eval exec $command \
                 [list $file1 $file2 >>& $output] }
}

# Function to call shell.  Change to your favorite
# shell.
#
proc call_shell {} {
    exec csh >@ stdout 2>@ stderr
}

# Function to execute a command in another directory.
# Additional arguments are arguments to TCL exec that
# can reroute IO: e.g., >&@ stdout
#
proc exec_in_directory { directory command args } {
    eval exec csh -c "{cd $directory; $command}" $args
}

# Function to return the current process ID.
#
proc current_pid {} {
    return [id process]
}

# Function to display the state of processes within
# a process tree rooted at a given process.  Return
# value is the display.
#
proc display_process_tree { root_pid } {
    catch { exec pstree -pa $root_pid } out
    if { $out == "" } {
    	set out "No process with PID $root_pid exists"
    }
    return $out
}

# Function that looks at result of display_process_tree
# and returns true iff the root process for the tree
# was found to exist.
# 
proc process_found { display } {
    return [expr { \
        !  [regexp {^No process with PID .* exists} \
		   $display] }]
}

# Function to send signal to process subtree.  Signal
# must be KILL or INT.
#
# Note: we tried to use process groups, but making a
# process into a group leader disconnects the process
# from its stdin when that is a terminal, and that
# made life impossible.
#
proc signal_process_tree { signal root_pid } {
    catch { exec pstree -p $root_pid } out
    regsub -- {-pstree\([0-9]*\)} $out "-pstree" out
    regsub {^[^(]*\(} $out "\{" out
    regsub {\)[^)]*$} $out "\}" out
    regsub -all {\)[^(]*\(} $out "\} \{" out
    set list ""
    foreach pid $out {
        if { [regexp {^[0-9]+$} $pid] } {
	    lappend list $pid
	}
    }
    if { $list != "" } {
	echo kill $signal $list
	kill $signal $list
    }
}

# Function to turn signals into errors.
#
proc make_signals_errors {} {
    if { [info command signal] == "signal" } {
	signal error { HUP INT QUIT ALRM TERM }
    }
}

# Function to cause signals to be ignored.
#
proc make_signals_ignored {} {
    if { [info command signal] == "signal" } {
	signal ignore { HUP INT QUIT ALRM TERM }
    }
}

# Function to turn on signal default action.
#
proc make_signals_default {} {
    if { [info command signal] == "signal" } {
	signal default { HUP INT QUIT ALRM TERM }
    }
}

# Function to disable stdout and stderr (e.g., by
# routing them to /dev/null).
#
proc disable_outputs {} {
    set ch [open /dev/null w]
    dup $ch stdout
    dup $ch stderr
}

# Function to return current account name.
#
proc account_name {} {
    return [id user]
}

# Function to return current host name.
#
proc host_name {} {
    return [id host]
}


# Parameters Not Usually Changed
# ---------- --- ------- -------


# File names:
#
set received_file		Received_Mail
set files_file			Files
set reply_file			Reply_Mail
set reply_history_file		Reply_Mail_History
set no_reply_file		No_Reply
set scoring_filter_file 	Scoring_Filter
set auto_score_file		Auto_Score
set manual_score_file		Manual_Score
set make_file			Makefile
set dispatch_pid_file		Dispatch_PID
set gotten_file			Gotten
set score_flag_file		Score_Flag
set needs_reply_flag_file	Needs_Reply_Flag
set scoreboard_pid_file		Scoreboard_PID
set scorefinder_output_file	Scorefinder_Output


# Directory names:
#
set mail_directory	$judging_directory/mail
set solutions_directory	$judging_directory/solutions
set info_directory	$judging_directory/info
set log_directory	$judging_directory/log
set flag_directory	$judging_directory/flag
set contest_directory	$judging_directory/contest
set help_directory	$judging_directory/help
set web_directory	$judging_directory/web
