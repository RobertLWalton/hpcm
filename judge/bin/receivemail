#! /bin/sh -f
#
# Process incoming mail for judging.
#
# File:		receivemail
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Aug 20 04:06:42 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/22 16:43:08 $
#   $RCSfile: receivemail,v $
#   $Revision: 1.11 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# If an argument is given, use it as a name of a
# directory to make current, and the argument is
# consumed.  This must be done before looking for the
# parameters file.
#
# Don't change argc or argv so error output will work.
#
set my_argc $argc
set my_argv $argv
if { $argc >= 1 } {
    cd [lindex $argv 0]
    set my_argv [lreplace $argv 0 0]
    set my_argc [expr { $argc - 1 }]
}

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"
catch {

set document "
receive \[directory\]

    Reads mail from the standard input and divides it
    into messages.  For each message, a subdirectory is
    made in the `$mail_directory' to hold the message,
    its reply, and any program file extracted from the
    message, binary of that program, output of that
    program, etc.  The message is copied into the
    `$received_file' in that directory and the
    `dispatchmail' program is called with that directory
    as the current directory to dispatch a program to
    reply to the message.

    The name of the subdirectory for a message is the
    entire `From' line that begins the message,
    verbatim.

    If a message is read that already has a directory,
    the message is ignored.

    If the directory argument is given, this program
    makes that directory current before searching for
    the `$judging_parameters_file' file.

    If there are non-blank lines before the first `From'
    line in the input, these are organized into a spec-
    ial message from the current user to him/herself.
    The subject of this message is something ignored
    by `dispatchmail'.

    It is a fatal error if an mail `From' line contains
    a `/'.
    
    This program outputs the `From' lines that become
    the names of the directories actually created."

if { $my_argc != 0 } {
    puts $document
    exit 1
}

# Read stdin until non-blank line found.
#
while { "yes" } {
    set line [gets stdin]
    if { [eof stdin] } {
	exit 0
    } elseif { ! [regexp "^\[\ \t\]*\$" $line] } {
    	break
    }
}

# Make sure mkdir of a subdirectory of the mail
# directory will not fail because the mail directory
# does not exist or is not writable.
#
if { ! [file isdirectory "$mail_directory"] } {
    error "$mail_directory is not a directory."
} elseif { ! [file writable "$mail_directory"] } {
    error "$mail_directory is not writable."
}

# If the first non-blank mail line is not a `From' line,
# create a message header for a (fake) message from the
# current user to him/herself complaining about the text
# that does not have a `From' line, and then proceed to
# include this text in the message until a `From' line
# or end of input is reached.
#
if { ! [regexp $From_line_regexp $line] } {

    # Compute a fake From line for our fake message.
    # Keep trying until one that does not match an
    # existing directory is found.
    #
    set try_count 0
    while { "yes" } {
        set From_line \
	    "From [id user]\
	          [clock format [clock seconds]]"
	}
	set dirname [From_line_to_dirname $From_line]

	# The mkdir system command is used as a kind
	# of lock: it is assumed to fail only if the
	# directory to be made already exists.  (DON'T
	# try to use `file mkdir' instead).
	#
	if { ! [catch {
	          exec mkdir \
		      "$mail_directory/$dirname"
		} ] } {
	    break;
	}

	# Limit this madness.
	#
	incr try_count
	if { $try_count > 100 } {
	    error \
	        "Cannot create unique subdirectory of\
		 $mail_directory after 100 tries."
	}

	# Be sure the next name generated is different.
	#
	sleep 1
    }

    puts $dirname

    set d "$mail_directory/$dirname"
    set message_ch [open "$d/$received_file" w]

    puts $message_ch \
         $From_line
    puts $message_ch \
         "To: [id user]"
    puts $message_ch \
         "Subject: Text in mail input before `From'\
	  line" 
    puts $message_ch \
         ""
    puts $message_ch \
         "The following text appeared in mail input\
	  before"
    puts $message_ch \
         "any `From' line appeared."
    puts $message_ch \
         ""
    puts $message_ch \
         "---------------------- text:"

    while { "yes" } {
    	puts $message_ch $line
	set line [gets stdin]
	if { [eof stdin] } {
	    break
        } elseif { [regexp $From_line_regexp $line] } {
	    break
	}
    }
    puts $message_ch \
         "---------------------- end text"
    close $message_ch

    if { [eof stdin] } {
    	exit 0
    }
}

# Loop to handle each message.  Starts with $line
# equal to the `From' line of the message.
#
while { "yes" } {

    set From_line $line
    set dirname [From_line_to_dirname $From_line]

    # Make directory for message.  On sucess copy
    # message to the directory.  On failure, skip the
    # message.

    # The mkdir system command is used as a kind
    # of lock: it is assumed to fail only if the
    # directory already exists.
    #
    if { [catch \
	  { exec mkdir \
	    "$mail_directory/$dirname" } ] } {

	# Directory must already exist.  Skip message.
	#
	while { "yes" } {
	    set line [gets stdin]
	    if { [eof stdin] } {
	    	break;
	    } elseif { [regexp $From_line_regexp \
	               $line] } {
		break;
	    }
	}
    } else {

    	# Directory did NOT exist, and was just made.
	# Copy message.
	#
	puts $dirname
	set d "$mail_directory/$dirname"
	set message_ch [open "$d/$received_file" w]

	while { "yes" } {
	    puts $message_ch $line
	    set line [gets stdin]
	    if { [eof stdin] } {
	    	break;
	    } elseif { [regexp $From_line_regexp \
	               $line] } {
		break;
	    }
	}

	close $message_ch

	# Dispatch for new directory:
	#
	if { [catch {
		exec < /dev/null >& /dev/null \
		     dispatchmail \
		     "$mail_directory/$dirname" &
	     } catch_out ] } {
	    log_error $catch_out
	}
    }

    if { [eof stdin] } break
}

# Come here on eof for stdin.

exit 0

# Include common error catching code:
#
} caught_output
caught_error
