#!/bin/sh -f
#
# Receive incoming mail, write it into separate
# directories, and call dispatchmail. 
#
# File:		receivemail
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Aug 27 07:45:04 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/27 11:51:00 $
#   $RCSfile: receivemail,v $
#   $Revision: 1.16 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# If an argument is given, use it as a name of a
# directory to make current, and consume the argument.
# This must be done before looking for the parameters
# file.
#
# Don't change argc or argv so error output will work.
#
set my_argc $argc
set my_argv $argv
if { $argc >= 1 && ! [regexp {^-} [lindex $argv 0]] } {
    cd [lindex $argv 0]
    set my_argv [lreplace $argv 0 0]
    set my_argc [expr { $argc - 1 }]
}

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"
set log_globally yes
catch {

set document "
receivemail \[directory\]

    Reads mail from the standard input and divides it
    into messages.  For each message, a subdirectory is
    made in the mail directory to hold the message,
    its reply, and any program file extracted from the
    message, binary of that program, output of that
    program, etc.  The message is copied into the
    `$received_file' in that directory and the
    `dispatchmail' program is called with that directory
    as the current directory to dispatch a program to
    reply to the message.

    The name of the subdirectory for a message has the
    form:
		dddd-[<SU>]-{<tttt>}

    where dddd is the message date in filename format
    and tttt is the email address to reply to, or is
    derived therefrom.  If tttt cannot be computed, it
    is given the value `UNKNOWN'.

    If a message is read that already has a directory,
    the message is ignored.  Note that this means that
    no one (including `UNKNOWN') can send more than one
    message per second.

    If the directory argument is given, this program
    makes that directory current before searching for
    the `$judging_parameters_file' file.

    If there are non-blank lines before the first `From'
    line in the input, these are organized into a spec-
    ial message from the user `UNKNOWN' and date equal
    to the current time.  The subject of this message is
    something ignored by `dispatchmail'.

    This program outputs the names of the directories
    actually created."

if { $my_argc != 0 } {
    puts $document
    exit 1
}

# Make sure making subdirectory of the mail
# directory will not fail because the mail directory
# does not exist or is not writable.
#
if { ! [file isdirectory "$mail_directory"] } {
    error "$mail_directory is not a directory."
} elseif { ! [file writable "$mail_directory"] } {
    error "$mail_directory is not writable."
}

# Read stdin until non-blank line found.
#
while { "yes" } {
    set line [gets stdin]
    if { [eof stdin] } {
	exit 0
    } elseif { ! [regexp "^\[\ \t\]*\$" $line] } {
    	break
    }
}

# Loop to handle each message.  Starts with $line
# equal to the `From' line of the message unless
# it is the first non-blank line of the input and
# that is not a `From' line.
#
while { "yes" } {

    set From_line $line

    # Read header
    #
    if { [regexp {^From\ } $line } {
	set fake_message no
    	read_header stdin $line {x_hpcm_signature_ok}
    } else {

	set fake_message yes

        # If this is non-blank text before the first
	# `From' line in the input, fake a header.
	#
    	set null_ch [open /dev/null r]
	read_header $null_ch \
	            "From UNKNOWN\
		     [clock format [clock seconds]]"
	close $null_ch
	set message_subject \
	    "Subject: lines received in front of\
	              From line"
	set message_header \
	   "$message_header\n$message_subject"

	# Since there is no `From:', `Reply-to:' or
	# `Date:' in this fake header, the computed
	# reply-to and date will come from the fake
	# `From' line.
    }

    # If authentication is to be used, authenticate
    # header.
    #
    if { $use_authentication } {
    	compute_authentication
    }

    # Compute and reformat Reply-to.  Delete all
    # whitespace, and if Reply-to ends with <...>,
    # replace Reply-to by the ...
    #
    set reply_to [compute_message_reply_to]
    regsub -all "\[\ \t\n\]" $reply_to "" reply_to
    regexp {<([^<>]*)>$} $reply_to forget reply_to

    if { $reply_to == "" } {
    	set reply_to UNKNOWN
    }

    # Compute the message date.
    #
    set date [compute_message_date]

    set dddd [clock_to_filename_date [clock scan $date]]
    set dirname "$dddd-\[<SU>\]-{<$reply_to>}"
    	

    # Make directory for message.  On sucess copy
    # message to the directory.  On failure, skip the
    # message.

    if { [catch \
	  { make_directory \
	    "$mail_directory/$dirname" } ] } {

	# Directory must already exist.  Skip message.
	#
	while { "yes" } {
	    set line [gets stdin]
	    if { [eof stdin] } {
	    	break;
	    } elseif { [regexp {^From\ } $line] } {
		break;
	    }
	}
    } else {

    	# Directory did NOT exist, and was just made.
	# Copy message.
	#
	puts $dirname
	set d "$mail_directory/$dirname"
	set message_ch [open "$d/$received_file" w]

	puts $message_ch $message_header
	puts $message_ch ""

	while { "yes" } {
	    if { $fake_message } {
	    	set fake_message no
	    } else {
		set line [gets stdin]
	    }
	    if { [eof stdin] } {
	    	break;
	    } elseif { [regexp {^From\ } $line] } {
		break;
	    }
	    puts $message_ch $line
	}

	close $message_ch

	# Dispatch for new directory:
	#
	if { [catch {
		exec < /dev/null >& /dev/null \
		     dispatchmail \
		     "$mail_directory/$dirname" &
	     } catch_out ] } {
	    log_error $catch_out
	}
    }

    if { [eof stdin] } break
}

# Come here on eof for stdin.

exit 0

# Include common error catching code:
#
} caught_output
caught_error
