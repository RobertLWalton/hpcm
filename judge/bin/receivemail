#! /bin/sh -f
#
# Move submissions from a mail file into a judging
# directory.
#
# File:		receive_submissions
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Aug 16 06:41:25 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/16 11:24:46 $
#   $RCSfile: receivemail,v $
#   $Revision: 1.7 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

if { [info command signal] == "signal" } {
    signal error SIGINT
}

# Set program parameters that could be changed.
#
set allowed_extensions_default \
    ".c .cc .java"
set allowed_extensions_filename \
    "allowed_submission_extensions"
set log_filename \
    "receive_submissions.log"

# Regexp to match first line of mail message.
# If you send a line matching this in a mail message,
# a `>' will be prefixed to prevent the line from
# matching this regexp.
#
set From_line_regexp {^From\ }

set document "
receive_submissions mail_file judging_directory

    For each submission in the mail_file builds a sub-
    directory of the judging_directory containing the
    submitted file.  The subdirectory name is the entire
    `From' line for the submission message in the mail
    file, which includes the date and submitter.
    Nothing is done if the subdirectory already exists.

    All actions are logged by appendments to:
    	judging_directory/$log_filename

    Submission errors include:
        Submitted file before first mail message.
	Submitted file improperly terminated.
	2 or more submitted files in one message.
	Unallowed extension for submitted file.

    Errors are both logged in the log file and
    announced on the standard output.  All but the first
    error above cause a `.score' file to be written
    with the first line equal to `Submission Error'.

    The allowed extensions are read from the file:
        D/../lib/$allowed_extensions_filename
    where D is the directory containing the program.
    If this file is not readable (e.g. does not exist),
    the default allowed extensions are:
    	$allowed_extensions_default

    In the event of an interrupt or an error, this
    program may leave:
	A submission directory with a `.score' file
	    whose first line is `Submission Error'
    	An empty submission directory.
    	An submission directory with an invalid
	    (e.g. empty) `.score' file."

if { $argc != 2 } {
    puts $document
    exit 0
}

set mail_file [lindex $argv 0]
set judging_directory [lindex $argv 1]

if { ! [file readable $mail_file] } {
    puts "ERROR: not readale:"
    puts "       $mail_file"
    exit 1
}

if { ! [file isdirectory $judging_directory] } {
    puts "ERROR: not a directory:"
    puts "       $judging_directory"
    exit 1
}

set log_file "$judging_directory/$log_filename"
puts "Logging to $log_file"
set log_fd   [open $log_file a]

puts $log_fd \
     "-----------------------------------------------"
puts $log_fd \
     "Starting Run: [clock format [clock seconds]]"
puts $log_fd \
     "    Mail File: $mail_file"

set program_directory [file dirname $argv0]
set lib_directory "$program_directory/../lib"

set allowed_extensions_file \
    "$lib_directory/$allowed_extensions_filename"

if { [file readable $allowed_extensions_file] } {
    set allowed_extensions_fd \
        [open $allowed_extensions_file r]
    set allowed_extensions \
        [gets $allowed_extensions_fd]
    close $allowed_extensions_fd

    puts $log_fd "    Allowed extensions read from\
                      $allowed_extensions_file:"
    puts $log_fd "        $allowed_extensions"
} else {
    set allowed_extensions $allowed_extensions_default
    puts $log_fd "    No file $allowed_extensions_file"
    puts $log_fd "    Allowed extensions default to:"
    puts $log_fd "        $allowed_extensions"
}

set mail_fd [open $mail_file r]

# State can be `none', `found', `next_found'
#
set From_line_state none
set From_line       ""
set next_From_line  ""

# The following procedure reads the mail_fd until
# it encounters a submission file end line, and end
# of file, or a message beginning From line.  If
# it encounters a From line it sets From_line_state
# to next_found and next_From_line to the From line
# itself.
#
proc flush_submitted_file {} {
    global mail_fd next_From_line From_line_state \
           From_line_regexp

    while {1} {
	set line [gets $mail_fd]
	if { [eof $mail_fd] } {
	    break
	} elseif {
	    [regexp \
		{^\[\[\.\.ACM\.\.END\.\.\]\]} \
		$line] } {
	    break
	} elseif {
	    [regexp $From_line_regexp $line] } {
	    set next_From_line $line
	    set From_line_state next_found
	    break
	}
    }
}

# The following procedure outputs an error message
# line to the standard output, the log file, and the
# score file.  If the score_fd is "no", the score
# file is opened for writing, `Submission Error'
# is written to the file's first line, and creation
# of the score file is logged.  This procedure returns
# the value of score_fd, which it may change.
#
proc output_error { score_fd
		    score_file
		    error_message_line } {
    global log_fd From_line
    if { $score_fd == "no" } {
	puts $log_fd \
	     "    Creating $score_file"
	set score_fd \
	    [open $score_file w]
	puts $score_fd "Submission Error"
	puts $From_line
    }
    puts $log_fd   $error_message_line
    puts $score_fd $error_message_line
    puts           $error_message_line

    return $score_fd
}

# This procedure handles all processing of a submitted
# file after the [[..ACM..BEGIN]] line is read.
#
proc copy_submitted_file { directory submitted_file } {
    global From_line mail_fd log_fd \
           next_From_line From_line_state \
	   From_line_regexp

    set submitted_program \
        [file rootname $submitted_file]
    set submitted_extension \
        [file extension $submitted_file]
    set output_file \
	"$directory/$submitted_file"
    set score_file \
	"$directory/${submitted_program}.score"

    puts $log_fd $From_line
    puts $log_fd \
	 "    Making directory $directory"
    file mkdir $directory

    puts $log_fd "    Creating $output_file"
    set output_fd [open $output_file w]

    set number_of_good_lines 0
    set number_of_bad_lines 0

    set score_fd no

    while {1} {
	set line [gets $mail_fd]
	if { [eof $mail_fd] } {
	    set score_fd \
	        [output_error $score_fd $score_file \
		 "    ERROR: unexpected eof\
			 ends submitted file" ]
	    puts $output_fd \
		 "ERROR: unexpected eof ends\
			 this submitted file"
	    break
	} elseif { [regexp {^\.\.(.*)$} $line \
			   all real_part] } {
	    incr number_of_good_lines
	    puts $output_fd $real_part
	} elseif {
	    [regexp \
	     {^\[\[\.\.ACM\.\.END\.\.\]\]} \
	     $line] } {
	    break
	} elseif {
	    [regexp $From_line_regexp $line] } {
	    set next_From_line $line
	    set From_line_state next_found
	    set score_fd \
	        [output_error $score_fd $score_file \
		 "    ERROR: unexpected end of message\
			 ends submitted file" ]
	    puts $output_fd \
		 "ERROR: unexpected end of message\
			 ends this submitted file"
	    break
	} else {
	    if { ! [info exists score_fd] } {
		puts $log_fd \
		     "    Creating $score_file"
		set score_fd \
		    [open $score_file w]
		puts $score_fd "Submission Error"
		puts $From_line
	    }
	    incr number_of_bad_lines
	    puts $output_fd "ERROR: bad line in\
				submitted file:"
	    puts $output_fd $line
	    if { $number_of_bad_lines == 1 } {
		set score_fd \
		    [output_error $score_fd \
		                  $score_file \
			"    ERROR: bad lines in\
				  submitted file:" ]
	    }
	    if { $number_of_bad_lines <= 5 } {
		set score_fd \
		    [output_error $score_fd \
		                  $score_file \
			"           $line" ]
	    } elseif {
		  $number_of_bad_lines == 6 } {
		set score_fd \
		    [output_error $score_fd \
		                  $score_file \
		     "           AND THERE ARE\
			     MORE BAD LINES!" ]
	    }
	}
    }

    puts $log_fd \
	 "    There were $number_of_good_lines\
	      good lines in file."
    if { $score_fd != "no" } { close $score_fd }
    close $output_fd
}

# Below is the main program loop that reads the mail_fd
# file.  It remembers From lines as it encounters them,
# and processes submit files as it encounters the
# [[..ACM..BEGIN..]] lines.  If From_line_state equals
# next_found, instead of reading mail_fd this loop gets
# its next line from the next_From_line variable.

set number_of_files 0

while {1} {
    if { $From_line_state == "next_found" } {
    	set line next_From_line
	set From_line_state none
    } else {
	set line [gets $mail_fd]
	if { [eof $mail_fd] } break
    }

    if  { [regexp $From_line_regexp $line] } {
    	set From_line $line
	set From_line_state found
	set number_of_files 0
	set directory \
	    "$judging_directory/$From_line"
	set first_submitted_file ""
    } elseif {
	    [regexp {^\[\[\.\.ACM\.\.BEGIN\.\.\]\]} \
		    $line] } {

	incr number_of_files

	if { [llength $line] >= 2 } {
	    set submitted_file [lindex $line 1]
	    set submitted_file [file split $submitted_file]
	    set submitted_file [lindex $submitted_file end]
	} else {
	    set submitted_file "name_omitted"
	}

	set submitted_program \
	    [file rootname $submitted_file]
	set submitted_extension \
	    [file extension $submitted_file]

	if { $From_line_state == "none" } {
	    puts $log_fd \
		 "ERROR: file before any mail message:\
		         $submitted_file"
	    puts \
		 "ERROR: file before any mail message:\
		         $submitted_file"

	    flush_submitted_file
	} elseif { [file isdirectory $directory] } {
	    if { $first_submitted_file != "" } {

		set score_file \
		    [glob -nocomplain \
		          "$directory/*.score"]
		if ( [llength $score_file] != 1 } {
		    set score_file \
			"[file rootname \
			       $first_submitted_file \
			       ].score"
		}

		if { ! [file exists $score_file] } {
		    set score_fd no
		} else {
		    set score_fd [open $score_file a]
		}

		if { $number_of_files == 2 } {
		    set score_fd \
		        [output_error $score_fd \
				      $score_file \
			 "    ERROR: extra file in\
				     submission:\
			     $first_submitted_file"]
		}

		set score_fd [output_error $score_fd \
					   $score_file \
		     "    ERROR: extra file in\
		                 submission:\
				 $submitted_file"]
		close $score_fd
	    }

	    flush_submitted_file
	} elseif { [lsearch \
	            -exact $allowed_extensions \
		    $submitted_extension] < 0 } {
	    puts $log_fd $From_line
	    puts $log_fd \
	         "    Making directory $directory"
	    file mkdir $directory

	    set score_file \
		"$directory/${submitted_program}.score"

	    set score_fd [output_error no $score_file \
		 "    ERROR: bad extension on file\
		             named: $submitted_file"]
	    close $score_fd

	    flush_submitted_file
	} else {
	    set first_submitted_file $submitted_file
	    set ecode \
		[catch {
		    copy_submitted_file \
			$directory $submitted_file
		} emessage]
	    if { $ecode != 0 } {
	        puts         $From_line
	        puts         "    ERROR: $emessage"
	        puts $log_fd "    ERROR: $emessage"
	        puts         "    Deleting directory\
		                  $directory"
	        puts $log_fd "    Deleting directory\
		                  $directory"
		exec rm -rf $directory
	        puts         "    Abnormal exit $ecode"
	        puts $log_fd "    Abnormal exit $ecode"
		exit $ecode
	    }
	}
    }
}

puts $log_fd "Exiting normally"
puts         "Exiting normally"

exit 0
