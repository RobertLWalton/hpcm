#!/bin/sh
#
# Runs the trackfinder program to get tracking informa-
# tion, formats the results into a tables upon request,
# and dispatches the `manualreply' program to work on
# directories upon request.
#
# File:		tracker
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Nov  6 17:53:41 EST 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/11/06 23:59:16 $
#   $RCSfile: tracker,v $
#   $Revision: 1.7 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_mode none
catch {

set document "
tracker

    This program inputs the output of `trackfinder' to
    get tracking information.  This program is menu
    driven, with commmands that permit the tracking
    information to be displayed in various ways, and
    commands that permit the `manualreply' program to
    be dispatched for a subdirectory.

    Unlike most HPCM judging programs, errors made by
    this program are not written to log files, but are
    announced on standard error."


# If any arguments, print documentation and exit.
#
if { $argc > 0 } {
    puts $document
    exit 1
}

# The value of info_array($dirname) is a list of input
# lines that concern the directory.  The $dirname is
# calculated from the line
#
#	sub date {submitter}
#
# as `date-<<submitter>>-submission', or is taken from
# the line
#
#	dir date {dirname}
#
# The value of xxx_array($dirname) exists for every
# dirname with a `xxx' line, and equals that line.  This
# can be used to compute statistics of various kinds.
#
# The exception is for `chk' and `err' lines. For these
# there are arrays
#
#	chk_array($dirname)
#	err_array($dirname)
#
# whose values are merely lists of the filenames taken
# from the `chk' and `err' lines.  Note these filenames
# begin with a date and sorting on filenames sorts on
# the dates.

# Helper function to read scores from input channel:
#
proc save_line { line type minlength dirname } {

    global ${type}_array

    if { [info exists ${type}_array($dirname)] } {
	error "Too many `$type' lines for $dirname"
    } elseif { [llength $line] < $minlength } {
	error "Badly formatted `$type' line:\n\
	      \   $line"
    } else {
	set ${type}_array($dirname) $line
    }
}

# Read the scores from the input channel and accumulate
# them in the approprate arrays.
#
proc read_input { ch } {

    global info_array rec_array ext_array bin_array \
           out_array sco_array rep_array got_array \
	   pid_array chk_array err_array

    set line [gets $ch]
    if { [eof $ch] } return

    while { "yes" } {

        # Read submit_time and dirname.
	#
	if { [llength $line] < 3 \
	     || [lsearch {sub dir} \
	     		 [lindex $line 0]] < 0 } {
	    error "Non `sub' or `dir' line from\
	           `trackfinder':\n    $line"
	}
	set date	[lindex $line 1]
	set submit_time	[filename_date_to_clock $date]
	if { [lindex $line 0] == "sub" } {
	    set submitter [lindex $line 2]
	    set dirname \
	        "$date-<<$submitter>>-submission"
	} else {
	    set dirname [lindex $line 2]
	}

        # Clear previous knowledge about dirname.
	#
	if { [info exists info_array($dirname)] } {
	    unset info_array($dirname)
	    if { [info exists rec_array($dirname)] } {
		unset rec_array($dirname)
	    }
	    if { [info exists ext_array($dirname)] } {
		unset ext_array($dirname)
	    }
	    if { [info exists bin_array($dirname)] } {
		unset bin_array($dirname)
	    }
	    if { [info exists out_array($dirname)] } {
		unset out_array($dirname)
	    }
	    if { [info exists sco_array($dirname)] } {
		unset sco_array($dirname)
	    }
	    if { [info exists rep_array($dirname)] } {
		unset rep_array($dirname)
	    }
	    if { [info exists got_array($dirname)] } {
		unset got_array($dirname)
	    }
	    if { [info exists chk_array($dirname)] } {
		unset chk_array($dirname)
	    }
	    if { [info exists err_array($dirname)] } {
		unset err_array($dirname)
	    }
	    if { [info exists pid_array($dirname)] } {
		unset pid_array($dirname)
	    }
	}

	# Read and save information about dirname.
	#
	set info_array($dirname) [list $line]

	while { "yes" } {
	    set line [gets $ch]
	    if { [eof $ch] } break

	    if { [llength $line] == 0 } continue
	    switch [lindex $line 0] {
	    sub {
		    break
		}
	    dir {
		    break
		}
	    rec {
		    save_line $line rec 3 $dirname
		}
	    ext {
		    save_line $line ext 3 $dirname
		}
	    bin {
		    save_line $line bin 3 $dirname
		}
	    out {
		    save_line $line out 3 $dirname
		}
	    sco {
		    save_line $line sco 4 $dirname
		}
	    rep {
		    save_line $line rep 3 $dirname
		}
	    got {
		    save_line $line got 2 $dirname
		}
	    pid {
		    save_line $line pid 3 $dirname
		}
	    chk {
		    if { [llength $line] < 3 } {
			error "Badly formatted `chk'\
			       line:\n    $line"
		    } else {
			set file [lindex $line 2]
			if { ! [info \
			          exists \
				  chk_array($dirname)] \
				  } {
			    set chk_array($dirname) \
			        [list $file]
			} else {
			    lappend \
			        chk_array($dirname) \
				$file
			}
		    }
		}
	    err {
		    if { [llength $line] < 3 } {
			error "Badly formatted `err'\
			       line:\n    $line"
		    } else {
			set file [lindex $line 2]
			if { ! [info \
			          exists \
				  err_array($dirname)] \
				  } {
			    set err_array($dirname) \
			        [list $file]
			} else {
			    lappend \
			        err_array($dirname) \
				$file
			}
		    }
		}
	    }
	    lappend info_array($dirname) $line
	}

	if { [eof $ch] } break
    }
}

# List of directories.  Used to select directories
# for manualreply.
#
set directory_list ""
set directory_list_length 0

# Clear the directory list.
#
proc clear_list {} {
    global directory_list directory_list_length
    set directory_list		""
    set directory_list_length	0
}

# Add directories with unchecked errors to directory
# list, and return printable summary string.
#
proc add_err {} {

    global directory_list directory_list_length \
    	   err_array

    set items ""
    foreach dir [lsort [array names err_array]] {
        set files [lsort $err_array($dir)]
	if { [llength $files] == 0 } continue
	lappend items [list [lindex $files 0] \
			    $dir $files]
    }
    set result ""
    foreach item [lsort $items] {
        set dir   [lindex $item 1]
        set files [lindex $item 2]
	lappend directory_list $dir
	incr directory_list_length
	set result "$result\n[format {%3d. %s} \
	     $directory_list_length $dir]"
	foreach file $files {
	    set result "$result\n         $file"
	}
    }

    return $result
}

# Add directories with `Subject:'s not handled by auto-
# dispatch and no reply or no_reply to directory list,
# and return printable summary string.
#
proc add_queries {} {

    global directory_list directory_list_length \
    	   rec_array rep_array autodispatch_map

    set result ""
    foreach dir [lsort [array names rec_array]] {
        set rec_line $rec_array($dir)
	if { [info exists rep_array($dir)] } {
	    continue
	}
	set subject [lindex $rec_line 2]
	set dword [lindex $subject 0]
	if { [llength $subject] >= 1 \
	     && [info exists \
	              autodispatch_map($dword)] } {
	    continue
	}

	lappend directory_list $dir
	incr directory_list_length
	set result "$result\n[format {%3d. %s} \
	                      $directory_list_length \
			      $dir]"
	set result "$result\n         Subject: $subject"
    }

    return $result
}

# Add directories with too old dispatch pid files to
# directory list, and return printable summary string.
#
proc add_pid { { too_old "" } } {

    global directory_list directory_list_length \
    	   pid_array dispatch_too_old

    set result ""
    if { $too_old == "" } {
	set too_old $dispatch_too_old
    }
    foreach dir [lsort [array names pid_array]] {
        set pid_line $pid_array($dir)
	set mtime [lindex $pid_line 1]
	set rtime [lindex $pid_line 2]
	set elapsed [expr { $rtime - $mtime }]
	if { $elapsed < $too_old } continue

	lappend directory_list $dir
	incr directory_list_length
	set result "$result\n[format {%3d. %s} \
	                      $directory_list_length \
			      $dir]"
	set result "$result\n         running for\
		    $elapsed seconds"
    }

    return $result
}

# Add directories with Auto_Score file, an auto score
# not equal to `Completely Correct', and no Manual_Score
# or Dispatch_PID file.
#
proc add_score {} {

    global directory_list directory_list_length \
    	   sco_array pid_array rec_array

    set result ""
    foreach dir [lsort [array names sco_array]] {
        set sco_line $sco_array($dir)
	if { [lindex $sco_line 2] != "" } {
	    continue
	}
	set auto_score [lindex $sco_line 3]
	if { $auto_score == "Completely Correct" } {
	    continue
	}
	if { [info exists pid_array($dir)] } {
	    continue
	}
	if { [info exists rec_array($dir)] } {
	    set subject [lindex $rec_array($dir) 2]
	} else {
	    set subject "submit ???"
	}

	lappend directory_list $dir
	incr directory_list_length
	set result "$result\n[format {%3d. %s} \
	                      $directory_list_length \
			      $dir]"
	set result "$result\n         Subject: $subject\
	            Score: $auto_score"
    }

    return $result
}

# Add directories with `Subject:'s handled by autodis-
# patch and no reply or no_reply to directory list,
# and return printable summary string.
#
proc add_auto {} {

    global directory_list directory_list_length \
    	   rec_array rep_array pid_array \
	   autodispatch_map

    set result ""
    foreach dir [lsort [array names rec_array]] {
        set rec_line $rec_array($dir)
	if { [info exists rep_array($dir)] } {
	    continue
	}
	set subject [lindex $rec_line 2]
	set dword [lindex $subject 0]
	if { [llength $subject] < 1 \
	     || ! [info exists \
	                autodispatch_map($dword)] } {
	    continue
	}

	lappend directory_list $dir
	incr directory_list_length
	set result "$result\n[format {%3d. %s} \
	                      $directory_list_length \
			      $dir]"
	if { [info exists pid_array($dir)] } {
	    set pid_line $pid_array($dir)
	    set mtime [lindex $pid_line 1]
	    set rtime [lindex $pid_line 2]
	    set elapsed [expr { $rtime - $mtime }]

	    set result "$result\n         Subject:\
	                $subject       running for\
			$elapsed seconds"
	} else {
	    set result "$result\n         Subject:\
	                $subject"
	}
    }

    return $result
}

# Return summary of successful replies, etc.
#
proc summary {} {

    global rec_array rep_array err_array chk_array

    set replies 0
    set no_replies 0
    set submits 0
    set gets 0
    set queries 0
    set uncheckeds 0
    set checkeds 0

    foreach dir [array names rec_array] {
        set rec_line $rec_array($dir)
	set subject [lindex $rec_line 2]
	set dword [lindex $subject 0]
	if { $dword == "submit" } {
	    incr submits
	} elseif { $dword == "get" } {
	    incr gets
	} else {
	    incr queries
	}
	if { [info exists rep_array($dir)] } {
	    set rep_line $rep_array($dir)
	    if { [lindex $rep_line 1] != "" } {
	        incr replies
	    } else {
	        incr no_replies
	    }
	}
	if { [info exists err_array($dir)] } {
	    incr uncheckeds
	}
	if { [info exists chk_array($dir)] } {
	    incr checkeds
	}
    }

    set r1 ""
    set r2 ""
    if { $submits != 0 } {
        set r1 "$r1, $submits Submits"
    }
    if { $gets != 0 } {
        set r1 "$r1, $gets Gets"
    }
    if { $queries != 0 } {
        set r1 "$r1, $queries Queries"
    }
    if { $replies != 0 } {
        set r1 "$r1, $replies Replies"
    }
    if { $no_replies != 0 } {
        set r1 "$r1, $no_replies No Replies"
    }
    if { $checkeds != 0 } {
        set r2 "$r2, $checkeds Checked Errors"
    }
    if { $uncheckeds != 0 } {
        set r2 "$r2, $uncheckeds UNCHECKED Errors"
    }
    set r [string range $r1$r2 2 end]
    if { [string length $r] > 79 } {
        set r1 [string range $r1 2 end]
        set r2 [string range $r2 2 end]
	set r "$r1\n$r2"
    }
    return $r
}

# Given the number of an entry in the directory list,
# call manualreply for that directory, and on return
# reread that directory.  Return a string that can be
# printed to indicate success or failure.
#
proc call_manualreply { index } {

    global directory_list directory_list_length \
	   mail_directory

    if { $index < 1 \
	 || $index > $directory_list_length } {
	return "$index out of range"
    }

    set dir \
	[lindex $directory_list [expr { $index - 1 }]]

    if { [regexp {^[^<>]*-<<.*>>-submission$} $dir] } {
	set dir $mail_directory/$dir
    }

    exec manualreply $dir >@ stdout 2>@ stderr

    set ch [open "| trackfinder $dir" r]
    read_input $ch
    close $ch

    return "Done with [file tail $dir]"
}

# Clip output of add functions to n - m directories.
#
proc clip { out m n } {
    set limit [expr { $n - $m }]
    set outlist [split $out "\n"]
    set len [llength $outlist]
    if { 2 * $limit < $len - 1 } {
	set offset [expr { 2 * $limit }]
	set out [join [lrange $outlist 0 $offset] "\n"]
    }
    return $out
}

# Loop until eof.
#
while { "yes" } {

    # Read or re-read all input sources.
    #
    set ch [open "|trackfinder" r]
    read_input $ch
    close $ch
    if { [file isdirectory $log_directory] } {
	set ch [open "|trackfinder $log_directory" r]
	read_input $ch
	close $ch
    }
    if { [file isdirectory $default_log_directory] } {
	set jp $judging_parameters_file
	set dldjp $default_log_directory/$jp
        if { ! [file readable $dldjp] } {
            set jdjp $judging_directory/$jp
	    if { ! [regexp {^/} $jdjp] } {
	        set jdjp "[pwd]/$jdjp"
	    }
	    while { [regsub \
	             {/([^/.]|\.[^/.])[^/]*/\.\./} \
		     $jdjp {/} jdjp] > 0 } {}
	    file delete -force $dldjp
	    link_file $jdjp $dldjp
	}
	set ch [open "|trackfinder\
	              $default_log_directory" r]
	read_input $ch
	close $ch
    }

    set output ""
    while { "yes" } {
        clear_list

	set err_list [add_err]
	set err_last $directory_list_length
	set queries_list [add_queries]
	set queries_last $directory_list_length
	set pid_list [add_pid]
	set pid_last $directory_list_length
	set score_list [add_score]
	set score_last $directory_list_length

	if { $directory_list_length == 0 } {

	    set auto_list [add_auto]
	    if { $directory_list_length != 0 } {

		set list ""
		foreach dir $directory_list {
		    if { [regexp \
		          {^[^<>]*-<<.*>>-submission$} \
			  $dir] } {
			set dir $mail_directory/$dir
		    }
		    lappend list $dir
		}
		set ch [open "|trackfinder\
			      [join $list]" r]
		read_input $ch
		close $ch
		clear_list
		set auto_list [add_auto]
	    }

	    if { $directory_list_length == 0 } {
		puts "\n[summary]"
	    } else {
	        puts "1-$directory_list_length.\
		      Are being automatically\
		      processed;"
		puts "You should not need to do\
		      anything."
		puts [clip $auto_list 0 5]
	    }
	} else {
	    set o ""
	    set f 0
	    if { $err_list != "" } {
	        incr f
	        set o "$o\n$f-$err_last. \
		       Unchecked Errors"
	        set o \
		    "$o[clip $err_list 0 5]"
		set f $err_last
	    }
	    if { $queries_list != "" } {
	        incr f
	        set o "$o\n$f-$queries_last. \
		       Queries"
	        set o \
		    "$o[clip $queries_list $err_last 5]"
		set f $queries_last
	    }
	    if { $pid_list != "" } {
	        incr f
	        set o "$o\n$f-$pid_last. \
		       Stuck Submissions"
	        set o \
		    "$o[clip $pid_list $queries_last 5]"
		set f $pid_last
	    }
	    if { $score_list != "" } {
	        incr f
	        set o "$o\n$f-$score_last. \
		       Submissions Needing Manual\
		       Scoring"
	        set o \
		    "$o[clip $score_list $pid_last 5]"
		set f $score_last
	    }
	    puts $o
	}
	puts ""
	puts "$output"
	puts -nonewline "> "
	flush stdout
	set answer [string trim [gets stdin]]
	if { [eof stdin] } break
	if { ! [catch { expr { $answer } }] } {
	    set output [call_manualreply $answer]
	}
    }

    if { [eof stdin] } break
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
