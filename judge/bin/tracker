#!/bin/sh
#
# Runs the trackfinder program to get tracking informa-
# tion, formats the results into a tables upon request,
# and dispatches the `manualreply' program to work on
# directories upon request.
#
# File:		tracker
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Nov  5 12:16:47 EST 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/11/05 17:52:14 $
#   $RCSfile: tracker,v $
#   $Revision: 1.4 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_mode none
catch {

set document "
tracker

    This program inputs the output of `trackfinder' to
    get tracking information.  This program is menu
    driven, with commmands that permit the tracking
    information to be displayed in various ways, and
    commands that permit the `manualreply' program to
    be dispatched for a subdirectory.

    Unlike most HPCM judging programs, errors made by
    this program are not written to log files, but are
    announced on standard error."


# If any arguments, print documentation and exit.
#
if { $argc > 0 } {
    puts $document
    exit 1
}

# The value of info_array($dirname) is a list of input
# lines that concern the directory.  The $dirname is
# calculated from the line
#
#	sub date {submitter}
#
# as `date-<<submitter>>-submission', or is taken from
# the line
#
#	dir date {dirname}
#
# The value of xxx_array($dirname) exists for every
# dirname with a `xxx' line, and equals that line.  This
# can be used to compute statistics of various kinds.
#
# The exception is for `chk' and `err' lines. For these
# there are arrays
#
#	chk_array($dirname)
#	err_array($dirname)
#
# whose values are merely lists of the filenames taken
# from the `chk' and `err' lines.  Note these filenames
# begin with a date and sorting on filenames sorts on
# the dates.

# Helper function to read scores from input channel:
#
proc save_line { line type minlength dirname } {

    global ${type}_array

    if { [info exists ${type}_array($dirname)] } {
	error "Too many `$type' lines for $dirname"
    } elseif { [llength $line] < $minlength } {
	error "Badly formatted `$type' line:\n\
	      \   $line"
    } else {
	set ${type}_array($dirname) $line
    }
}

# Read the scores from the input channel and accumulate
# them in the approprate arrays.
#
proc read_input { ch } {

    global info_array rec_array ext_array bin_array \
           out_array sco_array rep_array got_array \
	   pid_array chk_array err_array

    set line [gets $ch]
    if { [eof $ch] } return

    while { "yes" } {

        # Read submit_time and dirname.
	#
	if { [llength $line] < 3 \
	     || [lsearch {sub dir} \
	     		 [lindex $line 0]] < 0 } {
	    error "Non `sub' or `dir' line from\
	           `trackfinder':\n    $line"
	}
	set date	[lindex $line 1]
	set submit_time	[filename_date_to_clock $date]
	if { [lindex $line 0] == "sub" } {
	    set submitter [lindex $line 2]
	    set dirname \
	        "$date-<<$submitter>>-submission"
	} else {
	    set dirname [lindex $line 2]
	}

        # Clear previous knowledge about dirname.
	#
	if { [info exists info_array($dirname)] } {
	    unset info_array($dirname)
	    if { [info exists rec_array($dirname)] } {
		unset rec_array($dirname)
	    }
	    if { [info exists ext_array($dirname)] } {
		unset ext_array($dirname)
	    }
	    if { [info exists bin_array($dirname)] } {
		unset bin_array($dirname)
	    }
	    if { [info exists out_array($dirname)] } {
		unset out_array($dirname)
	    }
	    if { [info exists sco_array($dirname)] } {
		unset sco_array($dirname)
	    }
	    if { [info exists rep_array($dirname)] } {
		unset rep_array($dirname)
	    }
	    if { [info exists got_array($dirname)] } {
		unset got_array($dirname)
	    }
	    if { [info exists chk_array($dirname)] } {
		unset chk_array($dirname)
	    }
	    if { [info exists err_array($dirname)] } {
		unset err_array($dirname)
	    }
	    if { [info exists pid_array($dirname)] } {
		unset pid_array($dirname)
	    }
	}

	# Read and save information about dirname.
	#
	set info_array($dirname) [list $line]

	while { "yes" } {
	    set line [gets $ch]
	    if { [eof $ch] } break

	    if { [llength $line] == 0 } continue
	    switch [lindex $line 0] {
	    sub {
		    break
		}
	    dir {
		    break
		}
	    rec {
		    save_line $line rec 3 $dirname
		}
	    ext {
		    save_line $line ext 3 $dirname
		}
	    bin {
		    save_line $line bin 3 $dirname
		}
	    out {
		    save_line $line out 3 $dirname
		}
	    sco {
		    save_line $line sco 4 $dirname
		}
	    rep {
		    save_line $line rep 3 $dirname
		}
	    got {
		    save_line $line got 2 $dirname
		}
	    pid {
		    save_line $line pid 3 $dirname
		}
	    chk {
		    if { [llength $line] < 3 } {
			error "Badly formatted `chk'\
			       line:\n    $line"
		    } else {
			set file [lindex $line 2]
			if { ! [info \
			          exists \
				  chk_array($dirname)] \
				  } {
			    set chk_array($dirname) \
			        [list $file]
			} else {
			    lappend \
			        chk_array($dirname) \
				$file
			}
		    }
		}
	    err {
		    if { [llength $line] < 3 } {
			error "Badly formatted `err'\
			       line:\n    $line"
		    } else {
			set file [lindex $line 2]
			if { ! [info \
			          exists \
				  err_array($dirname)] \
				  } {
			    set err_array($dirname) \
			        [list $file]
			} else {
			    lappend \
			        err_array($dirname) \
				$file
			}
		    }
		}
	    }
	    lappend info_array($dirname) $line
	}

	if { [eof $ch] } break
    }
}

# List of directories.  Used to select directories
# for manualreply.
#
set directory_list ""
set directory_list_length 0

# Clear the directory list.
#
proc clear_list {} {
    global directory_list directory_list_length
    set directory_list		""
    set directory_list_length	0
}

# Add directories with unchecked errors to directory
# list, and return printable summary string.
#
proc add_err {} {

    global directory_list directory_list_length \
    	   err_array

    set items ""
    foreach dir [array names err_array] {
        set files [lsort $err_array($dir)]
	if { [llength $files] == 0 } continue
	lappend items [list [lindex $files 0] \
			    $dir $files]
    }
    set result ""
    foreach item [lsort $items] {
        set dir   [lindex $item 1]
        set files [lindex $item 2]
	lappend directory_list $dir
	incr directory_list_length
	set result "$result\n[format {%3d. %s} \
	     $directory_list_length $dir]"
	foreach file $files {
	    set result "$result\n         $file"
	}
    }

    return $result
}

# Add directories with `Subject:'s not handled by auto-
# dispatch and no reply or no_reply to directory list,
# and return printable summary string.
#
proc add_nonauto {} {

    global directory_list directory_list_length \
    	   rec_array rep_array

    set result ""
    foreach dir [array names rec_array] {
        set rec_line $rec_array($dir)
	if { [info exists rep_array($dir)] } {
	    continue
	}
	set subject [lindex $rec_line 2]
	if { [llength $subject] >= 1 \
	     && [lsearch -exact {submit get} \
	     		 [lindex $subject 0]] >= 0 } {
	    continue
	}

	lappend directory_list $dir
	incr directory_list_length
	set result "$result\n[format {%3d. %s} \
	                      $directory_list_length \
			      $dir]"
	set result "$result\n         $subject"
    }

    return $result
}

# Add directories with too old dispatch pid files to
# directory list, and return printable summary string.
#
proc add_pid { { too_old "" } } {

    global directory_list directory_list_length \
    	   pid_array dispatch_too_old

    set result ""
    if { $too_old == "" } {
	set too_old $dispatch_too_old
    }
    foreach dir [array names pid_array] {
        set pid_line $pid_array($dir)
	set mtime [lindex $pid_line 1]
	set rtime [lindex $pid_line 2]
	set elapsed [expr { $rtime - $mtime }]
	if { $elapsed < $too_old } continue

	lappend directory_list $dir
	incr directory_list_length
	set result "$result\n[format {%3d. %s} \
	                      $directory_list_length \
			      $dir]"
	set result "$result\n         running for\
		    $elapsed seconds"
    }

    return $result
}

# Add directories with `Subject:'s handled by autodis-
# patch and no reply or no_reply to directory list,
# and return printable summary string.
#
proc add_auto {} {

    global directory_list directory_list_length \
    	   rec_array rep_array pid_array

    set result ""
    foreach dir [array names rec_array] {
        set rec_line $rec_array($dir)
	if { [info exists rep_array($dir)] } {
	    continue
	}
	set subject [lindex $rec_line 2]
	if { [llength $subject] >= 1 \
	     && [lsearch -exact {submit get} \
	     		 [lindex $subject 0]] < 0 } {
	    continue
	}

	lappend directory_list $dir
	incr directory_list_length
	set result "$result\n[format {%3d. %s} \
	                      $directory_list_length \
			      $dir]"
	if { [info exists pid_array($dir)] } {
	    set pid_line $pid_array($dir)
	    set mtime [lindex $pid_line 1]
	    set rtime [lindex $pid_line 2]
	    set elapsed [expr { $rtime - $mtime }]

	    set result "$result\n         $subject\
                        \        running for $elapsed\
			seconds"
	} else {
	    set result "$result\n         $subject"
	}
    }

    return $result
}

# Given the number of an entry in the directory list,
# call manualreply for that directory, and on return
# reread that directory.  Return a string that can be
# printed to indicate success or failure.
#
proc call_manualreply { index } {

    global directory_list directory_list_length \
	   mail_directory

    if { $index < 1 \
	 || $index > $directory_list_length } {
	return "$index out of range"
    }

    set dir \
	[lindex $directory_list [expr { $index - 1 }]]

    if { [regexp {^.*-<<.*>>-submission$} $dir] } {
	set dir $mail_directory/$dir
    }

    exec manualreply $dir >@ stdout 2>@ stderr

    set ch [open "| trackfinder $dir" r]
    read_input $ch
    close $ch

    return "Done with $dir"
}


set ch [open "|trackfinder" r]
read_input $ch
close $ch

set output ""
while { "yes" } {
    set directory_list ""
    set directory_list_length 0
    puts [add_err]
    puts [add_nonauto]
    puts [add_pid]
    puts [add_auto]
    puts ""
    puts "$output"
    puts -nonewline "> "
    flush stdout
    set answer [string trim [gets stdin]]
    if { [eof stdin] } break
    if { ! [catch { expr { $answer } }] } {
	set output [call_manualreply $answer]
    }
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error

