#!/bin/sh
#
# Recomputes the scoreboard every minute.
#
# File:		makescoreboard
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sat Oct 27 06:36:46 EDT 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/10/27 12:07:07 $
#   $RCSfile: makescoreboard,v $
#   $Revision: 1.15 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_globally yes
catch {

set document "
makescoreboard { start | status | stop | update } \\
               \[ parameter-filename | \\
	         scoreboard_instructions-value \] ...

    This program makes scoreboards by following the
    instructions stored in the `scoreboard_instructions'
    global variable.  See the $judging_parameters_file\
    				file
    for a description of these instructions.

    When this program starts, it processes its second
    and subsequent arguments as follows.  Any named
    parameter file is `sourced'.  Any argument that
    begins with a `{' is stored (with the `{ }' brackets
    removed) in the `scoreboard_instructions' global
    variable.
    
    This program calls
    
	scorefinder \\
	    > judging_directory/$scorefinder_output_file

    The $scorefinder_output_file file is used as input\
    						   by
    the `scoreboard' program to produce scoreboards.

    This program ignores signals when computing score-
    boards, and terminates without error on a signal
    while the program is sleeping for an interval.

    If called with an `update' command, this program
    processes the scoreboard instructions just once
    and then exits immediately.

    If called with the `start' command, this program
    writes its process ID of the $scoreboard_pid_file\
    		file
    in the judging directory, and begins to rerun itself
    at periodic intervals.  But if the\
    		$scoreboard_pid_file
    file already exists, AND the process ID it contains
    is valid, this program prints information about the
    ID'ed process and does nothing else.

    With the `start' command, this program first makes
    scoreboards as per the `update' command, and then
    this program reruns at intervals determined by the 
    `scoreboard_interval' global variable.  After every
    interval, this program checks the files input during
    the last making of a scoreboard to see if any have
    changed since the last run.  If not, this program
    does nothing; otherwise the program makes a new
    scoreboard remakes the scoreboard as per `update'.
    The $judging_parameters_file file in the judging\
    					directory
    and the parameter files listed in the arguments are
    among the files checked for change, and these are
    re-`sourced' when they change.  Before checking
    files for change, the $score_flag_file flag is
    checked, and if present, the\
    			$scorefinder_output_file
    file is remade by calling `scorefinder'.

    If called with the `stop' command, this program does
    nothing but send kill signals to the process whose
    ID is listed in the $scoreboard_pid_file file, and
    then deletes the file.  While doing this it outputs
    information about its progress.

    If called with the `status' command, this program
    just outputs information about the status of any
    process started by `makescoreboard start'.

    With the `update', `status', or `stop' commands this
    program does not log errors but writes them to the
    standard error.  This program does the same with
    `start' command errors that occur during the first
    making of the scoreboard.  After this program starts
    reruns for the `start' command, this program logs
    errors in the log directory."

# Print documentation if illegal (or -doc) first
# argument.
#
set command [lindex $argv 0]
if { ! [regexp {^(update|start|status|stop)$} $command] } {
    puts $document
}

# Constant equal to 256 spaces.
#
set space "        "
set space "$space$space$
set space "$space$space$
set space "$space$space$
set space "$space$space$
set space "$space$space$

if { $scoreboard_width > 256 } {
    error "scoreboard width > 256"
}

# Some abbreviations.
#
set finder_file \
    $judging_directory/$scorefinder_output_file
set pid_file \
    $judging_directory/$scoreboard_pid_file

# Compute possible parameters and save original values.
#
foreach name [info globals scoreboard_*] {
    regexp {^scoreboard_(.*)$} $name forget pname
    if { $pname != "instructions" } {
	set parameters_array($pname) [set $name]
    }
}

# Return `yes' if a file in the mtime_list has changed.
# Otherwise returns `no'.
#
# The mtime_file list is a list of items each of the
# format:
#
#	{ file-mtime file-name }
#
# The file-mtime can be a `clock seconds' value, or
# `none' if the file did not exist.  A file changes is
# it appears or disappears or has a larger mtime than
# it did.
#
# If mtime_list has the special value `changed', this
# function always returns `yes'.
#	
proc file_changed { mtime_list } {
    if { $mtime_list == "changed" } {
        return yes
    }
    foreach item $mtime_list {
       set mtime [lindex $item 0]
       set name  [lindex $item 1]
       if { $mtime == "none" } {
           if { [file readable $name] } {
	       return yes;
	   }
       } else {
           if { ! [file readable $name] } {
	       return yes;
	   } else if { [file mtime $name] > $mtime } {
	       return yes;
	   }
       }
    }
    return no
}

# File-mtime list for parameter files.
#
set parameter_mtime_list changed

# Mtime of latest parameter file.
#
set parameter_mtime ""

# Process arguments.  If parameter files (including
# the judging_parameters_file) have not changed,  just
# restore values of scoreboard_ variables listed in
# parameters_array.
#
proc process_arguments {} } {

    global judging_directory judging_parameters_file \
           parameter_mtime_list parameters_array \
	   parameter_mtime scoreboard_instructions
    foreach name [array names parameters_array] {
	global scoreboard_$name
    }

    if { ! [file_changed $parameter_mtime_list] } {

        foreach name [array names parameters_array] {
	    set scoreboard_$name \
	    	$parameters_array($name)
	}
	return
    }

    set parameter_mtime_list ""

    set pf $judging_directory/$judging_parameters_file
    if { $parameter_mtime_list != "changed" } { source $pf }
    set mtime [file mtime $pf]
    lappend parameter_mtime_list [list $mtime $pf]
    set parameter_mtime $mtime

    foreach arg $argv {
	if { [regexp "^{" $arg] } {
	    set scoreboard_instructions $arg
	} else {
	    source $arg
	    set mtime [file mtime $arg]
	    lappend parameter_mtime_list \
	    	    [list $mtime $arg]
	    if { $mtime > $parameter_mtime } {
	        set parameter_mtime $mtime
	    }

	}
    }

    foreach name [array names parameters_array] {
        set parameters_array($name) \
	    [set scoreboard_$name]
    }
}

process_arguments


# Given a value that may be an abbreviation defined
# in the abbreviation_array, return the value it
# abbreviates, or return the original value if it is not
# an abbreviation.
#
proc unabbreviate { value } {

    global abbreviation_array

    if { [info exists abbreviation_array($value)] } {
        return $abbreviation_array($value)
    } else {
        return $value
    }
}


# File-mtime list for scoring instructions files.
#
set file_mtime_list changed

# Earliest future time in an OUTPUT instruction.
#
set earliest_future_time ""

# Last value of parameters_mtime.
#
set last_parameters_mtime $parameters_mtime

# Process scoring instructions.
#
proc process_instructions {} {

    global scoreboard_instructions abbreviation_array \
           file_mtime_list earliest_future_time \
	   last_parameters_mtime parameters_mtime \
	   finder_file judging_directory \
	   score_flag_file
    foreach name [array names parameters_array] {
	global scoreboard_$name
    }

    set time [clock seconds]

    # Reinstall initial parameter values.
    #
    process_arguments

    if { $file_mtime_list == "changed" \
         || [test_flag $score_flag_file] } {

	set gotten ""
	if { [regexp {^(|team)$} \
	             $scoreboard_start_time] } {
	    set gotten -gotten
	}

	# The following code ensures that two copies of
	# scorefinder do not try to write the same file
	# at once.  It is possible that while one copy
	# is being written its filename will be deleted
	# and another will be started.

	make_signals_ignored
	while { "yes" } {
	    file delete -force -- $finder_file
	    if { [create_file $finder_file] } break
	    make_signals_default
	    sleep 2
	    make_signals_ignored
	}
	eval exec scorefinder $gotten \
	     > $finder_file
	make_signals_default
    }

    if {    $last_parameters_mtime \
               >= $parameters_mtime \
	 && ! [file_changed $file_mtime_list]
	 && $time < $earliest_future_time } {

        return
    }

    # Save abbreviations.
    #
    set abbreviation_array(START)  scoreboard_start_time
    set abbreviation_array(STOP)   scoreboard_stop_time
    set abbreviation_array(FREEZE) \
				 scoreboard_freeze_time
    set abbreviation_array(NAME)   scoreboard_name
    set abbreviation_array(TIME)   [clock format $time]

    # Ignore signals while processing instructions.
    #
    make_signals_ignored

    set instructions $scoreboard_instructions
    set pc 0
    set end_pc [llength $instructions]
    set out_pc -1

    set earliest_future_time ""

    while { "yes" } {

        set instruction [lindex $instructions $pc]

        if { ( $pc >= $end_pc \
	       || $instruction == "OUTPUT" ) \
	     && $out_pc >= 0 } {
	    if { $out_start != "" \
	          || $time $out_start } {
	        set update no
	    }
	    if {    $out_mtime != "" \
	         && $out_stop != "" \
	         && $out_mtime >= $out_stop } {
	        set update no
	    }

	    pass2 $instructions $out_pc $pc $update

	    if { $pc >= $end_pc } break
	}

	set opcode [lindex $instruction 0]
	switch $opcode {
	    OUTPUT {
		set out_file  [lindex $instruction 1]
		set out_start [lindex $instruction 2]
		set out_stop  [lindex $instruction 3]
		set out_file \
		   [file join $judging_directory \
		              $out_file]
		set out_start [unabbreviate $out_start]
		set out_stop [unabbreviate $out_stop]
		if { $out_start != "" } {
		    set out_start \
		        [clock scan $out_start]
		    if { $out_start > $time \
		         && (    $earliest_future_time \
			 	     == "" \
			      || $earliest_future_time \
			             > $out_start ) } {
		        set earliest_future_time \
			    $out_start
		    }
		}
		if { $out_stop != "" } {
		    set out_stop \
		        [clock scan $out_stop]
		    if { $out_stop > $time \
		         && (    $earliest_future_time \
			 	     == "" \
			      || $earliest_future_time \
			             > $out_stop ) } {
		        set earliest_future_time \
			    $out_stop
		    }
		}
		if { [file readable $out_file] } {
		    set out_mtime [file mtime $out_file]
		} else {
		    set update yes
		    set out_mtime ""
		}
	        set out_pc $pc
	    	set update no
		lappend file_mtime_list \
			[list out $out_file]
	    }

	    BLANK {}

	    BAR -
	    LINE {
	    	if { $last_parameters_mtime \
		     < $parameters_mtime } {
		    set update yes
		}
	    }

	    INPUT {
		foreach in_file \
		        [lrange $instruction 1 end] {
		    set in_file \
		        [file join $judging_directory \
			           $in_file]
		    if { [file readable $in_file] } {
			if { $update == "no" \
			     && [file mtime $in_file]
				> $out_mtime } {
			    set update yes
			}
			lappend file_mtime_list \
			        [list [file mtime \
				            $in_file] \
				      $in_file]
			break;
		    } else {
			lappend file_mtime_list \
				[list del $in_file]
		    }
		}
	    }
	    BOARD {
	    	if { $last_parameters_mtime \
		     < $parameters_mtime } {
		    set update yes
		}
		if { [file readable $finder_file] } {
		    if { $update == "no" \
			 && [file mtime $finder_file] \
			    > $out_mtime } {
			set update yes
		    }
		    [list [file mtime $finder_file] \
			  $finder_file]
		} else {
		    lappend file_mtime_list \
			    [list del $finder_file]
		}

	    }
	    SEND {}
	    default {}
	}
    }
    make_signals_default
}

proc pass2 { instructions pc end_pc update } {

    global parameters_array scoreboard_instructions \
           judging_directory finder_file
    foreach name [array names parameters_array] {
	global scoreboard_$name
    }

    set instructions $scoreboard_instructions
    set out_file [lindex [lindex $instructions $pc] 1]
    set out_file $judging_directory/$out_file"

    incr pc
    set contents ""
    set send no
    set send_qualifier ""

    while { $pc < $end_pc } {
        set instruction [lindex $instructions $pc]
	incr pc
	set opcode [lindex $instruction 0]
	switch $opcode_$update {

	    BLANK_yes {
	        set contents "$contents\n"
	    }
	    BAR_yes {
	        set w [expr { $scoreboard_width / 10 } ]
		while { $w > 0 } {
		    set contents "$contents========= "
		    incr w -1
		}
		set contents "$contents\n"
	    }
	    LINE_yes {
	        set left   [lindex $instruction 1]
	        set center [lindex $instruction 2]
	        set right  [lindex $instruction 3]

		set left   [unabbreviate $left]
		set center [unabbreviate $center]
		set right  [unabbreviate $right]

		set left_end [string length $left]
		incr left_end -1
		set right_begin \
		    [expr { $scoreboard_width - \
		            [string length $right] }]
		set center_length \
		    [string length $center]
		set center_begin  \
		    [expr { ( $scoreboard_width \
		              - $center_length ) / 2 }]
		set center_end \
		    [expr { $center_begin \
		            + $center_length - 1 }]
		set contents "$contents$left"
		set center_done no
		set right_done no
		if { $left_end < $center_begin \
		     && $center_end < $right_begin } {
		    incr left_end 1
		    incr center_begin -1
		    set contents \
		        "$contents[string \
			              range $space \
				      $left_end \
				      $center_begin]"
		    set contents "$contents$center"
		    set center_done yes
		    set left_end $center_end
		}
		if { $left_end < $right_begin } {
		    incr left_end 1
		    incr right_begin -1
		    set contents \
		        "$contents[string \
			              range $space \
				      $left_end \
				      $right_begin]"
		    set contents "$contents$right"
		    set right_done yes
		}
		if { $center_done == "no" } {
		    incr center_begin -1
		    set contents \
		        "$contents\n[string \
			                range $space \
					0 $center_begin]
		    set contents "$contents$center\n"
		}
		if { $right_done == "no" } {
		    incr right_begin -1
		    set contents \
		        "$contents\n[string \
			                range $space \
					0 $right_begin]
		    set contents "$contents$right\n"
		}
	    }

	    INPUT_yes {
		foreach in_file \
		        [lrange $instruction 1 end] {
		    set in_file \
		        [file join $judging_directory \
			           $in_file]
		    if { [file readable $in_file] } {
			if { [file size $in_file] > 0 \
					} {
			    set c [read_entire_file \
			    		$in_file]
			    set contents "$contents$c"
			}
			break;
		    }
		}
	    }
	    BOARD_yes {
	        set parameters ""
		foreach name \
		        [array names parameters_array] {
		    lappend \
		        [list $name \
			      [set scoreboard_$name]]
		}
		set scoreboard \
		    [exec scoreboard "{ $parameters }" \
				     < $finder_file]

		# If the scoreboard is empty, say so
		# explicitly.
		#
		if { $scoreboard == "" } {
		    set scoreboard \
		        "The scoreboard is currently\
			 EMPTY!  Nothing must have\
			 happened yet."
		}
	        set contents "$contents$scoreboard\n"
	    }
	    SEND_yes {
	    	set send_qualifier \
		    [lindex $instruction 1]
		set send yes
	    }
	    BLANK_no {}
	    BAR_no {}
	    LINE_no {}
	    INPUT_no {}
	    BOARD_no {}
	    SEND_no {}
	    default {
		set name $opcode
		set value [lindex $instruction 1]
	        if { ! [info exists \
		             parameters_array($name)] \
			     } {
		    error "$name is not a parameter\
		           name"
		}

		set value [unabbreviate $value]
		set scoreboard_$name $value
	    }
	}
    }

    if { $update } {
	set ch [open $out_file w]
        puts -nonewline $ch $contents
	close $ch

	if { $send } {
	    foreach to $scoreboard_addresses {
	        if { $send_qualifier != "" \
	             && ! [regexp {<} $to] } {
		    set to "<$to>"
	        }
	        send_message \
	           "To: $send_qualifier$to\n\n$contents"
	    }
    	}
    }
}


# Process command.
#
set log_mode none
switch $command {

    start {
	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { ! [regexp -nocase \
			    {^no process .* exists} \
			    $display] } {
		 puts "Previous makescoreboard still\
		       running:"
		 puts $display
		 exit 0
	     }
	     file delete -force $pid_file
	}
	write_file $pid_file [current_pid]

	set interval $scoreboard_interval

        process_instructions

	while { "yes" } {
	    sleep $interval
	    process_instructions
	}
    }

    status {
	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { ! [regexp -nocase \
			    {^no process .* exists} \
			    $display] } {
		 puts "Makescoreboard running:"
		 puts $display
	     } else {
		 puts "Makescoreboard has died:"
		 puts $display
		 puts ""
		 puts "Run `tracker' to find error\
		       logs, or look in"
		 puts "$log_directory for unchecked\
		       errors."
	     }
	} else {
	    puts "All previous makescoreboards have\
	          been stopped."
	}
    }

    stop {
	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { ! [regexp -nocase \
			    {^no process .* exists} \
			    $display] } {
		 puts "Killing previous makescoreboard:"
		 puts $display
		 set count 0
		 while { "true" } {
		     incr count 1
		     if { $count <= 5 } {
			 catch { signal_process_tree \
				 HUP $pid } out
			 puts $out
		     } elseif { $count <= 10 } {
			 catch { signal_process_tree \
				 KILL $pid } out
			 puts $out
		     } else {
			 puts "ERROR: Giving Up!"
			 exit 1
		     }
		     sleep 1
		     set display \
		         [display_process_tree $pid]
		     if { [regexp \
		               -nocase \
			       {^no process .* exists} \
			       $display] } {
			 break
		     }
		 }
	     }
	     file delete -force $pid_file
	} else {
	    puts "No previous makescoreboard running."
	}
    }

    update {
        process_instructions
    }
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
