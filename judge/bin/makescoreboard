#!/bin/sh
#
# Recomputes the scoreboard every minute.
#
# File:		makescoreboard
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Thu Oct 19 12:20:19 EDT 2006
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2006/10/19 19:46:22 $
#   $RCSfile: makescoreboard,v $
#   $Revision: 1.65 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl

# Set log mode, saving old mode.
#
set log_globally yes
set saved_log_mode $log_mode
set log_mode none

catch {

set document "
makescoreboard { start | status | stop | update } \\
               \[ parameter-filename | \\
	         scoreboard_instructions-value \] ...

    This program makes scoreboards by following the
    instructions stored in the `scoreboard_instructions'
    global variable.  See the hpcm_judging.rc file
    for a description of these instructions.

    When this program starts, it processes its second
    and subsequent arguments as follows.  Any named
    parameter file is `sourced'.  Any argument that
    begins with a `{' is stored (with the `{ }' brackets
    removed) in the `scoreboard_instructions' global
    variable.
    
    This program calls
    
	scorefinder -gotten \\
	    > judging_directory/Scorefinder_Output

    The Scorefinder_Output file is used as input by
    the `scoretable' program to produce a scoreboard
    table (i.e., the `tabular' part of the scoreboard).
    To avoid conflicts between the `start' and `update'
    commands, this program adds a `+' to the end of the
    name Scorefinder_Output when running the update
    command.

    This program ignores signals when computing score-
    boards, and terminates without error on a signal
    while the program is sleeping for an interval.

    If called with an `update' command, this program
    processes the scoreboard instructions just once
    and then exits immediately.

    If called with the `start' command, this program
    executes itself as a subprocess and writes into the
    Scoreboard_PID file in the judging directory the
    process ID of the subprocess.  This subprocess pro-
    cess the scoreboard instructions at periodic inter-
    vals.  But if the Scoreboard_PID file already
    exists, AND the process ID it contains is valid,
    this program prints information about the ID'ed
    process and does nothing else.

    The first time the `start' command processes the
    scoreboard instructions, it does so just like the
    `update' command.  Then this program resumes at
    intervals determined by the `scoreboard_interval'
    global variable.  After every interval, this
    program checks to see if any inputs to the last run
    have been changed, or any outputs have been deleted,
    and if yes, this program reruns the scoreboard in-
    structions.  The inputs checked for change include
    the hpcm_judging.rc file in the judging directory
    and the parameter files listed in the arguments.
    Before checking files for change, the Score_Flag
    flag is checked, and if present, the `scorefinder'
    program is called to remake the Scorefinder_Output
    file.  This is also done if the Scorefinder_Output
    file no longer exists.

    If called with the `stop' command, this program does
    nothing but send kill signals to the process whose
    ID is listed in the Scoreboard_PID file, and then
    deletes that file.  While doing this it outputs in-
    formation about its progress.

    If called with the `status' command, this program
    just outputs information about the status of the
    process whose ID is stored in the Scoreboard_PID
    file.

    With the `update', `status', or `stop' commands this
    program does not log errors but writes them to the
    standard error.  This program does the same with
    `start' command errors that occur during the first
    making of the scoreboard.  But after beginning
    reruns for the `start' command, this program logs
    errors in a global log directory."

# } to balance extra left bracket in documentation.

# Print documentation if illegal (or -doc) first
# argument.
#
set command [lindex $argv 0]
if { ! [regexp {^(update|start|status|stop|-start-)$} \
               $command] } {
    puts $document
    exit 1
}

# Constant equal to 256 spaces.
#
set space "        "
set space "$space$space"
set space "$space$space"
set space "$space$space"
set space "$space$space"
set space "$space$space"

# Compute file names.
#
set finder_file \
    $judging_directory/Scorefinder_Output
if { $command == "update" } {
    set finder_file $finder_file+
}
set pid_file \
    $judging_directory/Scoreboard_PID

# Mtime list for parameter files.  This is a list of
# items each of the format:
#
#	{ file-mtime file-name }
#
# The file-mtime can be a `clock seconds' value, or
# `none' if the file did not exist, or `out' if the
# file was output.
#
# The mtime list has the special value `changed'
# to force the assumption that files have changed.
#
set makescoreboard_mtime_list changed

# Last time the scoreboard update was started.
#
set makescoreboard_last_time ""

# Earliest time in an OUTPUT instruction that is after
# makescoreboard_last_time.  Or "" if none.
#
set makescoreboard_future_time ""

# `yes' to force update of output files, `no' not to.
#
set makescoreboard_force yes

# Return `yes' if any existing file has an mtime that
# is larger than makescoreboard_last_time, and set
# makescoreboard_force `yes' in this case.
#
# If makescoreboard_mtime_list has the special value
# `changed', this function always returns `yes', and
# set makescoreboard_force `yes' in this case.
#
# If makescoreboard_force is `yes', this funciton
# returns `yes'.
#
# Otherwise, return `yes' if a file in the makescore-
# board_mtime_list has changed.  A file changes if it
# appears or disappears or now has a larger mtime than
# that recorded for the file in makescoreboard_mtime_
# list.
#	
proc update_required { } {

    global makescoreboard_mtime_list \
           makescoreboard_last_time \
	   makescoreboard_force

    if { $makescoreboard_mtime_list == "changed" } {
	set makescoreboard_force yes
        return yes
    } elseif { $makescoreboard_force } {
        return yes
    }

    set result no
    foreach item $makescoreboard_mtime_list {
        set mtime [lindex $item 0]
        set name  [lindex $item 1]

        if { $mtime == "none" } {
            if { [file exists $name] } {
	       set result yes;
	    }
        } elseif { $mtime == "out" } {
            if { ! [file exists $name] } {
	        set result yes;
	    }
        } else {
            if { ! [file exists $name] } {
	        set result yes;
	    } elseif { [file mtime $name] > $mtime } {
	        set result yes;
	    } elseif {   $makescoreboard_last_time \
	                < $mtime } {
		set makescoreboard_force yes
		set result yes
	    } 
        }
    }
    return $result
}

# Execute makescoreboard -update- to update the score-
# board and set makescoreboard_mtime_list, makescore-
# board_last_time, and makescoreboard_future_time.
#
proc update_scoreboard { } {

    global makescoreboard_mtime_list \
           makescoreboard_last_time \
           makescoreboard_future_time \
           makescoreboard_force

    set last_time [clock seconds]

    # If we have no reason to rerun scoreboard instruc-
    # tions, return.
    #
    if {    [update_required] == "no" \
         && ! [test_flag Score_Flag] } {
	 && ( $makescoreboard_future_time == "" \
	      ||   $last_time \
	         < $makescoreboard_future_time ) } {

        return
    }

    set pfile $judging_directory/hpcm_judging.rc
    set mtime [file mtime $pfile]
    set mtime_list [list [list $mtime $pfile]]

    set list =\
	[eval exec makescoreboard -update- \
		   [list $last_time \
		         $makescoreboard_force] \
		   [lrange $argv 1 end]]

    set makescoreboard_mtime_list [lindex $list 1]
    set makescoreboard_last_time $last_time
    set makescoreboard_future_time [lindex $list 0]
}

# Process command.
#
switch -- $command {

    start {

	# Check pid_file and delete it if its process
	# is no longer running.
	# 
	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { [process_found $display] } {
		 puts "Previous makescoreboard still\
		       running:"
		 puts $display
		 exit 0
	     }
	     file delete -force $pid_file
	}

	# Run makescoreboard as a subprocess.
	#
        set pid [eval exec makescoreboard -start- \
	              [lrange $argv 1 end] &]

	# Wait for any output from first run.
	#
	set count 0
	while { ! [file exists $pid_file] } {
	    sleep 1
	    incr count
	    set display [display_process_tree $pid]
	    if { ! [process_found $display] } {
		error "makescoreboard -start- process\
		       died"
	    } elseif { $count > 60 } {
	        error "makescoreboard -start- did not\
		       write $pid_file in a timely\
		       manner"
	    }
	}
    }

    -start- {

	# Save interval before updating scoreboard.
	#
	set interval $scoreboard_interval

	# Update scoreboard for the first time.
	#
	set makescoreboard_force yes
	update_scoreboard

	# Set pid file.
	#
	write_file $pid_file [current_pid]

	# Resume a periodic intervals.
	#
	while { "yes" } {
	    sleep $interval
	    set c 0

	    # Run up to 4 times ignoring errors.
	    # Then if there are 4 erroneous runs, try
	    # a run in which errors stop the program.
	    #
	    # We do this because changes to files during
	    # a run may cause spurious errors.
	    #
	    set makescoreboard_force no
	    while { "yes" } {
	        incr c
		if { $c < 5 } {
		    if { ! [catch {
		              update_scoreboard
			      }] \
			          } break
		    sleep 10
		    set makescoreboard_force yes
		} else {
		    update_scoreboard
		}
	    }
	}
    }

    status {

	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { [process_found $display] } {
		 puts "Makescoreboard running:"
		 puts $display
	     } else {
		 puts "Makescoreboard has died:"
		 puts $display
		 puts ""
		 puts "Run `tracker' to find error\
		       logs, or look in"
		 puts "$judging_directory/log for\
		       unchecked errors."
	     }
	} else {
	    puts "All previous makescoreboards have\
	          been stopped."
	}
    }

    stop {
	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { [process_found $display] } {
		 puts "Killing previous makescoreboard:"
		 puts $display

		 # Try to kill up to 30 times, checking
		 # after each attempt for death.  The
		 # first 20 times are with HUP, the next
		 # 10 times are with KILL.
		 #
		 set count 0
		 while { "true" } {
		     incr count 1
		     if { $count <= 20 } {
			 catch { signal_process_tree \
				 HUP $pid } out
			 puts $out
		     } elseif { $count <= 30 } {
			 catch { signal_process_tree \
				 KILL $pid } out
			 puts $out
		     } else {
			 puts "ERROR: Giving Up!"
			 exit 1
		     }
		     sleep 1
		     set display \
		         [display_process_tree $pid]
	             if { ! [process_found $display] } {
			 break
		     }
		 }
	     }
	     file delete -force $pid_file
	} else {
	    puts "No previous makescoreboard running."
	}
    }

    update {
    }

    -update- {
    
	set makescoreboard_last_time [lindex $argv 0]
	set makescoreboard_force [lindex $argv 1]
	set argv [lrange $argv 2 end]

	# Restore log mode and disable standard output
	# and error.
	#
	set log_mode $saved_log_mode
	disable_outputs

    }

    default {
    	error "Bad command: $command"
    }

}

set makescoreboard_mtime_list {}
set makescoreboard_future_time ""

    # Recompute $finder_file.
    #
    make_signals_ignored
    clear_flag Score_Flag
    file delete -force -- $finder_file
    exec scorefinder -gotten > $finder_file
    make_signals_default

    # Process all the arguments, sourcing files as
    # necessary.
    #
    foreach arg [lrange $argv 1 end] {
	set LB "{"
	# "}" to balance left bracket in last line so
	# TCL will read this procedure code properly.
	#
	if { [regexp "^${LB}" $arg] } {
	    if { [catch { set scoreboard_instructions \
	                      [lindex $arg 0]
			  llength \
			      $scoreboard_instructions \
			}] } {
	        error "scoreboard instructions\
		       argument is not a TCL list:\
		       $arg"
	    }
	} else {
	    set makescoreboard_arg $arg
	    source $arg
	    set arg $makescoreboard_arg
	    set mtime [file mtime $arg]
	    lappend makescoreboard_mtime_list \
	            [list $mtime $arg]
	}
    }

# Given a value that may be an abbreviation defined
# in the abbreviation_array, return the value it
# abbreviates, or return the original value if it is not
# an abbreviation.
#
proc unabbreviate { value } {

    global abbreviation_array

    if { [info exists abbreviation_array($value)] } {
        return $abbreviation_array($value)
    } elseif {    [regexp {^(.*)([+-][0-9]+)$} $value \
    		          forget abbrev inc] \
	       && [info exists \
	                abbreviation_array($abbrev)] \
	       && ! [catch {
	       		set date \
			    $abbreviation_array($abbrev)
			set time \
			    [clock scan $date]
			   }] } {
	incr time $inc
	return [clock format $time]
    } else {
        return $value
    }
}

# Process parameter setting instruction.
#
proc set_parameter { instruction } {

    global makescoreboard_parameters

    set name  [lindex $instruction 0]
    set value [lindex $instruction 1]
    set value [unabbreviate $value]
    global scoreboard_$name

    if { [array exists scoreboard_$name] } {
	array set scoreboard_$name $value
    } elseif { [info exists scoreboard_$name] } {
	set scoreboard_$name $value
    } else {
	error "$name is not a parameter name"
    }

}

# Data for processing scoreboard instructions.

# Last time scoreboard instructions were executed, or ""
# in order to force execution of scoreboard instruc-
# tions.
#
set last_time ""


    # Use a single `run time' in computations.
    #
    set time [clock seconds]

    # Reinstall initial parameter values.
    #
    process_arguments
    set parameter_mtime $makescoreboard_parameter_mtime

    # Save abbreviations.  If possible, replace relative
    # stop and freeze times by normally formatted times
    # so if they appear in LINE's they will look OK.
    #
    set start_time $scoreboard_start_time
    set abbreviation_array(START) $start_time

    if { ! [regexp {^(|problem|team)$} $start_time] } {
        if { [catch { set st [clock scan $start_time] \
	            }] } {
	    error "badly formatted \
	           scoreboard_start_time: $start_time"
	}
    } else {
        set st ""
    }

    set stop_time $scoreboard_stop_time
    if {    [regexp {^(|\+)[0-9]+$} $stop_time] \
         && $st != "" } {
        set stop_time \
	    [clock format [expr { $st + $stop_time }]]
    }
    set abbreviation_array(STOP) $stop_time

    set freeze_time $scoreboard_freeze_time
    if {    [regexp {^(|\+)[0-9]+$} $freeze_time] \
         && $st != "" } {
        set freeze_time \
	    [clock format [expr { $st + $freeze_time }]]
    }
    set abbreviation_array(FREEZE) $freeze_time

    set abbreviation_array(NAME)   \
        $scoreboard_name
    set abbreviation_array(TIME)   \
        [clock format $time]

    # Ignore signals while processing instructions.
    #
    make_signals_ignored


    # Accumulate new earliest_future_time value in eft.
    #
    set eft ""

    # Process if statements.
    #
    set instructions {}
    parse_block $scoreboard_instructions instructions \
    	        [info globals scoreboard_*]

    # Loop to process instructions for first pass.
    #
    # Pass2 is called for every sequence of instructions
    # beginning with an OUTPUT instruction and ending
    # with the instruction before the next OUTPUT in-
    # struction or end of all instructions.

    set pc 0
    set end_pc [llength $instructions]
    set output_found no
    set board_found no

    while { "yes" } {

        set instruction [lindex $instructions $pc]
	incr pc

	if { [catch { llength $instruction }] } {
	    error "a scoreboard_instructions'\
	           instruction is not a TCL list:\
		   $instruction"
	    
	}
	set opcode [lindex $instruction 0]

	# If we are at the end of a sequence of
	# instructions that begins with an OUTPUT
	# instruction and ends just before the next
	# OUTPUT instruction or end of all instructions,
	# process OUTPUT instruction time parameters
	# and call pass2.
	#
        if { ( $pc > $end_pc || $opcode == "OUTPUT" ) \
	     && $output_found } {

	    # If we are before OUTPUT start time, do
	    # NOT update.
	    #
	    if { $out_start != "" \
	         && $time < $out_start } {
	        set update no
	    }

	    # If output file exists and has an mtime >=
	    # the OUTPUT stop time, do NOT update.
	    #
	    if {    $out_mtime != "" \
	         && $out_stop != "" \
	         && $out_mtime >= $out_stop } {
	        set update no
	    }

	    # Perform second pass.
	    #
	    pass2 $instructions \
	          $out_pc [expr $pc -1] $update

	    # Add updated output file to makescoreboard_
	    # mtime_list.
	    #
	    if { $update } {
		lappend makescoreboard_mtime_list \
		        [list out $out_file]
	    }
	}

	if { $pc > $end_pc } break

	# Perform first pass on instruction.
	#
	switch ${output_found}_$opcode {

	    no_OUTPUT -
	    yes_OUTPUT {

	        # Compute output file.
		#
		set out_file  [lindex $instruction 1]
		set out_file \
		   [file join $judging_directory \
		              $out_file]

		# Compute start and stop times and
		# update eft.
		#
		set out_start [lindex $instruction 2]
		set out_start [unabbreviate $out_start]
		if { $out_start != "" } {
		    set out_start \
		        [clock scan $out_start]
		    if { $out_start > $time \
		         && (    $eft == "" \
			      || $eft > $out_start ) } {
		        set eft $out_start
		    }
		}
		set out_stop  [lindex $instruction 3]
		set out_stop [unabbreviate $out_stop]
		if { $out_stop != "" } {
		    set out_stop \
		        [clock scan $out_stop]
		    if { $out_stop > $time \
		         && (    $eft == "" \
			      || $eft > $out_stop ) } {
		        set eft $out_stop
		    }
		}

		# Set out_mtime to the output file mtime
		# or "" if no output file exist, and set
		# `update' to no if the output file
		# exists and yes otherwise.
		#
		if { [file exists $out_file] } {
		    set update no
		    set out_mtime [file mtime $out_file]
		} else {
		    set update yes
		    set out_mtime ""
		}

	        # If scoreboard_instructions might have
		# changed force update.
		#
	    	if { $makescoreboard_force } {
		}

		# Set output variables.
		#
	        set out_pc $pc
		incr out_pc -1
		set output_found yes
	    }

	    yes_SEND {}
	    yes_GRANT_ACCESS {}

	    yes_BLANK {}

	    yes_BAR {}
	    yes_LINE {}

	    yes_INPUT {

	        # Loop through input files until an
		# existing one is found.
		#
		foreach in_file \
		        [lrange $instruction 1 end] {

		    set in_file \
		        [file join $judging_directory \
			           $in_file]

		    # Add input file to makescoreboard_
		    # mtime_list.
		    #
		    if { [file exists $in_file] } {
			set mtime [file mtime $in_file]

			# If existing input file is
			# later than output file, force
			# update.
			#
			if {    $out_mtime != "" \
			     && $mtime > $out_mtime } {
			    set update yes
			}

			lappend \
			    makescoreboard_mtime_list \
			    [list $mtime $in_file]
			break;
		    } else {
			lappend \
			    makescoreboard_mtime_list \
			    [list none $in_file]
		    }
		}
	    }

	    yes_BOARD {

		# Process finder_file mtime stored in
		# finder_mtime above.
		#
		if {    $out_mtime != "" \
		     && $finder_mtime > $out_mtime } {
		    set update yes
		}

		if { $board_found == "no" } {
		    set board_found yes
		    lappend makescoreboard_mtime_list \
			    [list $finder_mtime \
				  $finder_file]
		}
	    }

	    no_SEND -
	    no_GRANT_ACCESS -
	    no_BLANK -
	    no_BAR -
	    no_LINE -
	    no_INPUT -
	    no_BOARD {
	        error "`$instruction' appears before\
		       OUTPUT instruction"
	    }

	    default {

	        # Parameter setting instructions are
		# executed in the first pass only if
		# they are before all OUTPUT instruc-
		# tions.  Otherwise they are executed
		# in pass2.
		#
	        if { $output_found == "no" } {
		    set_parameter $instruction
		}
	    }
	}
    }

    # End of instruction processing loop.  Store record
    # of just finished actions and reenable interrupts.
    #
    set makescoreboard_future_time $eft
    make_signals_default

# Execute scoreboard instructions during second pass.
# Instruction at pc is an OUTPUT instruction, and
# instruction at endpc is the next OUTPUT instruction
# or is just beyond the end of all instructions.
#
proc pass2 { instructions pc end_pc update } {

    global makescoreboard_parameters \
           judging_directory finder_file space \
	   errorInfo errorCode
    make_scoreboard_parameters_global

    # Compute output file and step past OUTPUT instruc-
    # tion.
    #
    set instruction [lindex $instructions $pc]
    set out_file [lindex $instruction 1]
    if { $out_file == "" } {
        error "Bad OUTPUT instruction: $instruction"
    }
    set out_file \
        [file join $judging_directory $out_file]
    incr pc

    # Compute output file in `contents' variable.
    #
    set contents ""
    set send no
    set grant_access no

    # Compute BAR.
    #
    set bar ""
    set solid_bar =====
    set w [expr { $scoreboard_width / 5 } ]
    while { $w > 0 } {
	set bar "$bar== =="
	set solid_bar $solid_bar=====
	incr w -1
    }

    # Loop through remaining instructions.
    #
    while { $pc < $end_pc } {

	# Compute instruction and opcode and update pc.
	#
	set instruction [lindex $instructions $pc]
	incr pc
	set opcode [lindex $instruction 0]

	switch ${opcode}_$update {

	    SEND_yes {

	        # Compute send_addresses and send_name
		# for use when output done.
		#
		set name [lindex $instruction 1]
		if { $name == "" } {
		    set name addresses
		}
		set send_name scoreboard_$name
		if { ! [info exists $send_name] } {
		   set send_addresses ""
		} else {
		   set send_addresses [set $send_name]
		}

		# Set switch to indicate SEND happened.
		#
		set send yes
	    }

	    GRANT_ACCESS_yes {
		set grant_access yes
	    }

	    BLANK_yes {
		set contents "$contents\n"
	    }

	    BAR_yes {
	        set text [lindex $instruction 1]
		if { $text == "" } {
		    set contents "$contents$bar\n"
		} else {
		    set text [unabbreviate $text]
		    set sw $scoreboard_width
		    set len [string length $text]
		    incr len 2
		    if { $len + 4 > $sw} {
		        error "scoreboard_width not\
			       wide enough for\
			       `$instruction'"
		    }
		    set left \
		        [expr { ( $sw - $len ) / 2 }]
		    set right \
		        [expr { $sw - $len - $left }]
		    incr left -1
		    incr right -1
		    set left \
		        [string range $solid_bar \
			        0 $left]
		    set right \
		        [string range $solid_bar \
			        0 $right]
		    set contents \
		        "$contents$left $text $right\n"
		}
	    }

	    LINE_yes {

		# Make sure `space is long enough'.
		#
		if { $scoreboard_width > 256 } {
		    error "scoreboard width > 256"
		}

		# Compute left, center, and right
		# text.
		#
		set left   [lindex $instruction 1]
		set center [lindex $instruction 2]
		set right  [lindex $instruction 3]

		set left   [unabbreviate $left]
		set center [unabbreviate $center]
		set right  [unabbreviate $right]

		# Compute columns of beginning and/or
		# end for each of the three texts.
		# Columns are numbered 0, 1, ...
		#
		set left_end [string length $left]
		incr left_end -1
		set right_begin \
		    [expr { $scoreboard_width - \
			    [string length $right] }]
		set center_length \
		    [string length $center]
		set center_begin  \
		    [expr { ( $scoreboard_width \
			      - $center_length + 1 ) \
			    / 2 }]
		set center_end \
		    [expr { $center_begin \
			    + $center_length - 1 }]

		# Make sure texts are short enough so
		# that their ends are within limits.
		#
		if { $left_end >= $scoreboard_width } {
		    error "LINE left text too wide:\
		           $left"
		} elseif { $right_begin < 0 } {
		    error "LINE right text too wide:\
		           $right"
		} elseif {    $center_begin < 0 \
		           || $center_end \
			      >= $scoreboard_width } {
		    error "LINE center text too wide:\
		           $center"
		}

		# Compute line.  Start with left text.
		#
		set line $left

		set center_done no
		set right_done  no

		# If center is non-empty and has a 2
		# space gap between it and any other
		# non-empty text, add the center to the
		# line.
		#
		if {    $center != "" \
		     && ( $left == "" \
		          || $left_end + 2 \
			     < $center_begin ) \
		     && ( $right == "" \
		          || $center_end + 2 \
			     < $right_begin ) } {
		    incr left_end 1
		    incr center_begin -1
		    set line \
			"$line[string \
				  range $space \
				  $left_end \
				  $center_begin]"
		    set line "$line$center"
		    set center_done yes
		    set left_end $center_end
		}

		# If right text is non-empty and has a 2
		# space gap with the part of the line
		# to its left, add it to line.
		#
		if {    $right != ""
		     && ( $left_end == -1 \
		          || $left_end + 2 \
			     < $right_begin ) } {
		    incr left_end 1
		    incr right_begin -1
		    set line \
			"$line[string \
				  range $space \
				  $left_end \
				  $right_begin]"
		    set line "$line$right"
		    set right_done yes
		}

		# If center text did not get added to
		# first line, put it on a line by it-
		# self.
		#
		if { $center != "" && \
		     $center_done == "no" } {
		    incr center_begin -1
		    set line \
			"$line\n[string \
				    range $space \
				    0 $center_begin]"
		    set line "$line$center"
		}

		# If right text did not get added to
		# first line, put it on a line by it-
		# self.
		#
		if { $right != "" \
		     && $right_done == "no" } {
		    incr right_begin -1
		    set line \
			"$line\n[string \
				    range $space \
				    0 $right_begin]"
		    set line "$line$right"
		}

		# Add line(s) to contents of output.
		#
		set contents "$contents$line\n"
	    }

	    INPUT_yes {

	        # Loop through input files.
		#
		foreach in_file \
		        [lrange $instruction 1 end] {

		    set in_file \
		        [file join $judging_directory \
			           $in_file]

		    # Add first existing input file to
		    # the output contents.
		    #
		    if { [file exists $in_file] } {
			if { [file size $in_file] > 0 \
					} {
			    set c [read_entire_file \
			    		$in_file]
			    set contents "$contents$c\n"
			}
			break;
		    }
		}
	    }

	    BOARD_yes {

	        # Compute parameters to be passed to
		# the scoreboard program.
		#
	        set parameters ""
		foreach name \
		        [array names \
		           makescoreboard_parameters] {
		    lappend parameters \
		        [list $name \
			      [set scoreboard_$name]]
		}

		# Call the scoreboard program to compute
		# the board table.
		#
		set scoretable \
		    [exec scoretable "{ $parameters }" \
				     < $finder_file]

		# If the scoreboard table is empty, say
		# so explicitly.
		#
		if { $scoretable == "" } {
		    set scoretable \
		        "The scoreboard is currently\
			 EMPTY!  Nothing must have\
			 happened yet."
		}

		# Add the scoreboard table to the output
		# file contents.
		#
	        set contents "$contents$scoretable\n"
	    }

	    SEND_no -
	    GRANT_ACCESS_no -
	    BLANK_no -
	    BAR_no -
	    LINE_no -
	    INPUT_no -
	    BOARD_no {

		# If update is `no' most instructions do
		# nothing.
		#
	    }

	    default {
	        # Execute parameter setting instruction
		# regardless of update value.
		#
		set_parameter $instruction
	    }
	}
    }

    if { $update } {

	# Write output file.  If error, delete file and
	# hpcm_sendmail the judge.
	#
	# pass2_sent_error($out_file) is set if an error
	# for $out_file has been hpcm_sendmail'ed to the
	# judge since the last successful processing of
	# $out_file.
	#
	global pass2_sent_error
	if { [catch {

		set error_data "\nWriting $out_file\n"
		set ch [open $out_file w]
		puts -nonewline $ch $contents
		close $ch
		if { $grant_access } {
		    grant_access $out_file
		}

		# Send email.
		#
		if { $send } {
		    foreach to $send_addresses {
			set to [string trim $to]
		        if { [regexp {^!} $to] } {
			    set m {^!([^<]*)<([^>]*)>$}
			    if { ! [regexp $m $to \
			                   forget \
					   zzz \
					   account] } {
				error "Badly formatted\
				       address in\
				       $send_name: $to"
			    }
			    set f $judging_directory
			    set f $f/${zzz}_identity
			    set error_data \
				"\nError was during\
				 ssh_copy_message\
				 $f $account ...\n"
			    ssh_copy_message \
			        $f $account $contents
			} else {
			    set error_data \
				"\nError was during\
				 send_message\
				 \"To: $to..\"\n"
			    send_message \
			       "To: $to\n\n$contents"
			}
		    }
		}
		catch {
		    unset pass2_sent_error($out_file)
		}
	    } error_message] } {

	    # On error, delete output file and rethrow
	    # the error.  When we are rerun, the output
	    # file will be recomputed and remailed.
	    #
	    if { [file isfile $out_file] } {

		# Its possible if instructions are
		# miswritten to have out_file name a
		# directory.

		file delete -force -- $out_file
	    }
	    if { ! [info exists \
	                 pass2_sent_error($out_file)] \
			 	} {
	        set message \
		    "Subject: makescoreboard error\
		     outputting $out_file\n"
		set message "$message\nNOTE:\
		             the file $out_file has\
			     been DELETED!\n"
		set message "$message$error_data"
		set message \
		    "$message\n$error_message\n"
		set message \
		    "$message\nerrorCode:\n$errorCode\n"
		set message \
		    "$message\nerrorInfo:\n$errorInfo\n"
	        exec hpcm_sendmail << $message
		set pass2_sent_error($out_file) 1
	    }
	}
    }
}

if { $command == "-update-" } {
    puts [list $makescoreboard_future_time \
               $makescoreboard_mtime_list]
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
