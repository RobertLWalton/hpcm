#!/bin/sh -f
#
# Returns files to requester by email.
#
# File:		autoinfo
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Aug 30 16:00:36 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/30 20:19:34 $
#   $RCSfile: autoinfo,v $
#   $Revision: 1.10 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"
catch {

set document "
cd submission_directory; autoinfo

    Reads the `$received_file' file in the current
    directory.  Thus file must contain a single email
    message with a subject line of the form:

    	Subject: get name ...

    The body of the message must be empty.

    The names are taken relative to the info directory,
    and may either files or directories.  A directory
    name is replaced by the names of all readable files
    and subdirectories in the given directory, recur-
    sively.  The result of this is a list of file names.

    File names that begin with `.' or `-' or that
    contain a `.' right after a `/' are considered
    illegal.
    
    If all names are legal and all the named files are
    readable, all the named files are mailed back to the
    requester.  In this case the list of file names is
    printed to the standard output, and nothing else is
    printed.

    Otherwise, if any listed name is illegal or the file
    named is not readable or if the requesting email has
    even the slightest formatting error, this program
    mails a reply back to the requester giving the
    reasons why the requesting email is invalid.  In
    this case this program exits with exit code 0,
    indicating no error, but does not write anything to
    the standard output, indicating no file was sent.

    If something goes very wrong, such as finding that
    the `$received_file' file is not readable, this
    program creates an error log file in the current
    directory, does not print anything on the standard
    output (but does print on the error output), and
    exits with exit code 0."

if { $argc != 0 } {
    puts $document
    exit 1
}

# Create a reply file complaining of a request error,
# and email this reply to the requestor.  Include the
# request email in the reply.
#
proc info_error_reply { args } {
    eval reply -all \
         {"ERROR while reading requesting email:"} \
	 $args \
	 {""} \
	 {"THIS REQUEST (see below) IGNORED"} \
	 {"YOU MUST RESUBMIT"}

    exit 0
}

# Find the subject.  If bad subject call error.
#
set received_ch [open $received_file r]
read_header $received_ch
switch [llength $message_subject] {

    0		{
	error "No `Subject:' field in message"
    }

    1		{
	error "Too short `Subject:' field in message:\n\
	      \   Subject:$message_subject"
    }

    default	{
	if { [lindex $message_subject 0] != "get" } {
	    error "Bad `Subject:' field in message:\n\
		  \   Subject:$message_subject"
	}
    }
}

# If non-empty body reply with error.
#
if { [blank_body $received_ch] == "no" } {
     info_error_reply "Non-blank body in message"
}
close $received_ch

# Compute list of readable file names, list of unread-
# able file names, and list of illegal file names.
#
set names ""
set unreadables ""
set illegals ""
#
proc info_expand { name } {

    global names unreadables illegals info_directory

    set file "$info_directory/$name"

    if { [regexp {^\.|^\-|\/\.} $name] } {
    	lappend illegals $name
    } elseif { [file isdirectory $file] } {
        foreach f [lsort [glob -nocomplain $file/*]] {
	    if { [file readable $f] } {
	        info_expand "$name/[file tail $f]"
	    }
	}
    } elseif { [file readable $file] } {
        lappend names $name
    } else {
        lappend unreadables $name
    }
}

foreach n [lreplace $message_subject 0 0] {
    info_expand $n
}

set error_lines ""

if { $illegals != "" } {
    lappend error_lines \
	    "Some requested file names are illegal:"
    lappend error_lines \
	    "    $illegals"
} 
if { $unreadables != "" } {
    lappend error_lines \
	    "Some requested file names are unreadable:"
    lappend error_lines \
	    "    $unreadables"
} 

if { $error_lines != "" } {
    eval info_error_reply $error_lines
}

compose_reply "The requested files appear below\
               following the request message header."

set reply_ch [open "${reply_file}+" a]

puts $reply_ch ""

set dashes "------------------------------"

foreach n $names {
    puts $reply_ch "$dashes $n:"
    put_file "$info_directory/$n" $reply_ch
}
puts $reply_ch "$dashes end of files"

close $reply_ch

send_reply

puts $names
exit 0

# Include common error catching code:
#
} caught_output
caught_error
