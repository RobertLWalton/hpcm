#!/bin/sh -f
#
# Returns files to requester by email.
#
# File:		autoinfo
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Tue Aug 22 06:34:38 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/22 10:28:29 $
#   $RCSfile: autoinfo,v $
#   $Revision: 1.4 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"
catch {

set document "
cd submission_directory; autoinfo

    Reads the `$received_file' file in the current
    directory.  Thus file must have a subject line of
    the form:

    	Subject: get name ...

    The body of the mail file must be empty.

    The names are taken relative to the info_directory,
    and may either files or directories.  A directory
    name is replaced by the names of all readable files
    and subdirectories in the given directory, recur-
    sively.  The result of this is a list of file names.
    
    If all the named files are readable, they are mailed
    mailed back to the requester.  In this case the
    list of file names is printed to the standard
    output, and nothing else is printed.

    Otherwise, if any listed file is not readable or if
    the requesting email has even the slightest format-
    ting error, this program constructs a `$reply_file'
    file giving reasons why the requesting email is
    invalid.  This `$reply_file' is sent to the email
    address that is part of the current directory name.
    In this case this program exits with error code 0,
    indicating no error, but does not write anything to
    the standard output, indicating no file was sent.
    
    This program exits with non-zero error code only if
    something is very wrong, e.g. the `$received_file'
    file is not readable or the `$reply_file' file is
    not writable."

if { $argc != 0 } {
    puts $document
    exit 1
}

# Create a reply file complaining of a request error,
# and email this reply to the requestor.  Include the
# request email in the reply.
#
proc info_error_reply { args } {
    eval reply -all \
         {"ERROR while reading requesting email:"} \
	 $args \
	 {""} \
	 {"THIS REQUEST (see below) IGNORED"} \
	 {"YOU MUST RESUBMIT"}

    exit 0
}

if { [catch { set subject [find_subject -nobody] } \
            catch_out] } {
    info_error_reply catch_out
}

if { [llength $subject] < 1 \
     || [lindex $subject 0] != "get" } {
     info_error_replay "Badly formatted subject line"
}

# Compute list of readable file names, list of unread-
# able file names, and list of illegal file names.
#
set names ""
set unreadables ""
set illegals ""
#
proc info_expand { name } {

    global names unreadables illegals info_directory

    set file "$info_directory/$name"

    if { [regexp {^\.|\/\.} $name] } {
    	lappend illegals $name
    } elseif { [file isdirectory $file] } {
        foreach f [lsort [glob $file/*]] {
	    if { [file readable $f] } {
	        info_expand "$name/[file tail $f]"
	    }
	}
    } elseif { [file readable $file] } {
        lappend names $name
    } else {
        lappend unreadables $name
    }
}

foreach n [lreplace $subject 0 0] {
    info_expand $n
}

set error_lines ""

if { $illegals != "" } {
    lappend error_lines \
	    "Some requested file names are illegal:"
    lappend error_lines \
	    "    $illegals"
} 
if { $unreadables != "" } {
    lappend error_lines \
	    "Some requested file names are unreadable:"
    lappend error_lines \
	    "    $unreadables"
} 

if { $error_lines != "" } {
    eval info_error_reply $error_lines
}

compose_reply "The requested files appear below\
               following request message header."

set reply_ch [open "${reply_file}+" a]

puts $reply_ch ""

set whosh "****----****----"
set hsohw "----****----****"

foreach n $names {
    puts $reply_ch "$whosh ${n} $hsohw"
    put_file "$info_directory/$n" $reply_ch
}
puts $reply_ch "$whosh end $hsohw"

close $reply_ch

send_reply

puts $names
exit 0

# Include common error catching code:
#
} caught_output
caught_error
