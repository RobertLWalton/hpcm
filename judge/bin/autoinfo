#!/bin/sh -f
#
# Returns files to requester by email.
#
# File:		autoinfo
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Aug 28 16:32:51 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/28 20:52:35 $
#   $RCSfile: autoinfo,v $
#   $Revision: 1.8 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"
catch {

set document "
cd submission_directory; autoinfo

    Reads the `$received_file' file in the current
    directory.  Thus file must have a subject line of
    the form:

    	Subject: get name ...

    The body of the mail file must be empty.

    The names are taken relative to the info directory,
    and may either files or directories.  A directory
    name is replaced by the names of all readable files
    and subdirectories in the given directory, recur-
    sively.  The result of this is a list of file names.

    File names that begin with `.' or `-' or that
    contain a `.' right after a `/' are considered
    illegal.
    
    If all the named files are readable, they are mailed
    back to the requester.  In this case the list of
    file names is printed to the standard output, and
    nothing else is printed.

    Otherwise, if any listed file is not readable or if
    the requesting email has even the slightest format-
    ting error, this program constructs a `$reply_file'
    file giving reasons why the requesting email is
    invalid.  This `$reply_file' is sent to the email
    address that is part of the current directory name.
    In this case this program exits with exit code 0,
    indicating no error, but does not write anything to
    the standard output, indicating no file was sent.

    If something goes very wrong, such as finding that
    the `$received_file' file is not readable, this
    program creates an error log file in the current
    directory, does not print anything on the standard
    output (but does print on the error output), and
    exits with exit code 0."

if { $argc != 0 } {
    puts $document
    exit 1
}

# Create a reply file complaining of a request error,
# and email this reply to the requestor.  Include the
# request email in the reply.
#
proc info_error_reply { args } {
    eval reply -all \
         {"ERROR while reading requesting email:"} \
	 $args \
	 {""} \
	 {"THIS REQUEST (see below) IGNORED"} \
	 {"YOU MUST RESUBMIT"}

    exit 0
}

# Find the subject.  If bad subject reply.  If other
# error propagate the error.
#
if { [catch { set subject [find_subject -nobody] } \
            caught_out] } {
    switch -exact -- $errorCode {
	FIND_SUBJECT	{ info_error_reply $catch_out }
	default		{ error $caught_out $errorInfo \
				$errorCode }
    }
}

if { [llength $subject] < 2 \
     || [lindex $subject 0] != "get" } {
     info_error_reply "Badly formatted subject line:" \
	"Subject:$message_subject"
}

# Compute list of readable file names, list of unread-
# able file names, and list of illegal file names.
#
set names ""
set unreadables ""
set illegals ""
#
proc info_expand { name } {

    global names unreadables illegals info_directory

    set file "$info_directory/$name"

    if { [regexp {^\.|^\-|\/\.} $name] } {
    	lappend illegals $name
    } elseif { [file isdirectory $file] } {
        foreach f [lsort [glob -nocomplain $file/*]] {
	    if { [file readable $f] } {
	        info_expand "$name/[file tail $f]"
	    }
	}
    } elseif { [file readable $file] } {
        lappend names $name
    } else {
        lappend unreadables $name
    }
}

foreach n [lreplace $subject 0 0] {
    info_expand $n
}

set error_lines ""

if { $illegals != "" } {
    lappend error_lines \
	    "Some requested file names are illegal:"
    lappend error_lines \
	    "    $illegals"
} 
if { $unreadables != "" } {
    lappend error_lines \
	    "Some requested file names are unreadable:"
    lappend error_lines \
	    "    $unreadables"
} 

if { $error_lines != "" } {
    eval info_error_reply $error_lines
}

compose_reply "The requested files appear below\
               following the request message header."

set reply_ch [open "${reply_file}+" a]

puts $reply_ch ""

set whosh "*****-----*****-----"
set hsohw "-----*****-----*****"

foreach n $names {
    puts $reply_ch "$whosh ${n} $hsohw"
    put_file "$info_directory/$n" $reply_ch
}
puts $reply_ch "$whosh end $hsohw"

close $reply_ch

send_reply

puts $names
exit 0

# Include common error catching code:
#
} caught_output
caught_error
