#!/bin/sh
#
# Returns files to requester by email.
#
# File:		autoinfo
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Oct 25 00:35:34 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/10/25 10:40:03 $
#   $RCSfile: autoinfo,v $
#   $Revision: 1.21 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory; autoinfo

    Reads the `$received_file' file in the current
    directory.  Thus file must contain a single email
    request message with a subject line of the form:

    	Subject: get name ...

    The body of the message must be empty.  Otherwise
    this program sends a reply indicating a bad request
    and exits without error or output.

    Note that whenever this program replies to a message
    whose subject field is of the form `get ...', the
    subject of the reply has the form

	Subject: RE: get ...

    if the reply message contains files gotten, but the
    subject of the reply has the form 

	Subject: Errors In: get ...

    if the reply concerns errors in the request message.
    Files gotten are always returned in a message by
    themselves without any information about errors, and
    error information is always returned in a message
    that does not contain any files gotten, so that mes-
    sages containing files gotten can be selected for
    automatic processing by examining their subject
    fields.

    The names listed in the subject field of the re-
    ceived message are processed recursively to form a
    list of file names, and three other lists: a list of
    illegal names, a list of unreadable names, and a
    list of forbidden names.  The named files are re-
    turned to the user in reply email, and any non-empty
    lists of illegal, unreadable, or forbidden names are
    returned in separate reply email.  With each forbid-
    den name there is an error message explaining why
    the name is forbidden.

    A name is first looked up on the `info_map', an
    array that can map a name.  If `info_map(name)' has
    no value, the name is not mapped.  If instead the
    value of `info_map(name)' has the form of a list
    beginning with the word `FORBIDDEN', then the name
    is put on the forbidden list, and the second element
    of the `info_map(name)' value becomes the error mes-
    sage explaining why the name is forbidden.  Thus for
    a forbidden name the value of `info_map(name)'
    should have the form:

    	{ FORBIDDEN {error_message} }

    In reply mail this will be output in the context:

    	The following file names are for forbidden:
		name: error_message

    If the value of `info_map(name)' exists but does not
    indicate the name is forbidden, the value is taken
    as a list of names that replace the original name.
    Thus if `info_map(giant)' had the value `fee fie fo
    fum', a request for `giant' would be replaced by a
    request for `fee', `fie', `fo', and `fum'.

    After name mapping in this fashion, mapping is
    applied to just the tail component of the name using
    the `info_tail_map'.  Only the tail part of the name
    is mapped by this map.  This map is standardly set
    to map the tails `CVS' and `RCS' to empty lists,
    thus eliminating them.

    If the recursion involved in mapping gets to too
    great a depth, the system error function is called
    and there is no response.

    Next the name is checked for legality.  If the name
    begins with `.' or contains a `.' right after a `/'
    it is considered to be illegal and is consigned to
    the list of illegal names.

    Then the name is checked for readablilty.  If the
    name does not name a readable existing ordinary file
    or directory within the in info directory, after
    symbolic links are followed, the name is consigned
    to the list of unreadable names.

    Next, if relative to the info directory the name
    names a directory D, the name is replaced by the
    names relative to the info directory of the read-
    able components of the directory D (excluding
    as usual components whose names begin with `.').

    At this point the name is known to name an ordinary
    readable file within the info directory, and con-
    tents of this file are returned in the reply mes-
    sage.  If this file contains a line beginning with
    `From ', the line is prefixed with `>' when it is
    copied into the reply mail.

    If something goes very wrong, such as finding that
    the `$received_file' file is not readable, this
    program creates an error log file in the current
    directory, does not print anything on the standard
    output (but does print on the error output), and
    exits with exit code 0.  This is also done if the
    `Subject:' field value in the `$received_file' file
    is not sufficient to cause `autodispatch' to dis-
    patch to this program: or specifically, if the
    field value is not a list of at least 1 items the
    first of which is `get'."

# If there are any arguments, print documentation and
# exit.
#
if { $argc != 0 } {
    puts $document
    exit 1
}

# Find the subject.  If bad subject call error.
#
set received_ch [open $received_file r]
read_header $received_ch
switch [llength $message_subject] {

    0		{
	error "No `Subject:' field in message"
    }

    default	{
	if { [lindex $message_subject 0] != "get" } {
	    error "Bad `Subject:' field in message:\n\
		  \   Subject:$message_subject"
	}
    }
}

# If non-empty body reply with error.
#
if { [blank_body $received_ch] == "no" } {
    reply -all \
          "ERROR while reading requesting email:" \
          "    Non-blank body in message."
	  "" \
	  "THIS REQUEST (see below) IGNORED" \
	  "YOU MUST RESUBMIT" 
    exit 0
}
close $received_ch

# Compute lists of OK file names, unreadable names,
# illegal names, and forbidden names.  The items in
# the forbidden list have the form:
#
#	{name {message}}
#
set ok_names ""
set unreadables ""
set illegals ""
set forbiddens ""
#
proc info_expand { name } {

    global ok_names unreadables illegals forbiddens \
    	   info_directory info_map info_tail_map

    if { [info exists info_map($name)] } {
        set replacement $info_map($name)
	if { [llength $replacement] >= 1 \
	     && [lindex $replacement 0] == "FORBIDDEN" \
	     		} {
	    lappend forbiddens \
	    	[lreplace $replacement 0 0 $name]
	} else {
	    foreach n $replacement {
	    	info_expand $n
	    }
	}

	return
    }

    set tail [file tail $name]

    if { [info exists info_tail_map($tail)] } {
        set replacement $info_tail_map($tail)
	if { [llength $replacement] >= 1 \
	     && [lindex $replacement 0] == "FORBIDDEN" \
	     		} {
	    lappend forbiddens \
	    	[lreplace $replacement 0 0 $name]
	} else {
	    set dir [file dirname $name]
	    if { $dir == "." } {
	    	set prefix ""
	    } else {
	    	set prefix $dir/
	    }
	    foreach tail $replacement {
	    	info_expand $prefix$tail
	    }
	}

	return
    }


    set file $info_directory/$name

    if { [regexp {(^|/)\.} $name] } {
    	lappend illegals $name
    } elseif { ! [file readable $file] } {
        lappend unreadables $name
    } elseif { [file isdirectory $file] } {
	foreach f [lsort [glob -nocomplain \
			       $file/*]] {
	    if { [file readable $f] \
	    	 && ( [file isdirectory $f] \
		      || [file isfile $f] ) } {
		info_expand "$name/[file tail $f]"
	    }
	}
    } elseif { [file isfile $file] } {
        lappend ok_names $name
    } else {
        lappend unreadables $name
    }
}

foreach n [lreplace $message_subject 0 0] {
    info_expand $n
}

set lines ""

if { $forbiddens != "" } {
    lappend lines \
	    "The following file names are forbidden:"
    foreach item $forbiddens {
	lappend lines \
		"    [lindex $item 0]: [lindex $item 1]"
    }
    lappend lines ""
} 
if { $illegals != "" } {
    lappend lines \
	    "Some requested file names are illegal:"
    while { $illegals != "" } {
	lappend lines \
		"    [lrange $illegals 0 2]"
	set illegals [lrange $illegals 3 end]
    }
    lappend lines ""
} 
if { $unreadables != "" } {
    lappend lines \
	    "Some requested file names are unreadable:"
    while { $unreadables != "" } {
	lappend lines \
		"    [lrange $unreadables 0 2]"
	set unreadables [lrange $illegals 3 end]
    }
    lappend lines ""
} 

if { $lines != "" } {
    if { $ok_names == "" } {
	lappend lines \
		"There were no OK file names provided\
		 in the requesting message."
	lappend lines \
		"The subject of the requesting message\
		 should have the form:"
	lappend lines \
		"    Subject: get filename ..."
	eval compose_reply -errors $lines
	send_reply
    } else {
	lappend lines \
		"Requested files will be returned in\
		 a subsequent message."
	eval compose_reply -errors $lines
	send_reply -notfinal
    }
}

if { $ok_names != "" } {

    set lines ""
    lappend lines \
	    "The following requested files appear\
	     below after the request message header:"
    set fs $ok_names
    while { $fs != "" } {
	lappend lines "    [lrange $fs 0 2]"
	set fs [lrange $fs 3 end]
    }
    lappend lines ""

    eval compose_reply $lines

    set reply_ch [open $reply_file+ a]

    puts $reply_ch ""

    set dashes "---<>--<>---<>--<>---<>-----"

    foreach file $ok_names {
	puts $reply_ch "$dashes $file:"
	set file_ch [open $info_directory/$file r]
	while { "yes" } {
	    set line [gets $file_ch]
	    if { [eof $file_ch] } break
	    regsub {^From } $line {>From } line
	    puts $reply_ch $line
	}
	close $file_ch
    }
    puts $reply_ch "$dashes end of files"

    close $reply_ch

    send_reply
}

if { [file exists $gotten_file] } {
    file delete -force $gotten_file
}
set gotten_ch [open $gotten_file w]
puts $gotten_ch "Date: [clock format [clock seconds]]"
foreach file $ok_names {
    puts $gotten_ch "File: $file"
}
close $gotten_ch

puts $ok_names
exit 0

# Include common error catching code:
#
} caught_output
caught_error
