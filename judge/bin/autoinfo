#!/bin/sh
#
# Returns files to requester by email.
#
# File:		autoinfo
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Oct  9 09:42:34 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/10/09 16:06:13 $
#   $RCSfile: autoinfo,v $
#   $Revision: 1.18 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory; autoinfo

    Reads the `$received_file' file in the current
    directory.  Thus file must contain a single email
    message with a subject line of the form:

    	Subject: get name ...

    The body of the message must be empty.

    The names are processed recursively to form a list
    of files, and three other lists: a list of illegal
    names, a list of unreadable names, and a list of
    forbidden names.  The files are returned to the user
    in the reply email, as is any non-empty list of
    illegal, unreadable, or forbidden names.  With each
    forbidden name there is an error message explaining
    why the name is forbidden.  If the recursion gets
    to too great a depth, the system error function is
    called and there is no response.

    A name is first looked up on the `info_map', an
    array that can map a name.  If `info_map(name)'
    does not exist, the name is not mapped.  If instead
    `info_map(nam)' has the form of a list beginning
    with the word `FORBIDDEN', then the name is put on
    the forbidden list, and the second element of the
    list becomes the error message explaining why the
    name is forbidden.  Thus for a forbidden name the
    value of `info_map(name)' should have the form:

    	FORBIDDEN {error_message}

    In reply mail this will be output in the context:

    	The following file names are for forbidden:
		name: error_message

    If the value of `info_map(name)' exists but does not
    indicate the name is forbidden, the value is taken
    as a list of names that replace the original name.
    Thus if `info_map(giant)' had the value `fee fie fo
    fum', a request for `giant' would be replaced by a
    request for `fee', `fie', `fo', and `fum'.

    After name mapping in this fashion, mapping is
    applied to just the tail component of the name using
    the `info_tail_map'.  Only the tail part of the name
    is mapped by this map.  This map is standardly set
    to map the tails `CVS' and `RCS' to empty lists,
    thus eliminating them.

    Next the name is checked for legallity.  If the name
    begins with `.' or contains a `.' right after a `/'
    it is considered to be illegal and is consigned to
    the list of illegal names.

    Then the name is checked for readablilty.  If the
    name does not name a readable existing ordinary file
    or directory within the in info directory, after
    symbolic links are followed, the name is consigned
    to the list of unreadable names.

    Next, if relative to the info directory the name
    names a directory D, the name is replaced by the
    names relative to the info directory of the read-
    able components of the directory D (excluding
    as usual components whose names begin with `.').

    At this point the name is known to name an ordinary
    readable file within the info directory, and con-
    tents of this file are returned in the reply mes-
    sage.  If this file contains a line beginning with
    `From ', the line is prefixed with `>' when it is
    copied into the reply mail.

    If something goes very wrong, such as finding that
    the `$received_file' file is not readable, this
    program creates an error log file in the current
    directory, does not print anything on the standard
    output (but does print on the error output), and
    exits with exit code 0.  This is also done if the
    `Subject:' field value in the `$received_file' file
    is not sufficient to cause `autodispatch' to dis-
    patch to this program: or specifically, if the
    field value is not a list of at least 1 items the
    first of which is `get'."

# If there are any arguments, print documentation and
# exit.
#
if { $argc != 0 } {
    puts $document
    exit 1
}

# Find the subject.  If bad subject call error.
#
set received_ch [open $received_file r]
read_header $received_ch
switch [llength $message_subject] {

    0		{
	error "No `Subject:' field in message"
    }

    default	{
	if { [lindex $message_subject 0] != "get" } {
	    error "Bad `Subject:' field in message:\n\
		  \   Subject:$message_subject"
	}
    }
}

# If non-empty body reply with error.
#
if { [blank_body $received_ch] == "no" } {
    reply -all \
          "ERROR while reading requesting email:" \
          "    Non-blank body in message."
	  "" \
	  "THIS REQUEST (see below) IGNORED" \
	  "YOU MUST RESUBMIT" 
    exit 0
}
close $received_ch

# Compute lists of OK file names, unreadable names,
# illegal names, and forbidden names.  The items in
# the forbidden list have the form:
#
#	{name {message}}
#
set ok_names ""
set unreadables ""
set illegals ""
set forbiddens ""
#
proc info_expand { name } {

    global ok_names unreadables illegals forbiddens \
    	   info_directory info_map info_tail_map

    if { [info exists info_map($name)] } {
        set replacement $info_map($name)
	if { [llength $replacement] >= 1 \
	     && [lindex $replacement 0] == "FORBIDDEN" \
	     		} {
	    lappend forbiddens \
	    	[lreplace $replacement 0 0 $name]
	} else {
	    foreach n $replacement {
	    	info_expand $n
	    }
	}

	return
    }

    set tail [file tail $name]

    if { [info exists info_tail_map($tail)] } {
        set replacement $info_tail_map($tail)
	if { [llength $replacement] >= 1 \
	     && [lindex $replacement 0] == "FORBIDDEN" \
	     		} {
	    lappend forbiddens \
	    	[lreplace $replacement 0 0 $name]
	} else {
	    set dir [file dirname $name]
	    if { $dir == "." } {
	    	set prefix ""
	    } else {
	    	set prefix $dir/
	    }
	    foreach tail $replacement {
	    	info_expand $prefix$tail
	    }
	}

	return
    }


    set file $info_directory/$name

    if { [regexp {(^|/)\.} $name] } {
    	lappend illegals $name
    } elseif { ! [file readable $file] } {
        lappend unreadables $name
    } elseif { [file isdirectory $file] } {
	foreach f [lsort [glob -nocomplain \
			       $file/*]] {
	    if { [file readable $f] \
	    	 && ( [file isdirectory $f] \
		      || [file isfile $f] ) } {
		info_expand "$name/[file tail $f]"
	    }
	}
    } elseif { [file isfile $file] } {
        lappend ok_names $name
    } else {
        lappend unreadables $name
    }
}

foreach n [lreplace $message_subject 0 0] {
    info_expand $n
}

set lines ""

if { $forbiddens != "" } {
    lappend lines \
	    "The following file names are forbidden:"
    foreach item $forbiddens {
	lappend lines \
		"    [lindex $item 0]: [lindex $item 1]"
    }
    lappend lines ""
} 
if { $illegals != "" } {
    lappend lines \
	    "Some requested file names are illegal:"
    while { $illegals != "" } {
	lappend lines \
		"    [lrange $illegals 0 2]"
	set illegals [lrange $illegals 3 end]
    }
    lappend lines ""
} 
if { $unreadables != "" } {
    lappend lines \
	    "Some requested file names are unreadable:"
    while { $unreadables != "" } {
	lappend lines \
		"    [lrange $unreadables 0 2]"
	set unreadables [lrange $illegals 3 end]
    }
    lappend lines ""
} 
if { $ok_names != "" } {
    lappend lines \
	    "The following requested files appear\
	     below after the request message header:"
    set fs $ok_names
    while { $fs != "" } {
	lappend lines "    [lrange $fs 0 2]"
	set fs [lrange $fs 3 end]
    }
    lappend lines ""
} else { 
    lappend lines \
            "There were no OK file names provided\
	     in the requesting message."
    lappend lines \
            "The subject of the requesting message\
	     should have the form:"
    lappend lines \
            "    Subject: get filename ..."
}

eval compose_reply $lines

if { $ok_names != "" } {

    set reply_ch [open $reply_file+ a]

    puts $reply_ch ""

    set dashes "---<>--<>---<>--<>---<>-----"

    foreach file $ok_names {
	puts $reply_ch "$dashes $file:"
	set file_ch [open $info_directory/$file r]
	while { "yes" } {
	    set line [gets $file_ch]
	    if { [eof $file_ch] } break
	    regsub {^From } $line {>From } line
	    puts $reply_ch $line
	}
	close $file_ch
    }
    puts $reply_ch "$dashes end of files"

    close $reply_ch
}

send_reply

if { [file exists $gotten_file] } {
    file delete -force $gotten_file
}
set gotten_ch [open $gotten_file w]
puts $gotten_ch "Date: [clock format [clock seconds]]"
foreach file $ok_names {
    puts $gotten_ch "File: $file"
}
close $gotten_ch

puts $ok_names
exit 0

# Include common error catching code:
#
} caught_output
caught_error
