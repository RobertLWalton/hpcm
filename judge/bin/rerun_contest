#! /bin/sh
#
# Re-run the autojudge on contest data.
#
# File:		rerun_contest
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Mon Jan  1 09:30:49 EST 2007
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2007/01/01 17:40:55 $
#   $RCSfile: rerun_contest,v $
#   $Revision: 1.5 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Include common code and parameters:
#
set log_disable yes
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
rerun_contest \[-force|-norun\] \\
              \[PROBLEM_RE \[SUBMISSION_RE\]\]

    Copies submission Received_Mail files into ./rerun
    subdirectories and runs `autojudge -manual' in these
    directories.  The submissions choosen are those
    whose submission directories contain a substring
    matching the regular expression
    
	\"SUBMISSION_RE.*-submission\$\"

    and whose Received_Mail header contains a subject
    header line with a substring matching the regular
    expression
    
        \"submit.*PROBLEM_RE\"
	
    where the matches are case insensitive and the RE's
    both default to \".\".

    Rerun output may be compared with ./mail results
    using the rerun_diff program.  This program does not
    do anything for a submission whose ./rerun directory
    already exists.  The program rerun_remove can be
    used to remove submission ./rerun directories in
    preparation for redoing them.

    This program may be run in a copy of a judging di-
    rectory and its subdirectories made using `cp -r'
    or `tar cf, tar xf'.

    This program specifically does the following in
    the judging directory:

    (1) Repairs any broken links in the `solutions' sub-
        directory.  If this fails for some link, this
	program stops unless it is given the `-force'
	option.  This program also stops and does
	nothing if it finds a broken link and the
	./contest directory exists, unless the `-force'
	option is given.  This last is a safety measure.

	If used during a normal contest, no `solutions'
	sublinks should be broken, and this step should
	do nothing.

	To repair a link named P, this program selects
	the first of the following directories that
	exist:
		~/hpcm/problem_library
		\$hpcm_directory/problem_library
		
	In the selected directory this program searches
	for the following in order:

		demos/P
		public/P
		private/P

	and uses the first of these that is a directory.

    (2) Creates the `rerun' subdirectory of the judging
        directory if that does not exist.

    (3) Gives a-x permission to the judging directory,
        its parent, and its `rerun' subdirectory, so
	that JAVA will work.

    (4) For each submission subdirectory S in ./mail
        that has a Received_Mail file and matches the
	given RE's and for which the ./rerun/S directory
	does not already exist:

	(4a)	Make the ./rerun/S directory
	(4b)	Copy ./mail/S/Received_Mail to ./rerun/S
	(4c)	Execute `autojudge -manual' in ./rerun/S
		unless the `-norun' option is given.  A
		file named autodispatch.log is created
		just as the autodisptach program would,
		containing the standard output and error
		from `autojudge -manual'.
	(4d)	Print a note indicating the results from
		the above steps.  If ./mail/S/Received_
		Mail does not exist or is not readable,
		(4a,b,c) are not done and only the note
		is printed."
	

# Process options.
#
set force 0
set norun 0
set myargv $argv
while { 1 } {
    set arg [lindex $myargv 0]
    switch -glob -- $arg {
    -doc* {
	puts $document
	exit 1
    }
    -force { set force 1 }
    -norun { set norun 1 }
    default break
    }
    set myargv [lrange $myargv 1 end]
}
set problem_re [lindex $myargv 0]
set submission_re [lindex $myargv 1]
if { $problem_re == "" } { set problem_re "." }
if { $submission_re == "" } { set submission_re "." }
set problem_re "submit.*$problem_re"
set submission_re "$submission_re.*-submission\$"


# Abbreviations:
#
set j_d [truename $judging_directory]
set pwd [pwd]

puts "Judging directory is:"
puts "    $j_d"

# Repair solutions links.
#
set c_d_exists [file isdirectory $j_d/contest]
set p_l_list [list $env(HOME)/hpcm/problem_library \
                   $hpcm_directory/problem_library]
set p_l ""
foreach d $p_l_list {
    if { [file isdirectory $d] } {
	set p_l [truename $d]
	break
    }
}

set all_ok 1
foreach target \
        [lsort [glob -nocomplain $j_d/solutions/*]] {
    if {    ! [catch { set type [file type $target] }] \
         && $type == "link"
	 && ! [file exists $target] } {

	set name [file tail $target]

	# Broken link found.

	if { $c_d_exists && ! $force } {
	    # ./contest is directory.
	    puts "ERROR: Broken solutions/$name"
	    set all_ok 0
	    continue
	}

	if { $p_l == "" } {
	    # No place to search.
	    puts "ERROR: Broken solutions/$name"
	    set all_ok 0
	    continue
	}

	set ok 0
	foreach d {demos public private} {
	    set source $p_l/$d/$name
	    if { [file isdirectory $source] } {
	        puts "Relinking solutions/$name"
		puts "       to $source"
		file delete -force -- $target
		link_file $source $target
		set ok 1
		break
	    }
	}
	if { ! $ok } {
	    puts "ERROR: Could not re-link\
	          solutions/$name"
	    foreach d {demos public private} {
	        puts "     $p_l/$d/$name not found"
	    }
	    set all_ok 0
	    continue
	}
    }
}

if { ! $all_ok } {
    if { $p_l == "" } {
	foreach d $p_l_list {
	    puts "    $d not found"
	}
    }
    if { $c_d_exists && ! $force } {
	puts "    SAFETY VIOLATION: ./contest is a\
		  directory"
    }
    if { ! $force } { exit 1 }
}

# Create ./rerun if necessary.
#
if { ! [file exists $j_d/rerun] } {
    puts "Creating ./rerun"
    mkdir $j_d/rerun
}

# Be sure directories have permissions.
#
grant_access $j_d/.. x
grant_access $j_d x
grant_access $j_d/rerun x

# Function to return true if and only if the subject
# field of the source mail file header matches the
# regexp (with -nocase).
#
proc received_matches { source regexp } {
    global message_subject
    set ch [open $source r]
    read_header $ch
    close $ch
    return [regexp -nocase -- $regexp $message_subject]
}

# Process ./mail subdirectories.
#
foreach subdir \
        [lsort [glob -nocomplain $j_d/mail/*]] {
    set subdir [file tail $subdir]
    if { ! [regexp -nocase -- \
                   $submission_re $subdir] } continue
    if { [file isdirectory $j_d/rerun/$subdir] } \
        continue
    set source $j_d/mail/$subdir/Received_Mail
    set target $j_d/rerun/$subdir/Received_Mail
    if { ! [file exists $source] } {
        puts "ERROR: does not exist:\
	      ./mail/$subdir/Received_Mail"
    } elseif { ! [file readable $source] } {
        puts "ERROR: not readable: \
	      ./mail/$subdir/Received_Mail"
    } elseif { ! [received_matches $source \
                                   $problem_re] } {
        continue
    } elseif { [catch {
	    mkdir $j_d/rerun/$subdir
	    copy_file $source $target
		      } out] } {
	puts "ERROR: Cannot make\
	      ./rerun/$subdir/Received_Mail"
	puts $out
    } elseif { $norun } { 
        puts "Made ./rerun/$subdir/Received_Mail"
    } else {

	# Change to rerun directory.
	#
	cd $j_d/rerun/$subdir

	# Open autodispatch.log file.
	#
	set logch [open autodispatch.log a]
	puts $logch "----------------------------------"
	puts $logch "Starting autojudge -manual:\
		     [clock format [clock seconds]]"
	puts $logch "----------------------------------"
	set c [catch { exec autojudge -manual } out]
	puts $logch $out
	close $logch
	cd $pwd

	if { $c } {
	    puts "Reran with SYSTEM ERROR: $subdir"
	} else {
	    puts "Reran $subdir"
	}
    }
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
