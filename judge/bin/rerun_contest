#! /bin/sh
#
# Re-run the autojudge on contest data.
#
# File:		rerun_contest
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Wed Nov 15 08:53:42 EST 2006
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2006/11/15 14:31:37 $
#   $RCSfile: rerun_contest,v $
#   $Revision: 1.3 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
rerun_contest \[-force|-norun\]

    Given a subdirectory named `ORIGINAL_MAIL' in the
    judging directory that is a copy of the contest
    `mail' subdirectory, this program creates a brand
    new `mail' subdirectory and contains only `Received_
    Mail' submission files, and re-runs the autojudge
    on all these submissions.

    To use this program, make a copy of the judging di-
    rectory and its subdirectories (using `cp -r' or
    `tar cf, tar xf') and, working in the copy, rename
    the `mail' subdirectory to `ORIGINAL_MAIL' and then
    run this program as many times as you like.  The
    requirement that you produce the `ORIGINAL_MAIL'
    directory by hand is a safety measure intended to
    prevent this program from being run on a live con-
    test.

    This program specifically does the following in
    its judging directory (which is the copy of the
    original):

    (1) Moves any `contest' link or subdirectory to
        `ORIGINAL_CONTEST' provided the latter does
	not exist.  This is a safety measure intended
	to prevent contact with any original `contest'
	directory.

    (2) Adds stuff to the end of `hpcm_judging.rc', if
        the stuff is not already there, to suppress
	authentication checks and suppress mailing
	replies back to the contestant.

	Note that if you want to update old stuff pre-
	viously placed in this file by rerun_contest,
	you must delete the old stuff by hand and
	rerun this program.

	The stuff added is marked by lines:

	    ##### BEGIN RERUN_CONTEST STUFF #####
	and
	    ##### END RERUN_CONTEST STUFF #####

	You can edit this stuff, or make your own stuff
	from scratch surrounded by the above lines.

    (3) Repairs any broken links in the `solutions' sub-
        directory.  If this fails for some link, this
	program stops unless it is given the `-force'
	option.

	To repair a link named P, this program selects
	the first of the following directories that
	exist:
		~/hpcm/problem_library
		\$hpcm_directory/problem_library
		
	In the selected directory this program searches
	for the following in order:

		demos/P
		public/P
		private/P

	and uses the first of these that is a directory.

    (4) Deletes any existing `mail' subdirectory of the
        judging directory and then remakes an empty
	version.

    (5) Gives a-x permission to the judging directory
        and the new `mail' subdirectory so JAVA will
	work.

    (6) For each submission subdirectory S in `ORIGINAL_
        MAIL', makes a subdirectory named S in `mail'
	and copies the `Received_Mail' file from the
	`ORIGINAL_MAIL/S' submission subdirectory to
	the `mail/S' subdirectory.  If an `ORIGINAL_
	MAIL' submission subdirectory has no readable
	Received_Mail file, a note is printed and the
	subdirectory is skipped (ignored).

    (7) Unless the `-norun' option is given, invokes
        dispatchmail on all the submission subdirector-
	ies of `mail'."

# Process options.
#
set force 0
set norun 0
set myargv $argv
while { 1 } {
    set arg [lindex $myargv 0]
    switch -glob -- $arg {
    -doc* {
	puts $document
	exit 1
    }
    -force { set force 1 }
    -norun { set norun 1 }
    default {
        puts "ERROR: bad option: $arg"
	exit 1
    }
    }
    set myargv [lrange $myargv 1 end]
}

# Abbreviations:
#
set j_d [truename $judging_directory]
set o_mail $j_d/ORIGINAL_MAIL

puts "Judging directory is:"
puts "    $j_d"

if { ! [file isdirectory $o_mail] } {
    puts "ERROR: ORIGINAL_MAIL does not exist"
    exit 1
}

# Move contest to ORIGINAL_CONTEST if appropriate.
#
if {    ! [catch { file type $j_d/contest } ] \
     && [catch { file type $j_d/ORIGINAL_CONTEST }] } {
    puts "Renaming contest to ORIGINAL_CONTEST"
    file rename $j_d/contest $j_d/ORIGINAL_CONTEST
}

# Add to hpcm_judging.rc if appropriate.
#
set in [open $j_d/hpcm_judging.rc r]
set found no
set regexp {(BEGIN|END)[ \t]+RERUN_CONTEST[ \t]+STUFF}
while { "yes" } {
    set line [gets $in]
    if { [eof $in] } break;
    if { [regexp $regexp $line] } {
        set found yes
	break
    }
}
close $in

if { $found == "no" } {
    puts "Adding RERUN_CONTEST STUFF to hpcm_judging.rc"
    set out [open $j_d/hpcm_judging.rc a]
    puts $out ""
    puts $out "##### BEGIN RERUN_CONTEST STUFF #####"
    puts $out ""
    puts $out "set use_authentication no"
    puts $out "proc send_mail { message_file } { }"
    puts $out "proc send_message { message } { }"
    puts $out ""
    puts $out "##### END RERUN_CONTEST STUFF #####"
    close $out
}

# Repair solutions links.
#
set p_l_list [list $env(HOME)/hpcm/problem_library \
                   $hpcm_directory/problem_library]
set p_l ""
foreach d $p_l_list {
    if { [file isdirectory $d] } {
	set p_l [truename $d]
	break
    }
}

set all_ok yes
foreach target \
        [lsort [glob -nocomplain $j_d/solutions/*]] {
    if {    ! [catch { set type [file type $target] }] \
         && $type == "link"
	 && ! [file exists $target] } {

	set name [file tail $target]

	# Broken link found.
	#
	if { $p_l == "" } {
	    # No place to search.
	    if { $force } break
	    puts "ERROR: Broken solutions/$name"
	    set butand but
	    foreach d $p_l_list {
	        puts "   $butand $d not found"
		set butand and
	    }
	    exit 1
	}

	set ok $force
	foreach d {demos public private}
	{
	    set source $p_l/$d/$name
	    if { [file isdirectory $source] } {
	        puts "Relinking solutions/$name"
		puts "       to $source"
		file delete -force -- $target
		link_file $source $target
		set ok yes
		break
	    }
	}
	if { $ok == "no" } {
	    puts "ERROR: Could not re-link\
	          solutions/$name"
	    all_ok no
	}
    }
}

if { $all_ok == "no" } { exit 1 }

# Delete mail directory.
#
if { [file exists $j_d/mail] } {
    puts "Deleting mail"
    file delete -force -- $j_d/mail
}

# Recreate mail directory and its contents.
#
puts "Creating mail/*/Received_mail"
mkdir $j_d/mail
grant_access $j_d
grant_access $j_d/mail
set regexp {^.*<<.*>>-submission$}
set subdirs {}
foreach subdir \
        [lsort [glob -nocomplain $o_mail/*]] {
    set subdir [file tail $subdir]
    if { ! [regexp $regexp $subdir] } continue
    set source $o_mail/$subdir/Received_Mail
    set target $j_d/mail/$subdir/Received_Mail
    if { ! [file exists $source] } {
        puts "Does not exist:\
	      ORIGINAL_MAIL/$subdir/Received_Mail"
    } elseif { ! [file readable $source] } {
        puts "Not readable: \
	      ORIGINAL_MAIL/$subdir/Received_Mail"
    } elseif { [catch {
	    mkdir mail/$subdir
	    copy_file $source $target
	    lappend subdirs $subdir
		      } out] } {
	puts "ERROR: Cannot make\
	      mail/$subdir/Received_Mail"
	puts $out
	exit 1
    }
}

if { $norun == "no" } {
    puts "Executing dispatchmail for all submissions"
    exec dispatchmail >@ stdout 2>@ stderr \
         << "[join $subdirs "\n"]\n"
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
