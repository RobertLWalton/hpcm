#! /bin/sh
#
# Re-run the autojudge on contest data.
#
# File:		rerun_contest
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Mon Jan  1 13:07:30 EST 2007
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2007/01/01 19:28:54 $
#   $RCSfile: rerun_contest,v $
#   $Revision: 1.6 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Include common code and parameters:
#
set log_disable yes
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
rerun_contest \[-force|-norun\] \\
              \[PROBLEM_RE \[SUBMISSION_RE \\
	      \[SOURCE \[TARGET\]\]\]\]

    Copies submission Received_Mail files into ./rerun
    subdirectories and runs `autojudge -manual' in these
    directories.  The submissions choosen are those
    whose submission directories contain a substring
    matching the regular expression
    
	\"SUBMISSION_RE.*-submission\$\"

    and whose Received_Mail header contains a subject
    header line with a substring matching the regular
    expression
    
        \"submit.*PROBLEM_RE\"
	
    where the matches are case insensitive and the RE's
    both default to \".\".

    If SOURCE is given it replaces ./mail, and if TARGET
    is given it replaces ./rerun.

    Rerun output may be compared with ./mail results
    using the rerun_diff program.  This program does not
    do anything for a submission whose ./rerun directory
    already exists.  The program rerun_remove can be
    used to remove submission ./rerun directories in
    preparation for redoing them.

    This program may be run in a copy of a judging di-
    rectory and its subdirectories made using `cp -r'
    or `tar cf, tar xf'.

    This program specifically does the following in
    the judging directory:

    (1) Repairs any broken links in the `solutions' sub-
        directory.  If this fails for some link, this
	program stops unless it is given the `-force'
	option.  This program also stops and does
	nothing if it finds a broken link and the
	./contest directory exists, unless the `-force'
	option is given.  This last is a safety measure.

	If used during a normal contest, no `solutions'
	sublinks should be broken, and this step should
	do nothing.

	To repair a link named P, this program selects
	the first of the following directories that
	exist:
		~/hpcm/problem_library
		\$hpcm_directory/problem_library
		
	In the selected directory this program searches
	for the following in order:

		demos/P
		public/P
		private/P

	and uses the first of these that is a directory.

    (2) Creates the `rerun' subdirectory of the judging
        directory if that does not exist.

    (3) Gives a-x permission to the judging directory,
        its parent, and its `rerun' subdirectory, so
	that JAVA will work.

    (4) For each submission subdirectory S in ./mail
        that has a Received_Mail file and matches the
	given RE's and for which the ./rerun/S directory
	does not already exist:

	(4a)	Make the ./rerun/S directory
	(4b)	Copy ./mail/S/Received_Mail to ./rerun/S
	(4c)	Execute `autojudge -manual' in ./rerun/S
		unless the `-norun' option is given.  A
		file named autodispatch.log is created
		just as the autodisptach program would,
		containing the standard output and error
		from `autojudge -manual'.
	(4d)	Print a note indicating the results from
		the above steps.  If ./mail/S/Received_
		Mail does not exist or is not readable,
		(4a,b,c) are not done and only the note
		is printed."
	

# Process options.
#
set force 0
set norun 0
set myargv $argv
while { 1 } {
    set arg [lindex $myargv 0]
    switch -glob -- $arg {
    -doc* {
	puts $document
	exit 1
    }
    -force { set force 1 }
    -norun { set norun 1 }
    default break
    }
    set myargv [lrange $myargv 1 end]
}


# Abbreviations:
#
set j_d [truename $judging_directory]
set pwd [pwd]

puts "Judging directory is:"
puts "    $j_d"

# Calculate arguments.
#
set problem_re [lindex $myargv 0]
set submission_re [lindex $myargv 1]
set source [lindex $myargv 2]
set target [lindex $myargv 3]
if { $problem_re == "" } { set problem_re "." }
set problem_re "submit.*$problem_re"
if { $submission_re == "" } { set submission_re "." }
set submission_re "$submission_re.*-submission\$"
if { $source == "" } { set source $j_d/mail }
if { $target == "" } { set target $j_d/rerun }
set sourceabbrev [file tail $source]
set targetabbrev [file tail $target]

# Repair solutions links.
#
set c_d_exists [file isdirectory $j_d/contest]
set p_l_list [list $env(HOME)/hpcm/problem_library \
                   $hpcm_directory/problem_library]
set p_l ""
foreach d $p_l_list {
    if { [file isdirectory $d] } {
	set p_l [truename $d]
	break
    }
}

set all_ok 1
foreach ltarget \
        [lsort [glob -nocomplain $j_d/solutions/*]] {
    if {    ! [catch { set type [file type $ltarget] }] \
         && $type == "link"
	 && ! [file exists $ltarget] } {

	set name [file tail $ltarget]

	# Broken link found.

	if { $c_d_exists && ! $force } {
	    # ./contest is directory.
	    puts "ERROR: Broken solutions/$name"
	    set all_ok 0
	    continue
	}

	if { $p_l == "" } {
	    # No place to search.
	    puts "ERROR: Broken solutions/$name"
	    set all_ok 0
	    continue
	}

	set ok 0
	foreach d {demos public private} {
	    set lsource $p_l/$d/$name
	    if { [file isdirectory $lsource] } {
	        puts "Relinking solutions/$name"
		puts "       to $lsource"
		file delete -force -- $ltarget
		link_file $lsource $ltarget
		set ok 1
		break
	    }
	}
	if { ! $ok } {
	    puts "ERROR: Could not re-link\
	          solutions/$name"
	    foreach d {demos public private} {
	        puts "     $p_l/$d/$name not found"
	    }
	    set all_ok 0
	    continue
	}
    }
}

if { ! $all_ok } {
    if { $p_l == "" } {
	foreach d $p_l_list {
	    puts "    $d not found"
	}
    }
    if { $c_d_exists && ! $force } {
	puts "    SAFETY VIOLATION: ./contest is a\
		  directory"
    }
    if { ! $force } { exit 1 }
}

# Create ./rerun if necessary.
#
if { ! [file exists $target] } {
    puts "Creating $targetabbrev"
    mkdir $target
}

# Be sure directories have permissions.
#
grant_access $target/../.. x
grant_access $target/.. x
grant_access $target x

# Function to return true if and only if the subject
# field of the rm mail file header matches the
# regexp (with -nocase).
#
proc received_matches { rm regexp } {
    global message_subject
    set ch [open $rm r]
    read_header $ch
    close $ch
    return [regexp -nocase -- $regexp $message_subject]
}

# Process ./mail subdirectories.
#
foreach subdir [lsort [glob -nocomplain $source/*]] {
    set subdir [file tail $subdir]
    if { ! [regexp -nocase -- \
                   $submission_re $subdir] } continue
    if { [file isdirectory $target/$subdir] } \
        continue
    set sourcerm $source/$subdir/Received_Mail
    set targetrm $target/$subdir/Received_Mail
    if { ! [file exists $sourcerm] } {
        puts "ERROR: does not exist:\
	      $sourceabbrev/$subdir/Received_Mail"
    } elseif { ! [file readable $sourcerm] } {
        puts "ERROR: not readable: \
	      $sourceabbrev/$subdir/Received_Mail"
    } elseif { ! [received_matches $sourcerm \
                                   $problem_re] } {
        continue
    } elseif { [catch {
	    mkdir $target/$subdir
	    copy_file $sourcerm $targetrm
		      } out] } {
	puts "ERROR: Cannot make\
	      $targetabbrev/$subdir/Received_Mail"
	puts $out
    } elseif { $norun } { 
        puts "Made $targetabbrev/$subdir/Received_Mail"
    } else {

	# Change to rerun directory.
	#
	cd $target/$subdir

	# Open autodispatch.log file.
	#
	set logch [open autodispatch.log a]
	puts $logch "----------------------------------"
	puts $logch "Starting autojudge -manual:\
		     [clock format [clock seconds]]"
	puts $logch "----------------------------------"
	set c [catch { exec autojudge -manual } out]
	puts $logch $out
	close $logch
	cd $pwd

	if { $c } {
	    puts "Reran with SYSTEM ERROR: $subdir"
	} else {
	    puts "Reran $subdir"
	}
    }
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
