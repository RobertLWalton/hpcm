#!/bin/sh
#
# Runs the scorefinder program to get scores, and
# formats the scores into a table according to
# parameters set in hpcm_judging.rc or in arguments.
#
# File:		scoreboard
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Feb 24 08:42:48 EST 2002
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2002/02/24 13:47:28 $
#   $RCSfile: scoretable,v $
#   $Revision: 1.33 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
source $lib_directory/scoreboard_common.tcl
set log_globally yes
catch {

set document "
scoreboard \[ parameter-file-name | \\
             parameter-name-value-list \] ...

    When this program starts, it processes its arguments
    as follows.  Any named parameter file is `sourced'.
    Any argument that begins with a `{' is treated as a
    TCL list (after the outer `{ }' brackets are re-
    moved) of items each of the format `{PN V}'.  For
    each item, the global variable `scoreboard_PN' is
    set to the value V.

    This program inputs (from the standard input) the
    output of `scorefinder' to get scores, and organizes
    these scores into a table.  All the rules regarding
    the various scoreboard_xxx global variables in hpcm_
    judging.rc are followed: see documentation in that
    file.

    The scoreboard contains two lines for each submitter
    of the form

    submitter          pscore  pscore  ......  pscore
    C/time_score_______pscore__pscore__......__pscore

    Here the submitter name is from the submission dir-
    ectories as compressed by the `submitter_compress'
    function, the pscore's are problem scores, C is the
    number of problems correct, and the time_score is
    the total submitter time in seconds.  If more lines
    per submitter are required, they are added, and each
    uses a different column separator character before
    each pscore.  See hpcm/contestant/help/common/
    scoreboard for more details."

# } This closes extra left bracket in documentation so
# outer {} brackets work.

# On first -doc* argument, print documentation and exit.
#
if { [regexp {^-doc} [lindex $argv 0]] } {
    puts $document
    exit 1
}

# Process arguments.
#
set LB "{"
# } to balance left bracket in last line
#
foreach arg $argv {
    if { [regexp "^${LB}" $arg] } {
	if { [catch { set items [lindex $arg 0] }] } {
	    error "argument is not a TCL list: $arg"
	}
	foreach item $items {
	    if { [catch { set len [llength $item] }] \
	         || $len != 2 } {
	        "argument element is not a length 2\
		 TCL list: $item"
	    }
	    set name  [lindex $item 0]
	    set value [lindex $item 1]
	    if { ! [info exists scoreboard_$name] } {
	    	error "scoreboard_$name does not exist"
	    }
	    set scoreboard_$name $value
	}
    } else {
	source $arg
    }
}

# Read and prune scoreboard_array.
#
compute_scoreboard_array stdin
prune_scoreboard_array

# Compute scoreboard list and scoreboard_problem_list.
#
compute_scoreboard_list


# Start output of scoreboard.
#
set spaces32 "                                "
set spaces64 $spaces32$spaces32
set spaces128 $spaces64$spaces64
set spaces256 $spaces128$spaces128

# Compute number of problems per line (ppl).
# Also max_column of output (first column is 0).
# But if there are no problems, exit program without
# producing any output.
#
# scoreboard_width is the number of columns in the
# scoreboard.

set ppl [expr { ( $scoreboard_width - 20 ) / 10 } ]
set np [llength $scoreboard_problem_list]
if { $np == 0 } { exit 0 }
if { $np < $ppl } { set ppl $np }
set max_column [expr { 20 + 10 * $ppl - 1 }]

# Compute line marker characters.  First and last
# line markers are SPACE, and in last line all
# spaces will be replaced by underbars (_).
#
# [string index $markers N] marks line N.  The first
# character of `markers' is unused.
#
# scoreboard_markers are the marker characters used,
# in order.
#
set nl [expr { ( $np + $ppl - 1 ) / $ppl }]
if { $nl <= 2 } {
    set markers "X  "
} else {
    set markers $scoreboard_markers
    set markers "X [string range $markers 0 \
                           [expr { $nl - 3 }]] "
}

# Output labeling lines.
#
proc label_problems {} {

    global scoreboard_problem_list spaces256 ppl \
           markers max_column

    set count  0
    set marker $markers
    foreach problem $scoreboard_problem_list {
	    if { $count % $ppl == 0 } {
	        if { $count > 0 } {
		    puts $line
		}
		set marker [string range $marker 1 end]
		set m [string index $marker 0]

		if { $count == 0 } {
		    set line "Contestant Name"
		} elseif { $count == 1 } {
		    set line "Correct/Tot_Time"
		} else {
		    set line ""
		}
		set line [format {%-20.20s} $line]
	    }
	    incr count
	    set line "$line$m[format {%9.9s} $problem]"
    }
    if { $count <= $ppl } {
	puts $line
        set line "Correct/Tot_Time"
    }
    regsub -all " " [string range $line$spaces256 \
			    0 $max_column] \
	   "_" line
    puts $line
}

label_problems

# Loop though sorted scoreboard_list and output each
# submitter.
#
set current_problems_correct ""
set number_of_problems \
    [llength $scoreboard_problem_list]
foreach item $scoreboard_list {

    # If team has no submissions, stop the presses.
    #
    if { [lindex $item 0] == "000.999999999.000" } {
	break
    }

    set problems_correct [lindex $item 1]
    set time_score [lindex $item 2]
    set modifier [lindex $item 3]
    set submitter [lindex $item 4]
    set problem_scores [lreplace $item 0 4]

    set total_score "$problems_correct/$time_score"

    if { $modifier == "n" } {
    	set total_score "*${total_score}"
    }

    # Print the line(s) for the team.
    #
    set count 0
    set marker $markers
    foreach score $problem_scores {
	if { $count % $ppl == 0 } {
	    if { $count > 0 } {
		puts $line
	    }
	    set marker [string range $marker 1 end]
	    set m [string index $marker 0]

	    if { $count == 0 } {
		set line $submitter
	    } elseif { $count == 1 } {
		set line "$total_score"
	    } else {
		set line ""
	    }
	    set line [format {%-20.20s} $line]
	}
	incr count

	set line "$line$m[format {%9.9s} $score]"
    }
    if { $count <= $ppl } {
	puts $line
        set line $total_score
    }
    regsub -all " " [string range $line$spaces256 \
			    0 $max_column] \
	   "_" line
    puts $line
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
