#!/bin/sh
#
# Compute the auto score file in a submission directory.
#
# File:		autoscore
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Jul 29 16:01:49 EDT 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/07/30 03:40:05 $
#   $RCSfile: autoscore,v $
#   $Revision: 1.24 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory; autoscore program_name

    Given the submission directory as the current dir-
    ectory, given the program name (e.g. pppp), the test
    file (pppp.test, the judge's solution's version of
    the output file), and optionally the output file
    (pppp.out) and the error file (pppp.err), computes
    the `$auto_score_file' file in the submission\
					    directory,
    using purely automatic (non-manual means).

    If the error file (pppp.err) exists and is non-
    empty, the score is one of:

    	Cpu Time Limit Exceeded
	Output Size Limit Exceeded
	Program Crashed

    depending upon whether a line of the error file
    matches a regular expression indicating there
    was a cpu time or output size problem.  Currently
    it is not possible to discriminate memory limit
    exceedments from other memory errors, and they
    are all classed as `Program Crashed'.

    If the error file does not exist or is empty, and
    the output file does not exist or is empty, the
    score is:

	Program Crashed

    If the score is determined by any of the above, no
    .score file is created, and any existing .score file
    is deleted.  Otherwise the score file is computed
    as the output of

    	scorediff output_file test_file

    Then the score is computed by comparing the first
    line of the .score file to the whitespace separated
    items of the first line of any
    
	$scoring_instructions_file

    file in the submission directory.  If this last
    file is missing, the items default to:

    	$scoring_instructions_default

    The possible $scoring_instructions_file file items\
                                                 are:

    	whitespace	Allow matching whitespace in
			the two files to be not exactly
			the same, if each whitespace is
			within a line and not at the
			beginning or end of the line.
			Such mismatches are automatical-
			ly allowed if either whitespace
			is followed by a floating point
			number.

    	beginspace	Allow matching whitespace in
			the two files to be not exactly
			the same, if each whitespace is
			at the beginning of a line.
			Such mismatches are automatical-
			ly allowed if either whitespace
			is followed by a floating point
			number.

    	endspace	Allow matching whitespace in
			the two files to be not exactly
			the same, if each whitespace is
			at the end of a line.

    	linespace	Allow whitespace within blank
			lines not to match.

	linebreak	Allow one file to have line
			breaks where the other file does
			not.  If this happens, the
			whitespace at the beginnings and
			ends of the lines involved, and
			within blank lines, need not
			match.

	spacebreak	Allow one file to have white-
			space completely within some
			line when the other file has no
			whitespace at all.

	integer A R	Allow the two files to have
			matching integers whose absolute
			difference is as much as A, and
			whose relative difference is as
			much as R, where A and R are
			floating point values.  Numbers
			whose character strings match
			exactly are not considered dif-
			ferent in this sense.

			An integer is a number with no
			decimal point or exponent.

	float A R	Allow the two files to have mat-
			ching numbers at least one of
			which is floating point whose
			absolute difference is as much
			as A, and whose relative differ-
			ence is as much as R, where A
			and R are floating point values.
			Numbers whose character strings
			match exactly are not considered
			different in this sense.

			An floating point number is a
			number with no decimal point or
			exponent.

	decimal		Allow two files to have matching
			numbers that have different
			numbers of decimal digits, or
			for which only one of the
			matching numbers has a decimal
			point.

	exponent	Allow two files to have matching
			numbers just one of which has an
			exponent.

	sign		Allow two files to have matching
			numbers just one of which has an
			sign, or both of which have dif-
			ferent signs.

	number A R	The union of `integer A R',
			`float A R', `decimal',
			`exponent', and `sign'.

	case		Allow two files to have letters
			outside of numbers that match
			but for case.

	column		Allow to files to have matching
			numbers that do not end in the
			same line column, or matching
			non-whitespace characters out-
			side numbers that are not in the
			same line column.

    The possible scores (with empty error file and
    existing non-empty output file) are:

    	Completely Correct
	Formatting Error
	Incomplete Output
	Incorrect Output

    If scorediff reports `nonblank' or `eof2' (output
    has non-whitespace after test file ends), or if
    scorediff reports an `integer' or `float' difference
    greater than allowed by the\
             $scoring_instructions_file,
    the output is incorrect.  Otherwise, if scorediff
    reports `eof1' the output is incomplete.  Otherwise
    if scorediff reports something that is not allowed
    by the $scoring_instructions_file, the output has a
    formatting error.  Otherwise the output is correct.

    The relative difference of two numbers x and y is
    defined to be:

                       | x - y |
                    ----------------
                    max ( |x|, |y| )

    which has a maximum value of 2.  If x = y = 0, the
    relative difference of x and y is defined to be 0.

    The score is written to the `$auto_score_file' file
    in the submission directory and is also written as a
    single line to the standard output.  The score
    flag is also set (the `$score_flag_file' file in\
    				the flag
    directory) to indicate to scoreboard programs that
    the scoreboard needs to be recomputed.

    For the purpose of computing character line column
    positions, tabs are set every 8 columns.

    If something goes very wrong, such as finding that
    the `$auto_score_file' file is not writable, this
    program creates an error log file in the current
    directory, prints information about the error to the
    standard error output, and exits with exit code 0."

# If wrong number of arguments or first argument begins
# with `-', print documentation and exit with error.
#
if { $argc != 1 || [regexp {^-} [lindex $argv 0]] } {
    puts $document
    exit 1
}

# Set file names and check file permissions.
#
set program_name [lindex $argv 0]
set output_file $program_name.out
set error_file  $program_name.err
set test_file   $program_name.test
set score_file  $program_name.score

# Initialize score to blank.
#
set score ""

# If error file exists and is not empty, compute score.
#
if { [file exists $error_file] \
     && [file size $error_file] > 0 } {

    set error_fd [open $error_file r]
    while { "yes" } {
    	set line [gets $error_fd]
	if { [eof $error_fd] } break
	if { [regexp -nocase -- \
	             $time_limit_regexp $line] } {
	    set score "Cpu Time Limit Exceeded"
	    break;
	} elseif { [regexp -nocase -- \
	             $output_limit_regexp $line] } {
	    set score "Output Size Limit Exceeded"
	    break;
	}
    }
    close $error_fd

    if { $score == "" } {
    	set score "Program Crashed"
    }
} elseif { ! [file exists $output_file] \
           || [file size $output_file] == 0 } {

    # Error file does not exist or is empty, and
    # output file does not exist or is empty.
    #
    set score "Program Crashed"
}

# If score is still blank, compute the score using
# the instructions file and the results of scorediff.
# otherwise delete any score file.
#
if { $score != "" } {
    file delete -force $score_file
} else {

    # Read the instructions file or use default.
    #
    set scoring_instructions [find_scoring_instructions]

    # Encode the instructions in the following
    # variables:
    #
    set whitespace_ok	no
    set beginspace_ok	no
    set endspace_ok	no
    set linespace_ok	no
    set spacebreak_ok	no
    set linebreak_ok	no
    set integer_ok	no
    set float_ok	no
    set decimal_ok	no
    set exponent_ok	no
    set sign_ok 	no
    set case_ok		no
    set column_ok	no
    set integer_absdiff	0.0
    set integer_reldiff	0.0
    set float_absdiff	0.0
    set float_reldiff	0.0

    set last ""
    foreach i $scoring_instructions {
	if { $last == "integer" } {
	    if { [catch { expr $i }] } {
	        error \
		    "Non-number after `integer' in\
		     scoring instructions: $i"
	    }
	    set integer_absdiff $i
	    set last integer_absdiff
	} elseif { $last == "integer_absdiff" } {
	    if { [catch { expr $i }] } {
	        error \
		    "Non-number after `integer' in\
		     scoring instructions: $i"
	    }
	    set integer_reldiff $i
	    set last ""
	} elseif { $last == "float" } {
	    if { [catch { expr $i }] } {
	        error \
		    "Non-number after `float' in\
		     scoring instructions: $i"
	    }
	    set float_absdiff $i
	    set last float_absdiff
	} elseif { $last == "float_absdiff" } {
	    if { [catch { expr $i }] } {
	        error \
		    "Non-number after `float' in\
		     scoring instructions: $i"
	    }
	    set float_reldiff $i
	    set last ""
	} elseif { $last == "number" } {
	    if { [catch { expr $i }] } {
	        error \
		    "Non-number after `number' in\
		     scoring instructions: $i"
	    }
	    set integer_absdiff $i
	    set float_absdiff $i
	    set last number_absdiff
	} elseif { $last == "number_absdiff" } {
	    if { [catch { expr $i }] } {
	        error \
		    "Non-number after `number' in\
		     scoring instructions: $i"
	    }
	    set integer_reldiff $i
	    set float_reldiff $i
	    set last ""
	} elseif { $i == "float" } {
	    set float_ok yes
	    set last float
	} elseif { $i == "integer" } {
	    set integer_ok yes
	    set last integer
	} elseif { $i == "number" } {
	    set integer_ok yes
	    set float_ok yes
	    set last number
	} elseif { $i == "decimal" } {
	    set decimal_ok yes
	} elseif { $i == "exponent" } {
	    set exponent_ok yes
	} elseif { $i == "sign" } {
	    set sign_ok yes
	} elseif { $i == "case" } {
	    set case_ok yes
	} elseif { $i == "column" } {
	    set column_ok yes
	} elseif { $i == "spacebreak" } {
	    set spacebreak_ok yes
	} elseif { $i == "linebreak" } {
	    set linebreak_ok yes
	} elseif { $i == "whitespace" } {
	    set whitespace_ok yes
	} elseif { $i == "beginspace" } {
	    set beginspace_ok yes
	} elseif { $i == "endspace" } {
	    set endspace_ok yes
	} elseif { $i == "linespace" } {
	    set linespace_ok yes
	} else {
	    error "Unknown scoring_instruction: $i"
	}
    }
    
    if { $last != "" } {
	error \
	    "Number, integer, or float not followed by\
	     two floating point numbers\n\
	    \    in the scoring instructions:\n\
	    \        $scoring_instructions"
    }

    # Compute the .score file if it does not exist or
    # is younger than the .out or .test files.
    #
    if {  ! [file exists $score_file] \
         || [file mtime $score_file] \
	    < [file mtime $output_file] \
         || [file mtime $score_file] \
	    < [file mtime $test_file] } {

    	file delete -force $score_file

	exec scorediff $output_file $test_file \
	     > $score_file
    }

    # Read the first line of the .score file.
    #
    set scorediff [read_file $score_file]

    # Compute score based on scoring instructions and
    # results in the first line of the .score file.
    #
    set last ""
    foreach d $scorediff {
	if { $last == "integer" } {
	    if { $d > $integer_absdiff } {
		set score "Incorrect Output"
		break
	    }
	    set last integer_absdiff
	} elseif { $last == "integer_absdiff" } {
	    if { $d > $integer_reldiff } {
		set score "Incorrect Output"
		break
	    }
	    set last ""
	} elseif { $last == "float" } {
	    if { $d > $float_absdiff } {
		set score "Incorrect Output"
		break
	    }
	    set last float_absdiff
	} elseif { $last == "float_absdiff" } {
	    if { $d > $float_reldiff } {
		set score "Incorrect Output"
		break
	    }
	    set last ""
	} elseif { $d == "integer" } {
	    if { $integer_ok == "no" } {
		set score "Incorrect Output" 
		break
	    }
	    set last integer
	} elseif { $d == "float" } {
	    if { $float_ok == "no" } {
		set score "Incorrect Output" 
		break
	    }
	    set last float
	} elseif { $d == "nonblank" } {
	    set score "Incorrect Output"
	    break
	} elseif { $d == "eof2" } {
	    set score "Incorrect Output"
	    break
	} elseif { $d == "eof1" } {
	    set score "Incomplete Output"
	} elseif { $d == "decimal" } {
	    if { $decimal_ok == "no" \
	         && $score == "" } {
		set score "Formatting Error" 
	    }
	} elseif { $d == "exponent" } {
	    if { $exponent_ok == "no" \
	         && $score == "" } {
		set score "Formatting Error" 
	    }
	} elseif { $d == "sign" } {
	    if { $sign_ok == "no" \
	         && $score == "" } {
		set score "Formatting Error" 
	    }
	} elseif { $d == "case" } {
	    if { $case_ok == "no" \
	         && $score == "" } {
		set score "Formatting Error" 
	    }
	} elseif { $d == "column" } {
	    if { $column_ok == "no" \
	         && $score == "" } {
		set score "Formatting Error" 
	    }
	} elseif { $d == "whitespace" } {
	    if { $whitespace_ok == "no" \
	         && $score == "" } {
		set score "Formatting Error" 
	    }
	} elseif { $d == "beginspace" } {
	    if { $beginspace_ok == "no" \
	         && $score == "" } {
		set score "Formatting Error" 
	    }
	} elseif { $d == "endspace" } {
	    if { $endspace_ok == "no" \
	         && $score == "" } {
		set score "Formatting Error" 
	    }
	} elseif { $d == "linespace" } {
	    if { $linespace_ok == "no" \
	         && $score == "" } {
		set score "Formatting Error" 
	    }
	} elseif { $d == "spacebreak" } {
	    if { $spacebreak_ok == "no" \
	         && $score == "" } {
		set score "Formatting Error" 
	    }
	} elseif { $d == "linebreak" } {
	    if { $linebreak_ok == "no" \
	         && $score == "" } {
		set score "Formatting Error" 
	    }
	} elseif { $d == "none" } {
	    # No error
	} else {
	    error "Unknown scorediff result: $d" 
	}
    }
}

if { $score == "" } {
    set score "Completely Correct"
}

write_file $auto_score_file $score
set_flag $score_flag_file

puts $score

exit 0

# Include common error catching code:
#
} caught_output
caught_error
