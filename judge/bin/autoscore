#! /bin/sh -f
#
# Compute the judge.score file in a submission directory
#
# File:		autoscore
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Aug 16 07:30:59 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/19 15:56:05 $
#   $RCSfile: autoscore,v $
#   $Revision: 1.8 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"

set document "
cd submission_directory; autoscore program_name

    Given the submission directory as the current dir-
    ectory, given the program name (e.g. pppp), and
    given the output file (pppp.out), optional error
    file (pppp.err), and test file (pppp.test, the
    judge's solution's version of the output file),
    computes the `$auto_score_file' file in the
    submission directory, using purely automatic
    (non-manual means).

    If the error file (pppp.err) exists and is non-
    empty, the score is one of:

    	Cpu Time Limit Exceeded
	Output Size Limit Exceeded
	Program Crashed

    depending upon whether a line of the error file
    matches a regular expression indicating there
    was a cpu time or output size problem.  Currently
    it is not possible to discriminate memory limit
    exceedments from other memory errors, and they
    are all classed as `Program Crashed'.

    If the error file does not exist or is empty, the
    program is scored by comparing the output of

    	scorediff output_file test_file

    to the whitespace separated items of the first line
    of any
    
	$instructions_file

    file in the submission directory.  If this last
    file is missing, it defaults to:

    	$scoring_instructions_default

    The possible $instructions_file items are:

    	whitespace	Allow matching whitespace in
			the two files to be not exactly
			the same.  However, by itself
			this item does not permit
			different numbers of `\\n's.

	linebreak	Allow one file to have line
			breaks where the other file
			does not.  Only effective if
			whitespace or spacebreak is
			allowed.

	spacebreak	Allow one file to have white-
			space where the other file has
			none.  However, by itself this
			item does not permit one file
			to have `\\n's where there
			other file has no whitespace.

	number D	Allow the two files to have
			matching numbers whose absolute
			difference is as much as D,
			where D is a floating point
			value.

    The possible scores (with empty error file) are
    then:

    	Completely Correct
	Formatting Error
	Incomplete Output
	Incorrect Output

    If scorediff reports `nonblank' or `eof2' (output
    has non-whitespace after test file ends), or if
    scorediff reports a `number' difference greater than
    allowed by the ${instructions_file}, the
    output is incorrect.  Otherwise, if scorediff
    reports something other than `eof1' that is not
    allowed by ${instructions_file}, the output
    has a formatting error.  Otherwise if scorediff
    reports `eof1' the output is incomplete.  Otherwise
    the output is correct.

    The score is written to the `$auto_score_file' file
    in the submission directory and is also written as a
    single line to the standard output."

# If wrong number of arguments print documentation and
# exit with error.
#
if { $argc != 1 || [regexp {^-} [lindex $argv 1]] } {
    puts $document
    exit 1
}

# Set file names and check file permissions.
#
set program_name [lindex $argv 0]
set output_file "${program_name}.out"
set error_file  "${program_name}.err"
set test_file   "${program_name}.test"

if { ! [file readable $output_file] } {
    fatal_error "Not readable: $output_file"
}

if { ! [file readable $test_file] } {
    fatal_error "Not readable: $test_file"
}

if { [file exists $auto_score_file] \
     && ! [file writable $auto_score_file] } {
    fatal_error "Not writable: $auto_score_file"
}

if { [file exists $instructions_file] \
     && ! [file readable $instructions_file] } {
    fatal_error "Not readable: $instructions_file"
}

# Initialize score to blank.
#
set score ""

# If error file exists and is not empty, compute score.
#
if { [file exists $error_file] \
     && [file size $error_file] > 0 } {

    if { ! [file readable $error_file] } {
	fatal_error "Not readable: $error_file"
    }

    set error_fd [open $error_file r]
    while { "yes" } {
    	set line [gets $error_fd]
	if { [eof $error_fd] } break
	if { [regexp -nocase -- \
	             $time_limit_regexp $line] } {
	    set score "Cpu Time Limit Exceeded"
	    break;
	} elseif { [regexp -nocase -- \
	             $output_limit_regexp $line] } {
	    set score "Output Size Limit Exceeded"
	    break;
	}
    }
    close $error_fd

    if { $score == "" } {
    	set score "Program Crashed"
    }
}

# If score is still blank, compute the score using
# the instructions file and the results of scorediff.
#
if { $score == "" } {

    # Read the instructions file or use default.
    #
    if { ! [file readable $instructions_file] } {
	set scoring_instructions \
	    $scoring_instructions_default
    } else {
	set scoring_instructions_fd \
	    [open $instructions_file r]
	set scoring_instructions \
	    [gets $scoring_instructions_fd]
	close $scoring_instructions_fd
    }

    # Encode the instructions in the following
    # variables:
    #
    set spacebreak_ok	no
    set linebreak_ok	no
    set whitespace_ok	no
    set number_ok	no
    set number_diff	0.0

    set number_last no
    foreach i $scoring_instructions {
	if { $number_last } {
	    if { [catch "expr $i"] } {
	        fatal_error \
		    "Non-number after `number' in\
		     scoring instructions: $i"
	    }
	    set number_diff $i
	    set number_last no
	} elseif { $i == "number" } {
	    set number_ok yes
	    set number_last yes
	} elseif { $i == "spacebreak" } {
	    set spacebreak_ok yes
	} elseif { $i == "linebreak" } {
	    set linebreak_ok yes
	} elseif { $i == "whitespace" } {
	    set whitespace_ok yes
	} else {
	    fatal_error \
		"Unknown scoring_instruction: $i"
	}
    }
    
    if { $number_last } {
	fatal_error \
	    "Number not followed by floating point\
	     number" \
	    "in the scoring instructions:" \
	    "    $scoring_instructions"
    }

    # Compute result of scorediff applied to output
    # and test files.
    #
    set scorediff \
        [exec scorediff $output_file $test_file]

    # Compute score based on scoring instructions and
    # results of scorediff.
    #
    set number_last no
    foreach d $scorediff {
	if { $number_last } {
	    set number_last no
	    if { $d > $number_diff } {
		set score "Incorrect Output"
		break
	    }
	} elseif { $d == "number" } {
	    if { $number_ok == "no" } {
		set score "Incorrect Output" 
		break
	    }
	    set number_last yes
	} elseif { $d == "nonblank" } {
	    set score "Incorrect Output"
	    break
	} elseif { $d == "eof2" } {
	    set score "Incorrect Output"
	    break
	} elseif { $d == "whitespace" } {
	    if { $whitespace_ok == "no" } {
		set score "Formatting Error" 
	    }
	} elseif { $d == "spacebreak" } {
	    if { $spacebreak_ok == "no" } {
		set score "Formatting Error" 
	    }
	} elseif { $d == "linebreak" } {
	    if { $linebreak_ok == "no" } {
		set score "Formatting Error" 
	    }
	} elseif { $d == "eof1" } {
	    if { $score == "" } {
		set score "Incomplete Output"
	    }
	} elseif { $d == "none" } {
	    # No error
	} else {
	    fatal_error \
		"Unknown scorediff result: $d" 
	}
    }
}

if { $score == "" } {
    set score "Completely Correct"
}

set score_fd [open $auto_score_file w]
puts $score_fd $score
close $score_fd

puts $score

exit 0
