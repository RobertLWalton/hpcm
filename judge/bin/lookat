#!/bin/sh
#
# Looks at all the subdirectories of the mail directory
# that have a designated file containing a line matching
# a given regular expression.
#
# File:		lookat
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Nov  5 05:31:14 EST 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/11/05 10:33:46 $
#   $RCSfile: lookat,v $
#   $Revision: 1.1 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_globally yes
catch {

set document "
lookat filename regexp

    This program examines subdirectories of the mail
    directory that have a file with the given filename
    which has a line matching the given regular ex-
    pression.  The filename may have glob metacharac-
    ters: e.g., `*-unchecked-error' is a legal file-
    name.  The regular expression may match any part
    of a line, and letter case is ignored in matching.

    This program logs errors in the log directory."


# If wrong number of arguments or first argument
# begins with a `-', print documentation and exit.
#
if { $argc != 2 || [regexp {^-} [lindex $argv 0]] } {
    puts $document
    exit 1
}

# Set arguments.
#
set filename [lindex $argv 0]
set regexp   [lindex $argv 1]

# Loop until no more calls to manual reply.
#
while { "yes" } {

    # Loop through the subdirectory names.
    #
    set manualcount 0
    set manualdirs ""
    foreach dir \
            [lsort \
	       [glob -nocomplain $mail_directory/*]] {

	# See if there is a line matching in a
	# designated file in the subdirectory.
	#
	set match no
	foreach file [glob -nocomplain $dir/$filename] {
	    if { ! [file readable $file] } continue
	    set file_ch [open $file r]
	    while { "yes" } {
	        set line [gets $file_ch]
		if { [eof $file_ch] } break
		if { [regexp -nocase -- $regexp $line] } {
		    set match yes
		    break
		}
	    }
	    close $file_ch
	    if { $match } break
	}

	# If there was a matching line, add subdirectory
	# to list.
	#
	if { $match } {
	    incr manualcount
	    lappend manualdirs $dir
	}
    }

    # Execute manual reply on subdirectories.
    #
    while { $manualcount != 0 } {

	puts "Directories waiting to execute\
	      `manualreply':"
	foreach d $manualdirs {
	    puts "    [file tail $d]"
	}
	puts -nonewline \
	     "\nType ENTER or RETURN to continue;\
	      control-D to exit."
	flush stdout
	gets stdin
	if { [eof stdin] } { puts ""; exit 0 }

	set dir [lindex $manualdirs 0]
	exec manualreply $dir >@ stdout 2>@ stderr
	incr manualcount -1
	set manualdirs [lrange $manualdirs 1 end]
    }

}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
