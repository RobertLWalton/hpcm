#!/bin/sh
#
# Looks at all the subdirectories of the mail directory
# that have a designated file containing a line matching
# a given regular expression.
#
# File:		lookat
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Dec  4 02:16:24 EST 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/12/04 07:22:13 $
#   $RCSfile: lookat,v $
#   $Revision: 1.3 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_mode none
catch {

set document "
lookat filename regexp

    This program executes `manualreply' on subdirector-
    ies of the mail directory that have a file with the
    given filename which has a line matching the given
    regular expression.  The filename may have glob
    metacharacters: e.g., `*-unchecked-error' is a legal
    filename.  The regular expression may match any part
    of a line, and letter case is ignored in matching.

    After the list of subdirectories is computed, the
    list is displayed, and the user of this program
    is asked whether to execute `manualreply' on the
    first subdirectory, or to exit this program.  After
    executing `manualreply' on a subdirectory, the
    subdirectory is removed from the list and this
    program loops to display the remaining list.

    Unlike most HPCM judging programs, errors made by
    this program are not written to log files, but are
    announced on standard error."


# If wrong number of arguments or first argument
# begins with a `-', print documentation and exit.
#
if { $argc != 2 || [regexp {^-} [lindex $argv 0]] } {
    puts $document
    exit 1
}

# Set arguments.
#
set filename [lindex $argv 0]
set regexp   [lindex $argv 1]

# Loop through the subdirectory names.
#
set manualcount 0
set manualdirs ""
foreach dir \
	[lsort \
	   [glob -nocomplain $mail_directory/*]] {

    # See if there is a line matching in a
    # designated file in the subdirectory.
    #
    set match no
    foreach file [glob -nocomplain $dir/$filename] {
	if { ! [file readable $file] } continue
	set file_ch [open $file r]
	while { "yes" } {
	    set line [gets $file_ch]
	    if { [eof $file_ch] } break
	    if { [regexp -nocase -- $regexp $line] } {
		set match yes
		break
	    }
	}
	close $file_ch
	if { $match } break
    }

    # If there was a matching line, add subdirectory
    # to list.
    #
    if { $match } {
	incr manualcount
	lappend manualdirs $dir
    }
}

# Execute manual reply on subdirectories.
#
while { $manualcount != 0 } {

    puts "Directories waiting to execute\
	  `manualreply':"
    foreach d $manualdirs {
	puts "    [file tail $d]"
    }
    puts -nonewline \
	 "\nType ENTER or RETURN to continue;\
	  control-D to exit."
    flush stdout
    gets stdin
    if { [eof stdin] } { puts ""; exit 0 }

    set dir [lindex $manualdirs 0]
    exec manualreply $dir >@ stdout 2>@ stderr
    incr manualcount -1
    set manualdirs [lrange $manualdirs 1 end]
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
