#!/bin/sh
#
# Given a logical expression containing keywords, list
# the files the File_List whose keywords satisfy the
# expression.
#
# File:		file_list
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Fri Mar 22 08:54:27 EST 2002
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2002/03/22 14:06:01 $
#   $RCSfile: file_list,v $
#   $Revision: 1.3 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# This is a utility program that does NOT have to run
# in a judging directory tree.

set document "
file_list expression

    List all the file names in the HPCM File_List file
    for which the expression is true, where the names
    in the expression are taken as key names.  The
    operators `!', `&', `^', and `|' are permitted, as
    are parentheses.  Precedence order is `!', `&', `^',
    `|'.

    Unlike most HPCM judging programs, this program does
    not read any hpcm_judging.rc file and errors made by
    this program are not written to log files."

if { $argc != 1 || [regexp {^-doc} [lindex $argv 0]] } {
    puts $document
    exit 1
}

# Check that argument is a TCL list.
#
set argument [lindex $argv 0]
if { [catch { llength $argument }] } {
    error "Argument is not TCL list: $argument"
}


# A list of all the names in the expression.
#
set vars ""

# Expression to be evaluated: must add `$' to each var.
#
set expression ""

foreach var $argument {
    if { [regexp {^[_a-zA-Z][_a-zA-Z0-9]*} $var] } {
        lappend vars $var
        set expression "$expression \$$var"
    } elseif { [lcontain {( ) ! & ^ |} $var] } {
	set expression "$expression $var"
    } else {
        error "Bad atom `$var' in `$argument'"
    }
}

set ch [open "[file dirname $argv0]/../../File_List" r]

# We isolate evaluation in an environment where all
# key and variable names are local (assuming they
# do not begin and end with `_').
#
proc evaluator { _expression_ _keys_ _vars_ } {
    foreach _var_ $_vars_ { set $_var_ 0 }
    foreach _key_ $_keys_ { set $_key_ 1 }
    return [expr $_expression_]
}

set outsw 0
while { "yes" } {
    set line [gets $ch]
    if { [eof $ch] } break
    if { [regexp {^#KEYS:(.*)$} $line forget keys] } {
	set outsw [evaluator $expression $keys $vars]
	foreach key $keys {
	    set key_present($key) yes
	}
    } elseif { [regexp {^#} $line] } {
	set outsw 0
    } elseif { $outsw } {
	puts $line
    }
}

set bad_vars ""
foreach var $vars {
    if { ! [info exists key_present($var)] } {
        lappend bad_vars $var
    }
}
if { $bad_vars != "" } {
    puts stderr "ERROR: Logical expression contains\
    		 keys never used anywhere in\
		 File_List:\n    $bad_vars"
    exit 1
}

exit 0
