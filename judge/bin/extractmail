#!/bin/sh
#
# Extract submitted program from received mail file.
#
# File:		extractmail
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sat Nov 24 20:13:38 EST 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/11/25 03:53:28 $
#   $RCSfile: extractmail,v $
#   $Revision: 1.26 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory; extractmail

    Reads the `$received_file' file in the current direc-
    tory.  Thus file must contain an email with a sub-
    ject line of the form:

    	Subject: submit problemname\[.extension\]

    If there is a `$files_file' file in the current di-
    rectory, it lists the names of all the files that
    supposed to be submitted.  Otherwise only one file
    may be submitted, and it must have the file name
    `problemname.extension', where the extension must
    be given in the message `Subject:' field.

    For each file successfully extracted, this program
    prints the line `Extracted FFFF' to the standard
    output, where FFFF is the file name.  For each
    error, this program prints an error message to the
    standard error output.  This program always exits
    with exit code 0.  The TCL command:

    	catch { exec extractmail } out

    will capture both the standard and error outputs in
    the variable `out' and return a 0/1 value indicating
    whether there were any errors.  If there were errors
    that concern the judge, and not just the submitter,
    the text `SYSTEM ERROR' appears in the error output.
    Otherwise the value of `out' will be suitable for
    inclusion in a reply to the submitter.

    If there is a `$files_file' file in the current\
    			directory,
    all submitted files must have names listed in this
    `$files_file' file.  This file is interpreted as
    a TCL list (with list elements separated by spaces,
    tabs, or new lines) whose elements are file names
    and the special symbols:
    
    	-REQUIRED-	Indicates that the following
			file names name files that MUST
			be submitted.
    
    	-OPTIONAL-	Indicates that the following
			file names name files that may
			optionally be submitted.
    
    	-LINK-		Indicates that the following
			file names name files that MUST
			be linked from the problem
			solution directory.

    File names before any special symbol are treated as
    `-REQUIRED-'.  Special symbols can appear any number
    of times in the list and apply to all file names
    following them but before the next special symbol in
    the list.  The `extractmail' program ignores
    `-LINK-' file names.

    If there is no `$files_file' file, there is exactly\
    	one
    required submitted file whose name comes from the
    submission `Subject:' field and must be the problem
    name followed by one of the extensions in the
    `allowed_extensions' global variable, whose value by
    default is:

    	$allowed_extensions
    
    Submitted files may be encoded in the body of the
    message in the format:

   	HPCM_BEGIN filename
	..<1st line of file>
	..<2nd line of file>
	<more lines, each preceded by `..'>
	HPCM_END filename

    This format MUST be used if the `format_submissions'
    global variable is defined and equal to `yes'.  If
    this format is used, there must be nothing else in
    the body of the message except optional blank lines
    preceding, separating, and following the files.
    
    If this format is NOT used, the files may be in-
    cluded verbatim in the body of the message.  Files
    must be separated by blank lines, and there may be
    blank lines preceding the first file and following
    the last file.  All these blank lines will be dis-
    carded, and not treated as part of any file.  If
    files are given verbatim in the body of the message,
    the files may not begin with `HPCM_BEGIN'.
    
    When files are given verbatim in the body of the
    message, each file may have a file name given in the
    following way.  The first block of non-blank lines
    at the beginning of the file is searched for text of
    the form `File: FFFF', where FFFF is the filename.
    This text must appear within a single line, must
    be preceded or followed by whitespace (spaces or
    tabs) or line boundaries, and may have any or no
    whitespace between the `:' and FFFF.  The FFFF
    contains only non-whitespace characters.  It is a
    possibly undetected error if there are extra such
    pieces of text in a file, or if a file does not
    specify its name in this manner and there is more
    than one possible submission file.

    If a submitted file already exists and has a modifi-
    cation time equal to or later than that of the
    $received_file file, the submitted file is NOT writ-
    ten, but is instead compared to the existing file.
    If the comparison matches, the `Extracted FFFF' out-
    put line is generated, but if there is a mismatch,
    a system error message is generated.

    It is an error if the problem name contains `/' or
    `.' or begins with `-'.  It is a system error if the
    `Subject:' field does not begin with `submit', or
    if the $received_file or `$files_file' files are
    unreadable."

# If there are arguments, print documentation and exit.
#
if { $argc != 0 } {
    puts $document
    exit 1
}

# Print error message to standard error output and exit
# with cleanup.
#
proc extract_error { message } {
    puts stderr $message
    exit_cleanup
    exit 0
}

# Read the header.
#
if { [catch { set received_ch \
		  [open $received_file r] }] } {
    extract_error \
        "SYSTEM ERROR: cannot read $received_file"
}
set received_mtime [file mtime $received_file]
read_header $received_ch

# Check for legality of subject line:
#
if { [llength $message_subject] == 0 } {
    extract_error \
        "ERROR: Missing or empty `Subject:' field"
} elseif { [lindex $message_subject 0] != "submit" } {
    extract_error \
	"ERROR: Badly formatted subject field:\
	 $message_subject"
} elseif { [llength $message_subject] != 2 } {
    extract_error \
	"ERROR: Badly formatted subject field:\
	 $message_subject"
}

# Extract the problem name.
#
set filename [lindex $message_subject 1]
set problem [file rootname $filename]
if { [regexp {\.} $problem] } {
    extract_error \
         "ERROR: Bad problem name (contains `.'):\
	  $problem"
} elseif { [regexp {/} $problem] } {
    extract_error \
         "ERROR: Bad problem name (contains `/'):\
	  $problem"
} elseif { [regexp {^-} $problem] } {
    extract_error \
         "ERROR: Bad problem name (begins with `-'):\
	  $problem"
}

# Compute the list of submittable files.
#
if { [file exists $files_file] } {

    if { [catch { set filelist \
		      [read_entire_file $files_file] \
	        }] } {
        extract_error \
	    "SYSTEM ERROR: Cannot read $file_files"
    }
} else {
    if { $filename == $problem } {
        extract_error \
	    "ERROR: Bad filename in `Subject:\
	     $message_subject' (no extension)"
    }
    set extension [file extension $filename]
    if { [lsearch -exact $allowed_extensions \
		  $extension] < 0 } {
	extract_error \
	    "ERROR: bad file name extension in\
	     `Subject: $message_subject'"
    }
    set filelist [list $filename]
}

# Filename_array has a value for every submittable
# file.  The possible values are:
#
#	required	optional	found
#
set mode required
foreach name $filelist {
    switch $name {
	-REQUIRED-	{
	    set mode required
	}
	-REQUIRED-	{
	    set mode optional
	}
	-LINK-	{
	    set mode ""
	}
	default {
	    if { $mode != "" } {
		set filename_array($name) $mode
	    }
	}
    }
}

if { [llength [array names filename_array]] < 1 } {
    error "No allowed submittable files"
}

# WS matching whitespace character and NWS matching
# non-whitespace character.
#
set WS "\[\ \t\]"
set NWS "\[^\ \t]"

# If clean_filename is not "", close file_ch and delete
# cleanup_filename.
#
set cleanup_filename ""
proc exit_cleanup {} {
    global file_ch cleanup_filename
    if { $cleanup_filename != "" } {
	close $file_ch
	file delete -force $cleanup_filename
    }
}

# Open file for reading or writing.  Return the
# open channel in the global variable `file_ch' and
# return `read' or `write' if the file is opened for
# reading or writing.  A file is opened for reading
# if it exists and has an mtime >= received_mtime;
# and is opened for writing otherwise.  If opened for
# writing, any existing file is deleted.  Also sets
# cleanup_filename if file is being written, and
# checks filename for legality.
#
proc open_file { filename } {

    global filename_array problem received_mtime \
    	   file_ch cleanup_filename

    if { ! [info exists filename_array($filename)] } {
        extract_error "ERROR: Bad file name: $filename"
    } elseif { $filename_array($filename) == "found" } {
        extract_error "ERROR: Redundant file: $filename"
    }
    set filename_array($filename) found

    if { [file exists $filename] } {

        if { [file mtime $filename] \
	         >= $received_mtime } {
	    if { [catch { set file_ch \
	                      [open $filename r] }] } {
		extract_error \
		    "SYSTEM ERROR: Cannot read\
		     $filename"
	    }
	    return read
	} else {
	    puts "Deleting out-of-date $filename"
	    file delete -force $filename
	}
    }

    if { [catch { set file_ch [open $filename w] }] } {
        extract_error \
	    "SYSTEM ERROR: Cannot write $filename"
    }

    # Set cleanup for error exits.
    #
    set cleanup_filename $filename

    return write
}

# Return next non-blank line in received_ch.  Return ""
# on end of file.
#
proc read_non_blank_line {} {

    global received_ch NWS

    while { "yes" } {
	set line [gets $received_ch]
	if { [eof $received_ch] } {
	    return ""
	} elseif { [regexp $NWS $line] } {
	    return $line
	}
    }
}

# Close file.
#
proc close_file { filename } {
    global file_ch cleanup_filename
    close $file_ch
    set cleanup_filename ""
    puts "Extracted $filename"
}

# Skip over blank lines at start of body.
#
set line [read_non_blank_line]
if { $line == "" } {
    extract_error "ERROR: message body is blank"
}

# Select formatted or non-formatted input.
#
if { [regexp {^HPCM_BEGIN} $line] } {

    # Input is formatted.  Loop through files in
    # input.
    #
    while { "yes" } {

    	# Process HPCM_BEGIN line.
	#
        if { ! [regexp "^HPCM_BEGIN$WS+($NWS+)$WS*\$" \
                       $line forget filename] } {
	    extract_error \
	        "ERROR: bad HPCM_BEGIN line:\n$line"
	}
	set mode [open_file $filename]

	# Process file removing beginning `..'s until
	# HPCM_END line found.
	#
	while { "yes" } {
	    set line [gets $received_ch]
	    if { [eof $received_ch] } {
		extract_error \
		    "ERROR: Could not find\
		     `HPCM_END $filename' line"
	    } elseif { [regexp {^\.\.(.*)$} $line \
			       forget real_line] } {
		if { $mode == "write" } {
		    puts $file_ch $real_line
		} else {
		    set file_line [gets $file_ch]
		    if { $file_line != $real_line } {
		        extract_error \
			    "SYSTEM ERROR: file\
			     mismatch for\
			     `$filename':\nold:\
			     $file_line\nnew:\
			     $real_line"
		    }
		}
	    } elseif { \
		  [regexp \
		      "^HPCM_END$WS+($NWS+)$WS*\$" \
		      $line forget endname] \
		  && $endname == $filename } {
		break
	    } elseif { [regexp "^HPCM_END" $line] \
			    } {
		extract_error \
		    "ERROR: Badly formatted\
		     `HPCM_END $filename'\
		     line:\n$line"
	    } else {
		extract_error \
		    "ERROR: Bad line between\
		     `HPCM_BEGIN $filename' and\
		     `HPCM_END $filename':\n$line"
	    }
	}

	close_file $filename

	# Look for next non-blank line.
	#
	set line [read_non_blank_line]
	if { $line == "" } break
    }

} else {

    if { [info exists format_submissions] \
	 && $format_submissions == "yes" } {
	extract_error \
	    "ERROR: Bad line in body before\
	     `HPCM_BEGIN' line; or disallowed\
	     unformatted file"
    }

    # Input is unformatted.  Loop through blocks of
    # non-blank lines in message.
    #
    set file_ch ""
    set mode none
    set blank_lines ""
    while { ! [eof $received_ch] } {

	# Accumulate non-blank lines and look for
	# filename.
	#
	set lines ""
	set filename ""
	set FILE "File:$WS*($NWS+)"
    	while { [regexp $NWS $line] } {

	    if { [regexp \
	    	    "(^|$WS)$FILE(\$|$WS)" \
		    $line forget1 forget2 fname \
		    forget3] } {
		if { $filename == "" } {
		    set filename $fname
		} else {
		     extract_error \
		         "ERROR: extra file name in\
			  file: `File: $fname'"
		}
		if { [regexp \
		     "(^|$WS)$FILE($WS+)$FILE(\$|$WS)" \
		     $line] } {
		     extract_error \
		         "ERROR: extra file names in\
			  file:\n$line"
		}
	    }
	    lappend lines $line
	    set line [gets $received_ch]
	    if { [eof $received_ch] } break
	}

	if { $mode == "none" && $filename == "" } {
	    set filenames [array names filename_array]
	    if { [llength $filenames] == 1 } {
	        set filename [lindex $filenames 0]
	    } else {
		 extract_error \
		     "ERROR: no `File: ...' in first\
		      file in message body"
	    }
	}

	if { $filename != "" } {
	    if { $mode != "none" } {
	        close_file $filename
	    }
	    set mode [open_file $filename]
	} else {
	    set lines [concat $blank_lines $lines]
	}

	switch $mode {
	    read {
	        foreach line $lines {
		    set file_line [gets $file_ch]
		    if { $file_line != $real_line } {
			extract_error \
			    "SYSTEM ERROR: file\
			     mismatch for\
			     `$filename':\nold:\
			     $file_line\nnew:\
			     $real_line"
		    }
		}
	    }
	    write {
	        foreach line $lines {
		    puts $file_ch $line
		}
	    }
	}

	# Accumulate blank lines.
	#
	set blank_lines ""
	while { ! [eof $received_ch] } {
	    lappend blank_lines $line
	    set line [gets $received_ch]
	    if { [regexp $NWS $line] } break
	}

	if { [eof $received_ch] } {
	    if { $mode != "none" } {
	        close_file $filename
	    }
	    break
	}
    }
}

# Check for missing files.
#
foreach filename [array names filename_array] {
    if { $filename_array($filename) == "required" } {
        extract_error "ERROR: missing file: $filename"
    }
}

# Close received_ch and exit.
#
close $received_ch
exit 0

# Include common error catching code:
#
} caught_output
caught_error
