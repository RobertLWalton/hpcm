#!/bin/sh -f
#
# Extract submitted program from received.mail file.
#
# File:		extract
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Aug 16 06:41:25 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/19 02:33:36 $
#   $RCSfile: extractmail,v $
#   $Revision: 1.3 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"

set document "
cd submission_directory; extract

    Reads the `$received_file' file in the current
    directory.  Thus file must have a subject line of
    the form:

    	Subject: submit filename

   The submitted file is extracted from the email and
   placed in the current directory.

   If the submission email has a `Subject' line as above
   and the filename given is for a readable file, this
   program terminates without doing anything and without
   error.

   If this program terminates without error, it writes
   the the extracted filename to the standard output
   as a single line, and writes nothing else.

   Otherwise, if the submitted email has even the
   slightest formatting error, this program constructs a
   `$replied_file' file giving reasons why the sub-
   mission email is invalid.  This `$replied_file' is
   sent to the email address that is part of the current
   directory name.  In this case this program exits with
   error code 0, indicating no error, but does not write
   anything to the standard output, indicating no file
   was extracted."

if { $argc != 0 } {
    puts $document
    exit 1
}


if { ! [file readable $received_file] } {
    fatal_error "Not readable: $received_file"
}

set received_ch [open $received_file r]

proc extract_error_reply { args } {
    eval reply -include-received-email \
         "ERROR during submission file extraction:" \
	 $args "" \
	 "THIS SUBMISSION IGNORED" \
	 "YOU MUST RESUBMIT"
    exit 2
}

# Look for subject line.
#
while { "yes" } {
    set line [gets $received_ch]
    if { [eof $received_ch] } {
        extract_error_reply \
	    "Could not find `Subject' line."
    } elseif { [regexp {^Subject: submit } $line] } {
    	set filename [lindex $line 2]
	break
    } elseif { [regexp {^Subject:} $line] } {
    	extract_error_reply \
	    "Badly formatted subject line"
    } elseif { [regexp $From_line_regexp $line] } {
    	# From line is ok
    } elseif { [regexp ":" $line] } {
    	# other header lines are ok
    } else {
    	extract_error_reply \
	    "Bad line in header before `Subject'\
	         line:" \
	    $line
    }
}

# Check that `filename' has no `/'s.
#
if { [llength [file split $filename]] != 1 } {
    extract_error_replay \
        "Filename contains a `/': $filename"
}

# If named file is readable exit without error.
#
if { [file readable $filename] } {
    puts $filename
    exit 0
}

# Look for first non-header line.
#
while { "yes" } {
    set line [gets $received_ch]
    if { [eof $received_ch] } {
        extract_error_reply \
	    "Could not find message body."
    } elseif { ! [regexp ":" $line] } {
    	break
    }
}

# Look for BEGIN line.
#
while { "yes" } {
    if { [regexp "^BEGIN $filename\$" $line] } {
    	break
    } elseif { [regexp {^BEGIN} $line] } {
    	extract_error_reply \
	    "Badly formatted BEGIN line:" $line
    } elseif { [regexp {^[ 	]*$} $line] } {
    	# blank lines are ok
    } else {
    	extract_error_reply \
	    "Bad line in body before `BEGIN'\
	         line:" \
	    $line
    }
    set line [gets $received_ch]
    if { [eof $received_ch] } {
        extract_error_reply \
	    "Could not find `BEGIN' line."
    }
}

# If $filename exits, delete it.  Then open it for
# writing.
#
if { [file exists $filename] } {
    file delete -force $filename
}
set file_ch [open $filename w]

# Look for END line copying file.
#
while { "yes" } {
    set line [gets $received_ch]
    if { [eof $received_ch] } {
        close $file_ch
	file delete -force $filename
        extract_error_reply \
	    "Could not find END line."
    } elseif { [regexp {^\.\.(.*)$} $line \
                       all real_line] } {
	puts $file_ch $real_line
    } elseif { [regexp "^END $filename" $line] } {
    	break
    } else {
        close $file_ch
	file delete -force $filename
        extract_error_reply \
	    "Bad line between BEGIN and END:" $line
    }
}

close $file_ch

# Look for extaneous non-blan text after END line.
#
while { "yes" } {
    set line [gets $received_ch]
    if { [eof $received_ch] } {
	break
    } elseif { [regexp {^[ 	]*$} $line] } {
    	# blank lines are ok
    } else {
	file delete -force $filename
        extract_error_reply \
	    "Bad line after END:" $line
    }
}

close $received_ch

puts $filename
exit 0
