#!/bin/sh
#
# Extract submitted program from received mail file.
#
# File:		extractmail
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Nov  5 08:46:55 EST 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/11/05 14:02:02 $
#   $RCSfile: extractmail,v $
#   $Revision: 1.16 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory; extractmail

    Reads the `$received_file' file in the current
    directory.  Thus file must have a subject line of
    the form:

    	Subject: submit filename

    The submitted file is extracted from the email and
    placed in the current directory.  The submitted file
    must be encoded in the body of the message in the
    format:

   	BEGIN filename
	..<1st line of file>
	..<2nd line of file>
	<more lines, each preceded by `..'>
	END filename

    There may be nothing else in the body of the message
    except blank lines preceding and following the file.

    If this program succeeds in extracting the submitted
    file without error, this program prints the name
    of the submitted file to the standard output as a
    single line, and prints nothing else.

    If the submission email has a `Subject' line as
    above and the filename given is for an already
    existing readable file whose modification time is
    more recent that that of the `$received_file' file,
    this program terminates without error and without
    doing anything beyond reading the `Subject' line
    and printing the name of the submitted file to the
    standard output.

    If the submitted email has even the slightest for-
    matting error, or if the filename is illegal (con-
    tains a `/', or begins with either `.' or `-') this
    program constructs a `$reply_file' file giving
    reasons why the submission email is invalid.  This
    `$reply_file' file is emailed to the submitter.  In
    this case this program exits with exit code 0,
    indicating no error, but does not print anything to
    the standard output, indicating no file was extract-
    ed.

    If something goes very wrong, such as finding that
    the `$received_file' file is not readable, this
    program creates an error log file in the current
    directory, does not print anything on the standard
    output (but does print on the error output), and
    exits with exit code 0.  The program also does this
    if the `Subject:' field value is such that `auto-
    dispatch' will not invoke the `autojudge' program
    (the value is empty, or does not have a first item
    equal to `submit')."

if { $argc != 0 } {
    puts $document
    exit 1
}

# Create a reply file complaining of a submission
# error, and email this reply to the submitter.  Include
# the submission email in the reply.
#
proc extract_error_reply { args } {
    eval reply -all \
         {"ERROR during submission file extraction:"} \
	 $args \
	 {""} \
	 {"THIS SUBMISSION (see below) IGNORED"} \
	 {"YOU MUST RESUBMIT"}

    exit_cleanup
    exit 0
}

# Read the header.
#
set received_ch [open $received_file r]
read_header $received_ch

# Check for legality of subject line:
#
if { [llength $message_subject] == 0 } {
    error "Missing or empty `Subject:' field"
} elseif { [lindex $message_subject 0] != "submit" } {
    error \
	"Badly formatted subject field:" \
	"Subject: $message_subject"
} elseif { [llength $message_subject] != 2 } {
    extract_error_reply \
	"Badly formatted subject field:" \
	"Subject: $message_subject"
}

# Extract the filename and check its legality.
#
set filename [lindex $message_subject 1]

if { [regexp {^\.|^-|/} $filename] } {
    extract_error_reply \
        "Illegal filename (has `/' or beginning `.'\
			   or beginning `-'):\
	 $filename"
}

# If named file is readable and is more recent than the
# received mail file, then print the file name and exit
# without error.
#
if { [file readable $filename] \
     && [file mtime $received_file] \
	 <= [file mtime $filename] } {
    puts $filename
    exit 0
}

# If $filename exists, delete it.
#
if { [file exists $filename] } {
    puts "Deleting out-of-date $filename"
    file delete -force $filename
}

set WS "\[\ \t\]"
set NWS "\[^\ \t]"

# Look for BEGIN line.
#
while { "yes" } {

    set line [gets $received_ch]
    if { [eof $received_ch] } {
        extract_error_reply \
	    "Could not find `BEGIN' line."
    } elseif { [regexp "^BEGIN$WS+($NWS+)$WS*\$" $line \
                       forget beginname] \
	       && $beginname == $filename } {
    	break
    } elseif { [regexp {^BEGIN} $line] } {
    	extract_error_reply \
	    "Badly formatted BEGIN line:" $line
    } elseif { [regexp "^$WS*\$" $line] } {
    	# blank lines are ok
    } else {
    	extract_error_reply \
	    "Bad line in body before `BEGIN' line:" \
	    $line
    }
}

# Copy file, looking for END line.
#
set file_ch [open $filename w]

# Set cleanup for error exits.
#
proc exit_cleanup {} {
    global file_ch filename
    close $file_ch
    file delete -force $filename
}

while { "yes" } {
    set line [gets $received_ch]
    if { [eof $received_ch] } {
        extract_error_reply \
	    "Could not find END line."
    } elseif { [regexp {^\.\.(.*)$} $line \
                       forget real_line] } {
	puts $file_ch $real_line
    } elseif { [regexp "^END$WS+($NWS+)$WS*\$" $line \
                       forget endname] \
	       && $endname == $filename } {
    	break
    } elseif { [regexp "^END" $line] } {
        extract_error_reply \
	    "Badly formatted END line:" $line
    } else {
        extract_error_reply \
	    "Bad line between BEGIN and END:" $line
    }
}

# Look for extaneous non-blank text after END line.
#
while { "yes" } {
    set line [gets $received_ch]
    if { [eof $received_ch] } {
	break
    } elseif { [regexp "^$WS*\$" $line] } {
    	# blank lines are ok
    } else {
        extract_error_reply \
	    "Bad line after END:" $line
    }
}

# Close files, print name of submitted file, and exit
# without error.
#
close $file_ch
close $received_ch
puts $filename
exit 0

# Include common error catching code:
#
} caught_output
caught_error
