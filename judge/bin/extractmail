#!/bin/sh -f
#
# Extract submitted program from received mail file.
#
# File:		extractmail
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Aug 28 15:17:10 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/28 20:52:35 $
#   $RCSfile: extractmail,v $
#   $Revision: 1.10 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"
catch {

set document "
cd submission_directory; extract

    Reads the `$received_file' file in the current
    directory.  Thus file must have a subject line of
    the form:

    	Subject: submit filename

    The submitted file is extracted from the email and
    placed in the current directory.  The submitted file
    must be encoded in the body of the message in the
    format:

   	BEGIN filename
	..<1st line of file>
	..<2nd line of file>
	<more lines, each preceded by `..'>
	END filename

    There may be nothing else in the body of the message
    except blank lines preceding and following the file.

    If the submission email has a `Subject' line as
    above and the filename given is for an already
    existing readable file whose modification time is
    more recent that that of the `$received_file', this
    program terminates without error and without doing
    anything beyond reading the `Subject' line and
    printing the name of the submitted file to the
    standard output.

    If this program succeeds in extracting the submitted
    file without error, this program prints the name
    of the submitted file to the standard output as a
    single line, and prints nothing else.

    Otherwise, if the submitted email has even the
    slightest formatting error, this program constructs
    a `$reply_file' file giving reasons why the sub-
    mission email is invalid.  This `$reply_file' is
    sent to the email address that is part of the
    current directory name.  In this case this program
    exits with exit code 0, indicating no error, but
    does not print anything to the standard output,
    indicating no file was extracted.

    If something goes very wrong, such as finding that
    the `$received_file' file is not readable, this
    program creates an error log file in the current
    directory, does not print anything on the standard
    output (but does print on the error output), and
    exits with exit code 0."

if { $argc != 0 } {
    puts $document
    exit 1
}

# Create a reply file complaining of a submission
# error, and email this reply to the submitter.  Include
# the submission email in the reply.
#
proc extract_error_reply { args } {
    eval reply -all \
         {"ERROR during submission file extraction:"} \
	 $args \
	 {""} \
	 {"THIS SUBMISSION (see below) IGNORED"} \
	 {"YOU MUST RESUBMIT"}

    exit 0
}

# Read the header.
#
set received_ch [open $received_file r]
read_header $received_ch

# Check for legallity of subject line:
#
if { [llength $subject] == 0 } {
    extract_error_reply \
	"Missing or empty `Subject:' field"
} elseif { [llength $subject] != 2 \\
     || [lindex $subject 0] != "submit" } {
    extract_error_reply \
	"Badly formatted subject field:" \
	"Subject: $message_subject"
}

# Extract the filename and check its legality.
#
set filename [lindex $subject 1]

if { [regexp {^\.|\/} $filename] } {
    extract_error_reply \
        "Illegal filename (has `/' or beginning `.'):\
	 $filename"
}

# If named file is readable and is more recent than the
# received mail file, then print# the file name and exit
# without error.
#
if { [file readable $filename] \
     && [file mtime $recived_file] \
	 <= [file mtime $filename] } {
    puts $filename
    exit 0
}

# If $filename exists, delete it.
#
if { [file exists $filename] } {
    file delete -force $filename
}

# Look for BEGIN line.
#
while { "yes" } {

    set line [gets $received_ch]
    if { [eof $received_ch] } {
        extract_error_reply \
	    "Could not find `BEGIN' line."
    } elseif { [regexp "^BEGIN $filename\$" $line] } {
    	break
    } elseif { [regexp {^BEGIN} $line] } {
    	extract_error_reply \
	    "Badly formatted BEGIN line:" $line
    } elseif { [regexp "^\[\ \t\]*\$" $line] } {
    	# blank lines are ok
    } else {
    	extract_error_reply \
	    "Bad line in body before `BEGIN' line:" \
	    $line
    }
}

# Copy file, looking for END line.
#
set file_ch [open $filename w]

while { "yes" } {
    set line [gets $received_ch]
    if { [eof $received_ch] } {
        close $file_ch
	file delete -force $filename
        extract_error_reply \
	    "Could not find END line."
    } elseif { [regexp {^\.\.(.*)$} $line \
                       forget real_line] } {
	puts $file_ch $real_line
    } elseif { [regexp "^END $filename\$" $line] } {
    	break
    } elseif { [regexp "^END" $line] } {
        close $file_ch
	file delete -force $filename
        extract_error_reply \
	    "Badly formatted END line:" $line
    } else {
        close $file_ch
	file delete -force $filename
        extract_error_reply \
	    "Bad line between BEGIN and END:" $line
    }
}

close $file_ch

# Look for extaneous non-blank text after END line.
#
while { "yes" } {
    set line [gets $received_ch]
    if { [eof $received_ch] } {
	break
    } elseif { [regexp "^\[\ \t\]*\$" $line] } {
    	# blank lines are ok
    } else {
	file delete -force $filename
        extract_error_reply \
	    "Bad line after END:" $line
    }
}

# Close received email file, print name of submitted
# file, and exit without error.
#
close $received_ch
puts $filename
exit 0

# Include common error catching code:
#
} caught_output
caught_error
