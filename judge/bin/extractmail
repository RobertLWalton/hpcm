#!/bin/sh
#
# Extract submitted program from received mail file.
#
# File:		extractmail
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Nov 18 20:16:26 EST 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/11/19 01:13:46 $
#   $RCSfile: extractmail,v $
#   $Revision: 1.22 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory; extractmail

    Reads the `$received_file' file in the current direc-
    tory.  Thus file must contain an email with a sub-
    ject line of the form:

    	Subject: submit filename

    or

    	Subject: submit problemname

    In the first case there is only one file, which must
    have the given name; in the second case, there may
    be more than one file.  Note that problem names may
    not contain `.'.  The submitted files are extracted
    from the email and placed in the current directory.

    For each file successfully extracted, this program
    prints the line `Extracted FFFF' to the standard
    output, where FFFF is the file name.  For each
    error, this program prints an error message to the
    standard error output.  This program always exists
    with exit code 0.  The TCL command:

    	catch { exec extractmail } out

    will capture both the standard and error outputs in
    the variable `out' and return a code indicating
    whether there were any errors.  If there were errors
    that concern the judge, and not just the submitter,
    the text `SYSTEM ERROR' appears in the error output.
    Otherwise the value of `out' will be suitable for
    inclusion in a reply to the submitter.

    If there is a `$files_file' file in the current\
    			directory,
    all submitted files must have names listed in this
    `$files_file' file.  This file consists of file names
    separated by whitespace (either spaces or tabs or
    new lines).  If one of these file names begins with
    a `?', the `?' is discarded from the file name, and
    the file is optional.  Otherwise the file must be
    included in the submission.  If there is no\
    	`$files_file'
    file, the submitted file name must be the problem
    name followed by one of the extensions in the
    `allowed_extensions' global variable, whose value by
    default is:

    	$allowed_extensions
    
    The submitted files may be encoded in the body of
    the message in the format:

   	HPCM_BEGIN filename
	..<1st line of file>
	..<2nd line of file>
	<more lines, each preceded by `..'>
	HPCM_END filename

    This format MUST be used if the `format_submissions'
    variable is defined and equal to `yes'.  If this
    format is used, there must be nothing else in the
    body of the message except optional blank lines
    preceding and following the files.
    
    If this format is NOT used, the files may be in-
    cluded verbatim in the body of the message.  Files
    must be separated by blank lines, and there may be
    blank lines preceding the first file and following
    the last file.  All these blank lines will be dis-
    carded, and not treated as part of any file.  If
    there is more than one file, or if the `Subject:'
    field of the $received_file file does not give the
    filename, then each file must begin with a block of
    non-blank lines, exactly one of which contains
    text of the form `File: FFFF', where FFFF is the
    file name.  This text may be surrounded by white-
    space (spaces and tabs), there may be no or any
    kind of whitespace between the `:' and FFFF, but
    there must be no whitespace in the FFFF.  If a file
    name is given by both this method and in the
    `Subject:' field, the names must match.  If files
    are given verbatim in the body of the message, the
    files may not begin with `HPCM_BEGIN'.

    If a submitted file already exists and has a modifi-
    cation time equal to or later than that of the
    $received_file file, the submitted file is NOT writ-
    ten, but is instead compared to the existing file.
    If the comparison matches, the `Extracted FFFF' out-
    put line is generated, but if there is a mismatch,
    a system error message is generated.

    It is an error if a file name contains `/' or begins
    with `.' or `-'.  It is a system error if the
    `Subject:' field does not begin with `submit', or
    if the $received_file or `$files_file' files are
    unreadable."

if { $argc != 0 } {
    puts $document
    exit 1
}

proc extract_error { message } {
    puts stderr $message
    exit_cleanup
    exit 0
}

# Read the header.
#
if { [catch { set received_ch \
		  [open $received_file r] }] } {
    extract_error \
        "SYSTEM ERROR: cannot read $received_file"
}
set received_mtime [file mtime $received_file]
read_header $received_ch

# Check for legality of subject line:
#
if { [llength $message_subject] == 0 } {
    extract_error \
        "ERROR: Missing or empty `Subject:' field"
    exit 0
} elseif { [lindex $message_subject 0] != "submit" } {
    extract_error \
	"ERROR: Badly formatted subject field:\
	 $message_subject"
} elseif { [llength $message_subject] != 2 } {
    extract_error \
	"ERROR: Badly formatted subject field:\
	 $message_subject"
}

# Extract the problem name and possible filename and
# check legality.
#
set filename [lindex $message_subject 1]
set problem [file rootname $filename]
if { [regexp {\.} $problem] } {
    extract_error \
         "ERROR: Bad problem name (contains `.'):\
	  $problem"
} elseif { [regexp {/} $problem] } {
    extract_error \
         "ERROR: Bad problem name (contains `/'):\
	  $problem"
} elseif { [regexp {^-} $problem] } {
    extract_error \
         "ERROR: Bad problem name (begins with `-'):\
	  $problem"
}

if { [file exists $files_file] } {
    if { [catch { set filenames \
		      [lrange [read_entire_file \
		                   $files_file] \
			      0 end] }] } {
        extract_error \
	    "SYSTEM ERROR: Cannot read $file_files"
    }

    if { $filename != $problem \\
         && [lsearch -exact $filenames $filename] \
	        < 0 } {
        extract_error \
	    "ERROR: bad file name in\
	     `Subject: $message_subject'"
    }
} else {
    set filenames ""
    if { $filename != $problem } {
	set extension [file extension $filename]
	if { [lsearch -exact $allowed_extensions \
		      $extension] < 0 } {
	    extract_error \
		"ERROR: bad file name extension in\
		 `Subject: $message_subject'"
	}
        lappend filenames $filename
    }
}

# WS matching whitespace character and NWS matching
# non-whitespace character.
#
set WS "\[\ \t\]"
set NWS "\[^\ \t]"

# If clean_filename is not "", close file_ch and delete
# cleanup_filename.
#
set cleanup_filename ""
proc exit_cleanup {} {
    global file_ch cleanup_filename
    if { $cleanup_filename != "" } {
	close $file_ch
	file delete -force $cleanup_filename
    }
}

# Open file for reading or writing.  Return the
# open channel in the global variable `file_ch' and
# return `read' or `write' if the file is opened for
# reading or writing.  A file is opened for reading
# if it exists and has an mtime >= received_mtime;
# and is opened for writing otherwise.  If opened for
# writing, any existing file is deleted.
#
proc open_file { filename } {

    global filenames problem received_mtime file_ch \
           cleanup_filename

    if { [lsearch -exact $filenames $filename] < 0 \
         && (    [llength $filenames] > 0 \
              || [file rootname $filename] != $problem \
	      || [lsearch -exact \
	      		  [file extension $filename] \
	                  $allowed_extensions] < 0 ) } {
        extract_error "ERROR: Bad file name: $filename"
    }

    if { [file exists $filename] } {

        if { [file mtime $filename] \
	         >= $received_mtime } {
	    if { [catch { set file_ch \
	                      [open $filename r] }] } {
		extract_error \
		    "SYSTEM ERROR: Cannot read\
		     $filename"
	    }
	    return read
	} else {
	    puts "Deleting out-of-date $filename"
	    file delete -force $filename
	}
    }

    if { [catch { set file_ch [open $filename w] }] } {
        extract_error \
	    "SYSTEM ERROR: Cannot write $filename"
    }

    # Set cleanup for error exits.
    #
    set cleanup_filename $filename

    return write
}

# Return next non-blank line in received_ch.  Return ""
# on end of file.
#
proc read_nonblank_line {} {

    global received_ch NWS

    while { "yes" } {
	set line [gets $received_ch]
	if { [eof $received_ch] } {
	    return ""
	} elseif { [regexp $NWS $line] } {
	    return $line
	}
    }
}

# Close file.
#
proc close_file {} {
    global file_ch cleanup_filename
    close $file_ch
    set cleanup_filename ""
    puts "Extracted $filename"
}

# Skip over blank lines at start of body.
#
set line [read_non_blank_line]
if { $line == "" } {
    extract_error "ERROR: message body is blank"
}

# Select formatted or non-formatted input.
#
if { [regexp {^HPCM_BEGIN} $line] } {

    # Input is formatted.  Loop through files in
    # input.
    #
    while { "yes" } {

    	# Process HPCM_BEGIN line.
	#
        if { ! [regexp "^HPCM_BEGIN$WS+($NWS+)$WS*\$" \
                       $line forget filename] } {
	    extract_error \
	        "ERROR: bad HPCM_BEGIN line:\n$line"
	}
	set mode [open_file $filename]

	# Process file removing beginning `..'s until
	# HPCM_END line found.
	#
	while { "yes" } {
	    set line [gets $received_ch]
	    if { [eof $received_ch] } {
		extract_error \
		    "ERROR: Could not find\
		     `HPCM_END $filename' line"
	    } elseif { [regexp {^\.\.(.*)$} $line \
			       forget real_line] } {
		if { $mode == "write" } {
		    puts $file_ch $real_line
		} else {
		    set file_line [gets $file_ch]
		    if { $file_line != $real_line } {
		        extract_error \
			    "SYSTEM ERROR: file\
			     mismatch for `$filename'
		    }
		}
	    } elseif { \
		  [regexp \
		      "^HPCM_END$WS+($NWS+)$WS*\$" \
		      $line forget endname] \
		  && $endname == $filename } {
		break
	    } elseif { [regexp "^HPCM_END" $line] \
			    } {
		extract_error \
		    "ERROR: Badly formatted\
		     `HPCM_END $filename'\
		     line:\n$line"
	    } else {
		extract_error \
		    "ERROR: Bad line between\
		     `HPCM_BEGIN $filename' and\
		     `HPCM_END $filename':\n$line"
	    }
	}

	close_file

	# Look for next non-blank line.
	#
	set line [read_non_blank_line]
	if { $line == "" } break
    }

} else {

    if { [info exists format_submissions] \
	 && $format_submissions == "yes" } {
	extract_error \
	    "ERROR: Bad line in body before\
	     `HPCM_BEGIN' line or unformatted\
	     file:\n$line"
    }

    # Input is unformatted.  Loop through files in
    # input.
    #
    set file_ch ""
    set mode none
    set blank_lines ""
    while { ! [eof $received_ch] } {

	# Accumulate non-blank lines and look for
	# filename.
	#
	set lines ""
	set filename ""
    	while { [regexp $NWS $line] } {

	    if { [regexp \
	    	    "(^|$WS)File:$WS*($NWS+)(\$|$WS)" \
		    $line forget1 forget2 fname \
		    forget3] } {
		lappend filename $fname
	    }
	    lappend lines $line
	    set line [gets $received_ch]
	    if { [eof $received_ch] } break
	}

	switch [llength $filename] {
	    0 {
		if { $mode == "none" } {
		    if { [llength $filenames] != 1 } {
			extract_error \
			    "ERROR: no file name in\
			     `Subject"' field or body"
		    }
		    set mode \
			[open_file [lindex $filenames \
					   0]]
		} else {
		    set lines \
		        [concat $blank_lines $lines]
	        }
	    }
	    1 {
	        if { $mode != "none" } {
		    close_file
		}
		set mode \
		    [open_file [lindex $filename 0]]
	    }
	    default {
	        extract_error \
		    "ERROR: too many file names:\
		     $filename"
	    }
	}

	switch $mode {
	    read {
	        foreach line $lines {
		    set file_line [gets $file_ch]
		    if { $file_line != $real_line } {
			extract_error \
			    "SYSTEM ERROR: file\
			     mismatch for `$filename'
		    }
		}
	    }
	    write {
	        foreach line $lines {
		    puts $file_ch $line
		}
	    }
	}

	# Accumulate blank lines.
	#
	set blank_lines ""
	while { ! [eof $received_ch] } {
	    lappend blank_lines $line
	    set line [gets $received_ch]
	    if { [regexp $NWS $line] } break
	}

	if { [eof $received_ch] } {
	    if { $mode != none } close_file
	    break
	}
    }
}

# Close received_ch and exit.
#
close $received_ch
puts $filename
exit 0

# Include common error catching code:
#
} caught_output
caught_error
