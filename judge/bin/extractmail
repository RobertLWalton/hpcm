#!/bin/sh
#
# Extract submitted program from received mail file.
#
# File:		extractmail
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Nov 18 03:11:24 EST 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/11/18 08:47:29 $
#   $RCSfile: extractmail,v $
#   $Revision: 1.19 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory; extractmail

    Reads the `$received_file' file in the current direc-
    tory.  Thus file must contain an email with a sub-
    ject line of the form:

    	Subject: submit filename

    or

    	Subject: submit problemname

    In the first case there is only one file, which must
    have the given name; in the second case, there may
    be more than one file.  Note that problem names may
    not contain `.'.  The submitted files are extracted
    from the email and placed in the current directory.

    For each file successfully extracted, this program
    prints the line `Extracted FFFF' to the standard
    output, where FFFF is the file name.  For each
    error, this program prints an error message to the
    standard error output.  This program always exists
    with exit code 0.  The TCL command:

    	catch { exec extractmail } out

    will capture both the standard and error outputs in
    the variable `out' and return a code indicating
    whether there were any errors.  If there were errors
    that concern the judge, and not just the submitter,
    the text `SYSTEM ERROR' appears in the error output.
    Otherwise the value of `out' will be suitable for
    inclusion in a reply to the submitter.

    If there is a `$files_file' file in the current\
    			directory,
    all submitted files must have names listed in this
    `$files_file' file.  This file consists of file names
    separated by whitespace (either spaces or tabs or
    new lines).  If one of these file names begins with
    a `?', the `?' is discarded from the file name, and
    the file is optional.  Otherwise the file must be
    included in the submission.  If there is no\
    	`$files_file'
    file, the submitted file name must be the problem
    name followed by one of the extensions in the
    `allowed_extensions' global variable, whose value by
    default is:

    	$allowed_extensions
    
    The submitted files may be encoded in the body of
    the message in the format:

   	HPCM_BEGIN filename
	..<1st line of file>
	..<2nd line of file>
	<more lines, each preceded by `..'>
	HPCM_END filename

    This format MUST be used if the `format_submissions'
    variable is defined and equal to `yes'.  If this
    format is used, there must be nothing else in the
    body of the message except blank lines preceding and
    following the files.
    
    If this format is NOT used, the files name be in-
    cluded verbatim in the body of the message.  Files
    must be separated by blank lines, and there may be
    blank lines preceding the first file and following
    the last file.  All these blank lines will be dis-
    carded, and not treated as part of any file.  If
    there is more than one file, or if the `Subject:'
    field of the $received_file file does not give the
    filename, then each file must begin with a block of
    non-blank lines, exactly one of which contains
    text of the form `File: FFFF', where FFFF is the
    file name.  This text may be surrounded by white-
    space (spaces and tabs), there may be no or any
    kind of whitespace between the `:' and FFFF, but
    there must be no whitespace in the FFFF.  If a file
    name is given by both this method and in the
    `Subject:' field, the names must match.  If files
    are given verbatim in the body of the message, the
    files may not begin with `HPCM_BEGIN'.

    If a submitted file already exists and has a modifi-
    cation time equal to or later than that of the
    $received_file file, the submitted file is NOT writ-
    ten, but is instead compared to the existing file.
    If the comparison matches, the `Extracted FFFF' out-
    put line is generated, but if there is a mismatch,
    an error message is generated.

    It is an error if a file name contains `/' or begins
    with `.' or `-'.  It is a system error if the
    `Subject:' field does not begin with `submit', or
    if the $received_file or `$files_file' files are
    unreadable."

if { $argc != 0 } {
    puts $document
    exit 1
}

# Create a reply file complaining of a submission
# error, and email this reply to the submitter.  Include
# the submission email in the reply.
#
proc extract_error_reply { args } {
    eval reply -all \
         {"ERROR during submission file extraction:"} \
	 $args \
	 {""} \
	 {"THIS SUBMISSION (see below) IGNORED"} \
	 {"YOU MUST RESUBMIT"}

    exit_cleanup
    exit 0
}

# Read the header.
#
set received_ch [open $received_file r]
read_header $received_ch

# Check for legality of subject line:
#
if { [llength $message_subject] == 0 } {
    error "Missing or empty `Subject:' field"
} elseif { [lindex $message_subject 0] != "submit" } {
    extract_error_reply \
	"Badly formatted subject field:" \
	"Subject: $message_subject"
} elseif { [llength $message_subject] != 2 } {
    extract_error_reply \
	"Badly formatted subject field:" \
	"Subject: $message_subject"
}

# Extract the filename and check its legality.
#
set filename [lindex $message_subject 1]

if { [regexp {^\.|^-|/} $filename] } {
    extract_error_reply \
        "Illegal filename (has `/' or beginning `.'\
			   or beginning `-'):\
	 $filename"
}

# If named file is readable and is more recent than the
# received mail file, then print the file name and exit
# without error.
#
if { [file readable $filename] \
     && [file mtime $received_file] \
	 <= [file mtime $filename] } {
    puts $filename
    exit 0
}

# If $filename exists, delete it.
#
if { [file exists $filename] } {
    puts "Deleting out-of-date $filename"
    file delete -force $filename
}

set WS "\[\ \t\]"
set NWS "\[^\ \t]"

# Look for HPCM_BEGIN line or beginning of file.
#
while { "yes" } {

    set line [gets $received_ch]
    if { [eof $received_ch] } {
        extract_error_reply \
	    "Could not find `HPCM_BEGIN' or other\
	     non-blank line in message body."
    } elseif { [regexp "^HPCM_BEGIN$WS+($NWS+)$WS*\$" \
                       $line forget beginname] \
	       && $beginname == $filename } {
	set hpcm_begin_found yes
    	break
    } elseif { [regexp {^HPCM_BEGIN} $line] } {
    	extract_error_reply \
	    "Badly formatted HPCM_BEGIN line:" $line
    } elseif { [regexp "^$WS*\$" $line] } {
    	# blank lines are ok
    } else {
	if { [info exists format_submissions] \
	     && $format_submissions == "yes" } {
	    extract_error_reply \
		"Bad line in body before `HPCM_BEGIN'\
		 line:" \
		$line
	} else {
	    set hpcm_begin_found no
	    break
	}
    }
}

# Prepare to copy file.
#
set file_ch [open $filename w]

# Set cleanup for error exits.
#
proc exit_cleanup {} {
    global file_ch filename
    close $file_ch
    file delete -force $filename
}

if { $hpcm_begin_found } {

    # Copy file removing beginning `..'s until HPCM_END
    # line found.
    #
    while { "yes" } {
	set line [gets $received_ch]
	if { [eof $received_ch] } {
	    extract_error_reply \
		"Could not find HPCM_END line."
	} elseif { [regexp {^\.\.(.*)$} $line \
			   forget real_line] } {
	    puts $file_ch $real_line
	} elseif { [regexp \
	              "^HPCM_END$WS+($NWS+)$WS*\$" \
		      $line forget endname] \
		   && $endname == $filename } {
	    break
	} elseif { [regexp "^HPCM_END" $line] } {
	    extract_error_reply \
		"Badly formatted HPCM_END line:" $line
	} else {
	    extract_error_reply \
		"Bad line between HPCM_BEGIN and\
		 HPCM_END:" $line
	}
    }

    # Look for extaneous non-blank text after HPCM_END
    # line.
    #
    while { "yes" } {
	set line [gets $received_ch]
	if { [eof $received_ch] } {
	    break
	} elseif { [regexp "^$WS*\$" $line] } {
	    # blank lines are ok
	} else {
	    extract_error_reply \
		"Bad line after HPCM_END:" $line
	}
    }
} else { # not $hpcm_begin_found
    while { "yes" } {
	puts $file_ch $line
	set line [gets $received_ch]
	if { [eof $received_ch] } break
    }
}

# Close files, print name of submitted file, and exit
# without error.
#
close $file_ch
close $received_ch
puts $filename
exit 0

# Include common error catching code:
#
} caught_output
caught_error
