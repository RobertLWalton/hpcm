#!/bin/sh -f
#
# Extract submitted program from received mail file.
#
# File:		extractmail
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Aug 16 06:41:25 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/24 00:06:04 $
#   $RCSfile: extractmail,v $
#   $Revision: 1.7 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"
catch {

set document "
cd submission_directory; extract

    Reads the `$received_file' file in the current
    directory.  Thus file must have a subject line of
    the form:

    	Subject: submit filename

    The submitted file is extracted from the email and
    placed in the current directory.  The submitted file
    must be encoded in the body of the message in the
    format:

   	BEGIN filename
	..<1st line of file>
	..<2nd line of file>
	<more lines, each preceded by `..'>
	END filename

    There may be nothing else in the body of the message
    except blank lines preceding and following the file.

    If the submission email has a `Subject' line as
    above and the filename given is for an already
    existing readable file, this program terminates
    without error and without doing anything other than
    finding and reading the `Subject' line and printing
    the name of the submitted file to the standard
    output.

    If this program succeeds in extracting the submitted
    file without error, this program prints the name
    of the submitted file to the standard output as a
    single line, and prints nothing else.

    Otherwise, if the submitted email has even the
							/
    slightest formatting error, this program constructs
    a `$reply_file' file giving reasons why the sub-
    mission email is invalid.  This `$reply_file' is
    sent to the email address that is part of the
    current directory name.  In this case this program
    exits with error code 0, indicating no error, but
    does not write anything to the standard output,
    indicating no file was extracted.
    
    This program exits with non-zero error code only if
    something is very wrong, e.g. the `$received_file'
    file is not readable or the `$reply_file' file is
    not writable."

if { $argc != 0 } {
    puts $document
    exit 1
}

# Create a reply file complaining of a submission
# error, and email this reply to the submitter.  Include
# the submission email in the reply.
#
proc extract_error_reply { args } {
    eval reply -all \
         {"ERROR during submission file extraction:"} \
	 $args \
	 {""} \
	 {"THIS SUBMISSION (see below) IGNORED"} \
	 {"YOU MUST RESUBMIT"}

    make_checked
    exit 0
}

# Start reading $received_file.
#
set received_ch [open $received_file r]

# Look for subject line.
#
while { "yes" } {
    set line [gets $received_ch]
    if { [eof $received_ch] } {
        extract_error_reply \
	    "Could not find `Subject' line."
    } elseif { [regexp \
		    "^Subject: submit (\[^\ \t\]*)\$" \
                    $line all filename] } {
	break
    } elseif { [regexp {^Subject:} $line] } {
    	extract_error_reply \
	    "Badly formatted subject line"
    } elseif { [regexp $Header_line_regexp $line] } {
    	# header lines are ok
    } else {
    	extract_error_reply \
	    "Bad line in header before `Subject'\
	         line:" \
	    $line
    }
}

# Check that `filename' is legal.
#
if { [regexp {^\.|\/} $filename] } {
    extract_error_reply \
        "Illegal filename (has `/' or beginning `.'):\
	 $filename"
}

# If named file is readable exit without error.
#
if { [file readable $filename] } {
    puts $filename
    exit 0
}

# Look for first non-header line.
#
while { "yes" } {
    set line [gets $received_ch]
    if { [eof $received_ch] } {
        extract_error_reply \
	    "Could not find message body."
    } elseif { ! [regexp $Header_line_regexp $line] } {
    	break
    }
}

# Look for BEGIN line.
#
while { "yes" } {
    if { [regexp "^BEGIN $filename\$" $line] } {
    	break
    } elseif { [regexp {^BEGIN} $line] } {
    	extract_error_reply \
	    "Badly formatted BEGIN line:" $line
    } elseif { [regexp {^[ 	]*$} $line] } {
    	# blank lines are ok
    } else {
    	extract_error_reply \
	    "Bad line in body before `BEGIN'\
	         line:" \
	    $line
    }
    set line [gets $received_ch]
    if { [eof $received_ch] } {
        extract_error_reply \
	    "Could not find `BEGIN' line."
    }
}

# If $filename exists, delete it.  Then open it for
# writing.
#
if { [file exists $filename] } {
    file delete -force $filename
}
set file_ch [open $filename w]

# Copy file, looking for END line.
#
while { "yes" } {
    set line [gets $received_ch]
    if { [eof $received_ch] } {
        close $file_ch
	file delete -force $filename
        extract_error_reply \
	    "Could not find END line."
    } elseif { [regexp {^\.\.(.*)$} $line \
                       all real_line] } {
	puts $file_ch $real_line
    } elseif { [regexp "^END $filename\$" $line] } {
    	break
    } elseif { [regexp "^END" $line] } {
        close $file_ch
	file delete -force $filename
        extract_error_reply \
	    "Badly formatted END line:" $line
    } else {
        close $file_ch
	file delete -force $filename
        extract_error_reply \
	    "Bad line between BEGIN and END:" $line
    }
}

close $file_ch

# Look for extaneous non-blank text after END line.
#
while { "yes" } {
    set line [gets $received_ch]
    if { [eof $received_ch] } {
	break
    } elseif { [regexp {^[ 	]*$} $line] } {
    	# blank lines are ok
    } else {
	file delete -force $filename
        extract_error_reply \
	    "Bad line after END:" $line
    }
}

# Close received email file, print name of submitted
# file, and exit without error.
#
close $received_ch
puts $filename
exit 0

# Include common error catching code:
#
} caught_output
caught_error
