#!/bin/sh
#
# Extract submitted program from received mail file.
#
# File:		extractmail
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Thu Nov  8 06:25:35 EST 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/11/08 11:26:51 $
#   $RCSfile: extractmail,v $
#   $Revision: 1.18 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory; extractmail

    Reads the `$received_file' file in the current
    directory.  Thus file must have a subject line of
    the form:

    	Subject: submit filename

    The submitted file is extracted from the email and
    placed in the current directory.  The submitted file
    may simply be the body of the $received_file file
    message, or the submitted file may be encoded in the
    body of the message in the format:

   	HPCM_BEGIN filename
	..<1st line of file>
	..<2nd line of file>
	<more lines, each preceded by `..'>
	HPCM_END filename

    This format MUST be used if the `format_submissions'
    variable is defined and equal to `yes'.  If this
    format is used, there must be nothing else in the
    body of the message except blank lines preceding and
    following the file.  If this format is NOT used, and
    the file is the entire body of the message, blank
    lines at the beginning of the file will be deleted
    when the file is extracted.  Also in this case the
    file may NOT begin with the word `HPCM_BEGIN'.

    If this program succeeds in extracting the submitted
    file without error, this program prints the name
    of the submitted file to the standard output as a
    single line, and prints nothing else.

    If the submission email has a `Subject' line as
    above and the filename given is for an already
    existing readable file whose modification time is
    more recent that that of the `$received_file' file,
    this program terminates without error and without
    doing anything beyond reading the `Subject' line
    and printing the name of the submitted file to the
    standard output.

    If the submitted email has even the slightest for-
    matting error, or if the filename is illegal (con-
    tains a `/', or begins with either `.' or `-') this
    program constructs a `$reply_file' file giving
    reasons why the submission email is invalid.  This
    `$reply_file' file is emailed to the submitter.  In
    this case this program exits with exit code 0,
    indicating no error, but does not print anything to
    the standard output, indicating no file was extract-
    ed.

    If something goes very wrong, such as finding that
    the `$received_file' file is not readable, this
    program creates an error log file in the current
    directory, does not print anything on the standard
    output (but does print on the error output), and
    exits with exit code 0.  The program also does this
    if the `Subject:' field value is such that `auto-
    dispatch' will not invoke the `autojudge' program
    (the value is empty, or does not have a first item
    equal to `submit')."

if { $argc != 0 } {
    puts $document
    exit 1
}

# Create a reply file complaining of a submission
# error, and email this reply to the submitter.  Include
# the submission email in the reply.
#
proc extract_error_reply { args } {
    eval reply -all \
         {"ERROR during submission file extraction:"} \
	 $args \
	 {""} \
	 {"THIS SUBMISSION (see below) IGNORED"} \
	 {"YOU MUST RESUBMIT"}

    exit_cleanup
    exit 0
}

# Read the header.
#
set received_ch [open $received_file r]
read_header $received_ch

# Check for legality of subject line:
#
if { [llength $message_subject] == 0 } {
    error "Missing or empty `Subject:' field"
} elseif { [lindex $message_subject 0] != "submit" } {
    extract_error_reply \
	"Badly formatted subject field:" \
	"Subject: $message_subject"
} elseif { [llength $message_subject] != 2 } {
    extract_error_reply \
	"Badly formatted subject field:" \
	"Subject: $message_subject"
}

# Extract the filename and check its legality.
#
set filename [lindex $message_subject 1]

if { [regexp {^\.|^-|/} $filename] } {
    extract_error_reply \
        "Illegal filename (has `/' or beginning `.'\
			   or beginning `-'):\
	 $filename"
}

# If named file is readable and is more recent than the
# received mail file, then print the file name and exit
# without error.
#
if { [file readable $filename] \
     && [file mtime $received_file] \
	 <= [file mtime $filename] } {
    puts $filename
    exit 0
}

# If $filename exists, delete it.
#
if { [file exists $filename] } {
    puts "Deleting out-of-date $filename"
    file delete -force $filename
}

set WS "\[\ \t\]"
set NWS "\[^\ \t]"

# Look for HPCM_BEGIN line or beginning of file.
#
while { "yes" } {

    set line [gets $received_ch]
    if { [eof $received_ch] } {
        extract_error_reply \
	    "Could not find `HPCM_BEGIN' or other\
	     non-blank line in message body."
    } elseif { [regexp "^HPCM_BEGIN$WS+($NWS+)$WS*\$" \
                       $line forget beginname] \
	       && $beginname == $filename } {
	set hpcm_begin_found yes
    	break
    } elseif { [regexp {^HPCM_BEGIN} $line] } {
    	extract_error_reply \
	    "Badly formatted HPCM_BEGIN line:" $line
    } elseif { [regexp "^$WS*\$" $line] } {
    	# blank lines are ok
    } else {
	if { [info exists format_submissions] \
	     && $format_submissions == "yes" } {
	    extract_error_reply \
		"Bad line in body before `HPCM_BEGIN'\
		 line:" \
		$line
	} else {
	    set hpcm_begin_found no
	    break
	}
    }
}

# Prepare to copy file.
#
set file_ch [open $filename w]

# Set cleanup for error exits.
#
proc exit_cleanup {} {
    global file_ch filename
    close $file_ch
    file delete -force $filename
}

if { $hpcm_begin_found } {

    # Copy file removing beginning `..'s until HPCM_END
    # line found.
    #
    while { "yes" } {
	set line [gets $received_ch]
	if { [eof $received_ch] } {
	    extract_error_reply \
		"Could not find HPCM_END line."
	} elseif { [regexp {^\.\.(.*)$} $line \
			   forget real_line] } {
	    puts $file_ch $real_line
	} elseif { [regexp \
	              "^HPCM_END$WS+($NWS+)$WS*\$" \
		      $line forget endname] \
		   && $endname == $filename } {
	    break
	} elseif { [regexp "^HPCM_END" $line] } {
	    extract_error_reply \
		"Badly formatted HPCM_END line:" $line
	} else {
	    extract_error_reply \
		"Bad line between HPCM_BEGIN and\
		 HPCM_END:" $line
	}
    }

    # Look for extaneous non-blank text after HPCM_END
    # line.
    #
    while { "yes" } {
	set line [gets $received_ch]
	if { [eof $received_ch] } {
	    break
	} elseif { [regexp "^$WS*\$" $line] } {
	    # blank lines are ok
	} else {
	    extract_error_reply \
		"Bad line after HPCM_END:" $line
	}
    }
} else { # not $hpcm_begin_found
    while { "yes" } {
	puts $file_ch $line
	set line [gets $received_ch]
	if { [eof $received_ch] } break
    }
}

# Close files, print name of submitted file, and exit
# without error.
#
close $file_ch
close $received_ch
puts $filename
exit 0

# Include common error catching code:
#
} caught_output
caught_error
