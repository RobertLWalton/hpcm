#!/bin/sh -f
#
# Given a submission directory, be sure autodispatch
# has run, and then if necessary dispatch to programs
# such and `manualscore' and `manualreply'.
#
# File:		manualdispatch
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Fri Sep 15 11:30:16 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/09/15 16:42:56 $
#   $RCSfile: manualdispatch,v $
#   $Revision: 1.1 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# If an subdirectory name is given, make it current, and
# consume the subdirectory name argument.  This must be
# done before looking for the parameters file.
#
# Don't change argc or argv so error output will work.
#
set my_argc $argc
set my_argv $argv
if { $my_argc >= 1 \
     && ! [regexp {^-} [lindex $my_argv 0]] } {
    cd [lindex $my_argv 0]
    set my_argv [lreplace $my_argv 0 0]
    set my_argc [expr { $my_argc - 1 }]
}

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
manualdispatch \[directory\] \[-force\]

    If the directory argument is given, this program
    makes that directory current before searching for
    the `$judging_parameters_file' file or doing\
    anything else.

    This program then checks to see if there is evidence
    that autodispatch has run.  If not, it runs auto-
    dispatch.

    This program next creates the $dispatch_pid_file
    file containing the process ID of this program's
    process.  If this file already exists, this program
    exits without error or output.

    Otherwise this program makes its process into a
    process group leader, so the UNIX command

    	kill -INT -`cat $dispatch_pid_file`

    will kill this process and all its subprocesses.
    When this program exits, it deletes the
    $dispatch_pid_file file.

    This program then exits without error or output if
    any of the files:

    	$reply_file
    	$no_reply_file

    exist.  The `-force' option prevents such an exit.

    Otherwise, if the use_authentication global variable
    equals `yes', this program next authenticates the
    mail in $received_file file.  If the mail is NOT
    authentic, this program produces an error log file
    but does NOT exit.

    Then this program looks for an $auto_score_file\
    			file
    in the current directory and if present calls:

	manualscore

    Otherwise this program calls:

    	manualreply

    Finally this program exits without error or output,
    except for output produced by manualscore or other
    called program."

# Check for and consume -force option.
#
set force_option no
if { $my_argc >= 1 \
     && [lindex $my_argv 0] == "-force" } {
    set force_option yes
    set my_argv [lreplace $my_argv 0 0]
    set my_argc [expr { $my_argc - 1 }]
}

# If there are leftover arguments, print document and
# exit with error.
#
if { $my_argc != 0 } {
    puts $document
    exit 1
}

# Run autodispatch if only file present is $received_
# file and that has appropriate subject.

if { [glob -nocomplain *] == $received_file } {
    set received_ch [open $received_file r]
    read_header $received_ch
    close $received_ch

    if { [llength $message_subject] >= 2 \
         && [lsearch -exact {submit get} \
	             [lindex $message_subject 0]] \
	    >= 0 } {
    	puts "Execting autoscore"
	exec autoscore >@ stdout 2>@ stderr
    }
}

echo $dispatch_pid_file

# Lock current directory with $dispatch_pid_file.  If
# $dispatch_pid_file already exists, let our user
# take corrective action.
#
while { "yes" } {

    if { [dispatch_lock] == "yes" } break

    set time [expr { [clock seconds] - \
                     [file mtime $dispatch_pid_file] }]

    set group_display ""
    if { ! [catch { set pgid \
                        [read_file \
			    $dispatch_pid_file] }] } {
        set group_display \
	    [display_process_group $pgid]
        set group_display \
	    "\nProcess Group Tree:\n\n$group_display"
    }

    puts -nonewline "
$dispatch_pid_file file exists and is $time seconds old.
$group_display

What do you want to do?

u = update above info		d = delete\
                                    $dispatch_pid_file
k = kill -INT process group	x = exit this program
m = kill -KILL process group

> "
    set answer [string trim [gets stdin]]

    switch $answer \
	u	{
	} \
	k	{
	    catch {
		signal_process_group INT \
		    [read_file $dispatch_pid_file]
	    } out
	    puts $out
	} \
	m	{
	    catch {
		signal_process_group KILL \
		    [read_file $dispatch_pid_file]
	    } out
	    puts $out
	} \
	d {
	    file delete -force $dispatch_pid_file
	} \
	x {
	    exit_cleanup
	    exit 0
	} \
	default {
	    puts "Unknown: $answer"
	}
}

# Set exit_cleanup function (called before all exits
# in judging common code) to unlock current directory.
#
proc exit_cleanup {} {
    dispatch_unlock
}

# If one of several files exists, and there is no
# -force option, exit without error.
#
if { $force_option == "no" \
     && [llength [glob -nocomplain \
                        $reply_file $no_reply_file]] \
        != 0 } {
    exit_cleanup
    exit 0
}

# Read header.
#
set received_ch [open $received_file r]
read_header $received_ch
close $received_ch

# Check authentication if $use_authentication is `yes'.
# If not authenticated, write log error and exit.
#
if { [header_is_authentic] == "no" } {
    log_error \
        "Received message header is not authentic"
}

# Call program depending on existence of $auto_score_
# file.
#
if { [file exists $auto_score_file] } {
    exec manualscore >@ stdout 2>@ stderr
} else {
    exec manualreply >@ stdout 2>@ stderr
}

# If we did nothing, another program will see there
# is no $dispatch_pid_file, $reply_file, etc., and
# schedule manual action.

exit_cleanup
exit 0

# Include common error catching code:
#
} caught_output
caught_error
