#!/bin/sh
#
# Remake a problem Makefile made from prototypes.
#
# File:		remakeMakefile
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Tue Aug 17 02:47:42 EDT 2010
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2010/08/17 06:50:34 $
#   $RCSfile: remakeMakefile,v $
#   $Revision: 1.12 $
#
# The next lines start tclsh \
trap "echo remakeMakefile: Terminated by Signal" \
    HUP INT QUIT; \
tclsh "$0" "$@"; exit $status

set document "
remakeMakefile checkfile sourcefile problemdir ...

    For each problemdir, this program makes temporary
    modified versions of checkfile and sourcefile using
    information from problemdir/Makefile file.  Then
    this program copies the modified sourcefile to
    problemdir/Makefile if the modified checkfile exact-
    ly equals problemdir/Makefile and the modified
    sourcefile does NOT exactly equal problemdir/Make-
    file.
    
    If checkfile is \"\" the test that checkfile equals
    problemdir/Makefile is omitted.
    
    If sourcefile is \"\" the copy of sourcefile to
    problemdir/Makefile is omitted.

    If problemdir is not actually a directory, this is
    merely noted in the output.  Problemdir must end in
    the problem name; it CANNOT be `.'.

    The modification of a Makefile consists of:
    
        1. Replacing the first line of the file by the
	   first line of problemdir/Makefile.
	   
	2. Replacing the `problem_name' of any file line
	   of the form

		P = problem_name

	   with the last component of `problemdir'  Here
	   the `=' must be surrounded by single SPACE
	   characters, but other spacing may vary.

	3. Replacing any file line that matches

		#	\$Xxxx: ... $

	   by the corresponding line of problemdir/Make-
	   file if the lines match except for the `...'
	   and Xxxx is any of `Author', `Date',
	   `RCSfile', or `Revision'.

    The last modification (3) is NOT made when the mod-
    ified sourcefile is copied to problemdir/Makefile.

    The final disposition of each problemdir/Makefile is
    printed.

    Unlike most HPCM judging programs, this program does
    not read any hpcm_judging.rc file and errors made by
    this program are not written to log files."

# If too few arguments or first argument begins with
# `-', print documentation and exit with error.
#
if { $argc < 3 || [regexp {^-} [lindex $argv 0]] } {
    puts $document
    exit 1
}

# Process arguments.
#
set checkfile [lindex $argv 0]
set sourcefile [lindex $argv 1]

# Constants
#
set WS "\[\ \t\]"
set NWS "\[^\ \t\]"
set RCS_keys { Author Date RCSfile Revision }

# Function returns 1 if modified file equals problemdir/
# Makefile, and 0 otherwise.
#
proc test_file { file problemdir } {

    global WS NWS RCS_keys
    set RCS_match \
        "^(#$WS*)\\\$(\[^:\]*):(\[^\$\]*)\\\$($WS*)\$"

    set problem [file tail $problemdir]
    set file_ch [open $file r]
    set out_ch [open $problemdir/Makefile r]
    set first yes

    while { "yes" } {
	set file_line [gets $file_ch]
	set out_line [gets $out_ch]
	if { [eof $file_ch] } {
	    set match [eof $out_ch]
	    break
	} elseif { [eof $out_ch] } {
	    set match 0
	    break
	}
	if { $first } {
	    set first no
	} else {
	    if { [regexp \
		      "^($WS*)P = $NWS+($WS*)\$" \
		      $file_line forget \
		      bws ews] } {
		set file_line \
		    "${bws}P = $problem$ews"
	    } elseif { \
	           [regexp $RCS_match $file_line \
		           forget \
			   fbegin fname fstuff fend] \
	        && [regexp $RCS_match $out_line \
		           forget \
			   obegin oname ostuff oend] \
		&& [lsearch -exact $RCS_keys $fname] \
		   >= 0 \
		&& $fbegin == $obegin \
		&& $fname == $oname \
		&& $fend == $oend } {
	        set file_line $out_line
	    }
	    if { $file_line != $out_line } {
		set match 0
		break
	    }
	}
    }
    close $file_ch
    close $out_ch
    return $match
}

# Function to copy modified file to problemdir/Makefile.
# The target is deleted after its first line is read.
#
proc copy_file { file problemdir } {

    global WS NWS

    set problem [file tail $problemdir]
    set file_ch [open $file r]
    set out_ch [open $problemdir/Makefile r]
    set first_line [gets $out_ch]
    close $out_ch
    file delete -force $problemdir/Makefile
    set out_ch [open $problemdir/Makefile w]
    set first yes

    while { "yes" } {
	set file_line [gets $file_ch]
	if { [eof $file_ch] } break
	if { $first } {
	    set first no
	    set file_line $first_line
	} elseif { [regexp \
		      "^($WS*)P = $NWS+($WS*)\$" \
		      $file_line forget \
		      bws ews] } {
	    set file_line "${bws}P = $problem$ews"
	}
	puts $out_ch $file_line
    }
    close $file_ch
    close $out_ch
}

foreach problemdir [lrange $argv 2 end] {

    if { ! [file isdirectory $problemdir] } {
        puts "$problemdir is not a directory"
	continue
    }

    if { ! [file isfile $problemdir/Makefile] } {
        puts "$problemdir/Makefile does not exist"
	continue
    }

    if {      $checkfile != "" \
         && ! [test_file $checkfile $problemdir] } { \
	puts "$problemdir/Makefile does NOT equal\
	      modified $checkfile"
	continue
    }

    if {    $sourcefile != "" \
         && [test_file $sourcefile $problemdir] } { \
	puts "$problemdir/Makefile equals\
	      modified $sourcefile"
        continue
    }

    if { $sourcefile != "" } {
	copy_file $sourcefile $problemdir
	puts "modified $sourcefile copied to\
	      $problemdir/Makefile"
    } elseif { $checkfile != "" } {
	puts "$problemdir/Makefile equals\
	      modified $checkfile"
    } else {
	puts "$problemdir/Makefile not changed"
    }
}

exit 0
