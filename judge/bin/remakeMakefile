#!/bin/sh
#
# Remake a problem Makefile made from prototypes.
#
# File:		remakeMakefile
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Feb 13 00:21:58 EST 2002
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2002/02/13 05:20:36 $
#   $RCSfile: remakeMakefile,v $
#   $Revision: 1.5 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

set document "
remakeMakefile checkfile sourcefile problemdir ...

    For each problemdir, this program makes temporary
    modified versions of checkfile and sourcefile using
    information from problemdir/Makefile file.  Then
    this program copies the modified sourcefile to the
    problemdir/Makefile if the modified checkfile exact-
    ly equals problemdir/Makefile and the modified
    sourcefile does NOT exactly equal problemdir/Make-
    file.  If checkfile is \"\" the test that checkfile
    equals problemdir/Makefile is omitted.

    The modification of a Makefile consists of replacing
    the first line of the file by the first line of
    problemdir/Makefile, and replacing the `problem_
    name' of any file line of the form

    	P = problem_name

    with the last component of `problemdir'.  Here the
    `=' must be surrounded by single SPACE characters,
    but other spacing may vary.

    Unlike most HPCM judging programs, this program does
    not read any hpcm_judging.rc file and errors made by
    this program are not written to log files."

# If too few arguments or first argument begins with
# `-', print documentation and exit with error.
#
if { $argc < 3 || [regexp {^-} [lindex $argv 0]] } {
    puts $document
    exit 1
}

# Process arguments.
#
set checkfile [lindex $argv 0]
set sourcefile [lindex $argv 1]
set WS "\[\ \t\]"
set NWS "\[^\ \t\]"

# Function returns 1 if modified file equals problemdir/
# Makefile, and 0 otherwise.
#
proc test_file { file problemdir } {

    global WS NWS

    set problem [file tail $problemdir]
    set file_ch [open $checkfile r]
    set out_ch [open $problemdir/Makefile r]
    set first yes

    while { "yes" } {
	set file_line [gets $file_ch]
	set out_line [gets $out_ch]
	if { [eof $file_ch] } {
	    set match [eof $out_ch]
	    break
	} elseif { [eof $out_ch] } {
	    set match 0
	    break
	}
	if { $first } {
	    set first no
	} else {
	    if { [regexp \
		      "^($WS*)P = $NWS+($WS*)\$" \
		      $file_line forget \
		      bws ews] } {
		set file_line \
		    "${bws}P = $problem$ews"
	    }
	    if { $file_line != $out_line } {
		set match 0
		break
	    }
	}
    }
    close $file_ch
    close $out_ch
    return $match
}

# Function to copy modified file to problemdir/Makefile.
# The target is deleted after its first line is read.
#
proc copy_file { file problemdir } {

    global WS NWS

    set problem [file tail $problemdir]
    set file_ch [open $checkfile r]
    set out_ch [open $problemdir/Makefile r]
    set first_line [gets $out_ch]
    close $out_ch
    file delete -force $problemdir/Makefile
    set out_ch [open $problemdir/Makefile w]
    set first yes

    while { "yes" } {
	set file_line [gets $file_ch]
	if { [eof $file_ch] } break
	if { $first } {
	    set first no
	    set file_line $first_line
	} else {
	    if { [regexp \
		      "^($WS*)P = $NWS+($WS*)\$" \
		      $file_line forget \
		      bws ews] } {
		set file_line \
		    "${bws}P = $problem$ews"
	    }
	    puts $out_ch $file_line
	}
    }
    close $file_ch
    close $out_ch
}

foreach problemdir [lrange $argv 2 end] {

    if {      $checkfile != "" \
         && ! [test_file $checkfile $problemdir] } \
	continue

    if { [test_file $sourcefile $problemdir] } \
        continue

    copy_file $sourcefile $problemdir
}

exit 0
