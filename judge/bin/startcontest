#!/bin/sh
#
# Start the contest by setting permissions on files.
#
# File:		startcontest
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Jan  2 14:46:19 EST 2006
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2006/01/02 19:49:12 $
#   $RCSfile: startcontest,v $
#   $Revision: 1.7 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl

# Abbreviation for use in this file.
#
set c_d $judging_directory/contest

# Set log mode, saving old mode.
#
set log_globally yes
set saved_log_mode $log_mode
set log_mode none

catch {

set document "
startcontest \[delay\]

    This program merely sets a+rx permissions on the
    directory 

    	<judging_directory>/contest/problems
	
    and a+r permissions on the file
    
    	<judging_directory>/contest/help/problems
	
    if these exist.

    However, if the current time is before any absolute
    time value of the scoreboard_start_time global var-
    iable, it is an error if the program is run without
    the `delay' option.  But if the `delay' option is
    given, this program spawns a child that waits until
    the scoreboard_start_time and then sets permissions
    as above and emails the judge that the contest has
    started.

    If this program spawns a child with the `delay'
    option, it writes the process ID of the child into
    the Startcontest_PID file in the judging directory.
    If there already is such a file and the process it
    identifies is still running, this program will not
    spawn a child and will do nothing but print out
    information about the ID'ed process.
    
    Unlike most HPCM judging programs, errors made by
    this program are not written to log files, but are
    written to the standard error output instead."


# If there are any illegal arguments print documentation
# and exit with error.
#
set arg [lindex $argv 0]
if { $argc > 1 || \
     ! [lcontain {{} delay -WAIT-} $arg] } {
    puts $document
    exit 1
}

set pid_file $judging_directory/Startcontest_PID
set wrote_pid_file no

# If we have nothing to do, announce this and exit.
#
if { (    ! [file isdirectory $c_d/problems] \
       || [regexp {r.x} [get_access $c_d/problems]] ) \
     && \
     (    ! [file isfile $c_d/help/problems] \
       || [regexp {r..} \
                  [get_access \
		       $c_d/help/problems]] ) } {

    puts "startcontest has been done previously"
    exit 0
}

# Do something if scoreboard_start_time is a date and
# time.
#
set stime $scoreboard_start_time
if { ! [regexp {^(|problem|team)$} $stime] } {

    if { [catch { set stime [clock scan $stime] }] } {
	error "badly formatted scoreboard_start_time:\
	       $scoreboard_start_time"
    }
    switch -- $arg {
    "" {

        # If no argument, just announce error if it is
	# too early, and fall through to grant permis-
	# sions.
	#
    	if { [clock seconds] < $stime } {
	    puts "Not yet at scoreboard_start_time:\
	          $scoreboard_start_time"
	    puts "so startcontest did nothing."
	    exit 1
	}
    }
    delay {

        # If delay argument, start subprocess and exit
	# if it is too early, or fall through to grant
	# permissions otherwise.
	#
    	if { [clock seconds] < $stime } {

	    # Check pid_file and delete it if its process
	    # is no longer running.
	    # 
	    if { [file exists $pid_file] } {
		 set pid [read_file $pid_file]
		 set display [display_process_tree $pid]
		 if { [process_found $display] } {
		     puts "Previous startcontest still\
			   running:"
		     puts $display
		     exit 0
		 }
		 file delete -force $pid_file
	    }

	    # Run startcontest as a subprocess.
	    #
	    exec startcontest -WAIT- &

	    # Wait for any output from first run.
	    #
	    set count 0
	    while { ! [file exists $pid_file] } {
		sleep 1
		incr count
		if { $count > 120 } {
		    error "startcontest -WAIT- did not\
			   write $pid_file in a timely\
			   manner"
		}
	    }

	    puts "startcontest will run in background\
	          until $scoreboard_start_time"
	    puts "and then execute and email judge"
	    exit 0
	}
    }
    -WAIT- {

        # Come here if subprocess (indicated by special
	# -WAIT- argument).

	# Restore log mode and disable standard output
	# and error.
	#
	set log_mode $saved_log_mode
	disable_outputs

	# Set pid file.
	#
	write_file $pid_file [current_pid]
	set wrote_pid_file yes

	# Wait for start time and then fall through to
	# grant permissions.
	#
    	while { [clock seconds] < $stime } {
	    sleep 60
	}
    }
    }
}

# Grant permissions.
#
if { [file isdirectory $c_d/problems] } {
    grant_access $c_d/problems
}
if { [file isfile $c_d/help/problems] } {
    grant_access $c_d/help/problems
}

# Delete any PID file we wrote.
#
if { $wrote_pid_file } {
    file delete -force $pid_file
}

# Notify user that startcontest is finished.  If we are
# subprocess, this is done via hpcm_sendmail.
#
if { $arg == "-WAIT-" } {
    exec hpcm_sendmail << "startcontest done"
} else {
    puts "startcontest done"
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
