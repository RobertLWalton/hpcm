#!/bin/sh
#
# Start the contest by setting permissions on files.
#
# File:		startcontest
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Tue Jan  3 16:07:01 EST 2006
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2006/01/03 21:06:16 $
#   $RCSfile: startcontest,v $
#   $Revision: 1.10 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl

# Abbreviation for use in this file.
#
set c_d $judging_directory/contest

# Set log mode, saving old mode.
#
set log_globally yes
set saved_log_mode $log_mode
set log_mode none

catch {

set document "
startcontest { start | status | stop }

    With the `start' option, this program sets a+rx
    permissions on the directory 

    	<judging_directory>/contest/problems
	
    and a+r permissions on the file
    
    	<judging_directory>/contest/help/problems
	
    if these exist.

    However, if the current time is before any absolute
    time value of the scoreboard_start_time global var-
    iable, this program spawns a background child
    process that waits until the scoreboard_start_time
    and then sets permissions as above and emails the
    judge that the contest has started.

    If this program spawns a child, it writes the
    process ID of the child into the Startcontest_PID
    file in the judging directory.  If there already is
    such a file and the process it identifies is still
    running, this program will not spawn a child and
    will do nothing but print out information about the
    ID'ed process.

    If run with the `status' option this program will
    print status telling whether startcontest has
    already been executed and whether it is already
    running in background.

    If run with the `stop' option this program will
    stop any startcontest running in background.
    
    Unlike most HPCM judging programs, errors made by
    this program are not written to log files, but are
    written to the standard error output instead.
    However, errors made by any background child are
    logged to log files."


# If there are any illegal arguments print documentation
# and exit with error.
#
set arg [lindex $argv 0]
if { $argc > 1 || \
     ! [lcontain {start status stop -start-} $arg] } {
    puts $document
    exit 1
}

set pid_file $judging_directory/Startcontest_PID

# Handle the status argument.
#
if { $arg == "status" } {
    set startcontest_needed yes
    if { [file exists $pid_file] } {
	set pid [read_file $pid_file]
	set display [display_process_tree $pid]
	if { [process_found $display] } {
	    puts "Previous startcontest still running:"
	    puts $display
	    set startcontest_needed no
	} else {
	    puts "Previous startcontest has died."
	    puts $display
	    puts ""
	    puts "Run `tracker' to find error logs, or\
	          look in"
	    puts "$judging_directory/log for unchecked\
	          errors."
	}
    }
    if {    [file isdirectory $c_d/problems] \
         && [regexp {r.x} [get_access $c_d/problems]] \
         && [file isfile $c_d/help/problems] \
         && [regexp {r..} \
                    [get_access $c_d/help/problems]] } {
	puts "startcontest has already been run\
	      successfully"
    } elseif {    [file isdirectory $c_d/problems] \
               && [file isfile $c_d/help/problems] } {
	if { $startcontest_needed } { 
	    puts "You need to run: startcontest start"
	}
    } else {
        if { ! [file isdirectory $c_d/problems] } {
            puts "$c_d/problems needs to be created"
	}
	if { ! [file isfile $c_d/help/problems] } {
	    puts "$c_d/help/problems needs to be\
	          created"
	}
    }
    exit 0
}

# Handle the stop argument.
#
if { $arg == "stop" } {
    if { [file exists $pid_file] } {
	 set pid [read_file $pid_file]
	 set display [display_process_tree $pid]
	 if { [process_found $display] } {
	     puts "Killing previous startcontest:"
	     puts $display

	     # Try to kill up to 30 times, checking
	     # after each attempt for death.  The
	     # first 20 times are with HUP, the next
	     # 10 times are with KILL.
	     #
	     set count 0
	     while { "true" } {
		 incr count 1
		 if { $count <= 20 } {
		     catch { signal_process_tree \
			     HUP $pid } out
		     puts $out
		 } elseif { $count <= 30 } {
		     catch { signal_process_tree \
			     KILL $pid } out
		     puts $out
		 } else {
		     puts "ERROR: Giving Up!"
		     exit 1
		 }
		 sleep 1
		 set display \
		     [display_process_tree $pid]
		 if { ! [process_found $display] } {
		     break
		 }
	     }
	 } else {
	    puts "Previous startcontest has died."
	    puts $display
	    puts ""
	    puts "Run `tracker' to find error logs, or\
	          look in"
	    puts "$judging_directory/log for unchecked\
	          errors."
	 }
	 file delete -force $pid_file
    } else {
	puts "No previous startcontest running."
    }
    exit 0
}

# From this point on we are handling the start or
# -start- argument.

set wrote_pid_file no

# If we have nothing to do, announce this and exit.
#
if { (    ! [file isdirectory $c_d/problems] \
       || [regexp {r.x} [get_access $c_d/problems]] ) \
     && \
     (    ! [file isfile $c_d/help/problems] \
       || [regexp {r..} \
                  [get_access \
		       $c_d/help/problems]] ) } {

    puts "startcontest has been done previously"
    exit 0
}

# Do something if scoreboard_start_time is a date and
# time.
#
set stime $scoreboard_start_time
if { ! [regexp {^(|problem|team)$} $stime] } {

    if { [catch { set stime [clock scan $stime] }] } {
	error "badly formatted scoreboard_start_time:\
	       $scoreboard_start_time"
    }
    switch -- $arg {

    start {

        # If "start" argument, start subprocess and exit
	# if it is too early, or fall through to grant
	# permissions otherwise.
	#
    	if { [clock seconds] < $stime } {

	    # Check pid_file and delete it if its
	    # process is no longer running.
	    # 
	    if { [file exists $pid_file] } {
		 set pid [read_file $pid_file]
		 set display [display_process_tree $pid]
		 if { [process_found $display] } {
		     puts "Previous startcontest still\
			   running:"
		     puts $display
		     exit 0
		 }
		 file delete -force $pid_file
	    }

	    # Run startcontest as a subprocess.
	    #
	    exec startcontest -start- &

	    # Wait for any output from subprocess.
	    #
	    set count 0
	    while { ! [file exists $pid_file] } {
		sleep 1
		incr count
		if { $count > 120 } {
		    error "startcontest -start- did not\
			   write $pid_file in a timely\
			   manner"
		}
	    }

	    puts "startcontest will run in background\
	          until $scoreboard_start_time"
	    puts "and then execute and email judge"
	    exit 0
	}
    }
    -start- {

        # Come here if subprocess (indicated by special
	# -start- argument).

	# Restore log mode and disable standard output
	# and error.
	#
	set log_mode $saved_log_mode
	disable_outputs

	# Set pid file.
	#
	write_file $pid_file [current_pid]
	set wrote_pid_file yes

	# Wait for start time and then fall through to
	# grant permissions.
	#
    	while { [clock seconds] < $stime } {
	    sleep 60
	}
    }
    }
}

# Grant permissions.
#
if { [file isdirectory $c_d/problems] } {
    grant_access $c_d/problems
}
if { [file isfile $c_d/help/problems] } {
    grant_access $c_d/help/problems
}

# Delete any PID file we wrote.
#
if { $wrote_pid_file } {
    file delete -force $pid_file
}

# Notify user that startcontest is finished.  If we are
# subprocess, this is done via hpcm_sendmail.
#
if { $arg == "-start-" } {
    exec hpcm_sendmail << "startcontest done"
} else {
    puts "startcontest done"
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
