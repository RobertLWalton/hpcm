#!/bin/sh
#
# Recomputes the scoreboard every minute.
#
# File:		makescoreboard
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Dec 26 14:30:32 EST 2005
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2005/12/26 19:29:26 $
#   $RCSfile: old_makescoreboard,v $
#   $Revision: 1.48 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl

# Set log mode, saving old mode.
#
set log_globally yes
set saved_log_mode $log_mode
set log_mode none

catch {

set document "
makescoreboard { start | status | stop | update } \\
               \[ parameter-filename | \\
	         scoreboard_instructions-value \] ...

    This program makes scoreboards by following the
    instructions stored in the `scoreboard_instructions'
    global variable.  See the hpcm_judging.rc file
    for a description of these instructions.

    When this program starts, it processes its second
    and subsequent arguments as follows.  Any named
    parameter file is `sourced'.  Any argument that
    begins with a `{' is stored (with the `{ }' brackets
    removed) in the `scoreboard_instructions' global
    variable.
    
    This program calls
    
	scorefinder -gotten \\
	    > judging_directory/Scorefinder_Output

    The Scorefinder_Output file is used as input by
    the `scoreboard' program to produce scoreboards.
    To avoid conflicts between the `start' and `update'
    commands, this program adds a `+' to the end of the
    name Scorefinder_Output when running the update
    command.

    This program ignores signals when computing score-
    boards, and terminates without error on a signal
    while the program is sleeping for an interval.

    If called with an `update' command, this program
    processes the scoreboard instructions just once
    and then exits immediately.

    If called with the `start' command, this program
    executes itself as a subprocess and writes into the
    Scoreboard_PID file in the judging directory the
    process ID of the subprocess.  This subprocess pro-
    cess the scoreboard instructions at periodic inter-
    vals.  But if the Scoreboard_PID file already
    exists, AND the process ID it contains is valid,
    this program prints information about the ID'ed
    process and does nothing else.

    The first time the `start' command processes the
    scoreboard instructions, it does so just like the
    `update' command.  Then this program resumes at
    intervals determined by the `scoreboard_interval'
    global variable.  After every interval, this
    program checks to see if any inputs to the last run
    have been changed, or any outputs have been deleted,
    and if yes, this program reruns the scoreboard in-
    structions.  The inputs checked for change include
    the hpcm_judging.rc file in the judging directory
    and the parameter files listed in the arguments.
    Before checking files for change, the Score_Flag
    flag is checked, and if present, the `scorefinder'
    program is called to remake the Scorefinder_Output
    file.  This is also done if the Scorefinder_Output
    file no longer exists.

    If called with the `stop' command, this program does
    nothing but send kill signals to the process whose
    ID is listed in the Scoreboard_PID file, and then
    deletes that file.  While doing this it outputs in-
    formation about its progress.

    If called with the `status' command, this program
    just outputs information about the status of the
    process whose ID is stored in the Scoreboard_PID
    file.

    With the `update', `status', or `stop' commands this
    program does not log errors but writes them to the
    standard error.  This program does the same with
    `start' command errors that occur during the first
    making of the scoreboard.  But after beginning
    reruns for the `start' command, this program logs
    errors in a global log directory."

# } to balance extra left bracket in documentation.

# Print documentation if illegal (or -doc) first
# argument.
#
set command [lindex $argv 0]
if { ! [regexp {^(update|start|status|stop|-start-)$} \
               $command] } {
    puts $document
    exit 1
}

# Constant equal to 256 spaces.
#
set space "        "
set space "$space$space"
set space "$space$space"
set space "$space$space"
set space "$space$space"
set space "$space$space"

# Compute file names.
#
set finder_file \
    $judging_directory/Scorefinder_Output
if { $command == "update" } {
    set finder_file $finder_file+
}
set pid_file \
    $judging_directory/Scoreboard_PID

# Return `yes' if a file in the mtime_list has changed.
# Otherwise return `no'.
#
# The mtime_list is a list of items each of the format:
#
#	{ file-mtime file-name }
#
# The file-mtime can be a `clock seconds' value, or
# `none' if the file did not exist, or `out' if the
# file was output.  A file changes if it appears or
# disappears or now has a larger mtime than its file-
# mtime clock seconds value.
#
# If mtime_list has the special value `changed', this
# function always returns `yes'.
#	
proc file_changed { mtime_list } {

    if { $mtime_list == "changed" } {
        return yes
    }

    foreach item $mtime_list {
       set mtime [lindex $item 0]
       set name  [lindex $item 1]

       if { $mtime == "none" } {
           if { [file exists $name] } {
	       return yes;
	   }
       } elseif { $mtime == "out" } {
           if { ! [file exists $name] } {
	       return yes;
	   }
       } else {
           if { ! [file exists $name] } {
	       return yes;
	   } elseif { [file mtime $name] > $mtime } {
	       return yes;
	   }
       }
    }
    return no
}

# The names of global variables that must be imported
# to the process_arguments function below must be
# so that they will not be accidentally used by the
# sourced parameters files.  So we make them of the
# form makescoreboard_xxx.

# makescoreboard_parameters(xxx) stores the value
# that scoreboard_xxx should have at the beginning of
# processing the scoreboard instructions.  xxx is
# called a scoreboard parameter.  `instructions' is
# excluded, and is not a scoreboard parameter, as is
# any xxx for which scoreboard_xxx is an array.

# Execute `global scoreboard_xxx' for all scoreboard
# parameter names xxx.
#
proc make_scoreboard_parameters_global { } {
    global makescoreboard_parameters
    foreach name \
            [array names makescoreboard_parameters] {
        uplevel [list global scoreboard_$name]
    }
}

# Save scoreboard parameter values in makescoreboard_
# parameters.
#
proc save_scoreboard_parameters { } {
    global makescoreboard_parameters
    foreach name \
            [array names makescoreboard_parameters] {
        global scoreboard_$name
	set makescoreboard_parameters($name) \
	    [set scoreboard_$name]
    }
}

# Restore scoreboard parameter values from
# makescoreboard_parameters.
#
proc restore_scoreboard_parameters { } {
    global makescoreboard_parameters
    foreach name \
            [array names makescoreboard_parameters] {
        global scoreboard_$name
	set scoreboard_$name \
	    $makescoreboard_parameters($name)
    }
}

# Compute scoreboard parameter names.  `instructions' is
# excluded, as are arrays.
#
foreach name [info globals scoreboard_*] {
    regexp {^scoreboard_(.*)$} $name forget pname
    if {    $pname != "instructions" \
         && ! [array exists $name] } {
	set makescoreboard_parameters($pname) 1
    }
}
save_scoreboard_parameters

# Mtime-list for parameter files.
#
set makescoreboard_parameter_mtime_list changed

# Mtime of latest of all the parameter files.
#
set makescoreboard_parameter_mtime ""

# Process arguments and set the values of the global
# scoreboard_xxx variables listed in the parameters_
# array.  Save these new values in the parameters_
# array.
#
# If parameter files (including # the hpcm_judging.rc
# file) have not changed, just restore values of
# scoreboard_xxx variables listed in makescoreboard_
# parameters_array, without processing arguments.
#
proc process_arguments { } {

    global makescoreboard_parameter_mtime_list \
	   makescoreboard_parameter_mtime

    # Import standard globals, e.g. tclvars.
    #
    global env errorCode errorInfo argv argc
    foreach x [info globals tcl_*] {
        global $x
    }
    global judging_directory lib_directory

    make_scoreboard_parameters_global

    # If no file changes, restore variables and exit.
    #
    if { [file_changed \
            $makescoreboard_parameter_mtime_list] \
         == "no" } {

	restore_scoreboard_parameters
	return
    }

    # Set makescoreboard_parameter_mtime_list so that if
    # there is an error reading parameters, and we are
    # recalled to try again, the parameters will be
    # reread.  Errors may occur due to files changing
    # dynamically while makescoreboard runs asynchron-
    # ously.
    #
    set makescoreboard_parameter_mtime_list changed

    # Accumulate new makescoreboard_parameter_mtime_list
    # and parameter_mtime values in local variables
    # whose names will not likely be used by files being
    # sourced.
    #
    set pfile $judging_directory/hpcm_judging.rc
    set mtime [file mtime $pfile]
    set makescoreboard_mtime_list \
        [list [list $mtime $pfile]]
    set makescoreboard_mtime $mtime

    # Source hpcm_judging.rc.
    #
    source $pfile

    # Process all the arguments, sourcing files as
    # necessary.
    #
    foreach arg [lrange $argv 1 end] {
	set LB "{"
	# "}" to balance left bracket in last line so
	# TCL will read this procedure code properly.
	#
	if { [regexp "^${LB}" $arg] } {
	    if { [catch { set scoreboard_instructions \
	                      [lindex $arg 0]
			  llength \
			      $scoreboard_instructions \
			}] } {
	        error "scoreboard instructions\
		       argument is not a TCL list:\
		       $arg"
	    }
	} else {
	    set makescoreboard_arg $arg
	    source $arg
	    set arg $makescoreboard_arg
	    set mtime [file mtime $arg]
	    lappend \
	        makescoreboard_mtime_list \
	        [list $mtime $arg]
	    if { $mtime > $makescoreboard_mtime } {
	        set makescoreboard_mtime $mtime
	    }
	}
    }

    save_scoreboard_parameters

    set parameter_mtime_list $makescoreboard_mtime_list
    set parameter_mtime $makescoreboard_mtime
}

# Process arguments for the first time.
#
process_arguments


# Given a value that may be an abbreviation defined
# in the abbreviation_array, return the value it
# abbreviates, or return the original value if it is not
# an abbreviation.
#
proc unabbreviate { value } {

    global abbreviation_array

    if { [info exists abbreviation_array($value)] } {
        return $abbreviation_array($value)
    } elseif {    [regexp {^(.*)([+-][0-9]+)$} $value \
    		          forget abbrev inc] \
	       && [info exists \
	                abbreviation_array($abbrev)] \
	       && ! [catch {
	       		set date \
			    $abbreviation_array($abbrev)
			set time \
			    [clock scan $date]
			   }] } {
	incr time $inc
	return [clock format $time]
    } else {
        return $value
    }
}

# Process parameter setting instruction.
#
proc set_parameter { instruction } {

    global makescoreboard_parameters

    set name  [lindex $instruction 0]
    set value [lindex $instruction 1]

    if { ! [info exists \
	         makescoreboard_parameters($name)] } {
	error "$name is not a parameter name"
    }

    set value [unabbreviate $value]
    global scoreboard_$name
    set scoreboard_$name $value
}

# Data for processing scoreboard instructions.

# Mtime-list for scoreboard instructions INPUT and
# OUTPUT files.
#
set file_mtime_list changed

# Earliest future time in an OUTPUT instruction.  Or ""
# if no OUTPUT instruction time.
#
set earliest_future_time ""

# Last time scoreboard instructions were executed, or ""
# in order to force execution of scoreboard instruc-
# tions.
#
set last_time ""

# Process scoreboard instructions.
#
proc process_instructions {} {

    global scoreboard_instructions abbreviation_array \
           file_mtime_list earliest_future_time \
	   last_time makescoreboard_parameter_mtime \
	   finder_file judging_directory
    make_scoreboard_parameters_global

    # Use a single `run time' in computations.
    #
    set time [clock seconds]

    # Reinstall initial parameter values.
    #
    process_arguments
    set parameter_mtime $makescoreboard_parameter_mtime

    # Recompute $finder_file if necessary.
    #
    if {    $last_time == "" \
         || $last_time < $parameter_mtime \
         || ! [file readable $finder_file] \
         || [test_flag Score_Flag] } {

	make_signals_ignored
	clear_flag Score_Flag
	file delete -force -- $finder_file
	exec scorefinder -gotten > $finder_file
	make_signals_default
	set last_time ""
    }

    # Save $finder_file mtime for use below.
    #
    set finder_mtime [file mtime $finder_file]

    # If we have no reason to rerun scoreboard instruc-
    # tions, return.
    #
    if {    $last_time != ""
         && $last_time >= $parameter_mtime \
	 && [file_changed $file_mtime_list] == "no" \
	 && ( $earliest_future_time == "" \
	      || $time < $earliest_future_time ) } {

        return
    }

    # Save abbreviations.  If possible, replace relative
    # stop and freeze times by normally formatted times
    # so if they appear in LINE's they will look OK.
    #
    set start_time $scoreboard_start_time
    set abbreviation_array(START) $start_time

    if { ! [regexp {^(|problem|team)$} $start_time] } {
        if { [catch { set st [clock scan $start_time] \
	            }] } {
	    error "badly formatted \
	           scoreboard_start_time: $start_time"
	}
    } else {
        set st ""
    }

    set stop_time $scoreboard_stop_time
    if {    [regexp {^(|\+)[0-9]+$} $stop_time] \
         && $st != "" } {
        set stop_time \
	    [clock format [expr { $st + $stop_time }]]
    }
    set abbreviation_array(STOP) $stop_time

    set freeze_time $scoreboard_freeze_time
    if {    [regexp {^(|\+)[0-9]+$} $freeze_time] \
         && $st != "" } {
        set freeze_time \
	    [clock format [expr { $st + $freeze_time }]]
    }
    set abbreviation_array(FREEZE) $freeze_time

    set abbreviation_array(NAME)   \
        $scoreboard_name
    set abbreviation_array(TIME)   \
        [clock format $time]

    # Ignore signals while processing instructions.
    #
    make_signals_ignored


    # Set last_time so that if there is an error pro-
    # cessing instructions, and we are recalled to try
    # again, the instructions will be reprocessed.
    # Errors may occur due to files changing dynamically
    # while makescoreboard runs asynchronously.
    #
    set last_time ""

    # Accumulate new file_mtime_list value in this local
    # variable until we have succeeded.
    #
    set mtime_list ""

    # Accumulate new earliest_future_time value in eft.
    #
    set eft ""

    # Loop to process instructions for first pass.
    #
    # Instructions are converted to a list to make com-
    # putation faster.  Lrange will do this, but concat
    # will NOT.
    #
    # Pass2 is called for every sequence of instructions
    # beginning with an OUTPUT instruction and ending
    # with the instruction before the next OUTPUT in-
    # struction or end of all instructions.

    if { [catch { set instructions \
                      [lrange $scoreboard_instructions \
		              0 end] }] } {
        error "scoreboard_instructions is not a TCL\
	       list: $scoreboard_instructions"
    }
    set pc 0
    set end_pc [llength $instructions]
    set output_found no

    while { "yes" } {

        set instruction [lindex $instructions $pc]
	incr pc
	if { [regexp {^[ \t]*#} $instruction] } continue

	if { [catch { llength $instruction }] } {
	    error "a scoreboard_instructions'\
	           instruction is not a TCL list:\
		   $instruction"
	    
	}
	set opcode [lindex $instruction 0]

	# If we are at the end of a sequence of
	# instructions that begins with an OUTPUT
	# instruction and ends just before the next
	# OUTPUT instruction or end of all instructions,
	# process OUTPUT instruction time parameters
	# and call pass2.
	#
        if { ( $pc > $end_pc || $opcode == "OUTPUT" ) \
	     && $output_found } {

	    # If we are before OUTPUT start time, do
	    # NOT update.
	    #
	    if { $out_start != "" \
	         && $time < $out_start } {
	        set update no
	    }

	    # If output file exists and has an mtime >=
	    # the OUTPUT stop time, do NOT update.
	    #
	    if {    $out_mtime != "" \
	         && $out_stop != "" \
	         && $out_mtime >= $out_stop } {
	        set update no
	    }

	    # Perform second pass.
	    #
	    pass2 $instructions \
	          $out_pc [expr $pc -1] $update
	}

	if { $pc > $end_pc } break

	# Perform first pass on instruction.
	#
	switch ${output_found}_$opcode {

	    no_OUTPUT -
	    yes_OUTPUT {

	        # Compute output file.
		#
		set out_file  [lindex $instruction 1]
		set out_file \
		   [file join $judging_directory \
		              $out_file]

		# Compute start and stop times and
		# update eft.
		#
		set out_start [lindex $instruction 2]
		set out_start [unabbreviate $out_start]
		if { $out_start != "" } {
		    set out_start \
		        [clock scan $out_start]
		    if { $out_start > $time \
		         && (    $eft == "" \
			      || $eft > $out_start ) } {
		        set eft $out_start
		    }
		}
		set out_stop  [lindex $instruction 3]
		set out_stop [unabbreviate $out_stop]
		if { $out_stop != "" } {
		    set out_stop \
		        [clock scan $out_stop]
		    if { $out_stop > $time \
		         && (    $eft == "" \
			      || $eft > $out_stop ) } {
		        set eft $out_stop
		    }
		}

		# Set out_mtime to the output file mtime
		# or "" if no output file exist, set
		# `update' to no if the output file
		# exists and yes otherwise, and add
		# { out FILENAME } or { none FILENAME }
		# to the mtime_list according to whether
		# the file exists are not.
		#
		if { [file exists $out_file] } {
		    set update no
		    set out_mtime [file mtime $out_file]
		    lappend mtime_list \
		            [list out $out_file]
		} else {
		    set update yes
		    set out_mtime ""
		    lappend mtime_list \
		            [list none $out_file]
		}

	        # If scoreboard_instructions might have
		# changed force update.
		#
	    	if {    $last_time == ""
	    	     ||   $last_time \
		        < $parameter_mtime } {
		    set update yes
		}

		# Set output variables.
		#
	        set out_pc $pc
		incr out_pc -1
		set output_found yes
	    }

	    yes_SEND {}
	    yes_GRANT_ACCESS {}

	    yes_BLANK {}

	    yes_BAR {}
	    yes_LINE {}

	    yes_INPUT {

	        # Loop through input files until an
		# existing one is found.
		#
		foreach in_file \
		        [lrange $instruction 1 end] {

		    set in_file \
		        [file join $judging_directory \
			           $in_file]

		    # Add input file to mtime_list.
		    #
		    if { [file exists $in_file] } {
			set mtime [file mtime $in_file]

			# If existing input file is
			# later than output file, force
			# update.
			#
			if {    $out_mtime != "" \
			     && $mtime > $out_mtime } {
			    set update yes
			}

			lappend mtime_list \
			        [list $mtime $in_file]
			break;
		    } else {
			lappend mtime_list \
				[list none $in_file]
		    }
		}
	    }

	    yes_BOARD {

		# Process finder_file mtime stored in
		# finder_mtime above.
		#
		if {    $out_mtime != "" \
		     && $finder_mtime > $out_mtime } {
		    set update yes
		}
		lappend mtime_list \
			[list $finder_mtime \
			      $finder_file]
	    }

	    no_SEND -
	    no_GRANT_ACCESS -
	    no_BLANK -
	    no_BAR -
	    no_LINE -
	    no_INPUT -
	    no_BOARD {
	        error "`$instruction' appears before\
		       OUTPUT instruction"
	    }

	    default {

	        # Parameter setting instructions are
		# executed in the first pass only if
		# they are before all OUTPUT instruc-
		# tions.  Otherwise they are executed
		# in pass2.
		#
	        if { $output_found == "no" } {
		    set_parameter $instruction
		}
	    }
	}
    }

    # End of instruction processing loop.  Store record
    # of just finished actions and reenable interrupts.
    #
    set earliest_future_time $eft
    set last_time $time
    set file_mtime_list $mtime_list
    make_signals_default
}

# Execute scoreboard instructions during second pass.
# Instruction at pc is an OUTPUT instruction, and
# instruction at endpc is the next OUTPUT instruction
# or is just beyond the end of all instructions.
#
proc pass2 { instructions pc end_pc update } {

    global makescoreboard_parameters \
           judging_directory finder_file space \
	   errorInfo errorCode
    make_scoreboard_parameters_global

    # Compute output file and step past OUTPUT instruc-
    # tion.
    #
    set instruction [lindex $instructions $pc]
    set out_file [lindex $instruction 1]
    if { $out_file == "" } {
        error "Bad OUTPUT instruction: $instruction"
    }
    set out_file \
        [file join $judging_directory $out_file]
    incr pc

    # Compute output file in `contents' variable.
    #
    set contents ""
    set send no
    set grant_access no

    # Compute BAR.
    #
    set bar ""
    set solid_bar =====
    set w [expr { $scoreboard_width / 5 } ]
    while { $w > 0 } {
	set bar "$bar== =="
	set solid_bar $solid_bar=====
	incr w -1
    }

    # Loop through remaining instructions.
    #
    while { $pc < $end_pc } {

	# Compute instruction and opcode and update pc.
	#
	set instruction [lindex $instructions $pc]
	incr pc
	if { [regexp {^[ \t]*#} $instruction] } continue
	set opcode [lindex $instruction 0]

	switch ${opcode}_$update {

	    SEND_yes {

	        # Compute send_qualifier and send_
		# addresses for use when output done.
		#
		set send_qualifier \
		    [lindex $instruction 1]
		set name [lindex $instruction 2]
		if { $name == "" } {
		    set name addresses
		}
		if { ! [info exists scoreboard_$name] \
						} {
		   set send_addresses ""
		} else {
		   set send_addresses \
		       [set scoreboard_$name]
		}

		# Set switch to indicate SEND happened.
		#
		set send yes
	    }

	    GRANT_ACCESS_yes {
		set grant_access yes
	    }

	    BLANK_yes {
		set contents "$contents\n"
	    }

	    BAR_yes {
	        set text [lindex $instruction 1]
		if { $text == "" } {
		    set contents "$contents$bar\n"
		} else {
		    set text [unabbreviate $text]
		    set sw $scoreboard_width
		    set len [string length $text]
		    incr len 2
		    if { $len + 4 > $sw} {
		        error "scoreboard_width not\
			       wide enough for\
			       `$instruction'"
		    }
		    set left \
		        [expr { ( $sw - $len ) / 2 }]
		    set right \
		        [expr { $sw - $len - $left }]
		    incr left -1
		    incr right -1
		    set left \
		        [string range $solid_bar \
			        0 $left]
		    set right \
		        [string range $solid_bar \
			        0 $right]
		    set contents \
		        "$contents$left $text $right\n"
		}
	    }

	    LINE_yes {

		# Make sure `space is long enough'.
		#
		if { $scoreboard_width > 256 } {
		    error "scoreboard width > 256"
		}

		# Compute left, center, and right
		# text.
		#
		set left   [lindex $instruction 1]
		set center [lindex $instruction 2]
		set right  [lindex $instruction 3]

		set left   [unabbreviate $left]
		set center [unabbreviate $center]
		set right  [unabbreviate $right]

		# Compute columns of beginning and/or
		# end for each of the three texts.
		# Columns are numbered 0, 1, ...
		#
		set left_end [string length $left]
		incr left_end -1
		set right_begin \
		    [expr { $scoreboard_width - \
			    [string length $right] }]
		set center_length \
		    [string length $center]
		set center_begin  \
		    [expr { ( $scoreboard_width \
			      - $center_length + 1 ) \
			    / 2 }]
		set center_end \
		    [expr { $center_begin \
			    + $center_length - 1 }]

		# Make sure texts are short enough so
		# that their ends are within limits.
		#
		if { $left_end >= $scoreboard_width } {
		    error "LINE left text too wide:\
		           $left"
		} elseif { $right_begin < 0 } {
		    error "LINE right text too wide:\
		           $right"
		} elseif {    $center_begin < 0 \
		           || $center_end \
			      >= $scoreboard_width } {
		    error "LINE center text too wide:\
		           $center"
		}

		# Compute line.  Start with left text.
		#
		set line $left

		set center_done no
		set right_done  no

		# If center is non-empty and has a 2
		# space gap between it and any other
		# non-empty text, add the center to the
		# line.
		#
		if {    $center != "" \
		     && ( $left == "" \
		          || $left_end + 2 \
			     < $center_begin ) \
		     && ( $right == "" \
		          || $center_end + 2 \
			     < $right_begin ) } {
		    incr left_end 1
		    incr center_begin -1
		    set line \
			"$line[string \
				  range $space \
				  $left_end \
				  $center_begin]"
		    set line "$line$center"
		    set center_done yes
		    set left_end $center_end
		}

		# If right text is non-empty and has a 2
		# space gap with the part of the line
		# to its left, add it to line.
		#
		if {    $right != ""
		     && ( $left_end == -1 \
		          || $left_end + 2 \
			     < $right_begin ) } {
		    incr left_end 1
		    incr right_begin -1
		    set line \
			"$line[string \
				  range $space \
				  $left_end \
				  $right_begin]"
		    set line "$line$right"
		    set right_done yes
		}

		# If center text did not get added to
		# first line, put it on a line by it-
		# self.
		#
		if { $center != "" && \
		     $center_done == "no" } {
		    incr center_begin -1
		    set line \
			"$line\n[string \
				    range $space \
				    0 $center_begin]"
		    set line "$line$center"
		}

		# If right text did not get added to
		# first line, put it on a line by it-
		# self.
		#
		if { $right != "" \
		     && $right_done == "no" } {
		    incr right_begin -1
		    set line \
			"$line\n[string \
				    range $space \
				    0 $right_begin]"
		    set line "$line$right"
		}

		# Add line(s) to contents of output.
		#
		set contents "$contents$line\n"
	    }

	    INPUT_yes {

	        # Loop through input files.
		#
		foreach in_file \
		        [lrange $instruction 1 end] {

		    set in_file \
		        [file join $judging_directory \
			           $in_file]

		    # Add first existing input file to
		    # the output contents.
		    #
		    if { [file exists $in_file] } {
			if { [file size $in_file] > 0 \
					} {
			    set c [read_entire_file \
			    		$in_file]
			    set contents "$contents$c\n"
			}
			break;
		    }
		}
	    }

	    BOARD_yes {

	        # Compute parameters to be passed to
		# the scoreboard program.
		#
	        set parameters ""
		foreach name \
		        [array names \
		           makescoreboard_parameters] {
		    lappend parameters \
		        [list $name \
			      [set scoreboard_$name]]
		}

		# Call the scoreboard program to compute
		# the board.
		#
		set scoreboard \
		    [exec scoreboard "{ $parameters }" \
				     < $finder_file]

		# If the scoreboard is empty, say so
		# explicitly.
		#
		if { $scoreboard == "" } {
		    set scoreboard \
		        "The scoreboard is currently\
			 EMPTY!  Nothing must have\
			 happened yet."
		}

		# Add the scoreboard to the output file
		# contents.
		#
	        set contents "$contents$scoreboard\n"
	    }

	    SEND_no -
	    GRANT_ACCESS_no -
	    BLANK_no -
	    BAR_no -
	    LINE_no -
	    INPUT_no -
	    BOARD_no {

		# If update is `no' most instructions do
		# nothing.
		#
	    }

	    default {
	        # Execute parameter setting instruction
		# regardless of update value.
		#
		set_parameter $instruction
	    }
	}
    }

    if { $update } {

	# Write output file.  If error, delete file.
	#
	if { [catch {

		set ch [open $out_file w]
		puts -nonewline $ch $contents
		close $ch
		if { $grant_access } {
		    grant_access $out_file
		}

		# Send email.
		#
		if { $send } {
		    set sq $send_qualifier
		    foreach to $send_addresses {
			if { $sq != "" } {
			    if { [regexp {<} $to] } {
				set to "$sq-$to"
			    } else {
				set to "$sq<$to>"
			    }
			}
			send_message \
			   "To: $to\n\n$contents"
		    }
		}
	    } error_message] } {

	    # On error, delete output file and rethrow
	    # the error.  When we are rerun, the output
	    # file will be recomputed and remailed.
	    #
	    if { [file isfile $out_file] } {

		# Its possible if instructions are
		# miswritten to have out_file name a
		# directory.

		file delete -force -- $out_file
	    }
	    error $error_message $errorInfo $errorCode
	}
    }
}


# Process command.
#
switch -- $command {

    start {

	# Check pid_file and delete it if its process
	# is no longer running.
	# 
	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { [process_found $display] } {
		 puts "Previous makescoreboard still\
		       running:"
		 puts $display
		 exit 0
	     }
	     file delete -force $pid_file
	}

	# Run makescoreboard as a subprocess.
	#
        eval exec makescoreboard -start- \
	     [lrange $argv 1 end] &

	# Wait for any output from first run.
	#
	set count 0
	while { ! [file exists $pid_file] } {
	    sleep 1
	    incr count
	    if { $count > 120 } {
	        error "makescoreboard -start- did not\
		       write $pid_file in a timely\
		       manner"
	    }
	}
    }

    -start- {

	# Save interval before processing instructions.
	#
	set interval $scoreboard_interval

	# Process scoreboard instructions for the first
	# time.
	#
        process_instructions

	# Restore log mode and disable standard output
	# and error.
	#
	set log_mode $saved_log_mode
	disable_outputs

	# Set pid file.
	#
	write_file $pid_file [current_pid]

	# Resume a periodic intervals.
	#
	while { "yes" } {
	    sleep $interval
	    set c 0

	    # Run up to 4 times ignoring errors.
	    # Then if there are 4 erroneous runs, try
	    # a run in which errors stop the program.
	    #
	    # We do this because changes to files during
	    # a run may cause spurious errors.
	    #
	    while { "yes" } {
	        incr c
		if { $c < 5 } {
		    if { ! [catch {
		              process_instructions }] \
			          } break
		    sleep 10
		} else {
		    process_instructions
		}
	    }
	}
    }

    status {

	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { [process_found $display] } {
		 puts "Makescoreboard running:"
		 puts $display
	     } else {
		 puts "Makescoreboard has died:"
		 puts $display
		 puts ""
		 puts "Run `tracker' to find error\
		       logs, or look in"
		 puts "$judging_directory/log for\
		       unchecked errors."
	     }
	} else {
	    puts "All previous makescoreboards have\
	          been stopped."
	}
    }

    stop {
	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { [process_found $display] } {
		 puts "Killing previous makescoreboard:"
		 puts $display

		 # Try to kill up to 30 times, checking
		 # after each attempt for death.  The
		 # first 20 times are with HUP, the next
		 # 10 times are with KILL.
		 #
		 set count 0
		 while { "true" } {
		     incr count 1
		     if { $count <= 20 } {
			 catch { signal_process_tree \
				 HUP $pid } out
			 puts $out
		     } elseif { $count <= 30 } {
			 catch { signal_process_tree \
				 KILL $pid } out
			 puts $out
		     } else {
			 puts "ERROR: Giving Up!"
			 exit 1
		     }
		     sleep 1
		     set display \
		         [display_process_tree $pid]
	             if { ! [process_found $display] } {
			 break
		     }
		 }
	     }
	     file delete -force $pid_file
	} else {
	    puts "No previous makescoreboard running."
	}
    }

    update {
        process_instructions
    }
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
