#!/bin/sh
#
# Recomputes the scoreboard every minute.
#
# File:		makescoreboard
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sat Oct 27 11:33:16 EDT 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/10/27 15:42:01 $
#   $RCSfile: old_makescoreboard,v $
#   $Revision: 1.17 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_globally yes
catch {

set document "
makescoreboard { start | status | stop | update } \\
               \[ parameter-filename | \\
	         scoreboard_instructions-value \] ...

    This program makes scoreboards by following the
    instructions stored in the `scoreboard_instructions'
    global variable.  See the $judging_parameters_file\
    				file
    for a description of these instructions.

    When this program starts, it processes its second
    and subsequent arguments as follows.  Any named
    parameter file is `sourced'.  Any argument that
    begins with a `{' is stored (with the `{ }' brackets
    removed) in the `scoreboard_instructions' global
    variable.
    
    This program calls
    
	scorefinder \\
	    > judging_directory/$scorefinder_output_file

    The $scorefinder_output_file file is used as input\
    						   by
    the `scoreboard' program to produce scoreboards.
    To avoid conflicts between the `start' and `update'
    commands, this program adds a `+' to the end of the
    name $scorefinder_output_file when running the\
	update
    command.

    This program ignores signals when computing score-
    boards, and terminates without error on a signal
    while the program is sleeping for an interval.

    If called with an `update' command, this program
    processes the scoreboard instructions just once
    and then exits immediately.

    If called with the `start' command, this program
    writes its process ID of the $scoreboard_pid_file\
    		file
    in the judging directory, and begins to reprocess
    the scoreboard instructions at periodic intervals.
    But if the $scoreboard_pid_file file already\
    		exists, AND
    the process ID it contains is valid, this program
    prints information about the ID'ed process and does
    nothing else.

    The first time the `start' command processes the
    scoreboard instructions, it does so just like the
    `update' command.  Then this program resumes at
    intervals determined by the `scoreboard_interval'
    global variable.  After every interval, this
    program checks to see if any inputs to the last run
    have been changed, or any outputs have been deleted,
    and if yes, this program reruns the scoreboard in-
    structions.  The inputs checked for change include
    the $judging_parameters_file file in the judging\
    					directory
    and the parameter files listed in the arguments.
    Before checking files for change, the\
    		$score_flag_file
    flag is checked, and if present, the `scorefinder'
    program is called to remake the\
    	$scorefinder_output_file
    file.  This is also done if the\
    	$scorefinder_output_file
    no longer exists.

    If called with the `stop' command, this program does
    nothing but send kill signals to the process whose
    ID is listed in the $scoreboard_pid_file file, and
    then deletes the file.  While doing this it outputs
    information about its progress.

    If called with the `status' command, this program
    just outputs information about the status of any
    process started by `makescoreboard start'.

    With the `update', `status', or `stop' commands this
    program does not log errors but writes them to the
    standard error.  This program does the same with
    `start' command errors that occur during the first
    making of the scoreboard.  After this program starts
    reruns for the `start' command, this program logs
    errors in the log directory."

# } to balance extra left bracket in documentation.

# Print documentation if illegal (or -doc) first
# argument.
#
set command [lindex $argv 0]
if { ! [regexp {^(update|start|status|stop)$} $command] } {
    puts $document
    exit 1
}

# Constant equal to 256 spaces.
#
set space "        "
set space "$space$space"
set space "$space$space"
set space "$space$space"
set space "$space$space"
set space "$space$space"

# Compute file names.
#
set finder_file \
    $judging_directory/$scorefinder_output_file
if { $command == "update" } {
    set finder_file $finder_file+
}
set pid_file \
    $judging_directory/$scoreboard_pid_file

# Compute possible parameters and save original values.
#
foreach name [info globals scoreboard_*] {
    regexp {^scoreboard_(.*)$} $name forget pname
    if { $pname != "instructions" } {
	set parameters_array($pname) [set $name]
    }
}

# Return `yes' if a file in the mtime_list has changed.
# Otherwise return `no'.
#
# The mtime_file list is a list of items each of the
# format:
#
#	{ file-mtime file-name }
#
# The file-mtime can be a `clock seconds' value, or
# `none' if the file did not exist, or `out' if the
# file was output.  A file changes if it appears or
# disappears or now has a larger mtime than its file-
# mtime clock seconds value.
#
# If mtime_list has the special value `changed', this
# function always returns `yes'.
#	
proc file_changed { mtime_list } {

    if { $mtime_list == "changed" } {
        return yes
    }

    foreach item $mtime_list {
       set mtime [lindex $item 0]
       set name  [lindex $item 1]

       if { $mtime == "none" } {
           if { [file readable $name] } {
	       return yes;
	   }
       } elseif { $mtime == "out" } {
           if { ! [file exists $name] } {
	       return yes;
	   }
       } else {
           if { ! [file readable $name] } {
	       return yes;
	   } else if { [file mtime $name] > $mtime } {
	       return yes;
	   }
       }
    }
    return no
}

# File-mtime list for parameter files.
#
set parameter_mtime_list changed

# Mtime of latest parameter file.
#
set parameter_mtime ""

# Process arguments.  If parameter files (including
# the judging_parameters_file) have not changed,  just
# restore values of scoreboard_ variables listed in
# parameters_array.
#
set LB "{"
# } to balance left bracket in last line
#
proc process_arguments {} {

    global judging_directory judging_parameters_file \
           parameter_mtime_list parameters_array \
	   parameter_mtime scoreboard_instructions
    foreach name [array names parameters_array] {
	global scoreboard_$name
    }

    if { ! [file_changed $parameter_mtime_list] } {

        foreach name [array names parameters_array] {
	    set scoreboard_$name \
	    	$parameters_array($name)
	}
	return
    }

    set parameter_mtime_list ""

    set pf $judging_directory/$judging_parameters_file
    if { $parameter_mtime_list != "changed" } {
        source $pf
    }
    set mtime [file mtime $pf]
    lappend parameter_mtime_list [list $mtime $pf]
    set parameter_mtime $mtime

    foreach arg [lrange $argv 1 end] {
	if { [regexp "^${LB}" $arg] } {
	    set scoreboard_instructions [lindex $arg 0]
	} else {
	    source $arg
	    set mtime [file mtime $arg]
	    lappend parameter_mtime_list \
	    	    [list $mtime $arg]
	    if { $mtime > $parameter_mtime } {
	        set parameter_mtime $mtime
	    }

	}
    }

    foreach name [array names parameters_array] {
        set parameters_array($name) \
	    [set scoreboard_$name]
    }
}

process_arguments


# Given a value that may be an abbreviation defined
# in the abbreviation_array, return the value it
# abbreviates, or return the original value if it is not
# an abbreviation.
#
proc unabbreviate { value } {

    global abbreviation_array

    if { [info exists abbreviation_array($value)] } {
        return $abbreviation_array($value)
    } else {
        return $value
    }
}


# File-mtime list for scoring instructions files.
#
set file_mtime_list changed

# Earliest future time in an OUTPUT instruction.
#
set earliest_future_time ""

# Last value of parameters_mtime.
#
set last_parameters_mtime $parameters_mtime

# Process parameter setting instruction.
#
proc set_parameter { instruction } {

    global parameters_array

    set name  [lindex $instruction 0]
    set value [lindex $instruction 1]

    if { ! [info exists parameters_array($name)] } {
	error "$name is not a parameter name"
    }

    set value [unabbreviate $value]
    global scoreboard_$name
    set scoreboard_$name $value
}

# Process scoring instructions.
#
proc process_instructions {} {

    global scoreboard_instructions abbreviation_array \
           file_mtime_list earliest_future_time \
	   last_parameters_mtime parameters_mtime \
	   finder_file judging_directory \
	   score_flag_file parameters_array
    foreach name [array names parameters_array] {
	global scoreboard_$name
    }

    # Use a single `run time' in computations.
    #
    set time [clock seconds]

    # Reinstall initial parameter values.
    #
    process_arguments

    # Recompute $finder_file if necessary.
    #
    if {    $file_mtime_list == "changed" \
         || ! [file readable $finder_file]
         || [test_flag $score_flag_file] } {

	make_signals_ignored
	file delete -force -- $finder_file
	exec scorefinder -gotten > $finder_file
	make_signals_default
    }

    # If we have no reason to rerun scoreboard instruc-
    # tions, return.
    #
    if {    $last_parameters_mtime \
               >= $parameters_mtime \
	 && ! [file_changed $file_mtime_list]
	 && $time < $earliest_future_time } {

        return
    }

    # Save abbreviations.
    #
    set abbreviation_array(START)  \
        $scoreboard_start_time
    set abbreviation_array(STOP)   \
        $scoreboard_stop_time
    set abbreviation_array(FREEZE) \
	$scoreboard_freeze_time
    set abbreviation_array(NAME)   \
        $scoreboard_name
    set abbreviation_array(TIME)   \
        [clock format $time]

    # Ignore signals while processing instructions.
    #
    make_signals_ignored

    # Loop to process instructions for first pass.
    #
    # Instructions are stored as list to make computa-
    # tion faster.
    #
    # Pass2 is called for every sequence of instructions
    # beginning with an OUTPUT instruction and ending
    # with an instruction other than OUTPUT.

    set instructions [concat $scoreboard_instructions]
    set pc 0
    set end_pc [llength $instructions]

    set earliest_future_time ""
    set last_parameters_mtime $parameters_mtime
    set output_found no

    while { "yes" } {

        set instruction [lindex $instructions $pc]
	set opcode [lindex $instruction 0]

	# If we are at the end of a sequence of
	# instructions that begins with an OUTPUT
	# instruction and ends just before the next
	# OUTPUT instruction or end of all instructions,
	# process OUTPUT instruction time parameters
	# and call pass2.
	#
        if { ( $pc >= $end_pc || $opcode == "OUTPUT" ) \
	     && $output_found } {

	    # If we are before OUTPUT start time, do
	    # NOT update.
	    #
	    if { $out_start != "" \
	         && $time < $out_start } {
	        set update no
	    }

	    # If output file exists and has an mtime >=
	    # the OUTPUT stop time, do NOT update.
	    #
	    if {    $out_mtime != "" \
	         && $out_stop != "" \
	         && $out_mtime >= $out_stop } {
	        set update no
	    }

	    # Perform second pass.
	    #
	    pass2 $instructions $out_pc $pc $update
	}

	# Update pc.
	#
	if { $pc >= $end_pc } break
	incr pc

	# Perform first pass on instruction.
	#
	switch $output_found-$opcode {

	    no-OUTPUT -
	    yes-OUTPUT {

	        # Compute output file.
		#
		set out_file  [lindex $instruction 1]
		set out_file \
		   [file join $judging_directory \
		              $out_file]

		# Compute start and stop times and
		# update earliest_future_time.
		#
		set out_start [lindex $instruction 2]
		set out_start [unabbreviate $out_start]
		if { $out_start != "" } {
		    set out_start \
		        [clock scan $out_start]
		    if { $out_start > $time \
		         && (    $earliest_future_time \
			 	     == "" \
			      || $earliest_future_time \
			             > $out_start ) } {
		        set earliest_future_time \
			    $out_start
		    }
		}
		set out_stop  [lindex $instruction 3]
		set out_stop [unabbreviate $out_stop]
		if { $out_stop != "" } {
		    set out_stop \
		        [clock scan $out_stop]
		    if { $out_stop > $time \
		         && (    $earliest_future_time \
			 	     == "" \
			      || $earliest_future_time \
			             > $out_stop ) } {
		        set earliest_future_time \
			    $out_stop
		    }
		}

		# Set out_mtime to the output file mtime
		# or "" if no output file exist, and
		# set `update' to no if the output file
		# exists and yes otherwise.
		#
		if { [file exists $out_file] } {
		    set update no
		    set out_mtime [file mtime $out_file]
		} else {
		    set update yes
		    set out_mtime ""
		}

		# Set output variables.
		#
	        set out_pc $pc
		set output_found yes

		# Remember output file in file_mtime_
		# list.
		#
		lappend file_mtime_list \
			[list out $out_file]
	    }

	    yes-SEND {}
	    yes-GRANT_ACCESS {}

	    yes-BLANK {}

	    yes-BAR -
	    yes-LINE {

	        # If scoreboard_width might have changed
		# force update.
		#
	    	if { $last_parameters_mtime \
		     < $parameters_mtime } {
		    set update yes
		}
	    }

	    yes-INPUT {

	        # Loop through input files until a read-
		# able one is found.
		#
		foreach in_file \
		        [lrange $instruction 1 end] {

		    set in_file \
		        [file join $judging_directory \
			           $in_file]

		    # Add input file to file_mtime_list.
		    #
		    if { [file readable $in_file] } {
			set mtime [file mtime $in_file]

			# If readable input file is
			# later than output file, force
			# update.
			#
			if {    $out_mtime != "" \
			     && $mtime > $out_mtime } {
			    set update yes
			}

			lappend file_mtime_list \
			        [list $mtime $in_file]
			break;
		    } else {
			lappend file_mtime_list \
				[list none $in_file]
		    }
		}
	    }

	    yes-BOARD {

	        # If scoreboard_ parameters might have
		# changed, force update.
		#
	    	if { $last_parameters_mtime \
		     < $parameters_mtime } {
		    set update yes
		}

		# Process $finder_file as per INPUT
		# files above.
		#
		if { [file readable $finder_file] } {
		    set mtime [file mtime $finder_file]
		    if {    $out_mtime != "" \
			 && $mtime > $out_mtime } {
			set update yes
		    }
		    lappend file_mtime_list \
		            [list $mtime $finder_file]
		} else {
		    lappend file_mtime_list \
			    [list none $finder_file]
		}

	    }

	    no-SEND -
	    no-GRANT_ACCESS -
	    no-BLANK -
	    no-BAR -
	    no-LINE -
	    no-INPUT -
	    no-BOARD {
	        error "`$instruction' appears before\
		       OUTPUT instruction"
	    }

	    default {

	        # Parameter setting instructions are
		# executed in the first pass only if
		# they are before all OUTPUT instruc-
		# tions.
		#
	        if { $output_found == "no" } {
		    set_parameter $instruction
		}
	    }
	}
    }

    # End of instruction processing loop.  Reenable
    # interrupts.
    #
    make_signals_default
}

proc pass2 { instructions pc end_pc update } {

    global parameters_array scoreboard_instructions \
           judging_directory finder_file
    foreach name [array names parameters_array] {
	global scoreboard_$name
    }

    set instructions $scoreboard_instructions
    set out_file [lindex [lindex $instructions $pc] 1]
    set out_file \
        [file join $judging_directory $out_file]

    incr pc
    set contents ""
    set send no
    set grant_access no

    set bar ""
    set w [expr { $scoreboard_width / 5 } ]
    while { $w > 0 } {
	set bar "$bar== =="
	incr w -1
    }

    while { $pc < $end_pc } {
	set instruction [lindex $instructions $pc]
	incr pc
	set opcode [lindex $instruction 0]
	switch $opcode_$update {

	    SEND_yes {
		set send_qualifier \
		    [lindex $instruction 1]
		set name [lindex $instruction 2]
		if { $name == "" } {
		    set name = addresses
		}
		if { ! [info exists scoreboard_$name] \
						} {
		   set send_addresses ""
		} else {
		   set send_addresses \
		       [set scoreboard_$name]
		}
		set send yes
	    }

	    GRANT_ACCESS {
		set grant_access yes
	    }

	    BLANK_yes {
		set contents "$contents\n"
	    }

	    BAR_yes {
		set contents "$contents$bar\n"
	    }

	    LINE_yes {

		if { $scoreboard_width > 256 } {
		    error "scoreboard width > 256"
		}
		set left   [lindex $instruction 1]
		set center [lindex $instruction 2]
		set right  [lindex $instruction 3]

		set left   [unabbreviate $left]
		set center [unabbreviate $center]
		set right  [unabbreviate $right]

		set left_end [string length $left]
		incr left_end -1
		set right_begin \
		    [expr { $scoreboard_width - \
			    [string length $right] }]
		set center_length \
		    [string length $center]
		set center_begin  \
		    [expr { ( $scoreboard_width \
			      - $center_length ) / 2 }]
		set center_end \
		    [expr { $center_begin \
			    + $center_length - 1 }]

		if { $left_end >= $scoreboard_width } {
		    error "LINE left text too wide:\
		           $left"
		} else if { $right_end < 0 } {
		    error "LINE right text too wide:\
		           $right"
		} else if { $center_begin < 0 \
		            || $center_end \
			       >= $scoreboard_width } {
		    error "LINE center text too wide:\
		           $center"
		}

		set line "$left"

		set center_done no
		set right_done  no

		if {    $center != ""
		     && ( $left == "" \
		          || $left_end + 2 \
			     < $center_begin ) \
		     && ( $right == "" \
		          || $center_end + 2 \
			     < $right_begin ) } {
		    incr left_end 1
		    incr center_begin -1
		    set line \
			"$line[string \
				  range $space \
				  $left_end \
				  $center_begin]"
		    set line "$line$center"
		    set center_done yes
		    set left_end $center_end
		}
		if { $right != ""
		     && ( $left_end == -1 \
		          || $left_end + 2 \
			     < $right_begin ) } {
		    incr left_end 1
		    incr right_begin -1
		    set line \
			"$line[string \
				  range $space \
				  $left_end \
				  $right_begin]"
		    set line "$line$right"
		    set right_done yes
		}
		if { $center != "" && \
		     $center_done == "no" } {
		    incr center_begin -1
		    set line \
			"$line\n[string \
				    range $space \
				    0 $center_begin]
		    set line "$line$center"
		}
		if { $right != "" \
		     && $right_done == "no" } {
		    incr right_begin -1
		    set line \
			"$line\n[string \
				    range $space \
				    0 $right_begin]
		    set line "$line$right"
		}
		set contents "$contents$line\n"
	    }

	    INPUT_yes {
		foreach in_file \
		        [lrange $instruction 1 end] {
		    set in_file \
		        [file join $judging_directory \
			           $in_file]
		    if { [file readable $in_file] } {
			if { [file size $in_file] > 0 \
					} {
			    set c [read_entire_file \
			    		$in_file]
			    set contents "$contents$c\n"
			}
			break;
		    }
		}
	    }
	    BOARD_yes {
	        set parameters ""
		foreach name \
		        [array names parameters_array] {
		    lappend parameters \
		        [list $name \
			      [set scoreboard_$name]]
		}
		set scoreboard \
		    [exec scoreboard "{ $parameters }" \
				     < $finder_file]

		# If the scoreboard is empty, say so
		# explicitly.
		#
		if { $scoreboard == "" } {
		    set scoreboard \
		        "The scoreboard is currently\
			 EMPTY!  Nothing must have\
			 happened yet."
		}
	        set contents "$contents$scoreboard\n"
	    }
	    BLANK_no {}
	    BAR_no {}
	    LINE_no {}
	    INPUT_no {}
	    BOARD_no {}
	    SEND_no {}
	    default {
		set_parameter $instruction
	    }
	}
    }

    if { $update } {
	set ch [open $out_file w]
        puts -nonewline $ch $contents
	close $ch
	if { $grant_access } {
	    grant_access $out_file
	}

	if { $send } {
	    foreach to $send_addresses {
	        if { $send_qualifier != "" \
	             && ! [regexp {<} $to] } {
		    set to "<$to>"
	        }
	        send_message \
	           "To: $send_qualifier$to\n\n$contents"
	    }
    	}
    }
}


# Process command.
#
set saved_log_mode $log_mode
set log_mode none
switch $command {

    start {
	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { ! [regexp -nocase \
			    {^no process .* exists} \
			    $display] } {
		 puts "Previous makescoreboard still\
		       running:"
		 puts $display
		 exit 0
	     }
	     file delete -force $pid_file
	}

	set interval $scoreboard_interval

        process_instructions

	write_file $pid_file [current_pid]
	set log_mode $saved_log_mode

	while { "yes" } {
	    sleep $interval
	    set c 0
	    while { "yes" } {
	        incr c
		if { $c < 5 } {
		    if { ! [catch {
		              process_instructions }] \
			          } break
		    sleep 10
		} else {
		    process_instructions
		}
	    }
	}
    }

    status {
	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { ! [regexp -nocase \
			    {^no process .* exists} \
			    $display] } {
		 puts "Makescoreboard running:"
		 puts $display
	     } else {
		 puts "Makescoreboard has died:"
		 puts $display
		 puts ""
		 puts "Run `tracker' to find error\
		       logs, or look in"
		 puts "$log_directory for unchecked\
		       errors."
	     }
	} else {
	    puts "All previous makescoreboards have\
	          been stopped."
	}
    }

    stop {
	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { ! [regexp -nocase \
			    {^no process .* exists} \
			    $display] } {
		 puts "Killing previous makescoreboard:"
		 puts $display
		 set count 0
		 while { "true" } {
		     incr count 1
		     if { $count <= 5 } {
			 catch { signal_process_tree \
				 HUP $pid } out
			 puts $out
		     } elseif { $count <= 10 } {
			 catch { signal_process_tree \
				 KILL $pid } out
			 puts $out
		     } else {
			 puts "ERROR: Giving Up!"
			 exit 1
		     }
		     sleep 1
		     set display \
		         [display_process_tree $pid]
		     if { [regexp \
		               -nocase \
			       {^no process .* exists} \
			       $display] } {
			 break
		     }
		 }
	     }
	     file delete -force $pid_file
	} else {
	    puts "No previous makescoreboard running."
	}
    }

    update {
        process_instructions
    }
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
