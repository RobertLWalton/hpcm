#!/bin/sh
#
# Recomputes the scoreboard every minute.
#
# File:		makescoreboard
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sat Feb  9 10:38:27 EST 2002
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2002/02/09 15:55:13 $
#   $RCSfile: old_makescoreboard,v $
#   $Revision: 1.31 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl

# Set log mode, saving old mode.
#
set log_globally yes
set saved_log_mode $log_mode
set log_mode none

catch {

set document "
makescoreboard { start | status | stop | update } \\
               \[ parameter-filename | \\
	         scoreboard_instructions-value \] ...

    This program makes scoreboards by following the
    instructions stored in the `scoreboard_instructions'
    global variable.  See the $judging_parameters_file\
    				file
    for a description of these instructions.

    When this program starts, it processes its second
    and subsequent arguments as follows.  Any named
    parameter file is `sourced'.  Any argument that
    begins with a `{' is stored (with the `{ }' brackets
    removed) in the `scoreboard_instructions' global
    variable.
    
    This program calls
    
	scorefinder -gotten \\
	    > judging_directory/$scorefinder_output_file

    The $scorefinder_output_file file is used as input\
    						   by
    the `scoreboard' program to produce scoreboards.
    To avoid conflicts between the `start' and `update'
    commands, this program adds a `+' to the end of the
    name $scorefinder_output_file when running the\
	update
    command.

    This program ignores signals when computing score-
    boards, and terminates without error on a signal
    while the program is sleeping for an interval.

    If called with an `update' command, this program
    processes the scoreboard instructions just once
    and then exits immediately.

    If called with the `start' command, this program
    executes itself as a subprocess and writes into the
    $scoreboard_pid_file file in the judging directory\
    					the
    process ID of the subprocess.  This subprocess pro-
    cess the scoreboard instructions at periodic inter-
    vals.  But if the $scoreboard_pid_file file already
    exists, AND the process ID it contains is valid,
    this program prints information about the ID'ed
    process and does nothing else.

    The first time the `start' command processes the
    scoreboard instructions, it does so just like the
    `update' command.  Then this program resumes at
    intervals determined by the `scoreboard_interval'
    global variable.  After every interval, this
    program checks to see if any inputs to the last run
    have been changed, or any outputs have been deleted,
    and if yes, this program reruns the scoreboard in-
    structions.  The inputs checked for change include
    the $judging_parameters_file file in the judging\
    					directory
    and the parameter files listed in the arguments.
    Before checking files for change, the\
    		$score_flag_file
    flag is checked, and if present, the `scorefinder'
    program is called to remake the\
    	$scorefinder_output_file
    file.  This is also done if the\
    	$scorefinder_output_file
    no longer exists.

    If called with the `stop' command, this program does
    nothing but send kill signals to the process whose
    ID is listed in the $scoreboard_pid_file file, and\
    			then
    deletes that file.  While doing this it outputs in-
    formation about its progress.

    If called with the `status' command, this program
    just outputs information about the status of any
    process started by `makescoreboard start'.

    With the `update', `status', or `stop' commands this
    program does not log errors but writes them to the
    standard error.  This program does the same with
    `start' command errors that occur during the first
    making of the scoreboard.  But after beginning
    reruns for the `start' command, this program logs
    errors in a global log directory."

# } to balance extra left bracket in documentation.

# Print documentation if illegal (or -doc) first
# argument.
#
set command [lindex $argv 0]
if { ! [regexp {^(update|start|status|stop|-start-)$} \
               $command] } {
    puts $document
    exit 1
}

# Constant equal to 256 spaces.
#
set space "        "
set space "$space$space"
set space "$space$space"
set space "$space$space"
set space "$space$space"
set space "$space$space"

# Compute file names.
#
set finder_file \
    $judging_directory/$scorefinder_output_file
if { $command == "update" } {
    set finder_file $finder_file+
}
set pid_file \
    $judging_directory/$scoreboard_pid_file

# Compute possible parameters and save original values.
#
foreach name [info globals scoreboard_*] {
    regexp {^scoreboard_(.*)$} $name forget pname
    if { $pname != "instructions" } {
	set parameters_array($pname) [set $name]
    }
}

# Return `yes' if a file in the mtime_list has changed.
# Otherwise return `no'.
#
# The mtime_list is a list of items each of the format:
#
#	{ file-mtime file-name }
#
# The file-mtime can be a `clock seconds' value, or
# `none' if the file did not exist, or `out' if the
# file was output.  A file changes if it appears or
# disappears or now has a larger mtime than its file-
# mtime clock seconds value.
#
# If mtime_list has the special value `changed', this
# function always returns `yes'.
#	
proc file_changed { mtime_list } {

    if { $mtime_list == "changed" } {
        return yes
    }

    foreach item $mtime_list {
       set mtime [lindex $item 0]
       set name  [lindex $item 1]

       if { $mtime == "none" } {
           if { [file readable $name] } {
	       return yes;
	   }
       } elseif { $mtime == "out" } {
           if { ! [file exists $name] } {
	       return yes;
	   }
       } else {
           if { ! [file readable $name] } {
	       return yes;
	   } elseif { [file mtime $name] > $mtime } {
	       return yes;
	   }
       }
    }
    return no
}

# Mtime-list for parameter files.
#
set parameter_mtime_list changed

# Mtime of latest parameter file.
#
set parameter_mtime ""

# Process arguments.  If parameter files (including
# the judging_parameters_file) have not changed,  just
# restore values of scoreboard_ variables listed in
# parameters_array.
#
proc process_arguments { { first_time no } } {

    global judging_directory judging_parameters_file \
           parameter_mtime_list parameters_array \
	   parameter_mtime scoreboard_instructions argv
    foreach name [array names parameters_array] {
	global scoreboard_$name
    }

    if { [file_changed $parameter_mtime_list] \
         == "no" } {

        foreach name [array names parameters_array] {
	    set scoreboard_$name \
	    	$parameters_array($name)
	}
	return
    }

    # Set parameter_mtime_list so that if there is an
    # error reading parameters, and we are recalled to
    # try again, the parameters will be reread.  Errors
    # may occur due to files changing dynamically while
    # makescoreboard runs asynchronously.
    #
    set parameter_mtime_list changed

    # Accumulate new parameter_mtime_list value in this
    # local variable until we have succeeded.
    #
    set mtime_list ""

    set pf $judging_directory/$judging_parameters_file
    if { $first_time == "no" } {
        source $pf
    }
    set mtime [file mtime $pf]
    lappend mtime_list [list $mtime $pf]
    set parameter_mtime $mtime

    set LB "{"
    # } to balance left bracket in last line
    #
    foreach arg [lrange $argv 1 end] {
	if { [regexp "^${LB}" $arg] } {
	    set scoreboard_instructions [lindex $arg 0]
	} else {
	    source $arg
	    set mtime [file mtime $arg]
	    lappend mtime_list [list $mtime $arg]
	    if { $mtime > $parameter_mtime } {
	        set parameter_mtime $mtime
	    }

	}
    }

    foreach name [array names parameters_array] {
        set parameters_array($name) \
	    [set scoreboard_$name]
    }

    set parameter_mtime_list $mtime_list
}

# Process arguments for the first time.
#
process_arguments yes


# Given a value that may be an abbreviation defined
# in the abbreviation_array, return the value it
# abbreviates, or return the original value if it is not
# an abbreviation.
#
proc unabbreviate { value } {

    global abbreviation_array

    if { [info exists abbreviation_array($value)] } {
        return $abbreviation_array($value)
    } else {
        return $value
    }
}


# Mtime-list for scoreboard instructions files.
#
set file_mtime_list changed

# Earliest future time in an OUTPUT instruction.
#
set earliest_future_time ""

# Last value of parameter_mtime.
#
set last_parameter_mtime ""

# Process parameter setting instruction.
#
proc set_parameter { instruction } {

    global parameters_array

    set name  [lindex $instruction 0]
    set value [lindex $instruction 1]

    if { ! [info exists parameters_array($name)] } {
	error "$name is not a parameter name"
    }

    set value [unabbreviate $value]
    global scoreboard_$name
    set scoreboard_$name $value
}

# Process scoreboard instructions.
#
proc process_instructions {} {

    global scoreboard_instructions abbreviation_array \
           file_mtime_list earliest_future_time \
	   last_parameter_mtime parameter_mtime \
	   finder_file judging_directory \
	   score_flag_file parameters_array
    foreach name [array names parameters_array] {
	global scoreboard_$name
    }

    # Use a single `run time' in computations.
    #
    set time [clock seconds]

    # Reinstall initial parameter values.
    #
    process_arguments

    # Recompute $finder_file if necessary.
    #
    if {    $file_mtime_list == "changed" \
         || ! [file readable $finder_file]
         || [test_flag $score_flag_file] } {

	make_signals_ignored
	clear_flag $score_flag_file
	file delete -force -- $finder_file
	exec scorefinder -gotten > $finder_file
	make_signals_default
    }

    # Save $finder_file mtime for use below.
    #
    set finder_mtime [file mtime $finder_file]

    # If we have no reason to rerun scoreboard instruc-
    # tions, return.
    #
    if {    [file_changed $file_mtime_list] == "no"
         && $last_parameter_mtime \
               >= $parameter_mtime \
	 && ( $earliest_future_time == "" \
	      || $time < $earliest_future_time ) } {

        return
    }

    # Save abbreviations.
    #
    set start_time $scoreboard_start_time
    set abbreviation_array(START) $start_time

    if { ! [regexp {^(|team)$} $start_time] } {
        set st [clock scan $start_time]
    } else {
        set st ""
    }

    set stop_time $scoreboard_stop_time
    if {    [regexp {^(|\+)[0-9]+$} $stop_time] \
         && $st != "" } {
        set stop_time \
	    [clock format [expr { $st + $stop_time }]]
    }
    set abbreviation_array(STOP) $stop_time

    set freeze_time $scoreboard_freeze_time
    if {    [regexp {^(|\+)[0-9]+$} $freeze_time] \
         && $st != "" } {
        set freeze_time \
	    [clock format [expr { $st + $freeze_time }]]
    }
    set abbreviation_array(FREEZE) $freeze_time

    set abbreviation_array(NAME)   \
        $scoreboard_name
    set abbreviation_array(TIME)   \
        [clock format $time]

    # Ignore signals while processing instructions.
    #
    make_signals_ignored


    # Set file_mtime_list so that if there is an error
    # processing instructions, and we are recalled to
    # try again, the instructions will be reprocessed.
    # Errors may occur due to files changing dynamically
    # while makescoreboard runs asynchronously.
    #
    set file_mtime_list changed

    # Accumulate new file_mtime_list value in this local
    # variable until we have succeeded.
    #
    set mtime_list ""

    # Accumulate new earliest_future_time value in eft.
    #
    set eft ""

    # Loop to process instructions for first pass.
    #
    # Instructions are converted to a list to make com-
    # putation faster.  Lrange will do this, but concat
    # will NOT.
    #
    # Pass2 is called for every sequence of instructions
    # beginning with an OUTPUT instruction and ending
    # with the instruction before the next OUTPUT in-
    # struction or end of all instructions.

    set instructions \
        [lrange $scoreboard_instructions 0 end]
    set pc 0
    set end_pc [llength $instructions]
    set output_found no

    while { "yes" } {

        set instruction [lindex $instructions $pc]
	set opcode [lindex $instruction 0]

	# If we are at the end of a sequence of
	# instructions that begins with an OUTPUT
	# instruction and ends just before the next
	# OUTPUT instruction or end of all instructions,
	# process OUTPUT instruction time parameters
	# and call pass2.
	#
        if { ( $pc >= $end_pc || $opcode == "OUTPUT" ) \
	     && $output_found } {

	    # If we are before OUTPUT start time, do
	    # NOT update.
	    #
	    if { $out_start != "" \
	         && $time < $out_start } {
	        set update no
	    }

	    # If output file exists and has an mtime >=
	    # the OUTPUT stop time, do NOT update.
	    #
	    if {    $out_mtime != "" \
	         && $out_stop != "" \
	         && $out_mtime >= $out_stop } {
	        set update no
	    }

	    # Perform second pass.
	    #
	    pass2 $instructions $out_pc $pc $update
	}

	# Update pc.
	#
	if { $pc >= $end_pc } break
	incr pc

	# Perform first pass on instruction.
	#
	switch ${output_found}_$opcode {

	    no_OUTPUT -
	    yes_OUTPUT {

	        # Compute output file.
		#
		set out_file  [lindex $instruction 1]
		set out_file \
		   [file join $judging_directory \
		              $out_file]

		# Compute start and stop times and
		# update eft.
		#
		set out_start [lindex $instruction 2]
		set out_start [unabbreviate $out_start]
		if { $out_start != "" } {
		    set out_start \
		        [clock scan $out_start]
		    if { $out_start > $time \
		         && (    $eft == "" \
			      || $eft > $out_start ) } {
		        set eft $out_start
		    }
		}
		set out_stop  [lindex $instruction 3]
		set out_stop [unabbreviate $out_stop]
		if { $out_stop != "" } {
		    set out_stop \
		        [clock scan $out_stop]
		    if { $out_stop > $time \
		         && (    $eft == "" \
			      || $eft > $out_stop ) } {
		        set eft $out_stop
		    }
		}

		# Set out_mtime to the output file mtime
		# or "" if no output file exist, and
		# set `update' to no if the output file
		# exists and yes otherwise.
		#
		if { [file exists $out_file] } {
		    set update no
		    set out_mtime [file mtime $out_file]
		} else {
		    set update yes
		    set out_mtime ""
		}

	        # If scoreboard_instructions might have
		# changed force update.
		#
	    	if { $last_parameter_mtime == ""
	    	     || $last_parameter_mtime \
		        < $parameter_mtime } {
		    set update yes
		}

		# Set output variables.
		#
	        set out_pc $pc
		incr out_pc -1
		set output_found yes

		# Remember output file in mtime_list.
		#
		lappend mtime_list [list out $out_file]
	    }

	    yes_SEND {}
	    yes_GRANT_ACCESS {}

	    yes_BLANK {}

	    yes_BAR {}
	    yes_LINE {}

	    yes_INPUT {

	        # Loop through input files until a read-
		# able one is found.
		#
		foreach in_file \
		        [lrange $instruction 1 end] {

		    set in_file \
		        [file join $judging_directory \
			           $in_file]

		    # Add input file to mtime_list.
		    #
		    if { [file readable $in_file] } {
			set mtime [file mtime $in_file]

			# If readable input file is
			# later than output file, force
			# update.
			#
			if {    $out_mtime != "" \
			     && $mtime > $out_mtime } {
			    set update yes
			}

			lappend mtime_list \
			        [list $mtime $in_file]
			break;
		    } else {
			lappend mtime_list \
				[list none $in_file]
		    }
		}
	    }

	    yes_BOARD {

		# Process finder_file mtime stored in
		# finder_mtime above.
		#
		if {    $out_mtime != "" \
		     && $finder_mtime > $out_mtime } {
		    set update yes
		}
		lappend mtime_list \
			[list $finder_mtime \
			      $finder_file]
	    }

	    no_SEND -
	    no_GRANT_ACCESS -
	    no_BLANK -
	    no_BAR -
	    no_LINE -
	    no_INPUT -
	    no_BOARD {
	        error "`$instruction' appears before\
		       OUTPUT instruction"
	    }

	    default {

	        # Parameter setting instructions are
		# executed in the first pass only if
		# they are before all OUTPUT instruc-
		# tions.
		#
	        if { $output_found == "no" } {
		    set_parameter $instruction
		}
	    }
	}
    }

    # End of instruction processing loop.  Store record
    # of just finished actions and reenable interrupts.
    #
    set earliest_future_time $eft
    set last_parameter_mtime $parameter_mtime
    set file_mtime_list $mtime_list
    make_signals_default
}

# Execute scoreboard instructions during second pass.
# Instruction at pc is an OUTPUT instruction, and
# instruction at endpc is the next OUTPUT instruction
# or is just beyond the end of all instructions.
#
proc pass2 { instructions pc end_pc update } {

    global parameters_array judging_directory \
    	   finder_file space errorInfo errorCode
    foreach name [array names parameters_array] {
	global scoreboard_$name
    }

    # Compute output file and step past OUTPUT instruc-
    # tion.
    #
    set instruction [lindex $instructions $pc]
    set out_file [lindex $instruction 1]
    if { $out_file == "" } {
        error "Bad OUTPUT instruction: $instruction"
    }
    set out_file \
        [file join $judging_directory $out_file]
    incr pc

    # Compute output file in `contents' variable.
    #
    set contents ""
    set send no
    set grant_access no

    # Compute BAR.
    #
    set bar ""
    set solid_bar =====
    set w [expr { $scoreboard_width / 5 } ]
    while { $w > 0 } {
	set bar "$bar== =="
	set solid_bar $solid_bar=====
	incr w -1
    }

    # Loop through remaining instructions.
    #
    while { $pc < $end_pc } {

	# Compute instruction and opcode and update pc.
	#
	set instruction [lindex $instructions $pc]
	set opcode [lindex $instruction 0]
	incr pc

	switch ${opcode}_$update {

	    SEND_yes {

	        # Compute send_qualifier and send_
		# addresses for use when output done.
		#
		set send_qualifier \
		    [lindex $instruction 1]
		set name [lindex $instruction 2]
		if { $name == "" } {
		    set name addresses
		}
		if { ! [info exists scoreboard_$name] \
						} {
		   set send_addresses ""
		} else {
		   set send_addresses \
		       [set scoreboard_$name]
		}

		# Set switch to indicate SEND happened.
		#
		set send yes
	    }

	    GRANT_ACCESS_yes {
		set grant_access yes
	    }

	    BLANK_yes {
		set contents "$contents\n"
	    }

	    BAR_yes {
	        set text [lindex $instruction 1]
		if { $text == "" } {
		    set contents "$contents$bar\n"
		} else {
		    set sw $scoreboard_width
		    set len [string length $text]
		    incr len 2
		    if { $len + 4 > $sw} {
		        error "scoreboard_width not\
			       wide enough for\
			       `$instruction'"
		    }
		    set left \
		        [expr { ( $sw - $len ) / 2 }]
		    set right \
		        [expr { $sw - $len - $left }]
		    incr left -1
		    incr right -1
		    set left \
		        [string range $solid_bar \
			        0 $left]
		    set right \
		        [string range $solid_bar \
			        0 $right]
		    set contents \
		        "$contents$left $text $right\n"
		}
	    }

	    LINE_yes {

		# Make sure `space is long enough'.
		#
		if { $scoreboard_width > 256 } {
		    error "scoreboard width > 256"
		}

		# Compute left, center, and right
		# text.
		#
		set left   [lindex $instruction 1]
		set center [lindex $instruction 2]
		set right  [lindex $instruction 3]

		set left   [unabbreviate $left]
		set center [unabbreviate $center]
		set right  [unabbreviate $right]

		# Compute columns of beginning and/or
		# end for each of the three texts.
		# Columns are numbered 0, 1, ...
		#
		set left_end [string length $left]
		incr left_end -1
		set right_begin \
		    [expr { $scoreboard_width - \
			    [string length $right] }]
		set center_length \
		    [string length $center]
		set center_begin  \
		    [expr { ( $scoreboard_width \
			      - $center_length + 1 ) \
			    / 2 }]
		set center_end \
		    [expr { $center_begin \
			    + $center_length - 1 }]

		# Make sure texts are short enough so
		# that their ends are within limits.
		#
		if { $left_end >= $scoreboard_width } {
		    error "LINE left text too wide:\
		           $left"
		} elseif { $right_begin < 0 } {
		    error "LINE right text too wide:\
		           $right"
		} elseif {    $center_begin < 0 \
		           || $center_end \
			      >= $scoreboard_width } {
		    error "LINE center text too wide:\
		           $center"
		}

		# Compute line.  Start with left text.
		#
		set line $left

		set center_done no
		set right_done  no

		# If center is non-empty and has a 2
		# space gap between it and any other
		# non-empty text, add the center to the
		# line.
		#
		if {    $center != "" \
		     && ( $left == "" \
		          || $left_end + 2 \
			     < $center_begin ) \
		     && ( $right == "" \
		          || $center_end + 2 \
			     < $right_begin ) } {
		    incr left_end 1
		    incr center_begin -1
		    set line \
			"$line[string \
				  range $space \
				  $left_end \
				  $center_begin]"
		    set line "$line$center"
		    set center_done yes
		    set left_end $center_end
		}

		# If right text is non-empty and has a 2
		# space gap with the part of the line
		# to its left, add it to line.
		#
		if {    $right != ""
		     && ( $left_end == -1 \
		          || $left_end + 2 \
			     < $right_begin ) } {
		    incr left_end 1
		    incr right_begin -1
		    set line \
			"$line[string \
				  range $space \
				  $left_end \
				  $right_begin]"
		    set line "$line$right"
		    set right_done yes
		}

		# If center text did not get added to
		# first line, put it on a line by it-
		# self.
		#
		if { $center != "" && \
		     $center_done == "no" } {
		    incr center_begin -1
		    set line \
			"$line\n[string \
				    range $space \
				    0 $center_begin]"
		    set line "$line$center"
		}

		# If right text did not get added to
		# first line, put it on a line by it-
		# self.
		#
		if { $right != "" \
		     && $right_done == "no" } {
		    incr right_begin -1
		    set line \
			"$line\n[string \
				    range $space \
				    0 $right_begin]"
		    set line "$line$right"
		}

		# Add line to contents of output.
		#
		set contents "$contents$line\n"
	    }

	    INPUT_yes {

	        # Loop through input files.
		#
		foreach in_file \
		        [lrange $instruction 1 end] {

		    set in_file \
		        [file join $judging_directory \
			           $in_file]

		    # Add first readable input file to
		    # the output contents.
		    #
		    if { [file readable $in_file] } {
			if { [file size $in_file] > 0 \
					} {
			    set c [read_entire_file \
			    		$in_file]
			    set contents "$contents$c\n"
			}
			break;
		    }
		}
	    }

	    BOARD_yes {

	        # Compute parameters to be passed to
		# the scoreboard program.
		#
	        set parameters ""
		foreach name \
		        [array names parameters_array] {
		    lappend parameters \
		        [list $name \
			      [set scoreboard_$name]]
		}

		# Call the scoreboard program to compute
		# the board.
		#
		set scoreboard \
		    [exec scoreboard "{ $parameters }" \
				     < $finder_file]

		# If the scoreboard is empty, say so
		# explicitly.
		#
		if { $scoreboard == "" } {
		    set scoreboard \
		        "The scoreboard is currently\
			 EMPTY!  Nothing must have\
			 happened yet."
		}

		# Add the scoreboard to the output file
		# contents.
		#
	        set contents "$contents$scoreboard\n"
	    }

	    SEND_no -
	    GRANT_ACCESS_no -
	    BLANK_no -
	    BAR_no -
	    LINE_no -
	    INPUT_no -
	    BOARD_no {

		# If update is `no' most instructions do
		# nothing.
		#
	    }

	    default {
	        # Execute parameter setting instruction
		# regardless of update value.
		#
		set_parameter $instruction
	    }
	}
    }

    if { $update } {

	# Write output file.  If error, delete file.
	#
	if { [catch {

		set ch [open $out_file w]
		puts -nonewline $ch $contents
		close $ch
		if { $grant_access } {
		    grant_access $out_file
		}

		# Send email.
		#
		if { $send } {
		    set sq $send_qualifier
		    foreach to $send_addresses {
			if { $sq != "" } {
			    if { [regexp {<} $to] } {
				set to "$sq-$to"
			    } else {
				set to "$sq<$to>"
			    }
			}
			send_message \
			   "To: $to\n\n$contents"
		    }
		}
	    } error_message] } {

	    # On error, delete output file and rethrow
	    # the error.  When we are rerun, the output
	    # file will be recomputed and remailed.
	    #
	    if { [file isfile $out_file] } {

		# Its possible if instructions are
		# miswritten to have out_file name a
		# directory.

		file delete -force -- $out_file
	    }
	    error $error_message $errorInfo $errorCode
	}
    }
}


# Process command.
#
switch -- $command {

    start {

	# Check pid_file and delete it if its process
	# is no longer running.
	# 
	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { [process_found $display] } {
		 puts "Previous makescoreboard still\
		       running:"
		 puts $display
		 exit 0
	     }
	     file delete -force $pid_file
	}

	# Run makescoreboard as a subprocess.
	#
        eval exec makescoreboard -start- \
	     [lrange $argv 1 end] &

	# Wait for any output from first run.
	#
	while { ! [file exists $pid_file] } {
	    sleep 1
	}
    }

    -start- {

	# Save interval before processing instructions.
	#
	set interval $scoreboard_interval

	# Process scoreboard instructions for the first
	# time.
	#
        process_instructions

	# Restore log mode and disable standard output
	# and error.
	#
	set log_mode $saved_log_mode
	disable_outputs

	# Set pid file.
	#
	write_file $pid_file [current_pid]

	# Resume a periodic intervals.
	#
	while { "yes" } {
	    sleep $interval
	    set c 0

	    # Run up to 4 time ignoring errors.
	    # Then if there are 4 erroneous runs, try
	    # a run in which errors stop the program.
	    #
	    # We do this because changes to files during
	    # a run may cause spurious errors.
	    #
	    while { "yes" } {
	        incr c
		if { $c < 5 } {
		    if { ! [catch {
		              process_instructions }] \
			          } break
		    sleep 10
		} else {
		    process_instructions
		}
	    }
	}
    }

    status {

	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { [process_found $display] } {
		 puts "Makescoreboard running:"
		 puts $display
	     } else {
		 puts "Makescoreboard has died:"
		 puts $display
		 puts ""
		 puts "Run `tracker' to find error\
		       logs, or look in"
		 puts "$log_directory for unchecked\
		       errors."
	     }
	} else {
	    puts "All previous makescoreboards have\
	          been stopped."
	}
    }

    stop {
	if { [file exists $pid_file] } {
	     set pid [read_file $pid_file]
	     set display [display_process_tree $pid]
	     if { [process_found $display] } {
		 puts "Killing previous makescoreboard:"
		 puts $display

		 # Try to kill up to 30 times, checking
		 # after each attempt for death.  The
		 # first 20 times are with HUP, the next
		 # 10 times are with KILL.
		 #
		 set count 0
		 while { "true" } {
		     incr count 1
		     if { $count <= 20 } {
			 catch { signal_process_tree \
				 HUP $pid } out
			 puts $out
		     } elseif { $count <= 30 } {
			 catch { signal_process_tree \
				 KILL $pid } out
			 puts $out
		     } else {
			 puts "ERROR: Giving Up!"
			 exit 1
		     }
		     sleep 1
		     set display \
		         [display_process_tree $pid]
	             if { ! [process_found $display] } {
			 break
		     }
		 }
	     }
	     file delete -force $pid_file
	} else {
	    puts "No previous makescoreboard running."
	}
    }

    update {
        process_instructions
    }
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
