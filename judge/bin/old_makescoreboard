#!/bin/sh
#
# Makes contest/scoreboard.1 every minute.
#
# File:		makescoreboard
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sat Jan  6 10:45:39 EST 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/01/06 16:25:18 $
#   $RCSfile: old_makescoreboard,v $
#   $Revision: 1.6 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_globally yes
catch {

set document "
makescoreboard \[-start | -status | -stop\] \\
               \[-email address\]\
	       \[-parameters parameter-file\] \\
               \[interval\]

    This program makes the scoreboard putting it in the
    file contest_directory/scoreboard.1 and/or e-mailing
    it to a given address at periodic intervals.  The
    interval in seconds can be set by the interval argu-
    ment, but will default to 60 seconds.
    
    This program calls
    
	scorefinder | scoreboard \[parmeters-file\]

    to recompute the scoreboard.
    
    If the judging_directory/contest directory exists,
    this program recomputes the file:

    	judging_directory/contest/scoreboard.1

    whenever the scoreboard is recomputed, by prepending
    the file

    	judging_directory/contest/scoreboard.1head

    to the recomputed scoreboard.

    This program prepends any
    contest_directory/scoreboard.1head file to the out-
    put of the scoreboard program when making the
    scoreboard.1 file, and postfixes the file
    ./scoreboard.notes to the output of the scoreboard
    program to form the message to send to an email
    address.  This program uses the directory
    score flag file and mtimes of files, including
    $judging_parameters_file, to avoid actually\
    				recomputing and
    resending the scoreboard unnecessarily.

    If the -email option is given, this program e-mails
    to the address given in the option the recomputed
    scoreboard with the file
    
    	judging_directory/scoreboard.notes

    appended, whenever the scoreboard is recomputed.

    Deleting an existing scoreboard.1 file, our touching
    (see the UNIX touch(1) command) or changing any
    of the files:

    	$judging_parameters_file
	contest_directory/scoreboard.1head
	judging_directory/scoreboard.notes

    will cause this program to recompute the scoreboard
    when its next interval expires.
    
    Calling this program with an interval of 0 will
    cause this program to recompute the scoreboard just
    once and then exit immediately.

    This program ignores signals when recomputing the
    scoreboard, and terminates without error on a signal
    while the program is sleeping for the interval.

    If called with the -start option, this program
    creates a subprocess in which it calls itself with-
    out the -start option, and writes the process ID of
    that subprocess into the $scoreboard_pid_file file\
    		in
    the judging directory.  While doing this, this pro-
    gram outputs information about its progress (however
    the subprocess does not output anything).  But if
    the $scoreboard_pid_file already exists, AND the\
    		process
    ID it contains is valid, this program prints infor-
    mation about the ID'ed process and does nothing
    else.
    
    If called with the -stop option, this program does
    nothing but send kill signals to the process whose
    ID is listed in the $scoreboard_pid_file file, and
    then deletes the file.  While doing this it outputs
    information about its progress.

    If called with the -status option, this program just
    outputs information about the status of any process
    started by `makescoreboard -start'.

    With the -start, -status, or -stop option this
    program does not log errors but writes them to the
    standard error.  Without these options, this program
    logs errors in the log directory."

# Process any -start option.  If second argument exists,
# it must be a non-zero interval.
#
if { $argc >= 1 && [lindex $argv 0] == "-start" \
     && ( $argc == 1 || \
          ( $argc == 2 && \
	    [regexp {^[1-9]} [lindex $argv 1]] ) ) } {
    set log_mode none
    set spid $judging_directory/$scoreboard_pid_file
    if { [file exists $spid] } {
         set pid [read_file $spid]
	 set display [display_process_tree $pid]
	 if { ! [regexp -nocase \
	                {^no process .* exists} \
		        $display] } {
	     puts "Previous makescoreboard still\
	           running:"
	     puts $display
	     exit 0
	 }
	 file delete -force $spid
    }
    set pid [eval exec makescoreboard \
                       [lrange $argv 1 end] \
    	               >& /dev/null &]
    write_file $spid $pid
    exit 0
}

# Process any -status option.  No second argument
# may exist.
#
if { $argc == 1 && [lindex $argv 0] == "-status" } {
    set log_mode none
    set spid $judging_directory/$scoreboard_pid_file
    if { [file exists $spid] } {
         set pid [read_file $spid]
	 set display [display_process_tree $pid]
	 if { ! [regexp -nocase \
	                {^no process .* exists} \
		        $display] } {
	     puts "Makescoreboard running:"
	     puts $display
	 } else {
	     puts "Makescoreboard has died:"
	     puts $display
	     puts ""
	     puts "Run `tracker' to find error logs,\
	           or look in log directory for"
	     puts "unchecked errors."
	 }
    } else {
        puts "All previous makescoreboards have been\
	      stopped."
    }
    exit 0
}

# Process any -stop option.  No second argument
# may exist.
#
if { $argc == 1 && [lindex $argv 0] == "-stop" } {
    set log_mode none
    set spid $judging_directory/$scoreboard_pid_file
    if { [file exists $spid] } {
         set pid [read_file $spid]
	 set display [display_process_tree $pid]
	 if { ! [regexp -nocase \
	                {^no process .* exists} \
		        $display] } {
	     puts "Killing previous makescoreboard:"
	     puts $display
	     set count 0
	     while { "true" } {
		 incr count 1
		 if { $count <= 5 } {
		     catch { signal_process_tree \
		             HUP $pid } out
		     puts $out
		 } elseif { $count <= 10 } {
		     catch { signal_process_tree \
		             KILL $pid } out
		     puts $out
		 } else {
		     puts "ERROR: Giving Up!"
		     exit 1
		 }
		 sleep 1
		 set display [display_process_tree $pid]
		 if { [regexp -nocase \
			      {^no process .* exists} \
			      $display] } {
		     break
		 }
	     }
	 }
	 file delete -force $spid
    } else {
        puts "No previous makescoreboard running."
    }
    exit 0
}

# If any non interval arguments, print documentation and
# exit.
#
if { $argc > 1 \
     || ( $argc == 1 \
          && [regexp {^-} [lindex $argv 0]] ) } {
    puts $document
    exit 1
}

# Set interval.
#
if { $argc == 1 } {
    set interval [lindex $argv 0]
    if { [catch { expr $interval }] \
    	 || $interval < 0 } {
    	error "$interval is not an integer >= 0"
    }
} else {
    set interval 60
}

# Abbreviate long file names.
#
set sbfile $contest_directory/scoreboard.1
set sbhead $contest_directory/scoreboard.1head
set jparam $judging_directory/$judging_parameters_file

# Ignore signals except during sleep (see below).
#
make_signals_ignored

# Loop forever (unless interval == 0).
#
while { "yes" } {

    # Clear score flag.  If its reset after we have
    # started to compute new scoreboard.1, then we need
    # to compute again.
    #
    clear_flag $score_flag_file

    # Check for unwritable contest directory.
    #
    if { ! [file isdirectory $contest_directory] \
	 || ! [file writable $contest_directory] } {
	error "$contest_directory is not a writable\
	       directory"
    }

    # Delete old scoreboard.1
    #
    if { [file exists $sbfile] } {
	file delete -force $sbfile
    }

    # Copy scoreboard.1head to scoreboard.1.
    #
    if { [file exists $sbhead] } {
        exec cat $sbhead - << "\n\n" > $sbfile
    }

    # Fill in rest of scoreboard.1.
    #
    exec scorefinder | scoreboard >> $sbfile

    # Make scoreboard.1 readable by everyone.
    #
    grant_access $sbfile

    # If interval == 0 do NOT loop indefinitely.
    #
    if { $interval == 0 } break

    # Sleep waiting for something to happen that
    # indicates scoreboard.1 needs recomputing.
    #
    while { "yes" } {

        make_signals_default
	sleep $interval
	make_signals_ignored

    	if { [test_flag $score_flag_file] } break
	if { ! [file exists $sbfile] } break
	if { [file exists $sbhead] \
	     && [file mtime $sbfile] \
	        < [file mtime $sbhead] } break
	if { [file mtime $sbfile] \
	        < [file mtime $jparam] } break
    }
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
