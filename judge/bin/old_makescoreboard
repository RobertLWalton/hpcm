#!/bin/sh
#
# Recomputes the scoreboard every minute.
#
# File:		makescoreboard
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Oct 24 12:22:20 EDT 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/10/24 16:21:04 $
#   $RCSfile: old_makescoreboard,v $
#   $Revision: 1.11 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_globally yes
catch {

set document "
makescoreboard { -start | -status | -stop | -update } \\
               \[ parameter-filename | \\
	          scoreboard-instructions \] ...

    This program makes scoreboards by following the
    instructions stored in the `scoreboard_instructions'
    global variable.  If desired the value of this
    variable can be the second argument to this program:
    it always begins with a `{' and is thus recoginized
    as not being a parameter file name.

    This program reruns a intervals determined by the
    `scoreboard_interval' global variable.  When rerun,
    if this program finds that the judging directory
    hpcm_judging.rc file has changed, it reloads this
    file, and if this program finds that all the files
    needed to produce a particular scoreboard output
    file (including hpcm_judging) have not changed,
    and the output file has not been deleted, this
    program does not reproduce that output file.
    
    This program calls
    
	scorefinder \\
	    > judging_directory/$scorefinder_output_file

    whenever the $score_flag_file in the flag directory
    changes.  The $scorefinder_output_file is used as\
    	in-
    put by the `scoreboard' program to produce score-
    boards.

    This program ignores signals when recomputing the
    scoreboard, and terminates without error on a signal
    while the program is sleeping for the interval.

    If called with an -update option, this program
    processes the scoreboard instructions just once
    and then exits immediately.

    If called with the -start option, this program
    writes its process ID of the $scoreboard_pid_file\
    		file
    in the judging directory, and begins normal execu-
    tion.  But if this $scoreboard_pid_file file already
    exists, AND the process ID it contains is valid,
    this program prints information about the ID'ed
    process and does nothing else.

    If called with the -stop option, this program does
    nothing but send kill signals to the process whose
    ID is listed in the $scoreboard_pid_file file, and
    then deletes the file.  While doing this it outputs
    information about its progress.

    If called with the -status option, this program just
    outputs information about the status of any process
    started by `makescoreboard -start'.

    If called with the -freeze option, this program

???

    In some contests the scoreboard is to be frozen
    during the last hour of the contest, to increase
    suspense.  To do this, use the -stop option, and
    then edit the scoreboard.1 file by hand to indicate
    the contest is frozen.  If using an emailed score-
    board, edit the scoreboard.mail file by hand and
    resend it using `/usr/bin/sendmail -io -t'.

    With the -start, -status, or -stop option this
    program does not log errors but writes them to the
    standard error.  This program does the same with
    program argument errors.  Otherwise, this program
    logs errors in the log directory."

# Print documentation if -doc.* first argument.
#
if { [regexp {^-doc} [lindex $argv 0]] } {
    puts $document
}

# Constant equal to 256 spaces.
#
set space "        "
set space "$space$space$
set space "$space$space$
set space "$space$space$
set space "$space$space$
set space "$space$space$

if { $scoreboard_width > 256 } {
    error "scoreboard width > 256"
}

# Some abbreviations.
#
set finder_file \
    $judging_directory/$scorefinder_output_file
set pid_file \
    $judging_directory/$scoreboard_pid_file

# Process arguments.
#
foreach arg $argv {
    if { [regexp "^{" $arg] } {
        set scoreboard_instructions $arg
    } else {
        source $arg
    }
}

# Compute possible parameters and save original values.
#
foreach name [info globals scoreboard_*] {
    regexp {^scoreboard_(.*)$} $name forget pname
    if { $pname != "instructions" } {
	set parameters_array($pname) [set $name]
    }
}


proc unabbreviate { value } {

    global abbreviation

    if { [info exists abbreviation($value)] } {
        return $abbreviation($value)
    { else {
        return $value
    }
}

proc pass1 { instructions } {

    global parameters_array abbreviation

    # Reinstall initial parameter values.
    #
    foreach name [array names parameters_array] {
        set scoreboard_$name $parameters_array($name)
    }

    # Save abbreviations.
    #
    set abbreviation(START)  scoreboard_start_time
    set abbreviation(STOP)   scoreboard_stop_time
    set abbreviation(FREEZE) scoreboard_freeze_time
    set abbreviation(NAME)   scoreboard_name
    set time		     [clock seconds]
    set abbreviation(TIME)   [clock format $time]

    set pc 0
    set end_pc [llength $instructions]
    set out_pc -1


    while { "yes" } {

        set instruction [lindex $instructions $pc]

        if { ( $pc >= $end_pc \
	       || $instruction == "OUTPUT" ) \
	     && $out_pc >= 0 } {
	    if { $out_start != "" \
	          || $time \
		     < [clock scan $out_start] ) {
	        set update no
	    }
	    if {    $out_mtime != "" \
	         && $out_stop != "" \
	         && $out_mtime \
		    >= [clock scan $out_stop] } {
	        set update no
	    }

	    pass2 $instructions $out_pc $pc $update

	    if { $pc >= $end_pc } break
	}

	set opcode [lindex $instruction 0]
	switch $opcode {
	    OUTPUT {
		set out_file  [lindex $instruction 1]
		set out_start [lindex $instruction 2]
		set out_stop  [lindex $instruction 2]
		set out_file \
		   [file join $judging_directory \
		              $out_file]
		set out_start [unabbreviate $out_start]
		set out_stop [unabbreviate $out_stop]
		if { [file readable $out_file] } {
		    set out_mtime [file mtime $out_file]
		} else {
		    set update yes
		    set out_mtime ""
		}
	        set out_pc $pc
	    	set update no
	    }

	    BLANK {}
	    BAR {}
	    LINE {}

	    INPUT {
		foreach in_file \
		        [lrange $instruction 1 end] {
		    set in_file \
		        [file join $judging_directory \
			           $in_file]
		    if { [file readable $in_file] } {
			if { $update == "no" \
			     && [file mtime $in_file]
				> $out_mtime } {
			    set update yes
			}
			break;
		    }
		}
	    }
	    BOARD {
	        if { $update == "no" \
		     && [file readable $finder_file] \
		     && [file mtime $finder_file] \
		        > $out_mtime } {
		    set update yes
		}

	    }
	    default {}
	}
    }
}

proc pass2 { instructions pc end_pc update } {

    global parameters_array scoreboard_width

    set out_file [lindex [lindex $instructions $pc] 1]
    set out_file $judging_directory/$out_file"

    incr pc
    set contents ""

    while { $pc < $end_pc } {
        set instruction [lindex $instructions $pc]
	incr pc
	set opcode [lindex $instruction 0]
	switch $opcode_$update {

	    BLANK_yes {
	        set contents "$contents\n"
	    }
	    BAR_yes {
	        set w [expr { $scoreboard_width / 10 } ]
		while { $w > 0 } {
		    set contents "$contents========= "
		    incr w -1
		}
		set contents "$contents\n"
	    }
	    LINE_yes {
	        set left   [lindex $instruction 1]
	        set center [lindex $instruction 2]
	        set right  [lindex $instruction 3]

		set left   [unabbreviate $left]
		set center [unabbreviate $center]
		set right  [unabbreviate $right]

		set left_end [string length $left]
		incr left_end -1
		set right_begin \
		    [expr { $scoreboard_width - \
		            [string length $right] }]
		set center_length [string length $center]
		set center_begin  \
		    [expr { ( $scoreboard_width \
		              - $center_length ) / 2 }]
		set center_end \
		    [expr { $center_begin \
		            + $center_length - 1 }]
		set contents "$contents$left"
		set center_done no
		set right_done no
		if { $left_end < $center_begin \
		     && $center_end < $right_begin } {
		    incr left_end 1
		    incr center_begin -1
		    set contents \
		        "$contents[string \
			              range $space \
				      $left_end \
				      $center_begin]"
		    set contents "$contents$center"
		    set center_done yes
		    set left_end $center_end
		}
		if { $left_end < $right_begin } {
		    incr left_end 1
		    incr right_begin -1
		    set contents \
		        "$contents[string \
			              range $space \
				      $left_end \
				      $right_begin]"
		    set contents "$contents$right"
		    set right_done yes
		}
		if { $center_done == "no" } {
		    incr center_begin -1
		    set contents \
		        "$contents\n[string \
			                range $space \
					0 $center_begin]
		    set contents "$contents$center\n"
		}
		if { $right_done == "no" } {
		    incr right_begin -1
		    set contents \
		        "$contents\n[string \
			                range $space \
					0 $right_begin]
		    set contents "$contents$right\n"
		}
	    }

	    INPUT_yes {
		foreach in_file \
		        [lrange $instruction 1 end] {
		    set in_file \
		        [file join $judging_directory \
			           $in_file]
		    if { [file readable $in_file] } {
			if { [file size $in_file] > 0 \
					} {
			    set c [read_entire_file \
			    		$in_file]
			    set contents "$contents$c"
			}
			break;
		    }
		}
	    }
	    BOARD_yes {
	        set parameters ""
		foreach name \
		        [array names parameters_array] {
		    lappend \
		        [list $name \
			      [set scoreboard_$name]
		}
	        set contents \
		    "$contents[exec scoreboard \
		    		    "{ $parameters }" \
				    < $finder_file]"
	    }
	    BLANK_no {}
	    BAR_no {}
	    LINE_no {}
	    INPUT_no {}
	    BOARD_no {}
	    default {
		set name $opcode
		set value [lindex $instruction 1]
	        if { ! [info exists \
		             parameters_array($name)] \
			     } {
		    error "$name is not a parameter\
		           name"
		}

		set value [unabbreviate $value]
		set scoreboard_$name $value
	    }
	}
    }

    if { $update } {
	set ch [open $out_file w]
        puts -nonewline $ch $contents
	close $ch
    }
}

proc process_arguments { argv } {

    global email_address parameters_file interval \
           document log_mode contest_directory

    while { [llength $argv] > 0 } {
        if { [lindex $argv 0] == "-email" } {
	    set email_address [lindex $argv 1]
	    set argv [lrange $argv 2 end]
	} elseif { [lindex $argv 0] == "-parameters" } {
	    set parameters_file [lindex $argv 1]
	    if { ! [file readable $parameters_file] } {
	        error "$parameters_file is not readable"
	    }
	    set argv [lrange $argv 2 end]
	} elseif { ! [catch { expr [lindex $argv 0] }] \
    	           && [lindex $argv 0] >= 0 } {
	    set interval [lindex $argv 0]
	    set argv [lrange $argv 1 end]
	} else {
	    puts $document
	    exit 1
	}
    }

    if { $email_address == "" \
         && ! [file isdirectory $contest_directory] } {
	set log_mode none
    	error "no email address and no contest\
	       directory"
    }
}

# Process any -start option.
#
if { $argc >= 1 && [lindex $argv 0] == "-start" } {

    # Check arguments for errors
    #
    set log_mode none
    process_arguments [lrange $argv 1 end]

    set spid $judging_directory/$scoreboard_pid_file
    if { [file exists $spid] } {
         set pid [read_file $spid]
	 set display [display_process_tree $pid]
	 if { ! [regexp -nocase \
	                {^no process .* exists} \
		        $display] } {
	     puts "Previous makescoreboard still\
	           running:"
	     puts $display
	     exit 0
	 }
	 file delete -force $spid
    }
    set pid [eval exec makescoreboard \
                       [lrange $argv 1 end] \
    	               >& /dev/null &]
    write_file $spid $pid
    exit 0
}

# Process any -status option.  No second argument
# may exist.
#
if { $argc == 1 && [lindex $argv 0] == "-status" } {
    set log_mode none
    set spid $judging_directory/$scoreboard_pid_file
    if { [file exists $spid] } {
         set pid [read_file $spid]
	 set display [display_process_tree $pid]
	 if { ! [regexp -nocase \
	                {^no process .* exists} \
		        $display] } {
	     puts "Makescoreboard running:"
	     puts $display
	 } else {
	     puts "Makescoreboard has died:"
	     puts $display
	     puts ""
	     puts "Run `tracker' to find error logs,\
	           or look in"
	     puts "$log_directory for unchecked\
	           errors."
	 }
    } else {
        puts "All previous makescoreboards have been\
	      stopped."
    }
    exit 0
}

# Process any -stop option.  No second argument
# may exist.
#
if { $argc == 1 && [lindex $argv 0] == "-stop" } {
    set log_mode none
    set spid $judging_directory/$scoreboard_pid_file
    if { [file exists $spid] } {
         set pid [read_file $spid]
	 set display [display_process_tree $pid]
	 if { ! [regexp -nocase \
	                {^no process .* exists} \
		        $display] } {
	     puts "Killing previous makescoreboard:"
	     puts $display
	     set count 0
	     while { "true" } {
		 incr count 1
		 if { $count <= 5 } {
		     catch { signal_process_tree \
		             HUP $pid } out
		     puts $out
		 } elseif { $count <= 10 } {
		     catch { signal_process_tree \
		             KILL $pid } out
		     puts $out
		 } else {
		     puts "ERROR: Giving Up!"
		     exit 1
		 }
		 sleep 1
		 set display [display_process_tree $pid]
		 if { [regexp -nocase \
			      {^no process .* exists} \
			      $display] } {
		     break
		 }
	     }
	 }
	 file delete -force $spid
    } else {
        puts "No previous makescoreboard running."
    }
    exit 0
}

# Process arguments
#
process_arguments $argv

# Abbreviate long file names.
#
set sbfile  $contest_directory/scoreboard.1
set sbhead  $contest_directory/scoreboard.1head
set sbnotes $judging_directory/scoreboard.notes
set sbmail  $judging_directory/scoreboard.mail
set jparam  $judging_directory/$judging_parameters_file

# Ignore signals except during sleep (see below).
#
make_signals_ignored

# Loop forever (unless interval == 0).
#
while { "yes" } {

    # Record the time we start computing the scoreboard.
    #
    set time [clock seconds]
    set date [clock format $time]

    # Clear score flag.  If its reset after we have
    # started to compute new scoreboard, then we need
    # to compute again.
    #
    clear_flag $score_flag_file

    # Collect scoreboard.
    #
    if { $parameters_file == "" } {
	catch { exec scorefinder | scoreboard } \
	      scoreboard
    } else {
	catch { exec scorefinder | \
		scoreboard $parameters_file } \
	      scoreboard
    }

    # If the scoreboard is empty, say so explicitly.
    #
    if { $scoreboard == "" } {
	set scoreboard "The scoreboard is currently\
	                EMPTY!  Nothing must have\
			happened yet."
    }

    # Handle case with email_address.
    #
    if { $email_address != "" } {

	# Compute email_scoreboard.
	#
	if { [file readable $sbnotes] } {
	    set tail [read_entire_file $sbnotes]
	    set email_scoreboard \
	        "To: $email_address

See notes below.           $date

=================== ===================\
=================== ===================
$scoreboard
=================== ===================\
=================== ===================

$tail"

	} else {
	    set email_scoreboard "To: $email_address

$date

$scoreboard"
	   
	}

	# Send the scoreboard to the email-address.
	#
	send_message $email_scoreboard

	# Delete and rewrite scoreboard.mail
	#
	if { [file exists $sbmail] } {
	    file delete -force $sbmail
	}
	write_file $sbmail $email_scoreboard
    }

    # Handle case with contest directory.
    #
    if { [file isdirectory $contest_directory] } {

	# Check for unwritable contest directory.
	#
	if { ! [file writable $contest_directory] } {
	    error "$contest_directory is not writable"
	}

	# Compute scoreboard_page.
	#
	if { [file readable $sbhead] } {
	    set head [read_entire_file $sbhead]
	    set scoreboard_page \
	        "$date

$head

=================== ===================\
=================== ===================
$scoreboard
=================== ===================\
=================== ==================="

	} else {
	    set scoreboard_page "$date

$scoreboard"
	   
	}

	# Delete and rewrite scoreboard.1
	#
	if { [file exists $sbfile] } {
	    file delete -force $sbfile
	}
	write_file $sbfile $scoreboard_page

	# Make scoreboard.1 readable by everyone.
	#
	grant_access $sbfile

    }

    # If interval == 0 do NOT loop indefinitely.
    #
    if { $interval == 0 } break

    # Sleep waiting for something to happen that
    # indicates scoreboard needs recomputing.
    #
    while { "yes" } {

        make_signals_default
	sleep $interval
	make_signals_ignored

    	if { [test_flag $score_flag_file] } break
	if { [file isdirectory $contest_directory]
	     && ! [file exists $sbfile] } break
	if { $email_address != ""
	     && ! [file exists $sbmail] } break
	if { [file exists $sbhead] \
	     && $time < [file mtime $sbhead] } break
	if { [file exists $sbnotes] \
	     && $time < [file mtime $sbnotes] } break
	if { $time < [file mtime $jparam] } break
    }
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
