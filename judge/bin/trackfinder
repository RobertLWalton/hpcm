#!/bin/sh
#
# Looks at the subdirectories of the mail directory and
# prints information about the existance and dates of
# files that allows tracker to work.
#
# File:		trackfinder
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Jan 27 10:10:31 EST 2002
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2002/01/27 15:55:57 $
#   $RCSfile: trackfinder,v $
#   $Revision: 1.10 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_globally yes
catch {

set document "
trackfinder \[directory ...\]

    This program examines subdirectories of the mail
    directory that have names of the form:

    	date-<<submitter>>-submission

    It outputs information that tells what files
    exist in these subdirectories and when the files
    were last modified.

    Specifically, for each directory a line is output
    with the form

	sub date {submitter}

    where `sub' denotes `subdirectory' of the mail dir-
    ectory and the date and submitter of this line are
    copied from the subdirectory name.  After this line
    the following lines are output indicating which
    files exist in the subdirectory and what the modifi-
    cation times (mtimes) of these files are:

    	rec  time {subject}	Mtime of and `Subject'
				field of $received_file.

    	ext  time {filename}	Mtime of and name of
				file extracted from
				$received_file, if this
				has a `Subject:' of the
				form `submit filename'.

	bin  time1 time2	Mtimes of the binary
				and .cerr files, respec-
				tively.

	out  time1 time2	Mtimes of the .out and
				.err files, respective-
				ly.

	sco   time1 time2 {autoscore} {manualscore}
				Mtimes and contents of
				$auto_score_file and
				$manual_score_file,
				respectively.

	rep   time1 time2	Mtimes of $reply_file
				and $no_reply_file,
				respectively.

	his   time		Mtime of
				$reply_history_file.

	got   time		Mtime of $gotten_file.

	pid   time1 time2	Mtime of\
				    $dispatch_pid_file,
				and time mtime was
				read, respectively.

	err   time {file}	Mtime of file with name
				matching:
				    *-unchecked-error

	chk   time {file}	Mtime of file with name
				matching:
				    *-checked-error

    If any file is missing, its time is `{}', and any
    contents are also `{}', e.g., for a missing score
    file.  If all files whose times are in one of the
    above lines are missing, the line is not output.

    All the non-missing times are integer numbers of
    seconds relative to the date in the `sub' line that
    begins the set of lines for a subdirectory.

    If arguments are given, these are taken as the names
    of the directories to look at.  These must be valid
    relative to the current directory, and can include
    names whose last component is not of the form

    	date-<<submitter>>-submission

    in which case instead of a `sub' line there will be
    a line of the form

	dir date {directory-name}

    where the date is taken as the mtime of the direc-
    tory.  Typically the directory is a log directory.

    This program logs errors in the log directory."


# If the first argument begins with `-', print docu-
# mentation and exit with error.
#
if { $argc >= 1 && [regexp {^-} [lindex $argv 0]] } {
    puts $document
    exit 1
}

# Set list of directories to look at:
#
if { $argc > 0 } {
    set directories $argv
} else {
    set directories \
	[lsort [glob -nocomplain \
	          $mail_directory/*-<<*>>-submission]]
}

# Return mtime of file, or "{}" if file is not
# readable.
#
proc get_mtime { file } {

    global submit_time

    if { ! [file readable $file] } {
    	return "{}"
    } else {
    	return [expr { [file mtime $file] \
		       - $submit_time }]
    }
}


# Return first line file, or "{}" if file is not
# readable or empty.
#
proc get_file { file } {

    if { ! [file readable $file] } {
    	return "{}"
    } else {
    	return "{[read_file $file]}"
    }
}


# Loop through the subdirectory names.
#
foreach dir $directories {

    if { ! [file isdirectory $dir] } {
	error "$dir is not a directory"
    }

    set subdir [file tail $dir]

    if { [regexp {^([^<>]*)-<<(.*)>>-submission$} \
    		   $subdir forget date submitter] \
	 && ! [regexp "\n" $subdir] } {

	set submitter [string trim $submitter]
	if { $submitter == "" } {
	    set submitter UNKNOWN
	}
	puts "sub $date {$submitter}"

    } else {

	if { $argc == 0 } {
	    error "Illegal mail subdirectory name:\
	           $subdir"
	}
	set date [clock_to_filename_date \
		     [file mtime $dir]]
	puts "dir $date {$dir}"
    }

    set submit_time [filename_date_to_clock $date]

    set submitted_name	  ""
    set submitted_problem ""

    set mtime [get_mtime $dir/$received_file]
    if { $mtime != "{}" } {

	set received_ch [open $dir/$received_file r]
	read_header $received_ch
	close $received_ch

	set subject [string trim $message_subject]
	regsub "\[\ \t\]*\n\[\ \t\]*" $subject { } \
	       subject

	puts "rec $mtime {$subject}"

	if { [llength $subject] == 2 \
	     && [lindex $subject 0] == "submit" } {
	    set submitted_name [lindex $subject 1]
	    set submitted_problem \
	        [file rootname $submitted_name]
	}
    }

    set mtime [get_mtime $dir/$gotten_file]
    if { $mtime != "{}" } {
	puts "got $mtime"
    }

    if { $submitted_name != "" } {

        set mtime [get_mtime $dir/$submitted_name]
    	if { $mtime != "{}" } {
	    puts "ext $mtime {$submitted_name}"
	}

	set mtime1 \
	    [get_mtime $dir/$submitted_problem]
	set mtime2 \
	    [get_mtime $dir/$submitted_problem.cerr]
	if { $mtime1 != "{}" || $mtime2 != "{}" } {
	    puts "bin $mtime1 $mtime2"
	}

	set mtime1 \
	    [get_mtime $dir/$submitted_problem.out]
	set mtime2 \
	    [get_mtime $dir/$submitted_problem.err]
	if { $mtime1 != "{}" || $mtime2 != "{}" } {
	    puts "out $mtime1 $mtime2"
	}
    }

    set mtime1 \
	[get_mtime $dir/$auto_score_file]
    set mtime2 \
	[get_mtime $dir/$manual_score_file]
    if { $mtime1 != "{}" || $mtime2 != "{}" } {
	puts "sco $mtime1 $mtime2\
	      [get_file $dir/$auto_score_file] \
	      [get_file $dir/$manual_score_file]"
    }

    set mtime1 [get_mtime $dir/$reply_file]
    set mtime2 [get_mtime $dir/$no_reply_file]
    if { $mtime1 != "{}" || $mtime2 != "{}" } {
	puts "rep $mtime1 $mtime2"
    }

    set mtime [get_mtime $dir/$reply_history_file]
    if { $mtime != "{}" } {
	puts "his $mtime [expr { [clock seconds] \
				 - $submit_time }]"
    }

    set mtime [get_mtime $dir/$dispatch_pid_file]
    if { $mtime != "{}" } {
	puts "pid $mtime [expr { [clock seconds] \
				 - $submit_time }]"
    }

    foreach file \
            [lsort [glob -nocomplain \
	    		 $dir/*-checked-error]] {
	if { [regexp "\n" $file] } continue
	set mtime [get_mtime $file]
	if { $mtime != "{}" } {
	    puts "chk $mtime {[file tail $file]}"
	}
    }

    foreach file \
            [lsort [glob -nocomplain \
	    	         $dir/*-unchecked-error]] {
	if { [regexp "\n" $file] } continue
	set mtime [get_mtime $file]
	if { $mtime != "{}" } {
	    puts "err $mtime {[file tail $file]}"
	}
    }
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
