#!/bin/sh
#
# Make the subdirectories, symbolic links, and indices
# of a judging directory and its associated contest
# directory.
#
# File:		makejudgingdir
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Oct  1 10:40:00 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/10/02 07:51:45 $
#   $RCSfile: makecontest,v $
#   $Revision: 1.13 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_mode none
catch {

set document "
cd judging_directory
makejudgingdir options index_spec ...

  Options:
    -email	Sets up an email contest.
		Equals -info, -solutions, -mail
    -formal     Sets up a formal contest.
		Equals all options but -info,
		-trashable, -txt, and -help_informal.
    -informal   Sets up an informal contest.
		Equals all options but -problems,
		-trashable, -txt, and -help_formal
    -info	Make ./info
    -solutions  Make ./solutions
    -problems	Make ./contest/problems
		Include .txt files only if -txt given.
    -txt	Include .txt files in ./contest/
		problems.
    -mail	Make ./mail
    -help_informal
    -help_formal
	        Make ./contest/help2 link
    -help	Make ./contest/help1/problems,
		     ./contest/help1/this_contest,
		     ./contest/help3 link
    -bin	Make ./contest/bin link
    -secure	Make ./contest/secure/passwords,
		     ./contest/secure/hpcm_sendmail.rc
    -who_where  Make ./contest/who_where
    -printer    Make ./contest/printer
    -trashable  Make ./contest/trashable
    -prototype  Make ./contest/prototype
    -home	Make ./contest/home

  Index Specification:

    index_file\[: index_directory\], name1s=name1t, \\
	  option1s:'option11t option12t ...', \\
	  name2s=name2t, ...

  Pre-Existing Files and Links:

    ./hpcm_judging.rc	 Parameters file.
    ./contest		 Link to contest directory.
    ./contest/contestant Link to hpcm/contestant.

    Given a judging directory as the current directory,
    complete with hpcm_judging.rc file, this program
    makes subdirectories, links, and problem index files
    in the judging directory and optional associated
    contest directory, according to instructions in the
    index specifications and options.  The form of the
    index specifications and options is given above.
    The `./contest' directory, if any, should be symbol-
    ically linked to the actual contest directory before
    this program is run.  In some cases `./contest
    /contestant' should be symbolically linked to the
    `..../hpcm/contestant' directory before this program
    is run.

    This program appends instructions for its user to
    edit certain files to the ./TODO file, and prints
    this file at the end of this program.

    The index files are read and concatenated to form
    the `index' file in any new info directory and a
    `problems.help' file in any new problems directory,
    with unused entries omitted.
    
    If an info directory is being made, symbolic links
    are made from it to problem directories referenced
    in the index file.  Ditto for the solutions
    directory.  The problems directory is similar but
    instead of making links, selected files are copied
    into subdirectories of the problems directory.

    If the program is building a ./info directory, it
    actually builds a ./info+ directory instead.  Then
    it does a `diff -r ./info ./info+', discarding the
    printed output, to determine if the new directory
    is any different from the previous directory.  If
    it is not different, the ./info+ directory is re-
    moved and nothing else is done.  If the two direc-
    tories are different, the following renaming
    occurs:

    		./info-	    becomes    ./info--
    		./info	    becomes    ./info-
    		./info+	    becomes    ./info

    A similar strategem is followed for ./solutions
    and ./contest/problems directories.

    Other files and directories are made if they do
    not exist or are out of date.  If this program does
    not have adequate information to make a file or
    directory, it writes instructions to the user in
    ./TODO.

    Each input index file is associated with an index
    directory.  An unedited version of the index file is
    normally found in its index directory.  Sometimes an
    edited copy of this index file is placed in the
    current judging directory, with the editing consist-
    ing of changes to the item entry options described
    below which control what is included in the new info
    and solutions directories.

    If no index directory is given in an index specifi-
    cation, it defaults to the directory that contains
    the index file given in the index specification.

    The index file consists of two types of entries:
    header entries and item entries.  Item entries begin
    with a line that starts with `***', followed by
    whitespace, and optionally preceded by whitespace.
    Header entries begin with a line that starts with
    neither whitespace nor `***'.  A header entry stops
    at the next line that begins an item entry, or at
    the end of file.  An item entry stops at the next
    line that begins a header or item entry, or at the
    end of file.

    The first line of an item entry has the form:

    	*** name options

    The item name is the name of a file or directory
    relative to the index directory (the directory
    normally containing the unedited index file).  The
    possible options are:

      info	  Include item in ./info directory.
      solutions	  Include item in ./solutions directory.
      problems	  Include item in ./contest/problems
      		  directory.
      all	  If info or problems option present,
                  include all readable files from this
		  item in the info or problems sub-
		  directory for this item.  Otherwise
		  if the item is a directory, only the
		  Makefile and *.txt file in the item
		  directory will be included in the
		  info or problems directory.

    These options are rarely encoded directly in the
    index files.  Instead options categorizing the
    entries are made up by the author of the index file
    and mapped by the index specification onto the above
    options.  Mapping is done by option substitution
    that occurs before the options are finally pro-
    cessed.  A substitution of the form:

    	option1s:'option11t option12t ...'

    in the index specification replaces option1s by the
    options in the list `option11t option12t ...'.
    Substitution is recursive.  After option substitu-
    tion, unknown options are ignored.

    If an item is included in the new info directory,
    the item entry is included in the index of that
    directory.  Otherwise the item entry is omitted.
    All header entries are included, no matter what.
    However, if no items at all from any of the input
    index files are included in the new info directory,
    the new index file for that directory is deleted,
    so that new info directory is completely empty.

    If an item is included in a new problems or info
    directory, and the -help option is present, the
    index item entry is included in a ./contest/help1/
    problems file.  No header items are included in
    this file.

    When an item is included in the solutions directory,
    the item must itself be a directory, and the name of
    the item in the solutions directory is the last
    component of the item name.  This means that all
    problems in the system should have unique single
    component names.

    Ditto for the problems directory.

    When an item is included in the info directory its
    name in the info directory is a modified version of
    the item name.  Specifically, a substitution of the
    form nameXs=nameXt may be applied to the item name.
    If the item name begins with the nameXs string, that
    string will be replaced by nameXt.  If there are
    several possible substitutions, the longest nameXs
    will be selected, and if there are several longest,
    the first will be selected.
    
    Thus, for example, given an index specification of
    the form

    	my_index: foo/bar, public/=, \\
	          public/shelf/=old/

    then

    	public/frap	     becomes	frap
	public/shelf/frap    becomes	old/frap

    with the changed names being used as the names of
    the items within the info directory.

    When an item entry is copied to the index file of
    the new info directory, or to a problems.help file,
    the `***' in the first line of the entry is replace
    by 3 space characters, the item name is replaced by
    the name of the item directory within the info dir-
    ectory for ./info/index or the problems directory
    for ./problems/problems.help, and the options are
    removed.

    When ./mail is made (by -mail) its mode is set to
    a+x.

    When ./contest/help1 is made (by -help) its mode is
    set to a+rx.  Then ./contest/help1/problems is
    symbolically linked to ./contest/problems/problems
    .help, and a default ./contest/help1/this_contest
    file is made.  None of these things is done if the
    directories and files to be made already exist.  If
    the this_contest file is made, an instruction to
    edit it is appended to the ./TODO file.

    The .contest/help3 directory is made by symbolically
    linking it to ./contest/contestant/help/formal (by
    -help_formal) or ./contest/contestant/help/informal
    (by -help_informal).

    The .contest/help3 directory is made (by -help) by
    symbolically linking it to ./contest/contestant/
    help/common.
    
    Note that the `help' command searches ./contest/
    help1, ./contest/help2, ./contest/help3, and
    ./contest/help4 in order for help files.

    The ./bin directory is made by symbolically link-
    ing it to ./contestant/bin.

    When the ./secure directory is made (by -secure) its
    mode is set to go-rwx, as is the mode of every file
    made in this directory.  When the ./secure/passwords
    file is made, instructions for editing it are
    written to ./TODO, but the file made automatically
    is empty.  If the ./secure/hpcm_sendmail.rc file is
    made, instructions for editing it and the
    ~/.procmailrc file are written into ./TODO.

    If -secure is given and any line in ./secure
    /passwords has an empty password, a random password
    is generated and inserted in that file.

    When ./contest/who_where is made, accounts in ./secure/
    passwords are written into it and instructions for
    editing it are written into ./TODO.

    When ./contest/printer is to be made, it is set by
    guess and instructions to edit it are written to
    ./TODO.

    If -home is given, a check is made to see if the
    directory ./contest/home exists and the files
    empty.ls, setup.ls, and setup.tar exist in that
    directory and are readable.  If not, instructions
    are written to ./TODO.

    The ./trashable file is a list of contestant
    accounts made from ./secure/passwords.  The
    ./prototype file is the list of prototype contes-
    tant accounts (usually only one).  To run TRASH_
    ACCOUNT an account must be listed in ./trashable.
    To run TRASH_PROBLEMS it must be listed in
    ./prototye or ./trashable.  To run SETUP_PROTOTYE
    it must be listed in ./prototype.  Generally
    ./trashable is made when needed and then deleted
    to ensure that contestants cannot damage themselves
    by perversly running TRASH_ACCOUNT or TRASH_
    PROBLEMS.

    If anything is made in ./contest, a+x is set for
    that directory and all its ancestors.  If anything
    is linked to ./contestant, ditto.  If ./mail is
    made, ditto.  Note that `cd .../hpcm; make' should
    be run to set up the contestant directory.  If any
    file or directory modes seem wrong, notes are
    written to ./TODO.

    The `./mail' directory name above is actually
    specified as a hpcm_judging.rc parameter, and could
    be set to something else.  Ditto for `./info' and
    `./solutions'.  All other names are NOT determined
    by hpcm_judging.rc, and are literally as given
    above.
    
    Unlike most HPCM judging programs, errors made by
    this program are not written to log files, but are
    announced on standard error."

# Argi is the index of the current argument, for use in
# lindex.
#
set argi 0

# Set options, consuming option arguments.
#
set info_option			no
set solutions_option		no
set problems_option		no
set txt_option			no
set mail_option			no
set help_option			no
set help_formal_option		no
set help_informal_option	no
set bin_option			no
set home_option			no
set secure_option		no
set who_where_option		no
set printer_option		no
set trashable_option		no
set prototype_option		no
#
while { "yes" } {
    if { $argi >= $argc } break;
    switch -- [lindex $argv $argi] {
        -email		{ set info_option 	yes
			  set solutions_option	yes
			  set mail_option	yes }
        -formal		{ set solutions_option	yes
			  set problems_option	yes
			  set mail_option	yes
			  set help_option	yes
			  set help_formal_option \
						yes
			  set bin_option	yes
			  set home_option	yes
			  set secure_option	yes
			  set who_where_option	yes
			  set printer_option	yes
			  set prototype_option	yes }
        -informal	{ set solutions_option	yes
			  set info_option	yes
			  set mail_option	yes
			  set help_option	yes
			  set help_informal_option \
						yes
			  set bin_option	yes
			  set home_option	yes
			  set secure_option	yes
			  set who_where_option	yes
			  set printer_option	yes
			  set prototype_option	yes }
        -info		{ set info_option 	yes }
        -solutions	{ set solutions_option 	yes }
        -problems	{ set problems_option 	yes }
        -txt		{ set txt_option 	yes }
        -mail		{ set mail_option 	yes }
        -help		{ set help_option 	yes }
        -help_formal	{ set help_formal_option \
						yes }
        -help_informal	{ set help_informal_option \
						yes }
        -bin		{ set bin_option 	yes }
        -home		{ set home_option 	yes }
        -secure		{ set secure_option 	yes }
        -who_where	{ set who_where_option 	yes }
        -printer	{ set printer_option 	yes }
        -trashable	{ set trashable_option 	yes }
        -prototype	{ set prototype_option 	yes }
	default		{ break }
    }
    incr argi
}

# Set up TODO
#
set TODO_ch ""
set TODO_existed [expr { [file exists TODO] \
                         && [file size TODO] > 0 }]
proc TODO { args } {
    global TODO_ch
    if { $TODO_ch == "" } {
    	set TODO_ch [open TODO a]
    }
    puts $TODO_ch "----------"
    foreach line $args {
    	puts $TODO_ch $line
    }
}

# Set up TODO_hpcm_make
#
set TODO_hpcm_make_done no
proc TODO_hpcm_make {} {
    global TODO_hpcm_make_done
    if { $TODO_hpcm_make_done == "no" } {
    	set TODO_hpcm_make_done yes
	TODO "    run `make' in `hpcm' directory"
    }
}

# Make 10 character random password.
#
random seed
proc make_password {} {
    return [format {%03d%03d%04d} \
		   [random 1000] \
		   [random 1000] \
		   [random 10000]]
}

# If no arguments left or first remaining argument
# begins with `-', print documentation and exit with
# error.
#
if { $argi >= $argc \
     || [regexp {^-} [lindex $argv $argi]] } {
    puts $document
    exit 1
}

# Check for some elementary errors, such as ./contest
# not existing if it is needed.
#
if { $problems_option \
     || $help_option \
     || $help_formal_option \
     || $help_informal_option \
     || $bin_option \
     || $home_option \
     || $secure_option \
     || $who_where_option \
     || $printer_option \
     || $trashable_option \
     || $prototype_option } {
    if { ! [file isdirectory "contest"] \
         || ! [file executable "contest"] \
         || ! [file readable "contest"] } {
	error "`./contest' is not a useable directory"
    }
}
if { $help_option \
     || $help_formal_option \
     || $help_informal_option \
     || $bin_option } {
    if { ! [file isdirectory "contest/contestant"] \
         || ! [file executable "contest/contestant"] \
         || ! [file readable "contest/contestant"] } {
	error "`./contest/contestant' is not a useable\
	       directory"
    }
}

# Logically derived options:
#
if { $help_option \
     && ( $problems_option || $info_option ) } {
    set help_problems_option yes
} else {
    set help_problems_option no
}

# Array specifying option substitutions.  For each
# op1 to be substituted for, the value of
#
#	option_array(op1)
#
# is the list of options that is the substitution.

# Expand a list of options and return the result.
# Do not let the depth of expansion run away.
#
proc expand_options { option_list { depth 0 } } {

    global option_array

    if { $depth > 100 } {
    	error "Infinite recursive option substitution"
    }

    set result ""
    foreach option $option_list {
        if { [info exists option_array($option)] } {
	    set result \
	        [concat $result \
		        [expand_options \
			    $option_array($option) \
			    [expr { $depth + 1 }]]]
	} else {
	    lappend result $option
	}
    }

    return $result
}

# List of substitutions to be made in the names
# of the current input index file.  Each item of
# the list has the form `{source target}' which
# specifies that if a name begins with the
# string `source' that string should be replaced
# by the string `target'.
#
set substitutions ""

# Make the longest substitution possible in the
# name argument and return the result (or if
# there are no substitutions return the name
# argument).  If there is a length tie, apply
# the first substitution.
#
proc make_substitutions { name } {

    global substitutions

    set result $name
    set best_end -1

    foreach substitution $substitutions {
        set source [lindex $substitution 0]
	set end [string length $source]
	incr end -1

	if { [string range $name 0 $end] == $source \
	     && $best_end < $end } {
	    set target [lindex $substitution 1]
	    set best_end $end
	    incr end
	    set result [string range $name $end end]
	    set result $target$result
	}
    }

    return $result
}


# Process index specification using global variables
# as parameters:
#
#   index_file		the input index file name
#   index_directory	index directory name
#   newindex_ch		output index file channel
#   newhelp_ch		output .contest/help1/problems
#			file channel
#   option_array	option substitutions
#			(see above)
#   substitutions	filename substitutions
#			(see above)
#   info_option		options
#   solutions_option
#   problems_option
#   info_directory	directory names
#   solutions_directory	directory names
#   problems_directory	directory names
#
proc process_index_specification {} {

    global index_file index_directory \
           newindex_ch newhelp_ch \
           info_option solutions_option \
	   problems_option \
	   help_problems_option \
           info_directory solutions_directory \
	   problems_directory


    # Be sure index directory is absolute name, else
    # symbolic links will fail.
    #
    if { ! [regexp {^/} $index_directory] } {
	set index_directory [pwd]/$index_directory
    }

    # Read the input index file and process its entries.
    #
    set index_ch [open $index_file r]
    set index_copy	no
    set index_did_copy	no
    set help_copy	no 
    set help_did_copy	no

    while { "yes" } {

        # Read next input index line.
	#
	set line [gets $index_ch]
        if { [eof $index_ch] } break;

	if { [llength $line] >= 1 \
	     && [lindex $line 0] == "***" } {

	    # Beginnning item entry.

	    set name [lindex $line 1]
	    set options \
	        [expand_options [lreplace $line 0 1]]
	    set source $index_directory/$name
	    set ws "\[\ \t\]*"
	    regexp "^($ws\\*\\*\\*$ws)(\[^\ \t\]|$)" \
		   $line forget indent forget2
	    regsub {\*\*\*} $indent {   } indent

	    # Process info option.
	    #
	    if { [lsearch -exact $options info] >= 0 \
	         && $info_option } {

		set target [make_substitutions $name]

		set index_copy yes
		puts $newindex_ch "$indent$target"
		set index_did_copy yes

		set target $info_directory+/$target

		if { [lsearch -exact $options all] \
		     >= 0 \
		     || [file isfile $source] } {
		    file mkdir [file dirname $target]
		    link_file $source $target
		} else {
		    file mkdir $target
		    link_file $source/Makefile \
		              $target/Makefile
		    set problem [glob $source/*.txt]
		    if { [llength $problem] != 1 } {
			error "Too many or too few\
			       $source/*.txt files"
		    }
		    set problem [file tail $problem]
		    link_file $source/$problem \
		              $target/$problem
		}
	    } else {
		# Come here if no `info' option.
	    	set index_copy no
	    }

	    # Process problems option.
	    #
	    if { [lsearch -exact $options problems] \
	         >= 0 \
		 && $problems_option } {

		if { ! [file isdirectory $source] } {
		    error "$source problem is not a\
		           directory"
		}
		set target [file tail $name]
		set target $problems_directory+/$target
		file mkdir $target
		grant_access $target

		if { [lsearch -exact $options all] \
		     >= 0 } {
		    foreach file [glob -nocomplain \
		    		       $source/*] {

			# Note: in TCL, isfile tests
			# the target of links.

			if { [file isfile $file] \
			     && [file readable $file] \
			     } {
			    set tail [file tail $file]
			    file copy $file \
			    	      $target/$tail
			    grant_access $target/$tail
			}
		    }
		} else {
		    file copy $source/Makefile \
		              $target/Makefile
	            grant_access $target/Makefile

		    if { $txt_option } {
			set problem \
			    [glob $source/*.txt]
			if { [llength $problem] \
			     != 1 } {
			    error "Too many or too few\
				   $source/*.txt files"
			}
			set problem [file tail $problem]
			file copy $source/$problem \
				  $target/$problem
			grant_access $target/$problem
		    }
		}
	    }

	    # Process help for problems and info
	    # options.
	    #
	    if { ( [lsearch -exact $options problems] \
	           >= 0
		   || \
	           [lsearch -exact $options info] \
	           >= 0 ) \
		 && $help_problems_option } {

		if { ! [file isdirectory $source] } {
		    error "$source problem is not a\
		           directory"
		}
		set target [file tail $name]

		set help_copy yes
		puts $newhelp_ch "$indent$target"
		set help_did_copy yes

	    } else {
		# Come here if no `help' entry.
	    	set help_copy no
	    }

	    # Process solution option.
	    #
	    if { [lsearch -exact $options solutions] \
	         >= 0 \
		 && $solutions_option } {
		if { ! [file isdirectory $source] } {
		    error "$source solution is not a\
		           directory"
		}
	        set sdp $solutions_directory+
	        link_file $source \
			  "$sdp/[file tail $name]"
	    }

	} elseif { [regexp "^\[^\ \t\]" $line] } {

	    # Beginning of header entry or line
	    # inside current header entry.

	    if { $info_option } {
		puts $newindex_ch $line

		set index_copy		yes
		set index_did_copy	yes
	    }
	    
	    set help_copy	no

	} else {

	    # Line inside header or item entry.

	    if { $index_copy } {
		puts $newindex_ch $line
	    }
	    if { $help_copy } {
		puts $newhelp_ch $line
	    }
	}
    }

    # If we copied any index entries, put out 2 blank
    # lines to separate this input index file's entries
    # from those of the next input index file.  Ditto
    # for help file with 1 blank line.
    #
    if { $index_did_copy } {
    	puts $newindex_ch ""
    	puts $newindex_ch ""
    }
    if { $help_did_copy } {
    	puts $newhelp_ch ""
    	puts $newhelp_ch ""
    }

    close $index_ch
}

# Set up info+, solutions+, and problems+
# directories, and info+/index and problems+
# /problems.help files.
#
if { $info_option } {
    if { [file exists $info_directory+] } {
        puts "Deleting $info_directory+"
	exec rm -rf $info_directory+ >@ stdout
    }
    file mkdir $info_directory+
    set newindex_ch [open $info_directory+/index w]
}
if { $problems_option } {

    set problems_directory ./contest/problems

    if { ! [file isdirectory contest] } {
    	error "problems: contest is not a directory"
    }
    if { [file exists $problems_directory+] } {
        puts "Deleting $problems_directory+"
	exec rm -rf $problems_directory+ >@ stdout
    }
    file mkdir $problems_directory+
    if { ! [file exists $problems_directory] } {
        puts "Granting a+x access to contest directory"
    	grant_access contest x
    }
}
if { $solutions_option } {
    if { [file exists $solutions_directory+] } {
        puts "Deleting $solutions_directory+"
	exec rm -rf $solutions_directory+ >@ stdout
    }
    file mkdir $solutions_directory+
}

# Make contest/help1 directory.
#
if { $help_option \
     && ! [file isdirectory contest/help1] } {
    if { ! [catch { set help1_type \
    			[file type contest/help1] }] } {
	if { $help1_type == "link" } {
	    puts "Deleting contest/help1"
	    file delete -force contest/help1
	} else {
	    error "contest/help1 exists but is not\
                   a directory"
	}
    }
    file mkdir contest/help1
    grant_access contest/help1
}

# Open contest/help1/problems file.
#
if { $help_problems_option } {
    if { ! [catch { file type \
			 contest/help1/problems }] } {
	puts "Deleting contest/help1/problems"
	file delete -force contest/help1/problems
    }
    set newhelp_ch [open ./contest/help1/problems w]
    puts $newhelp_ch "Problems Index Help      \
	 [clock format [clock seconds]]"
    puts $newhelp_ch ""
    puts $newhelp_ch ""
}

# Process arguments, forming index specifications
# encoded in global variables, and call process_index_
# specification (see above) for each specification.
#
set mode file
#
# Mode indicates what next argument should be: file,
# directory, or substitution.
#
foreach arg [lreplace $argv 0 [expr { $argi - 1 }]] {

    # Process next argument.  Whether argument ends in
    # `,' or `:' tells mode of next argument.
    #
    if { $mode == "file" } {
    	if { [regexp {^(.*):$} $arg forget arg] } {
	    set mode directory
    	} else {
	    if { [regexp {^(.*),$} $arg forget arg] } {
		set mode substitution
	    }
	    set index_directory [file dirname $arg]
	}
	set index_file $arg
	set substitutions ""
	foreach opt [array names option_array] {
	    unset option_array($opt)
	}
    } elseif { $mode == "directory" } {
    	if { [regexp {^(.*),$} $arg forget arg] } {
	    set mode substitution
	} else {
	    set mode file
	}
	set index_directory $arg
    } elseif { $mode == "substitution" } {
    	if { ! [regexp {^(.*),$} $arg forget arg] } {
	    set mode file
	}
	if { [regexp {^([^=]*)=([^=]*)$} $arg forget \
	               source destination] } {
	    lappend substitutions \
		    [list $source $destination]
	} elseif { [regexp {^([^:]*):([^:]*)$} \
	                   $arg forget \
	               source destination] } {
	    set option_array($source) \
	        [string trim $destination]
	} else {
	    error "Badly formatted substitution:\
	           `$arg'"
	}
    }

    if { $mode == "file" } {
    	process_index_specification
    }
}
if { $mode != "file" } {
    error "Last argument ends with `,' or `:'"
}

# Finish up index and ./contest/help1/problems files.
#
if { $info_option } {
    close $newindex_ch
    if { [llength [glob -nocomplain \
			$info_directory+/*]] == 1 } {
	file delete -force $info_directory+/index
    }
}
if { $help_problems_option } {
    close $newhelp_ch
    TODO "    run startcontest to grant access to\
              ./contest/help1/problems"
}

# Rename directories iff $directory+ differs from
# $directory as determined by `diff -r'.  If a directory
# is not renamed, delete it.  Return `yes' if directory
# renamed, and `no' if deleted.
#
proc rename_directory { directory } {
    
    if { ! [catch { exec diff -r $directory \
                         $directory+ > /dev/null } ] \
         } {
    	puts "New $directory does not differ from\
	      previous version."
	exec rm -rf $directory+ >@stdout
	return no
    } else {

	if { [file exists $directory--] } {
	    exec rm -rf $directory-- >@ stdout
	}
	if { [file exists $directory-] } {
	    puts "Renaming $directory- to $directory--"
	    file rename $directory- $directory--
	}
	if { [file exists $directory] } {
	    puts "Renaming $directory to $directory-"
	    file rename $directory $directory-
	}
	if { [file exists $directory+] } {
	    puts "Renaming $directory+ to $directory"
	    file rename $directory+ $directory
	}
	return yes
    }
}

if { $info_option } {
    rename_directory $info_directory
}
if { $problems_option } {
    if { [rename_directory $problems_directory] } {
    	TODO "    chmod a+rx $problems_directory" \
	     "when contest starts"
    }
}
if { $solutions_option } {
    rename_directory $solutions_directory
}

# Make mail directory.
#
if { $mail_option \
      && ! [file isdirectory mail] } {
    file mkdir $mail_directory
    grant_access $mail_directory x
}

# Make contest/help1/this_contest file.
#
if { $help_option \
     && ! [file isfile contest/help1/this_contest] } {
    if { ! [catch {
              set help1_this_contest_type \
    		  [file type contest/help1/this_contest]
				}] } {
	if { $help1_this_contest_type == "link" } {
	    puts "Deleting contest/help1/this_contest"
	    file delete -force \
		 contest/help1/this_contest
	} else {
	    error "contest/help1/this_contest exists\
		   but is not a file"
	}
    }
    set this_contest_ch \
    	[open contest/help1/this_contest w]
    puts $this_contest_ch "This Contest Help	 \
         [clock format [clock seconds]]"
    puts $this_contest_ch ""
    puts $this_contest_ch "For a list of help topics\
    			   other than this, use the"
    puts $this_contest_ch "command `help index'."
    close $this_contest_ch
    grant_access ./contest/help1/this_contest

    TODO "    edit contest/help1/this_contest"
}

# Make contest/help2 directory.
#
if { ( $help_formal_option || $help_informal_option ) \
     && ! [file isdirectory contest/help2] } {
    if { ! [catch {
	      set help2_type \
		  [file type contest/help2] }] } {
	if { $help2_type == "link" } {
	    puts "Deleting contest/help2"
	    file delete -force contest/help2
	} else {
	    error "contest/help2 exists but is not\
                   a directory"
	}
    }
    if { $help_formal_option } {
    	if { $help_informal_option } {
	    error "both -help_formal and\
	           -help_informal set"
	}
	link_file contestant/help/formal \
		  contest/help2
    } else {
	link_file contestant/help/informal \
		  contest/help2
    }
}

# Make contest/help3 directory.
#
if { $help_option \
     && ! [file isdirectory contest/help3] } {
    if { ! [catch { set help3_type \
    			[file type contest/help3] }] } {
	if { $help3_type == "link" } {
	    puts "Deleting contest/help3"
	    file delete -force contest/help3
	} else {
	    error "contest/help3 exists but is not\
                   a directory"
	}
    }
    link_file contestant/help/common contest/help3
}

# Make contest/bin directory.
#
if { $bin_option \
     && ! [file isdirectory contest/bin] } {
    set source contest/contestant/bin
    if { ! [file isdirectory $source] } {
    	error "bin: $source is not a directory"
    }
    if { ! [file executable $source] } {
    	error "bin: $source has no x permission"
    }
    if { ! [catch { set bin_type \
			[file type contest/bin] }] } {
	if { $bin_type == "link" } {
	    puts "Deleting contest/bin"
	    file delete -force contest/bin
	} else {
	    error "contest/bin exists but is not\
                   a directory"
	}
    }

    puts "Linking bin to $source"
    link_file contestant/bin contest/bin

    TODO_hpcm_make
}

# Make secure directory.
#
if { $secure_option } {
    if { ! [file isdirectory contest] } {
    	error "secure: contest is not a directory"
    }
    if { ! [file isdirectory contest/secure] } {
    	file mkdir contest/secure
	chmod og-rwx contest/secure
    }
    if { ! [file readable contest/secure/passwords] } {
	write_file contest/secure/passwords \
		"ACCOUNT-NAME:PASSWORD"
	TODO "    edit contest/secure/passwords"
	chmod og-rwx contest/secure/passwords
    } else {
        set passwords_ch \
	    [open contest/secure/passwords r]
	set lines ""
	set changed no
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    if { [regexp {^([^:]+)(|:|::.*)$} $line \
			 forget account forget2] } {
		set password [make_password]
		set rest ""
		regexp {^[^:]+:(:.*)$} $line \
		       forget rest
	        set line "$account:$password$rest"
		set changed yes
	    }
	    lappend lines $line
	}
	close $passwords_ch
	if { $changed} {
	    set passwords_ch \
	        [open contest/secure/passwords w]
	    foreach line $lines {
	        puts $passwords_ch $line
	    }
	    close $passwords_ch
	    TODO "    inspect contest/secure/passwords"
	}
    }
    if { ! [file readable \
    		 contest/secure/hpcm_sendmail.rc] } {
	set rc_ch \
	    [open contest/secure/hpcm_sendmail.rc w]
	puts $rc_ch \
	     "To: [make_password]<[id user]@[id host]>"
	puts $rc_ch \
	     "Key: [make_password]"
	set key_name [file tail [pwd]]
	regexp {^(.*)(-|_)[^-_]*$} $key_name \
	       forget key_name forget2
	puts $rc_ch \
	     "Key-Name: $key_name"
	close $rc_ch
	chmod og-rwx contest/secure/hpcm_sendmail.rc
	TODO "    edit contest/secure/hpcm_sendmail.rc" \
	     "    either remove the Key and Key-Name" \
	     "    or edit the hpcm_judging.rc\
		  authorization variables"
    }
}

# Make contest/who_where
#
if { $who_where_option \
     && ! [file isfile contest/who_where] } {
    if { ! [catch {
              set who_where_type \
    		  [file type contest/who_where]
				}] } {
	if { $who_where_type == "link" } {
	    puts "Deleting contest/who_where"
	    file delete -force \
		 contest/who_where
	} else {
	    error "contest/who_where exists\
		   but is not a file"
	}
    }
    set who_where_ch \
    	[open contest/who_where w]
    set passwords_ch \
    	[open contest/secure/passwords r]
    while { "yes" } {
	set line [gets $passwords_ch]
	if { [eof $passwords_ch] } break
	regexp {^([^:]*):} $line forget line
	puts $who_where_ch \
	  "$line:WHO:WHERE:COACH-EMAIL:PRACTICE-EMAIL"
    }
    close $passwords_ch
    close $who_where_ch
    grant_access ./contest/who_where

    TODO "    edit contest/who_where"
}

# Make contest/printer
#
if { $printer_option \
     && ! [file isfile contest/printer] } {
    if { ! [catch {
              set printer_type \
    		  [file type contest/printer]
				}] } {
	if { $printer_type == "link" } {
	    puts "Deleting contest/printer"
	    file delete -force \
		 contest/printer
	} else {
	    error "contest/printer exists\
		   but is not a file"
	}
    }
    set printer_ch [open contest/printer w]
    if { [info exists env(PRINTER)] } {
	puts $printer_ch $env(PRINTER)
    } else {
	puts $printer_ch UNKNOWN
    }
    close $printer_ch
    grant_access ./contest/printer

    TODO "    edit contest/printer"
}

# Make contest/trashable
#
if { $trashable_option \
     && ! [file isfile contest/trashable] } {
    if { ! [catch {
              set trashable_type \
    		  [file type contest/trashable]
				}] } {
	if { $trashable_type == "link" } {
	    puts "Deleting contest/trashable"
	    file delete -force \
		 contest/trashable
	} else {
	    error "contest/trashable exists\
		   but is not a file"
	}
    }
    set trashable_ch [open contest/trashable w]
    set passwords_ch \
    	[open contest/secure/passwords r]
    while { "yes" } {
	set line [gets $passwords_ch]
	if { [eof $passwords_ch] } break
	regexp {^([^:]*):} $line forget line
	puts $who_where_ch $line
    }
    close $passwords_ch
    close $trashable_ch
    grant_access ./contest/trashable

    TODO "    check and maybe edit contest/trashable"
}

# Make contest/prototype
#
if { $prototype_option \
     && ! [file isfile contest/prototype] } {
    if { ! [catch {
              set prototype_type \
    		  [file type contest/prototype]
				}] } {
	if { $prototype_type == "link" } {
	    puts "Deleting contest/prototype"
	    file delete -force \
		 contest/prototype
	} else {
	    error "contest/prototype exists\
		   but is not a file"
	}
    }
    set prototype_ch [open contest/prototype w]
    close $prototype_ch
    grant_access ./contest/prototype

    TODO "    edit contest/prototype"
}

# Check for ./contest/home directory.
#
if { $home_option } {
    if { ! [file isdirectory ./contest/home] \
         || ! [file readable ./contest/home] \
         || ! [file readable ./contest/home/empty.ls] \
         || ! [file readable ./contest/home/setup.ls] \
         || ! [file readable ./contest/home/setup.tar] \
		} {
	TODO "    run SETUP_PROTYPE in prototype\
                  account" \
	     "    and rerun `makejudgingdir -home'"
    }
}

# Finish TODO
#
set TODO_written [expr { $TODO_ch != "" }]
if { $TODO_written || $TODO_existed } {
    if { $TODO_written } {
	close $TODO_ch
    }
    set TODO_ch [open TODO r]
    if { $TODO_existed } {
        if { $TODO_written } {
	    puts "old+new TODO:"
	} else {
	    puts "old TODO:"
	}
    } else {
	puts "new TODO:"
    }
    while { "yes" } {
    	set line [gets $TODO_ch]
	if { [eof $TODO_ch] } break
	puts $line
    }
    puts "----------"
    puts "end of TODO"
    close $TODO_ch
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
