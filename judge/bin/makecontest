#!/bin/sh
#
# Make the subdirectories, symbolic links, and indices
# of a judging directory and its associated contest
# directory.
#
# File:		makecontest
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed May  3 04:41:25 EDT 2006
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2006/05/03 09:02:02 $
#   $RCSfile: makecontest,v $
#   $Revision: 1.163 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
set contestant_help_directory \
    "[file dirname $argv0]/../../contestant/help"
source $lib_directory/judging_common.tcl
set log_mode none
catch {

# Compute true name of judging_directory, with no
# `/.'s or `/..'s.
#
set judging_directory [truename $judging_directory]

# Abbreviations used in this program to shorten lines.
#
set j_d $judging_directory
set c_d $j_d/contest

set document "
makecontest option ... index_specification ...

  If no arguments are given, makecontest takes its
  arguments from the makecontest_arguments global
  variable, if that exists.

  Options:
    -local	Equals all options needed to have local
    		contestant accounts; specifically, the
		following: -contest, -bin, -home, -help,
		-help2, -this_contest, -solutions,
		-mail, -print_files, -solution_files
		-secure, -procmailrc, -who_where,
		-trashable.
    -email	Equals all options needed to have email
    		contestant accounts; specifically, the
		following: -info, -solutions, -mail,
		-this_contest, -procmailrc, -print_
		files, -solution_files.
    -formal     Same as local plus -problems and -demos.
    -informal   Same as local plus -startcontest and
    		-info.

    -info	Make ./info, ./info/help/index,
    		./info/help/problems, ./info/help/demos.

    -solutions  Make ./solutions

    -contest	Make ./contest
    -bin	Make ./contest/bin
    -home	Make ./contest/home
    -problems	Make ./contest/problems.  Includes
    		problem description files for non-`all'
		directory entries only if -description
		is given.
    -demos	Make ./contest/demos.  Includes
    		problem description files for non-`all'
		directory entries only if -description
		is given.
    -description     Include problem description (.txt,
    		.html, .ps, etc.) files in ./contest/
		problems, ./contest/demos, or ./contest/
		help.
    -help	Make ./contest/help,
    		     ./contest/help/index,
    		     ./contest/help/problems,
    		     ./contest/help/demos
    -help2	Make ./help2

    -secure	Make ./contest/secure/passwords,
		     ./contest/secure/hpcm_sendmail.rc
    -ssh	Make ./contest/extra_setup.tar contain-
    		ing a .ssh/authorized_keys file that
		contains .ssh/id_rsa.pub, .ssh/id_
		dsa.pub, and .ssh/identity.pub.

    -this_contest    Make ./help, ./help/index,
		          ./help/this_contest,
		          ./help/this_contest_parameter,
		          ./help/this_contest_original
    -print_files  Make ./help_print_files,
    		       ./problems_print_files,
		       ./demos_print_files.
    -solution_files  Make ./solution_files.

    -mail	Make ./mail
    -procmailrc	Update ~/.procmailrc

    -who_where  Make ./contest/who_where
    -trashable  Make ./contest/trashable with non-
    		existing accounts
    -trashall   Make ./contest/trashable with all
    		accounts

    -printer    Make ./contest/printer and
    		     ./contest/printer_jobs
    -printer_map    Make ./contest/printer_map and
    		         ./contest/printer_jobs

    -javahelp	Make ./contest/javahelp
    -stlhelp	Make ./contest/stlhelp

    -web	Make ./web

    -scoreboard_ssh
    		For each zzz in the scoreboard_ssh
		global variable, make ./zzz_identity,
		./zzz_identity.pub, and ./zzz_
		authorized_keys.
    -scoreboard_procmailrc
    		For each zzz in the scoreboard_
		procmailrc global variable, make
		./zzz_procmailrc.

    -startcontest   Run the startcontest program if
    		    necessary.
    -scoreboard     Run the makescoreboard program if
    		    necessary.

  Index Specification:

    index_file\[: index_directory\], name1s=name1t, \\
	  option1s:'option11t option12t ...', \\
	  name2s=name2t, ...

  Pre-Existing Files and Links:

    ./hpcm_judging.rc	 Parameters file.



    Given a judging directory as the current directory,
    complete with hpcm_judging.rc file, this program
    makes subdirectories, links, and index files in the
    judging directory and optional associated contest
    directory, according to instructions in the index
    specifications and options.  The form of the index
    specifications and options is given above.

    This program appends instructions for its user to
    edit certain files and run certain programs to the
    ./TODO file, and prints an announcement at the end
    of the program if this file is not empty.  Informa-
    tion items in the ./TODO file are call `TODO's.

    The -contest program option makes the contest direc-
    tory and the symbolic link `./contest' to that di-
    rectory.  This is needed contests with local contes-
    tant accounts, but not for contests with only email
    accounts.  If `./contest' does not exist, and name
    of the judging directory is ~/XXX/judging_YYY_PPP
    where PPP is a password, the directory named
    ~/XXX/contest_YYY is made and used as the contest
    directory.  That is, the judging directory name is
    modified by replacing `judging_' by `contest_' at
    its beginning, and removing from the end any `_PPP'.
    If the judging directory name is ~/XXX/judging_YYY
    and there is no `_PPP', the contest directory name
    ~/XXX/contest_YYY is still used (YYY must not con-
    tain a `_').  It is an error if `./contest' does not
    exist but the contest directory already exists.

    If `./contest' is made, or if anything is made in
    `./contest', a+x is set for that directory and its
    parent.

    The -bin program option makes the symbolic link
    ./contest/bin to `\$hpcm_directory/contestant/bin',
    where the `hpcm_directory' global variable defaults
    to `~/hpcm'.  If this cannot be done, it is not an
    error, but a TODO to fix the situation is written.

    The -home program option makes the symbolic link
    ./contest/home to ~PROTO/home, where PROTO is the
    name of the prototype account that is set up by
    the `SETUP_PROTOTYPE' program.  PROTO is defined
    as the value of the global variable `hpcm_prototype_
    account' if that variable is defined.  Otherwise
    PROTO is the unique account name which has the form
    `*\[_-\]proto' such that the directory ~PROTO/home
    is readable and executable and the files ~PROTO/
    home/setup.tar, ~PROTO/home/setup.ls, and ~PROTO/
    home/empty.ls exist and are readable, if such a
    unique account name exists.  If the prototype
    account cannot be found, it is not an error, but
    a TODO to fix the situation is written.

    The index files are read and used to generate a list
    of items to be included in the ./info and ./contest
    directories.  Each item is a file or directory, and
    corresponds to an item entry in an index file.  The
    item entry has the form:

    	*** item_name item_option ...
	    Text describing the item.

    Items have names which, after optional substitutions
    described below, must begin with `help/', `demos/',
    or `problems/', depending the subdirectory of ./info
    or ./contest into which the item is to be included.
    Only the three subdirectories just mentioned are
    allowed.  The item entry of each included item is
    copied into an output index file, which is the
    `help/index' file if the item name begins with
    `help/', the `help/problems' file if the item name
    begins with `problems/', or the `help/demos' file
    if the item name begins with `demos/'.

    When an item entry is copied to an output index,
    the `***' in the first line of the entry is replace
    by 3 space characters, the item name is replaced by
    the name after substitutions, and the item options
    are removed.

    The input index files also contain header entries
    that precede item entries.  When an item entry is
    copied into an output index, the header entry im-
    mediately preceding it is copied into the same out-
    put index.  More specifically, a header entry is
    copied if it is separated from an item entry being
    copied only by other item entries.

    Lastly, any line beginning with `#' in an input
    index file is a comment line that is completely
    ignored, as if it did not exist.

    When an item is included in the ./info directory,
    a symbolic link is made to the item if it is a
    file.  If it is a directory, a new directory
    is created containing a symbolic link to any problem
    source and description files in the directory.  The
    exact definitions of problem source and description
    files are given below.  Problem description file
    links are included within the ./info directory even
    if no -description program option is given.

    When an item is included in the ./contest directory
    (i.e., in ./contest/demos, ./contest/problems, or
    ./contest/help) files are copied and new directories
    are made.  Access is granted using a+r and a+rx file
    and directory modes, except for
    
    		./contest/problems 
    		./contest/help/problems

    which are left with the mode determined by the
    umask (presumably o-rx or og-rx).  The `startcon-
    test' program sets the mode of these to a+rx.  The
    directory items copied are determined by the
    problem_source_files, problem_description_files,
    and problem_excluded_files global variables and the
    `all' option in the index.  See below for details.

    If we consider the directory pairs:

    	./info/demos		./contest/demos
    	./info/problems		./contest/problems
    	./info/help		./contest/help

    then if both directories of a pair are made, both
    are identical after symbolic links are followed,
    except that if there is no -description option,
    problem description files are generally copied into
    ./info subdirectories but not into ./contest subdir-
    ectories.  But if the -description option is given,
    the UNIX `diff -r' command should report the two
    directories in each of the above pairs to be
    identical.

    Directory items may also be included in the
    ./solutions directory.  In this directory the item
    name after substitutions is stripped of any direc-
    tory prefix; e.g., the name `demos/count' becomes
    `count'.  The inclusion here is by symbolic link
    from directory to directory: e.g. `./solutions
    /count' is symbolically linked to the item direc-
    tory.  This means that all demos and problems in the
    contest must have unique single component names
    (except for items with the `nosolution' item option:
    see below).

    If this program is building a ./info directory, it
    actually builds a ./info+ directory instead.  Then
    it does a `diff -r ./info ./info+', and checks the
    output to see if there is any difference between
    ./info and ./info+ except for the first lines of
    the help indices (help/demos, help/problems, and
    help/index).  If there are no differences, the
    ./info+ directory is removed and nothing else is
    done.  If the two directories have other differ-
    ences, the following renaming occurs:

    		./info-	    becomes    ./info--
    		./info	    becomes    ./info-
    		./info+	    becomes    ./info

    A similar stratagem is followed for ./solutions,
    ./contest/problems, ./contest/demos, and .contest/
    help.

    The item entries and header entries are in input
    index files, each of which is referenced in a sep-
    arate index specification.  The format of an index
    specification is given above: it is a sequence of
    arguments, all but the last of which end in either a
    `:' or a `,'.  The `:' indicates the next argument
    is an index directory name (see below) and the `,'
    indicates the next argument is either a name sub-
    stitution or an option substitution (also see
    below).

    Each input index file is associated with an index
    directory.  An unedited version of the index file is
    normally found in its index directory.  Sometimes an
    edited copy of this index file is placed in the
    current judging directory, with the editing consist-
    ing of changes to the item entry options described
    below which control what is included in the new
    info, contest, and solutions directories.  Often,
    however, an edited copy of the index file need not
    be made, because item entry option mapping, describ-
    ed below, is sufficient.

    An index directory may optionally be given in a
    specification by ending the first argument of the
    specification, which names the index input file,
    with a `:', and giving the name of the index direc-
    tory as the second argument in the specification
    (with an optional ending `,').  If no index direc-
    tory is given in an index specification, the direc-
    tory that contains the index file is used as the
    index directory.

    The index file consists of two types of entries:
    header entries and item entries.  Item entries begin
    with a line that starts with `***', followed by
    whitespace, and optionally preceded by whitespace.
    Header entries begin with a line that starts with
    neither whitespace nor `***' followed by whitespace.
    A header entry stops at the next line that begins an
    item entry, or at the end of file.  An item entry
    stops at the next line that begins a header or item
    entry, or at the end of file.

    As noted above, the first line of an item entry has
    the form:

    	*** item_name item_option ...

    The item name is the name of the item file or direc-
    tory relative to the index directory (the directory
    normally containing the unedited index file).  The
    possible item options are:

      include	  Include item in the ./info and
      		  ./contest directories, and in the
		  ./solutions directory if the
		  `nosolution' item option is absent
		  and the item name after substitutions
		  begins with `demos/' or `problems/'.

      nosolution  Do NOT include the item in the 
                  ./solutions directory, even if the
		  item name after substitutions begins
		  with `demos/' or `problems/'.

      all	  This changes the definition of the
      		  global variable problem_source_files
		  to {.*}, which means that all files
		  not excluded by the global variable
		  problem_excluded_files will be
		  source or description files.  See
		  below for details.

      ...	  Other options may be given that are
      		  passed to the PROBLEM.rc file: see
		  below for details.

    The `include' option is rarely encoded directly in
    the index files.  Instead options categorizing the
    entries are made up by the author of an index file
    and mapped by the index specification to the
    `include' option.  Mapping is done by option substi-
    tution that occurs before the options are finally
    processed.  A substitution of the form:

    	option1s:'option11t option12t ...'

    in the index specification replaces option1s by the
    options in the list `option11t option12t ...'.
    As a special case, if `option1s' is `ALL', the
    options in the list `option11t option12t ...' are
    always added to the substitution result without
    replacing any option in the original option list.
    Substitution is NOT recursive: it is done only on
    options appearing in the item entries in the index
    files, and not on options that are the result of
    substitution.  After substitutions are done, unknown
    options are ignored.

    In mapping item options, the item_name is also
    mapped like an option and the result treated as
    options.  This permits substitutions like

    	item_name:include

    to include an item by name.  Thus an item_name is
    used twice, once as the name of the item  (more on
    this below), and once as an item_option.

    If an item has the `include' option after option
    substitutions, the item entry is included in an out-
    put index within the ./info directory.   The indices
    are

    	   index		for items named

      ./info/help/index	    ./info/help/...
      ./info/help/demos	    ./info/demos/...
      ./info/help/problems  ./info/problems/...

    There is a similar inclusion for the ./contest dir-
    ectory.

    When an item entry is included in an output index,
    the header entry preceding it is included if it is
    separated from the item entry only by item entries
    that were not included in that output index.  Thus
    a header entry is associated with the consecutive
    item entries that follow it, and the header entry is
    included in an output index if and only if any of
    these item entries is included.  The header entry
    may end up being included in several output indices
    if the item entries following it are included in
    several different output indices.

    The program options -demos, -problems, and -help can
    be used by omission to prevent the ./contest/demos,
    ./contest/problems, or ./contest/help directories
    from being created, but program options never affect
    the content of any output indices that are created.

    The name of an item is a modification of the name
    of the item as it appears in the input index file
    item entry.  The modification results from substitu-
    tions specified in the index specification.  Spec-
    ifically, a substitution of the form `nameXs=nameXt'
    may be applied to the item name.  If the item name
    begins with the nameXs string, that string will be
    replaced by nameXt.  If there are several possible
    substitutions, the longest nameXs will be selected,
    and if there are several longest, the first will be
    selected.

    Thus, for example, given an index specification of
    the form

    	my_index: foo/bar, public/=problems/, \\
	          public/shelf/=problems/old/

    then

      public/foo2	   becomes    problems/foo2
      public/shelf/foo1    becomes    problems/old/foo1

    with the changed names being used as the names of
    the items within the ./info and ./contest
    directories and as the names of the item in any
    output index files.

    Substitutions are not recursive: the result of a
    substitution is NOT subject to further substitu-
    tions.

    When an index item names a problem, demo, or help
    directory, it is necessary to determine the problem,
    demo, or help source and description files.  In this
    case the directory is inspected for a file named
    `PROBLEM.rc', where `PROBLEM' is the last component
    of the directory name.  If that file exists it is
    sourced into a local procedure (so it will not
    define global variables other than those needed by
    makecontest).  The PROBLEM.rc file may reference the
    variables

    	PROBLEM		Name of problem.
	EXTENSION	Equals \"UNDEFINED\"
	OPTIONS		The options in the index item,
			as a TCL list, after expansion.

   The PROBLEM.rc file may define the following vari-
   ables:

	problem_description_files
   	problem_source_files
   	problem_solution_files
   	problem_excluded_files
	problem_print_files

    The values of these variables are TCL lists of
    regular expressions.  Default values are provided
    for these variables by hpcm_judging.rc, and these
    in turn default as follows:

	problem_description_files:
	    [indent_list 12 $problem_description_files]
   	problem_source_files:
	    [indent_list 12 $problem_source_files]
   	problem_solution_files:
	    [indent_list 12 $problem_solution_files]
   	problem_excluded_files:
	    [indent_list 12 $problem_excluded_files]
   	problem_print_files:
	    Undefined.

    The description and source file lists are lists of
    description or source file names relative to the
    index item directory.  To be listed a file must have
    a name whose LAST component matches a regular ex-
    pression in the problem_description_files or pro-
    blem_source_files global variable values, and NOT
    have ANY name component that matches a regular
    expression in problem_excluded_files.  If a file
    would be in both the description and file lists, it
    is deleted from the source list, so it is in only
    the description file list.
    
    The difference between source and description files
    is that source files are always copied into
    ./contest/{problems,demos,help}, whereas description
    files are copied only if the -description option is
    given to makecontest.
    
    The `all' option in an index item changes the
    problem_source_files value to {.*} and the problem_
    description_files value to {}.  This effectively
    eliminates the effect these two global variables and
    includes all files not excluded by the problem_
    excluded_files global variable, regardless of the
    setting of the -description option.

    The print files are a list of all the files to be
    printed and given to contestants.  This is a list of
    file names relative to the index item directory.  It
    is the value of the problem_print_files global vari-
    able if that is defined, and is otherwise the sorted
    list of description files.

    The name `PROBLEM.rc' is something of a misnomer for
    help files.  In this case `PROBLEM' is merely the
    last component of the index item directory name.  It
    is very rare for a help file directory to need a .rc
    file.

    By convention, a problem or demo source file that
    has the extension `.ISF' is intended as the initial
    version of a writable contestant file that the con-
    testant will submit and may alter before submitting.
    The writable contestant file itself has the name of
    the initialization file with the `.ISF' stripped
    from its end.  Thus a source file named `foo.c.ISF'
    should be copied into a writable contestant file
    named `foo.c' that will be submitted (by the con-
    testant executing `make submit').  `.ISF' stands for
    `initial submittable file'.

    This current program does nothing special with files
    having the `.ISF' extension.  It is the `hpcm_get'
    and `hpcm_extract' programs that automatically copy
    a file with a name such as `xxx.ISF' into a writable
    file named `xxx'.

    We proceed to describe the program options not di-
    rectly involved with making ./info, ./contest/help,
    ./contest/problems, or ./contest/demos.

    The -this_contest program option creates the follow-
    ing if they do not exist:

	./help				directory
	./help/index			file
	./help/this_contest		file
	./help/this_contest_parameter	file
	./help/this_contest_original	file

    Note these are in the judging directory proper, and
    not in the ./info or ./contest subdirectories.  The
    ./help/index file is an INPUT index file that con-
    tains an entry for ./help/this_contest.  The latter
    file is information about the current contest.  The
    -this_contest option is processed before any input
    index files are read, so ./help/index may be used as
    an input index file in the same call to
    `makecontest' that creates the ./help/index file.

    If used, the ./help/index file should be the refer-
    enced by the first help file index specification
    given to this program.  It contains a header entry
    designed to start the output index `help/index', and
    with this header entry, all the help index files,
    `help/demos', `help/problems', and `help/index', are
    mentioned at the beginning of `help/index'.

    The ./help/this_contest* files are written to be a
    copy of the `this_contest' global variable.  The
    ./help/this_contest_original is written only if it
    does not exist.  The ./help/this_contest_parameter
    file is written if it does not exist or if it exists
    but is not equal to the value of the `this_contest'
    global variable.  The ./help/this_contest files is
    written only if it does not exist, or if it equals
    ./help/this_contest_parameter and the latter is to
    be written.

    Thus initially all the ./help/this_contest* files
    are equal to the `this_contest' global variable
    value.  You can then either update that value, or
    you can edit the ./help/this_contest file.

    If ./help/this_contest is written, a TODO is written
    indicating what has been done.

    The -mail program option causes the ./mail directory
    to be made if it does not exist.  If it is made, its
    mode is set to a+x as is the mode of its parent and
    its parent's parent.  This last is necessary because
    the JAVA interpreter turns relative file names into
    absolute file names, requiring `a+x' permissions
    in the path from the root to the object file.

    The -help2 program option creates the ./contest/
    help2 directory if it does not exist.  It is simply
    linked to the ./contest/help directory.

    Note that the contestant's `help' command searches
    ./contest/help1, ./contest/help2, ./contest/help3,
    and ./contest/help4 in order for help files.  Thus
    files put in ./contest/help1 will override those
    in ./contest/help that is linked to ./contest/help2.

    The -print_files program option makes the ./help_
    print_files, ./problem_print_files, and ./demos_
    print_files files which each list files that can be
    fprint'ed.  These lists begin with the help/index,
    help/problems, and help/demos index files respec-
    tively, and then list all the files listed in those
    indices.  However, if help/this_contest is listed in
    help_print_files, it is moved to the front of the
    help_print_files list.

    The -solution_files program option makes the
    ./solution_files file that lists files in the
    solutions subdirectory that can be posted on the web
    to define solutions.  These files are defined by
    the problem_solution_files and problem_excluded_
    files global variables.

    The -secure program option makes the following if
    they do not exist:

	./contest/secure		    directory
	./contest/secure/hpcm_sendmail.rc   file
	./contest/secure/passwords	    file

    If any of these are made their modes are set to
    go-rw.  If the ./contest/secure/passwords file is
    made, a TODO for editing it is written, but the
    file automatically made is empty.

    The `To' address in hpcm_sendmail.rc is the first
    address in the `autojudge_addresses' global varia-
    ble, if that variable is non-empty, and is otherwise
    made automatically and using a random number.

    The ./contest/secure/passwords file consists of
    lines of the form

    	account:password:who:c-email:t-email:comment

    Here `account' is a the login name of the contes-
    tant, `who' is a description of who the contestant
    is, and the `c-email' and `t-email' fields are the
    email addresses used to contact the coach and to
    contact the team members using the account, respec-
    tively.  The account name `none' may be used to
    indicate a line is not associated with an account,
    and the password `none' may be used to indicate the
    password is to be assigned by other means.

    The -secure program option also causes any existing
    ./contest/secure/passwords file to be inspected for
    lines with empty passwords.  If any are found,
    random passwords are generated and inserted in place
    of the missing passwords.  The password `none' may
    be used in a line to prevent a random password from
    being generated and to prevent the hpcm_set_
    passwords program from setting the password of the
    line's account.  If a new password is generated for
    an existing account, a TODO is written telling how
    to reset the account's password.

    The -ssh program option makes the file `./contest/
    extra_setup.tar' containing the file `.ssh/
    authorized_keys' which is the concatenation of all
    the files `~/.ssh/identity.pub, `~/.ssh/id_rsa.pub',
    and `~/.ssh/id_dsa.pub' that exist.  If none of
    these files exist, it is not an error, but a TODO
    to fix the situation is written.  In order to make
    the tar file, `./.ssh' and `./ssh/authorized_keys'
    are made.

    The -procmailrc program option updates the ~/
    .procmailrc file with one entry for each autojudge
    address.  If `./contest/secure/hcpm_sendmail.rc'
    exists, one autojudge address is made from its
    contents.  The other autojudge addresses are listed
    in the `autojudge_addresses' global variable.  If
    there are no autojudge addresses, it is not an
    error, but a TODO to fix the situation is written.

    The -procmailrc program option also ensures that
    the entry

    		:0 c:
		hpcm_mbox

    is in the ~/.procmailrc file to put a copy of all
    incoming mail into the ~/hpcm_mbox file, just in
    case such a record is needed.  This entry must be
    before other entries that route mail.

    The -who_where program option makes the ./contest/
    who_where file if it does not exist, or updates it
    if it does exist and the ./contest/secure/passwords
    file is newer.  The ./contest/who_where file is a
    copy of the ./contest/secure/passwords file with the
    passwords replaced by where values.  If any new
    places to insert a `where' value are made in the
    ./contest/who_where file, a TODO to edit the file
    is written.  There may be accounts in the `who_
    where' file that are not in the `passwords' file.
    Lines with account name `none' in the `passwords'
    file are not copied to the `who_where' file.

    The -trashable program option creates the ./contest/
    trashable file from the ./contest/secure/passwords
    file.  The `trashable' file is just a list of the
    accounts in the `passwords' file, not including the
    account name `none', and not including the names of
    any accounts that already exist.  The -trashall
    option is like the -trashable option but includes
    all accounts other than `none', whether or not the
    account already exists.

    An account needs to be listed in the `trashable'
    file in order for the `TRASH_ACCOUNT' program be
    able to initialize the files in the account.  This
    feature is intended to prevent accidental reini-
    tializing of accounts.

    If -trashable is given when all accounts exist, the
    `trashable' file is deleted.

    If the `trashable' file is changed to something non-
    empty, a TODO is written on how to set up the
    accounts.

    The -printer program option makes the ./contest/
    printer file if that file does not exist.  This file
    is the name of the printer, which is the value of
    the `printer' global variable if that exists, else
    is the value of the `PRINTER' environment variable
    if that exists, else is the value `UNKNOWN' which
    means the file needs to be edited.  If the `printer'
    global variable does not exist, a TODO is written
    to suggest editing the .contest/printer file just
    made.

    The -printer_map program option is similar to the
    -printer option but makes a ./contest/printer_map
    file instead of a ./contest/printer file and always
    uses the value of the `printer_map' global variable.
    The file is written if it does not exist or if it
    does not equal the `printer_map' variable value.  If
    the `printer_map' variable is not set, the file is
    not written but a TODO is written.

    Note that if both the ./contest/printer and
    ./contest/printer_map files exist, contestant
    programs ignore ./contest/printer.

    If either the ./contest/printer or ./contest/
    printer_map files are written, the ./contest/
    printer_jobs file is also made if it does not
    exist.

    The -javahelp program option writes the ./contest/
    javahelp file, making the file equal to the value
    of the `javahelp' global variable.  The file is
    written if it does not exist or if it does not equal
    the `javahelp' variable value.  If the `javahelp'
    variable is not set, the file is not written but a
    TODO is written.

    The -stlhelp program option is just like -javahelp
    but writes the ./contest/stlhelp file from the
    `stlhelp' global variable.

    The -web program option invokes the makeweb program
    to make the ./web directory.  More specifically,
    ./web+ is made, compared with ./web, and if not the
    same, then ./web- is renamed to ./web--, ./web to
    ./web-, and ./web+ to ./web.

    The -startcontest program option executes the
    `startcontest start' command unless this has already
    been done, or if it has been done but a background
    process waiting to start the contest has died.

    The -scoreboard_ssh program option makes files need-
    ed if the `makescoreboard' program is to copy the
    scoreboard to remote accounts using ssh (see
    scoreboard_addresses in hpcm/judge/lib/hpcm_judg-
    ing.rc).  For each element zzz of the scoreboard_ssh
    global variable, the ssh_keygen function (see hpcm_
    judging.rc) is called to make a private key ./zzz_
    identity and a public key ./zzz_identity.pub, and an
    entry for the ~/.ssh/authorized_keys file in receiv-
    ing accounts is made in ./zzz_authorized_keys.

    The -scoreboard_procmailrc program option makes
    files useful if the `makescoreboard' program is to
    email the scoreboard to remote accounts (see
    scoreboard_addresses in hpcm/judge/lib/hpcm_judg-
    ing.rc).  For each element zzz of the scoreboard_
    procmailrc global variable, ./zzz_procmailrc is
    made containing an entry for the ~/.procmailrc file
    in receiving accounts.

    The -scoreboard program option executes the
    `makescoreboard start' command unless this has
    already been done, or if the background process that
    maintains the scoreboard has died.  This option also
    moves any scoreboard.1head file from the judging
    directory to the contest directory if the contest
    directory exists and does not have this file.

    Although we have used the names `./info', `./mail',
    `./contest', and `./help' in this description, the
    actual directories are the info, mail, contest,
    help, etc. subdirectories of the judging_directory.
    The file names within these directories are literal-
    ly as given in this document.

    Like other HPCM programs, `makecontest' can be
    run from anywhere in the judge's directory subtree
    which is rooted by the directory containing the
    `hpcm_judging.rc' file.

    Unlike most HPCM judging programs, errors made by
    this program are not written to log files, but are
    announced on the standard error output."

# If no arguments are given, use the value of the
# makecontest_arguments global variable if that
# exists.
#
if {    $argc == 0 \
     && [info exists makecontest_arguments] } {
    set argv $makecontest_arguments
    set argc [llength $argv]
}

# Argi is the index of the current argument, for use in
# lindex.
#
set argi 0

# Set options, consuming option arguments.
#
set info_option			no
set solutions_option		no
set contest_option		no
set bin_option			no
set home_option			no
set problems_option		no
set demos_option 		no
set description_option		no
set help_option			no
set help2_option		no
set this_contest_option		no
set mail_option			no
set print_files_option		no
set solution_files_option	no
set secure_option		no
set ssh_option			no
set procmailrc_option		no
set who_where_option		no
set trashable_option		no
set trashall_option		no
set printer_option		no
set printer_map_option		no
set javahelp_option		no
set stlhelp_option		no
set web_option			no
set scoreboard_ssh_option	no
set scoreboard_procmailrc_option	no
set startcontest_option		no
set scoreboard_option		no
#
while { $argi < $argc } {
    switch -- [lindex $argv $argi] {
        -local		{ set contest_option	yes
			  set bin_option	yes
			  set home_option	yes
			  set solutions_option	yes
			  set help_option	yes
			  set help2_option	yes
			  set this_contest_option \
			  			yes
			  set mail_option	yes
			  set print_files_option \
			  			yes
			  set solution_files_option \
			  			yes
			  set secure_option	yes
			  set procmailrc_option	yes
			  set who_where_option	yes
			  set trashable_option	yes }
        -email		{ set info_option	yes
			  set solutions_option	yes
			  set this_contest_option \
			  			yes
			  set mail_option	yes
			  set print_files_option \
			  			yes
			  set solution_files_option \
			  			yes
			  set procmailrc_option	yes }
        -formal		{ set contest_option	yes
			  set bin_option	yes
			  set home_option	yes
			  set solutions_option	yes
			  set help_option	yes
			  set help2_option	yes
			  set this_contest_option \
			  			yes
			  set mail_option	yes
			  set print_files_option \
			  			yes
			  set solution_files_option \
			  			yes
			  set secure_option	yes
			  set procmailrc_option	yes
			  set who_where_option	yes
			  set trashable_option	yes
			  set problems_option	yes
			  set demos_option	yes }
        -informal	{ set contest_option	yes
			  set bin_option	yes
			  set home_option	yes
			  set solutions_option	yes
			  set help_option	yes
			  set help2_option	yes
			  set this_contest_option \
			  			yes
			  set mail_option	yes
			  set print_files_option \
			  			yes
			  set solution_files_option \
			  			yes
			  set secure_option	yes
			  set procmailrc_option	yes
			  set who_where_option	yes
			  set trashable_option	yes
			  set info_option	yes
			  set startcontest_option \
			  			yes }
        -info		{ set info_option 	yes }
        -solutions	{ set solutions_option 	yes }
        -contest	{ set contest_option 	yes }
        -bin		{ set bin_option 	yes }
        -home		{ set home_option 	yes }
        -problems	{ set problems_option 	yes }
        -demos		{ set demos_option 	yes }
        -description	{ set description_option \
						yes }
        -help		{ set help_option 	yes }
        -help2		{ set help2_option 	yes }
	-this_contest	{ set this_contest_option \
						yes }
        -mail		{ set mail_option 	yes }
        -print_files	{ set print_files_option \
						yes }
        -solution_files	{ set solution_files_option \
						yes }
        -secure		{ set secure_option 	yes }
        -ssh		{ set ssh_option 	yes }
	-procmailrc	{ set procmailrc_option	yes }
        -who_where	{ set who_where_option 	yes }
        -trashable	{ set trashable_option 	yes }
        -trashall	{ set trashall_option 	yes }
        -printer	{ set printer_option 	yes }
        -printer_map	{ set printer_map_option \
						yes }
        -javahelp	{ set javahelp_option	yes }
        -stlhelp	{ set stlhelp_option	yes }
        -web		{ set web_option	yes }
        -scoreboard_ssh	{ set scoreboard_ssh_option \
						yes }
        -scoreboard_procmailrc	\
	                { set \
			  scoreboard_procmailrc_option \
						yes }
        -startcontest	{ set startcontest_option \
						yes }
        -scoreboard	{ set scoreboard_option \
						yes }
	default		{ break }
    }
    incr argi
}

# If first remaining argument begins with `-', print
# documentation and exit with error.
#
if {    $argi < $argc \
     && [regexp {^-} [lindex $argv $argi]] } {
    puts $document
    exit 1
}

# Announce judging directory.
#
puts "The Judging Directory, hereafter referred to as\
      `.', is:"
puts "    $j_d"


# Set up TODO
#
set TODO_file $j_d/TODO
set TODO_ch ""
set TODO_existed [expr { [file exists $TODO_file] \
                         && [file size $TODO_file] > 0 \
			 }]
proc TODO { args } {
    global TODO_file TODO_ch
    if { $TODO_ch == "" } {
    	set TODO_ch [open $TODO_file a]
	puts $TODO_ch \
	     "====================\
	      [clock format [clock seconds]] TODOs:"
    }
    puts $TODO_ch "--------"
    foreach line $args {
    	puts $TODO_ch "    $line"
    }
}

# Make 10 character random password.
#
random seed
proc make_password {} {
    return [format {%02x%02x%02x%02x%02x} \
		   [random 256] \
		   [random 256] \
		   [random 256] \
		   [random 256] \
		   [random 256]]
}

# The judging directory name relative to the home
# directory, for use in .procmailrc.  Note that j_d is
# absolute with no `/.'s or `/..'s: see above.
#
set j_d_relative $j_d
set hd $env(HOME)
if { ! [regexp "^$hd/(.*)\$" $j_d_relative \
               forget j_d_relative] } {
    error "$j_d_relative does not begin with $hd/"
}

# Make $c_d directory.
#
if { $contest_option } {
    if { [catch { file type $c_d }] } {
        set dir [file dirname $j_d]
    	# Note j_d has no /.'s or /..'s; see above.
	set tail [file tail $j_d]
	if { ! [regexp {^judging_(.*)$} $tail \
		       forget tail] } {
	    error "$j_d last component does not\
	           begin with `judging_' and ./contest\
		   does not exist"
	}
	regexp {^(.*)_[^_]+$} $tail forget tail
	if { ! [catch { file type \
	                     $dir/contest_$tail }] } {
	    error "$dir/contest_$tail exists and\
	           ./contest does not exist"
	}
	mkdir $dir/contest_$tail
	link_file $dir/contest_$tail $j_d/contest
	puts "Made $dir/contest_$tail"
	puts "     and linked ./contest to it"
    }
    if { ! [file isdirectory $c_d] } {
        error "./contest is not a directory"
    }
}

# Check if ./contest does not exist when it is needed.
# If ./contest is needed, grant a+x access to it and its
# parent.
#
if {    $contest_option \
     || $bin_option \
     || $home_option \
     || $problems_option \
     || $demos_option \
     || $help_option \
     || $help2_option \
     || $secure_option \
     || $ssh_option \
     || $who_where_option \
     || $trashable_option \
     || $trashall_option \
     || $printer_option \
     || $printer_map_option \
     || $javahelp_option \
     || $stlhelp_option \
     || $startcontest_option } {
    if {    ! [file isdirectory $c_d] \
         || ! [file executable $c_d] \
         || ! [file readable $c_d] } {
	error "./contest is not a useable directory"
    }
    if {    ! [regexp ..x [get_access $c_d]] \
         || ! [regexp ..x [get_access $c_d/..]] } {
	puts "Granting a+x access"
	puts "         to ./contest"
	puts "         and its parent"
	grant_access $c_d x
	grant_access $c_d/.. x
    }
}

# Make $c_d/bin directory.
#
if { $bin_option } {
    if {    [catch { file type $c_d/bin }] \
         && [file isdirectory \
	          $hpcm_directory/contestant/bin] } {
	link_file $hpcm_directory/contestant/bin \
	          $c_d/bin
	puts "Linked ./contest/bin"
	puts "    to $hpcm_directory/contestant/bin"
    }
    if { ! [file exists $c_d/bin] } {
        TODO "./contest/bin does not exist." \
	     "Link ./contest/bin to\
	      ..../hpcm/contestant/bin"
    } elseif { ! [file isdirectory $c_d/bin] } {
        TODO "./contest/bin is not a directory." \
	     "Link it to ..../hpcm/contestant/bin"
    } elseif { ! [regexp {r.x} [get_access $c_d/bin]] \
    			} {
        TODO "./contest/bin is not a+rx." \
	     "Run `make' in ~/hpcm"
    }
}

# Make $c_d/home directory.
#
if { $home_option } {
    if { [catch { file type $c_d/home }] } {
        if {    [info exists hpcm_prototype_account] \
	     && $hpcm_prototype_account != "" } {
	    set phd [account_home_directory \
	               $hpcm_prototype_account]
	} else {
	    set hds {}

	    # Warning, you must put - first in [-_], as
	    # if you use *[_-]proto it accepts all names
	    # whose last character is from _ through ]
	    # or is p, r, o, t, or o.
	    #
	    foreach hd [account_home_directories \
	    		    {*[-_]proto}] {
		if {    [file readable $hd/home] \
		     && [file executable $hd/home] \
		     && [file readable \
		              $hd/home/empty.ls] \
		     && [file readable \
		              $hd/home/setup.ls] \
		     && [file readable \
		              $hd/home/setup.tar] } {
		    lappend hds $hd
		}
	    }
	    set phd ""
	    if { [llength $hds] == 1 } {
	        set phd [lindex $hds 0]
	    } elseif { [llength $hds] == 0 } {
	        set phd_error \
		    "No suitable *\[_-\]proto account\
		     found."
	    } else {
	        set phd_error \
		    "Too many prototype accounts found:\
		     $hds."
	    }
	}
	if { $phd != "" } {
	    link_file $phd/home $c_d/home
	    puts "Linked ./contest/home"
	    puts "    to $phd/home"
	    set phd_error \
		"./contest/home is improper link."
	}
    } else {
        set phd_error \
	    "./contest/home is improper link."
    }

    if {    ! [file readable $c_d/home] \
         || ! [file executable $c_d/home] \
         || ! [file readable $c_d/home/empty.ls] \
         || ! [file readable $c_d/home/setup.ls] \
         || ! [file readable $c_d/home/setup.tar] } {
	TODO "$phd_error" \
	     "Be sure an appropriate\
	      prototype account exists:" \
	     "See `SETUP_PROTOTYPE -doc'" \
	     "Then symbolically link ./contest/home" \
	     "to ~prototype_account/home," \
	     "and rerun `makecontest -home'."
    }
    if { [file exists $c_d/home] \
         && ! [regexp {r.x} [get_access $c_d/home]] } {
    	TODO "While logged into prototype account," \
	     "chmod a+rx target-of-./contest/home"
    }
}

# Array specifying option substitutions.  For each
# op1 to be substituted for, the value of
#
#	option_array(op1)
#
# is the list of options that is the substitution.

# Expand a list of options and return the result.
#
proc expand_options { option_list } {

    global option_array

    set result ""
    foreach option $option_list {
        if { [info exists option_array($option)] } {
	    set result \
	        [concat $result \
			$option_array($option)]
	} else {
	    lappend result $option
	}
    }

    if { [info exists option_array(ALL)] } {
	set result \
	    [concat $result $option_array(ALL)]
	}

    return $result
}

# List of substitutions to be made in the names of the
# current input index file.  Each item of the list has
# the form `{source target}' which specifies that if a
# name begins with the string `source' that string
# should be replaced by the string `target'.
#
set substitutions ""

# Make the longest substitution possible in the
# name argument and return the result (or if
# there are no substitutions return the name
# argument).  If there is a length tie, apply
# the first substitution.
#
proc make_substitutions { name } {

    global substitutions

    set result $name
    set best_end -2

    foreach substitution $substitutions {
        set source [lindex $substitution 0]
	set end [string length $source]
	incr end -1

	if { [string range $name 0 $end] == $source \
	     && $best_end < $end } {
	    set target [lindex $substitution 1]
	    set best_end $end
	    incr end
	    set result [string range $name $end end]
	    set result $target$result
	}
    }

    return $result
}


# Process index specification using global variables
# as parameters:
#
#   index_file		the input index file name
#   index_directory	index directory name
#   help_index_chs	output help/index file channel
#			list; "" if none;  If there is
#			a help/index file, there may
#			in fact be two (one in ./info
#			and one in ./contest), so all
#			its lines must be written into
#			up to two channels, that are
#			listed here.
#   demos_index_chs	Ditto for help/demos file.
#   problems_index_chs	Ditto for help/problems file.
#   option_array	option substitutions
#			(see above)
#   substitutions	filename substitutions
#			(see above)
#   info_option		options
#   solutions_option
#   problems_option
#   demos_option
#   help_option
#   j_d			directory names
#   c_d

# Helper function called when ${targetdir}index_ch is ""
# to compute and return the correct value of this
# variable.
#
proc get_index_chs { targetdir } {

    global info_option help_option j_d c_d \
           help_index_chs problems_index_chs \
	   demos_index_chs \

    set chs ""
    if { $info_option || $help_option } {
	switch $targetdir {
	help		{ set file index
			  set head "Help Index" }
	problems	{ set file problems
			  set head "Problems Index" }
	demos		{ set file demos
			  set head "Demos Index" }
	}
	if { $info_option } {
	    lappend chs \
	    	    [open $j_d/info+/help/$file w]
	}
	if { $help_option } {
	    lappend chs [open $c_d/help+/$file w]
	}

	set ${targetdir}_index_chs $chs

	foreach ch $chs {
	    puts $ch [format {%-28s%28s} $head \
	    		     [clock format \
			     	    [clock seconds]]]
	    puts $ch ""
	    puts $ch ""
	}
    }
    return $chs
}

# Main function to process an index specification.
#
# Subfunction to read problem.rc file.
#
proc read_rc_file { file problem options } {
    global PROBLEM EXTENSION OPTIONS \
           problem_source_files \
           problem_solution_files \
	   problem_description_files \
	   problem_excluded_files \
	   problem_print_files
    set PROBLEM $problem
    set EXTENSION UNDEFINED
    set OPTIONS $options
    source_file $file
}
# Subfunction that returns true if item matches any
# regexp in a list of regexps.
#
proc index_match { item regexps } {
    foreach regexp $regexps {
        if { [regexp "^($regexp)\$" $item] } {
	    return 1
	}
    }
    return 0
}
#
# Subfunction to compute {description,source,solution}_
# files.  Directory and subdirectory names end in / or
# are empty.
#
proc index_find \
	{ dir subdir description_files_name \
	             source_files_name \
		     solution_files_name } {

    global problem_description_files \
    	   problem_source_files \
    	   problem_solution_files \
    	   problem_excluded_files

    upvar $description_files_name description_files
    upvar $source_files_name source_files
    upvar $solution_files_name solution_files

    foreach name [glob -directory $dir$subdir \
	               -nocomplain -- *] {

	set name [file tail $name]
	if { [index_match $name \
	                  $problem_excluded_files] } \
	    continue
	    
        if { [file isdirectory $dir$subdir$name] } {
	    index_find $dir $subdir$name/ \
	    		       description_files \
			       source_files \
			       solution_files
	} elseif { [file exists $dir$subdir$name] } {
	    if { [index_match \
	              $name \
		      $problem_description_files] } {
	        lappend description_files $subdir$name
	    } elseif { [index_match \
			    $name \
			    $problem_source_files] \
		     } {
	        lappend source_files $subdir$name
	    }
	    if { [index_match \
	              $name \
		      $problem_solution_files] } {
	        lappend solution_files $subdir$name
	    }
	}
    }
}
#
# Subfunction to grant access to a file and the
# subdirectories of a directory that contain it.
#
proc index_grant { dir file } {
    while { $file != "" && $file != "." } {
        grant_access $dir/$file
	set file [file dirname $file]
    }
}
#
# Subfunction to copy list of files from a source
# directory to a target directory, making target
# subdirectories as necessary.  If link is true,
# link instead of copy.  If copying, use index_
# grant to grant access to copy.
#
proc index_copy { source dest files link } {
    foreach file $files {
	file mkdir [file dirname $dest/$file]
	if { $link } {
	    link_file $source/$file $dest/$file
	} else {
	    copy_file $source/$file $dest/$file
	    index_grant $dest $file
	}
    }
}
#
proc process_index_specification {} {

    global index_file index_directory \
           help_index_chs problems_index_chs \
	   demos_index_chs \
	   help_print_files problems_print_files \
	   demos_print_files problems_solution_files \
           info_option solutions_option \
	   problems_option demos_option \
	   help_option description_option \
           j_d c_d \
	   problem_description_files \
	   problem_source_files \
	   problem_solution_files \
	   problem_excluded_files \
	   problem_print_files

    # Save hpcm_judging.rc defined values of global
    # variables reset by PROBLEM.rc file.
    #
    set default_description_files \
        $problem_description_files
    set default_source_files \
        $problem_source_files
    set default_solution_files \
        $problem_solution_files
    set default_excluded_files \
        $problem_excluded_files

    # Be sure index directory is absolute name, else
    # symbolic links will fail.
    #
    if { ! [regexp {^/} $index_directory] } {
	set index_directory [pwd]/$index_directory
    }
    set index_directory \
        [truename $index_directory]

    # Read the input index file and process its entries.
    #
    set index_ch [open $index_file r]

    # Are we in header, in item, or neither (in a
    # skipped item or at beginning of file).
    #
    set in_header		no
    set in_item			no

    # The xxxx_index_chs value for a current index
    # item.
    #
    set index_chs		""

    # Last header entry encountered, and switches to
    # tell if it has been used in various indices.
    #
    set header_entry		""
    set help_header_used	no
    set demos_header_used	no
    set problems_header_used	no

    # Switches to tell if any items have been written
    # into the various indices.
    #
    set help_index_written	no
    set demos_index_written	no
    set problems_index_written	no

    while { "yes" } {

        # Read next input index line.
	#
	set line [gets $index_ch]
        if { [eof $index_ch] } break;

	# Skip comments.
	#
	if { [regexp {^#} $line] } continue;

	if {    ! [catch { set len [llength $line] }] \
	     && $len >= 1 \
	     && [lindex $line 0] == "***" } {

	    # Beginning of item entry.

	    set in_header	no

	    set name [lindex $line 1]
	    set options \
	        [expand_options [lrange $line 1 end]]
	    set source $index_directory/$name

	    # Check name for legality.
	    #
	    if { [regexp {(^|/)(\.|-)} $name] } {
	    	error "Illegal item name `$name' in\
		       `$index_file'."
	    }

	    # Compute `indent', the part of the first
	    # item entry line before the item name,
	    # with `***' replaced by three spaces.
	    #
	    set ws "\[\ \t\]*"
	    regexp "^($ws\\*\\*\\*$ws)(\[^\ \t\]|\$)" \
		   $line forget indent forget2
	    regsub {\*\*\*} $indent {   } indent

	    if { ! [lcontain $options include] } {

		# Item is not included.

	    	set in_item	no

	    } else {

	    	# Item is included.

		set in_item	yes

		set target [make_substitutions $name]

		# Check target for legality.
		#
		if { [regexp {(^|/)(\.|-)} $target] } {
		    error "Illegal item name `$name'\
		           after substitutions,\n\
			   \    in `$index_file'."
		}

		# Compute and check targetdir and
		# targettail such that $target ==
		# $targetdir/+$targettail and $targetdir
		# is the first component of the name
		# $target, and has no /'s.
		#
		# Targetdir must == `help', `demos', or
		# `problems'.
		#
		if { ! [regexp {^([^/]*)/+([^/].*)$} \
		               $target forget \
			       targetdir targettail] \
		     || ! [lcontain \
			     {help demos problems} \
			     $targetdir] } {
		    error "Bad item name directory\
		    	   after substitution: $target"
		}

	        # Compute output index channels associ-
		# ated with targetdir.
		#
	        set index_chs \
		    [set ${targetdir}_index_chs]

		if { $index_chs == "" } {
		    set index_chs \
		    	[get_index_chs $targetdir]
		}

		# Write headers to output indices if
		# appropriate.
		#
		if { [set ${targetdir}_header_used] \
		     == "no" } {
		    set ${targetdir}_header_used yes
		    if { $header_entry != "" } {
		        foreach ch $index_chs {
			    puts $ch $header_entry
			}
		    }
		}

		# Write first line of item entry, after
		# editing, to output indices, if appro-
		# priate.
		#
		foreach ch $index_chs {
		    puts $ch "$indent$target"
		}

		set ${targetdir}_index_written yes

		# Compute source, description, and solu-
		# tion files if $source is a directory.
		#
		if { [file isdirectory $source] } {

		    # Compute needed global variables.
		    #
		    set problem_description_files \
		        $default_description_files
		    set problem_source_files \
		        $default_source_files
		    set problem_solution_files \
		        $default_solution_files
		    set problem_excluded_files \
		        $default_excluded_files
		    catch { unset problem_print_files }
		    set PROBLEM [file tail $source]
		    read_rc_file \
		        $source/$PROBLEM.rc \
			$PROBLEM $options
		    if { [lcontain $options all] } {
		        set problem_source_files {.*}
		        set problem_description_files {}
		    }
		    set source_files {}
		    set description_files {}
		    set solution_files {}
		    index_find $source/ "" \
		        description_files source_files \
			solution_files
		    if { [info exists \
			       problem_print_files] } {
		        set print_files \
			    $problem_print_files
		    } else {
		        set print_files \
			    [lsort $description_files]
		    }
		}

		# Process info option.
		#
		if { $info_option } {

		    set destination \
		    	$j_d/info+/$target

		    if { [file isfile $source] } {
			file mkdir \
			     [file dirname $destination]
			link_file $source $destination
		    } elseif { [file isdirectory \
		    		     $source] } {
			file mkdir $destination
			index_copy \
			    $source $destination \
			    [concat \
			       $source_files \
			       $description_files] \
			    1
		    } else {
		        error "Source `$source' is\
			       neither a file nor a\
			       directory."
		    }
		}

		# Process $targetdir option.
		#
		if { [set ${targetdir}_option] } {

		    set destination "$c_d/$targetdir+"
		    set destination \
		        "$destination/$targettail"
		    if { [file isfile $source] } {
			file mkdir \
			     [file dirname $destination]
			copy_file $source $destination
			index_grant $c_d/$targetdir+ \
				    $targettail
		    } elseif { [file isdirectory \
		    		     $source] } {
			file mkdir $destination
			index_grant $c_d/$targetdir+ \
				    $targettail
			
			set files $source_files
			if { $description_option } {
			    eval lappend files \
			         $description_files
			}
			index_copy \
			    $source $destination \
			    $files 0
		    } else {
		        error "Source `$source' is\
			       neither a file nor a\
			       directory."
		    }
		}

		# Process solutions option.
		#
		if {    $solutions_option \
		     && [lcontain {problems demos} \
				  $targetdir] \
		     && ! [lcontain $options \
				    nosolution] } {
		    if { ! [file isdirectory $source] \
		    		} {
			error "$source solution is not\
			       a directory"
		    } elseif { [regexp {/} \
		    		       $targettail] } {
			error "`$targettail' is to be\
			       linked into the\
			       solutions directory but\
			       contains a `/'"
		    }
		    set s_d $j_d/solutions+
		    link_file $source $s_d/$targettail
		}

		# Add to print file lists.
		#
		if { $solutions_option } {
		    set s $j_d/solutions+/$targettail
		} else {
		    set s $j_d/solutions/$targettail
		}
		if { $info_option } {
		    set i $j_d/info+/$target
		} else {
		    set i $j_d/info/$target
		}
		if { [set ${targetdir}_option] } {
		    set t $j_d/contest
		    set t $t/$targetdir+/$targettail
		} else {
		    set t $j_d/contest/$target
		}
		if {    [lcontain {problems demos} \
				  $targetdir] \
		     && [file exists $s] } {
		    set print_target \
		    	solutions/$targettail
		} elseif { [file exists $i] } {
		    set print_target info/$target
		} elseif { [file exists $t] } {
		    set print_target contest/$target
		} else {
		    set print_target UNKNOWN/$target
		}
		if { [file isdirectory $source] } {
		    foreach f $print_files {
			lappend \
			    ${targetdir}_print_files \
			    $print_target/$f
		    }
		} else {
		    lappend ${targetdir}_print_files \
			    $print_target
		}

		# Add to problems solution file list.
		#
		if {    [file isdirectory $source] \
		     && $targetdir == "problems" } {
		    foreach f $solution_files {
			lappend \
			    problems_solution_files \
			    solutions/$targettail/$f
		    }
		}
	    }

	} elseif { $in_header } {

	    # Line inside header.

	    set header_entry "$header_entry\n$line"

	} elseif { [regexp "^\[^\ \t\]" $line] } {

	    # Beginning of header entry.

	    set header_entry		$line
	    set in_header		yes
	    set in_item			no
	    set help_header_used	no
	    set demos_header_used	no
	    set problems_header_used	no

	} elseif { $in_item } {

	    # Line inside included item.

	    foreach ch $index_chs {
		puts $ch $line
	    }
	}
    }

    # If we copied any index entries, put out 2 blank
    # lines to separate this input index file's entries
    # from those of the next input index file.
    #
    foreach dir {help problems demos} {
        if { [set ${dir}_index_written] } {
	    foreach ch [set ${dir}_index_chs] {
	    	puts $ch ""
	    	puts $ch ""
	    }
	}
    }

    close $index_ch

    # Restore hpcm_judging.rc defined values of global
    # variables reset by PROBLEM.rc file.
    #
    set problem_source_files \
        $default_source_files
    set problem_solution_files \
        $default_solution_files
    set problem_description_files \
        $default_description_files
    set problem_excluded_files \
        $default_excluded_files
}

# Set up info+, solutions+, problems+, demos+, and
# help+ directories.
#
if { $info_option } {
    if { [file exists $j_d/info+] } {
        puts "Deleting ./info+"
	file delete -force -- $j_d/info+
    }
    file mkdir $j_d/info+
    file mkdir $j_d/info+/help
}
foreach dir {problems demos help} {
    if { [set ${dir}_option] } {
	if { [file exists $c_d/$dir+] } {
	    puts "Deleting out-of-date ./contest/$dir+"
	    file delete -force -- $c_d/$dir+
	}
	file mkdir $c_d/$dir+
	if { $dir != "problems" } {
	    grant_access $c_d/$dir+
	}
    }
}
if { $solutions_option } {
    if { [file exists $j_d/solutions+] } {
        puts "Deleting ./solutions+"
	file delete -force -- $j_d/solutions+
    }
    file mkdir $j_d/solutions+
}

# Process -this_contest.
#
if { $this_contest_option } {
    set TODO_lines {}

    # Make help directory.
    #
    if { ! [file isdirectory $j_d/help] } {
	file mkdir $j_d/help
	puts "Made ./help"
    }

    # Make help/index file.
    #
    if { ! [file readable $j_d/help/index] } {
	write_file $j_d/help/index [string trim "
To display the file listed as `help/topic' below use the
command:
		      help topic

E.g., `help index' displays this file.


Indices:
--------

    help/index
	This file.

    help/demos
	Index of contest demonstration problems.

    help/problems
	Index of contest problems.



Introductory Information:
-------------------------


*** this_contest include
	Information about this contest.
"]
        lappend TODO_lines "  ./help/index"
	puts "Wrote ./help/index"
    }

    # Compute header for help/this_contest* files.
    #
    set header \
        [format "%-28s%28s\n\n" \
		"About This Contest" \
		[clock format [clock seconds]]]

    # Compute content for help/this_contest* files.
    #
    set content [string trim $this_contest]

    # Make help/this_contest_original file.
    #
    if { ! [file readable \
      	         $j_d/help/this_contest_original] } {
	write_file $j_d/help/this_contest_original \
		   "$header$content"
        lappend TODO_lines \
	        "  ./help/this_contest_original"
	puts "Wrote ./help/this_contest_original"
    }

    # Save help/this_contest_parameter file.
    #
    set tcpexists \
        [file readable $j_d/help/this_contest_parameter]
    if { $tcpexists } {
        set tcpcontent \
	    [read_entire_file \
	         $j_d/help/this_contest_parameter]
	regexp {^About This Contest[^\n]*\n\n(.*)$} \
	       $tcpcontent forget tcpcontent
    }

    # Make help/this_contest_parameter file.
    #
    if {    ! $tcpexists \
	 || $content != $tcpcontent } {
	write_file $j_d/help/this_contest_parameter \
		   "$header$content"
        lappend TODO_lines \
	        "  ./help/this_contest_parameter"
	puts "Wrote ./help/this_contest_parameter"
    }

    # Save help/this_contest file.
    #
    set tcexists \
        [file readable $j_d/help/this_contest]
    if { $tcexists } {
        set tccontent \
	    [read_entire_file $j_d/help/this_contest]
	regexp {^About This Contest[^\n]*\n\n(.*)$} \
	       $tccontent forget tccontent
    }

    # Make help/this_contest file.
    #
    if {    ! $tcexists
	 || (    $tcpexists \
	      && $tcpcontent == $tccontent \
	      && $content != $tccontent ) } {
	write_file $j_d/help/this_contest \
		   "$header$content"
        lappend TODO_lines "  ./help/this_contest"
	eval TODO Made $TODO_lines \
	     {"You may want to edit\
	       ./help/this_contest" \
	      "and rerun `makecontest -help'"}
	puts "Wrote ./help/this_contest"
    }
}

# Set up print file lists.
#
set help_print_files ""
set problems_print_files ""
set demos_print_files ""
set problems_solution_files ""

# Set up channel lists.
#
set help_index_chs	""
set demos_index_chs	""
set problems_index_chs	""

# Process arguments, forming index specifications
# encoded in global variables, and call process_index_
# specification (see above) for each specification.
#
set mode file
#
# Mode indicates what next argument should be: file,
# directory, or substitution.
#
foreach arg [lrange $argv $argi end] {

    # Process next argument.  Whether argument ends in
    # `,' or `:' tells mode of next argument.
    #
    if { $mode == "file" } {
    	if { [regexp {^(.*):$} $arg forget arg] } {
	    set mode directory
    	} else {
	    if { [regexp {^(.*),$} $arg forget arg] } {
		set mode substitution
	    }
	    set index_directory [file dirname $arg]
	}
	set index_file $arg
	set substitutions ""
	if { [array exists option_array] } {
	    unset option_array
	}
    } elseif { $mode == "directory" } {
    	if { [regexp {^(.*),$} $arg forget arg] } {
	    set mode substitution
	} else {
	    set mode file
	}
	set index_directory $arg
    } elseif { $mode == "substitution" } {
    	if { ! [regexp {^(.*),$} $arg forget arg] } {
	    set mode file
	}
	if { [regexp {^([^=]*)=([^=]*)$} $arg forget \
	               source destination] } {
	    lappend substitutions \
		    [list $source $destination]
	} elseif { [regexp {^([^:]*):([^:]*)$} \
	                   $arg forget \
	               source destination] } {
	    set option_array($source) \
	        [string trim $destination]
	} else {
	    error "Badly formatted substitution:\
	           `$arg'"
	}
    }

    if { $mode == "file" } {
    	process_index_specification
    }
}
if { $mode != "file" } {
    error "Last argument ends with `,' or `:'"
}

# Finish up index output files.
#
foreach dir {problems help demos} {
    foreach ch [set ${dir}_index_chs] {
        close $ch
    }
}
if { [file exists $c_d/help+/index] } {
    grant_access $c_d/help+/index
}
if { [file exists $c_d/help+/demos] } {
    grant_access $c_d/help+/demos
}

# Diff two directories.  If the only differences are the
# first lines of help indices, return `no'.  Else return
# `yes'.  Returning `yes' when one should have returned
# `no' introduces a lack of optimization, but no func-
# tional error.
#
proc diff_dirs { dir1 dir2 } {
    catch { diff_directories $dir1 $dir2 } out
    set out [split $out "\n"]

    while { [llength $out] > 0 } {
	set diffexp \
	  {^diff -r .*/([^/ ]*) .*/([^/ ]*)$}
	if { [regexp $diffexp [lindex $out 0] \
	             forget index1 index2] \
	     && $index1 == $index2 \
	     && [lcontain {demos problems index} \
			  $index1] } {
	    if { [lindex $out 1] != "1c1" } {
	    	return yes
	    } elseif { ! [regexp {^< [^ ]* Index} \
				  [lindex $out 2]] } {
	    	return yes
	    } elseif { [lindex $out 3] != "---" } {
	    	return yes
	    } elseif { ! [regexp {^> [^ ]* Index} \
				  [lindex $out 4]] } {
	    	return yes
	    }
	    set out [lrange $out 5 end]
	} elseif { [lindex $out 0] == \
		   "child process exited abnormally" } {
	    set out [lrange $out 1 end]
	} else {
	    return yes
	}
    }

    return no
}

# Rename directories iff $directory+ differs from
# $directory as determined by `diff_dirs'.  If a
# directory is not renamed, delete it.  Return `yes' if
# directory renamed, and `no' if deleted.
#
proc rename_directory { directory } {

    global j_d
    set dname $directory
    set len [string length $j_d]
    incr len
    if { [string compare -length $len \
                 $j_d/ $directory] } {
        set dname ./[string range $directory $len end]
    }

    if { [diff_dirs $directory $directory+] \
         == "no" } {
	file delete -force -- $directory+
	return no
    } else {

	if { [file exists $directory--] } {
	    file delete -force -- $directory--
	}
	if { [file exists $directory-] } {
	    puts "Renaming $dname-"
	    puts "      to $dname--"
	    file rename $directory- $directory--
	    deny_access $directory--
	}
	if { [file exists $directory] } {
	    puts "Renaming $dname"
	    puts "      to $dname-"
	    file rename $directory $directory-
	    deny_access $directory-
	}
	if { [file exists $directory+] } {
	    puts "Renaming $dname+"
	    puts "      to $dname"
	    file rename $directory+ $directory
	}
	return yes
    }
}

if { $info_option } {
    rename_directory $j_d/info
}
if { $problems_option } {
    if { [regexp {r.x} [get_access $c_d/problems]] } {
    	grant_access $c_d/problems+
    }
    rename_directory $c_d/problems
}
if { $help_option } {
    if { [regexp {r..} \
    		 [get_access $c_d/help/problems]] } {
    	grant_access $c_d/help+/problems
    }
    rename_directory $c_d/help
}
if { $demos_option } {
    rename_directory $c_d/demos
}
if { $solutions_option } {
    rename_directory $j_d/solutions
}

# Output print files if necessary
#
if { $print_files_option } {
    if { [file isdirectory $j_d/info/help] } {
	set target info/help
    } elseif { [file isdirectory $j_d/contest/help] } {
	set target contest/help
    } else {
	set target UNKNOWN/help
    }
    foreach dir {problems demos help} {
	if { $dir == "help" } {
	    set output $target/index

	    # Move this_contest to front of help list.
	    #
	    set i [lsearch -regexp $help_print_files \
	    			   {/this_contest$}]
	    if { $i >= 0 } {
		set tc [lindex $help_print_files $i]
	        set output "$tc\n$output"
		set help_print_files \
		    [lreplace $help_print_files $i $i]
	    }
	} else {
	    set output $target/$dir
	}
	foreach f [set ${dir}_print_files] {
	    set output "$output\n$f"
	}
	set f $j_d/${dir}_print_files
	if {    ! [file readable $f] \
	     || [read_entire_file $f] != $output } {
	    file delete -force -- $f--
	    if { [file exists $f-] } {
		puts "Renaming ./${dir}_print_files-"
		puts "      to ./${dir}_print_files--"
		file rename $f- $f--
	    }
	    if { [file exists $f] } {
		puts "Renaming ./${dir}_print_files"
		puts "      to ./${dir}_print_files-"
		file rename $f $f-
	    }
	    write_file $f $output
	    puts "Wrote ./${dir}_print_files"
	}
    }
}

# Output solution files if necessary
#
if { $solution_files_option } {
    set output ""
    foreach f $problems_solution_files {
        set output "$output\n$f"
    }
    set output [string range $output 1 end]
    set f $j_d/solution_files
    if {    ! [file readable $f] \
	 || [read_entire_file $f] != $output } {
	file delete -force -- $f--
	if { [file exists $f-] } {
	    puts "Renaming ./solution_files-"
	    puts "      to ./solution_files--"
	    file rename $f- $f--
	}
	if { [file exists $f] } {
	    puts "Renaming ./solution_files"
	    puts "      to ./solution_files-"
	    file rename $f $f-
	}
	write_file $f $output
	puts "Wrote ./solution_files"
    }
}

# Make mail directory.
#
if { $mail_option \
      && ! [file isdirectory $j_d/mail] } {
    file mkdir $j_d/mail
    puts "Made ./mail"
    grant_access $j_d/mail x
    grant_access $j_d x
    grant_access $j_d/.. x
    puts "Granting a+x access"
    puts "         to $j_d"
    puts "         and its parent"
}

# Make $c_d/help2 directory.
#
if { $help2_option \
     && ! [file isdirectory $c_d/help2] } {
    if { ! [catch {
	      set help2_type \
		  [file type $c_d/help2] }] } {
	if { $help2_type == "link" } {
	    puts "Deleting ./contest/help2"
	    file delete -force -- $c_d/help2
	} else {
	    error "./contest/help2 exists but is not a\
	           directory"
	}
    }
    link_file help $c_d/help2
    puts "Linked ./contest/help2"
    puts "    to ./contest/help"
}

# Make secure directory.
#
if { $secure_option \
     && ! [file isdirectory $c_d/secure] } {
    file mkdir $c_d/secure
    deny_access $c_d/secure
    puts "Made directory ./contest/secure"
}

# Make or edit secure/passwords file.
#
if { $secure_option } {
    if { ! [file readable $c_d/secure/passwords] } {
	set apw account:password:who
    	set ctc coaches-email:team-email:comment
	set ch [open $c_d/secure/passwords w]
	puts $ch "# $apw:$ctc"
	puts $ch ""
	close $ch
	deny_access $c_d/secure/passwords
	puts "Wrote ./contest/secure/passwords"
	TODO "Edit ./contest/secure/passwords;" \
	     "each of its lines has the format:" \
	     "`$apw:$ctc'." \
	     "Then rerun `makecontest'"
    } else {
        set passwords_ch [open $c_d/secure/passwords r]
	set lines ""
	set changed no
	set account_exists no
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    if {    ! [regexp {^[ \t]*(#|$)} $line] \
	         && [regexp {^([^:]+)(|:|::.*)$} $line \
			    forget account forget2] } {
		set password [make_password]
		set rest ""
		regexp {^[^:]+:(:.*)$} $line \
		       forget rest
	        set line "$account:$password$rest"
		set changed yes
		if { [account_home_directory \
		          $account] != "" } {
		    set account_exists yes
		}
	    }
	    lappend lines $line
	}
	close $passwords_ch
	if { $changed} {
	    set passwords_ch \
	        [open $c_d/secure/passwords w]
	    foreach line $lines {
	        puts $passwords_ch $line
	    }
	    close $passwords_ch
	    puts "Wrote ./contest/secure/passwords"

	    if { $account_exists } {
		set tc_d [truename $c_d]
		set ts_d [truename $hpcm_directory]
		set ts_d "$ts_d/secure/bin"
		TODO "Passwords have been added to" \
		      $c_d/secure/passwords." \
		     "You should inspect this file and\
		      then execute:" \
		     "" \
		     "    su root" \
		     "    $ts_d/hpcm_set_passwords \\" \
		     "        $tc_d" \
		     "    exit" \
		     "" \
		     "to reset the passwords for all\
		      accounts."
	    }
	}
    }
}

# Make secure/hpcm_sendmail.rc file.
#
if { $secure_option \
     && ! [file readable \
     		$c_d/secure/hpcm_sendmail.rc] } {
    set rc_ch [open $c_d/secure/hpcm_sendmail.rc w]
    if { [llength $autojudge_addresses] > 0 } {
        set to [lindex $autojudge_addresses 0]
    } else {
	set to \
	  "[make_password]<[account_name]@[host_name]>"
    }
    puts $rc_ch "To: $to"
    set key [make_password]
    puts $rc_ch "Key: $key"
    set key_name [file tail $j_d_relative]
    regexp {^(.*)(-|_)[^-_]*$} $key_name \
	   forget key_name forget2
    puts $rc_ch "Key-Name: $key_name"
    close $rc_ch
    deny_access $c_d/secure/hpcm_sendmail.rc
    puts "Wrote ./contest/secure/hpcm_sendmail.rc"


    # Check contest/bin/hpcm_sendmail mode.
    #
    if {    [file exists $c_d/bin/hpcm_sendmail] \
	 && ! [regexp {..s} \
	              [get_access \
		           $c_d/bin/hpcm_sendmail]] } {
	TODO "chmod u+s,a+x ./contest/bin/hpcm_sendmail"
    }
}

# Check secure directory and file modes minimally.
#
if { $secure_option } {
    if {    [file exists $c_d/secure] \
         && ! [regexp -- {---} \
	              [get_access $c_d/secure]] } {
        TODO "chmod o-rwx ./contest/secure"
    }
    if {    [file exists $c_d/secure/hpcm_sendmail.rc] \
         && ! [regexp -- {---} \
	              [get_access \
		        $c_d/secure/hpcm_sendmail.rc]] \
					} {
        TODO "chmod o-rwx\
	      ./contest/secure/hpcm_sendmail.rc"
    }
    if {    [file exists $c_d/secure/passwords] \
         && ! [regexp -- {---} \
	              [get_access \
		           $c_d/secure/passwords]] } {
        TODO "chmod o-rwx ./contest/secure/passwords"
    }
}

# Make ./contest/extra_setup.tar
#
if {    $ssh_option \
     && ! [file readable $c_d/extra_setup.tar] } {
    set keys ""
    foreach f { identity.pub id_rsa.pub id_dsa.pub } {
	set f $env(HOME)/.ssh/$f
        if { [file readable $f] } {
	    set keys "$keys\n[read_entire_file $f]"
	}
    }
    set keys [string range $keys 1 end]
    if { $keys != "" } {
        file delete -force -- $j_d/.ssh
        file mkdir $j_d/.ssh
	deny_access $j_d/.ssh
	write_file $j_d/.ssh/authorized_keys $keys
	deny_access $j_d/.ssh/authorized_keys
	set wd [pwd]
	cd $j_d
	exec tar cf ./contest/extra_setup.tar .ssh
	cd $wd
	grant_access $c_d/extra_setup.tar
	puts "Wrote ./contest/extra_setup.tar"
    } else {
        TODO "Cannot make ./contest/extra_setup.tar" \
	     "    because none of the files\
	      ~/.ssh/identity.pub, ~/.ssh/id_rsa.pub" \
	     "    or ~/.ssh/id_dsa.pub exist." \
	     "Run ssh-keygen and then `makecontest\
	      -ssh'."
    }
}

# Update ~/.procmailrc
#
if { $procmailrc_option } {
    set addresses $autojudge_addresses
    set to [lindex [read_sendmail_rc] 0]
    if { $to != "" } {
    	lappend addresses $to
    }
    if { [llength $addresses] == 0 } {
        TODO "There are no autojudge addresses" \
	     "Set the autojudge_addresses variable" \
	     "and run `makecontest -procmailrc'"
    }
    set passwords {}
    foreach to $addresses {
	set password ""
	regexp {^([^<]*)<} $to forget password
	set password [string trim $password]
	if { $password == "" } {
	    error \
	      "Cannot find autojudge password in\
	       address `$to'\nthat is\
	       in ./contest/secure/hpcm_sendmail.rc\
	       or autojudge_addresses"
	}
	if { ! [lcontain $passwords $password] } {
	    lappend passwords $password
	}
    }

    set add_mbox yes
    set mbox {(^|[ \t])hpcm_mbox($|[ \t])}
    set password ""
    set to_line ". . ."
    set dis {receivemail[ \t]+([^ \t]+)($|[ \t])}
    set original_passwords $passwords
    if { ! [catch { set ch [open ~/.procmailrc r] }] } {
        while { "yes" } {
	    set line [gets $ch]
	    if { [eof $ch] } break

	    if { [regexp {^[ \t]*#} $line] } {
	    	# comment line
	    } elseif { [regexp {^:} $line] } {
	    	# start of procmailrc entry
	        set password ""
		set to_line ". . ."
	    } elseif { [regexp {To:.*$} $line to] } {
		set password ""
	        regexp {^To:\.\*([^<]*)(<|$)} $to \
		       forget password
		set password [string trim $password]
		set to_line $line
	    } elseif {    [regexp $dis $line \
	                          forget dir] \
		       &&    [string trim $dir] \
		          == $j_d_relative } {
		set i [lsearch -exact \
			       $passwords $password]
		if { $password == "" } {
		    TODO "Bad entry in ~/.procmail" \
		    	 "    $to_line" \
			 "    $line" \
			 "    . . ." \
			 " Remove or fix entry."
		} elseif {   [lsearch \
		                -exact $password \
				$original_passwords] \
			   < 0 } {
		    TODO "Extra entry in ~/.procmail" \
		    	 "    $to_line" \
			 "    $line" \
			 "    . . ." \
			 "Remove entry or add address\
			  to autojudge_addresses\
			  global variable."
		} elseif { $i >= 0 } {
		    set passwords \
		        [lreplace $passwords $i $i]
		}
	    } elseif { [regexp $mbox $line] } {
	        set add_mbox no
	    }
	}
	close $ch
    }

    if { $add_mbox || [llength $passwords] > 0 } {
	set file [read_entire_file ~/.procmailrc]
	if { $add_mbox } {
	    set file ":0 c:\nhpcm_mbox\n\n$file"
	    puts "The following has been prepended\
		  to ~/.procmailrc:"
	    puts "    :0 c:"
	    puts "    hpcm_mbox"
	}
	foreach password $passwords {
	    set file "$file\n\n:0\n*\
		      ^To:.*$password\n|\
		      receivemail $j_d_relative | \\\n \
		      dispatchmail $j_d_relative"
	    puts "The following has been appended\
		  to ~/.procmailrc:"
	    puts "    :0"
	    puts "    * ^To:.*$password"
	    puts "    | receivemail $j_d_relative | \\"
	    puts "      dispatchmail $j_d_relative"
	}
	write_file ~/.procmailrc $file
    }
}

# Make $c_d/who_where
#
if { $who_where_option } {
    if { ! [file readable $c_d/secure/passwords] } {
        error "./contest/secure/passwords does not\
	       exist for -who_where option"
    } elseif { ! [file readable $c_d/who_where] } {
	set who_where_ch [open $c_d/who_where w]
	set passwords_ch [open $c_d/secure/passwords r]
	set empty yes
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    if { [regexp {^[ \t]*(#|$)} $line] } \
	    	continue
	    regexp {^([^:]*):} $line forget account
	    set rest ""
	    regexp {^[^:]*:[^:]*:(.*)$} $line \
	           forget rest
	    if { $account != "none" } {
		puts $who_where_ch \
		     "$account:WHERE:$rest"
		set empty no
	    }
	}
	close $passwords_ch
	close $who_where_ch

	if { $empty } {
	    file delete -force -- $c_d/who_where
	} else {
	    grant_access $c_d/who_where
	    puts "Wrote ./contest/who_where"

	    TODO "Edit ./contest/who_where to specify\
		  location" \
		 "of teams, by replacing `WHERE' for\
		  each" \
		 "account with a SHORT description of\
		  the" \
		 "team's location."
	}
    } elseif { [file mtime $c_d/who_where] \
	       < [file mtime $c_d/secure/passwords] } {

	# Read $c_d/secure/passwords, decomposing the
	# lines into `$account:$password:$rest', saving
	# $rest in $passwords_array($account), and
	# making a list of accounts in the order their
	# lines were encountered in $passwords_accounts
	# 
	set passwords_ch [open $c_d/secure/passwords r]
	set passwords_accounts ""
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    if { [regexp {^[ \t]*(#|$)} $line] } \
	    	continue
	    regexp {^([^:]*)(:|$)} $line \
	           forget account forget2
	    set rest ""
	    regexp {^[^:]*:[^:]*:(.*)$} $line \
	           forget rest

	    if { $account != "none" } {
		set passwords_array($account) $rest
		lappend passwords_accounts $account
	    }
	}
	close $passwords_ch

	# The lines for the new who_where file are
	# put in the list $new_who_where.  $changed
	# is set `yes' if this is a change from the
	# old who_where file, and `no' otherwise.
	#
	set new_who_where ""
	set changed no

	# Read the old who_where file.  Copy the lines
	# into $new_who_where, changing the $rest part
	# to that taken from passwords, and recording
	# any actual changes in $changed.  Delete
	# $passwords_array($account) for any account
	# encountered in the old who_where file.
	#
	set who_where_ch [open $c_d/who_where r]
	while { "yes" } {
	    set line [gets $who_where_ch]
	    if { [eof $who_where_ch] } break

	    regexp {^([^:]*)(:|$)} $line \
	           forget account forget2
	    set where ""
	    regexp {^[^:]*:([^:]*)(:|$)} $line \
	    	   forget where forget2
	    set rest ""
	    regexp {^[^:]*:[^:]*:(.*)$} $line \
	           forget rest
	    if { [info exists \
	               passwords_array($account)] } {
	        set prest \
		    $passwords_array($account)
		if { $prest != $rest } {
		    lappend new_who_where \
		    	    "$account:$where:$prest"
		    set changed yes
		} else {
		    lappend new_who_where $line
		}
		unset passwords_array($account)
	    } else {
	        lappend new_who_where $line
	    }
	}
	close $who_where_ch

	# For the accounts in the order encountered in
	# the $c_d/secure/passwords file, if the account
	# is not in $new_who_where yet, add it.
	#
	foreach account $passwords_accounts {
	    if { [info exists \
	               passwords_array($account)] } {
		set prest $passwords_array($account)
		lappend new_who_where \
		        "$account:WHERE:$prest"
		set changed yes
	    }
	}

        # If $changed is `yes', write $new_who_where.
	#
	if { $changed } {
	    file delete -force -- $c_d/who_where
	    set who_where_ch [open $c_d/who_where w]
	    foreach line $new_who_where {
		puts $who_where_ch $line
	    }
	    close $who_where_ch
	    grant_access $c_d/who_where
	    puts "Wrote ./contest/who_where"

	    TODO "Edit ./contest/who_where to specify\
					location" \
		 "of teams, by replacing `WHERE' for\
		 			each" \
		 "account with a SHORT description of\
		 			the" \
		 "team's location."
	}
    }
}

# Make $c_d/trashable
#
if { $trashable_option || $trashall_option } {
    if { ! [file readable $c_d/secure/passwords] } {
        error "./contest/secure/passwords does not\
	       exist for -trashable or -trashall\
	       options"
    }
    set trashable {}
    set passwords_ch [open $c_d/secure/passwords r]
    while { "yes" } {
	set line [gets $passwords_ch]
	if { [eof $passwords_ch] } break
	if { [regexp {^[ \t]*(#|$)} $line] } \
	    continue
	regexp {^([^:]*)(:|$)} $line \
	       forget account forget2
	if { $account == "" } {
	    error "Empty account name in\
	           ./contest/secure/passwords"
	}
	if {    $account != "none" \
	     && ( $trashall_option \
	          || [account_home_directory \
		          $account] == "" ) } {
	    lappend trashable $account
	}
    }
    close $passwords_ch

    if { [llength $trashable] == 0 } {
	if { [file exists $c_d/trashable] } {
	    puts "Deleted ./contest/trashable"
	    file delete -force $c_d/trashable
	}
    } else {
        if { [file readable $c_d/trashable] } {
	    set old_trashable \
	        [read_entire_file $c_d/trashable]
	    if { [catch { llength $old_trashable }] } {
	        error "./contest/trashable badly\
		       formatted"
	    }
	} else {
	    set old_trashable {}
	}

	if {    [lsort $old_trashable] \
	     != [lsort $trashable] } {
	    file delete -force $c_d/trashable
	    set trashable_ch [open $c_d/trashable w]
	    foreach account $trashable {
	        puts $trashable_ch $account
	    }
	    close $trashable_ch
	    grant_access $c_d/trashable
	    puts "Wrote ./contest/trashable"

	    set tc_d [truename $c_d]
	    set ts_d \
	        "[truename $hpcm_directory]/secure/bin"

	    if { $trashall_option } {
		TODO "./contest/trashable" \
		     "has been re-written to contain\
		      all accounts." \
		     "You should edit it to contain\
		      only the accounts you want to" \
		     "trash, and then you should\
		      execute:" \
		     "" \
		     "    su root" \
		     "    $ts_d/hpcm_TRASH_ACCOUNTS\
		          \\" \
		     "        $tc_d" \
		     "    exit" \
		     "    makecontest -trashable" \
		     "" \
		     "to trash the desired accounts."
	    } else {
		TODO "./contest/trashable" \
		     "has been written with new\
		      contents.  You should execute:" \
		     "" \
		     "    su root" \
		     "    $ts_d/hpcm_setup_accounts\
		          \\" \
		     "        $tc_d" \
		     "    exit" \
		     "    makecontest -trashable" \
		     "" \
		     "to setup new accounts."
	    }
	}
    }
}

# Printer_jobs pseudoswitch
#
set printer_jobs_option no

# Make $c_d/printer
#
if { $printer_option \
     && ! [file exists $c_d/printer] } {

    set printer_jobs_option yes

    if { [info exists printer] } {
        set todo no
    } elseif { [info exists env(PRINTER)] } {
	set printer $env(PRINTER)
        set todo yes
    } else {
	set printer UNKNOWN
        set todo yes
    }

    write_file $c_d/printer $printer
    grant_access $c_d/printer
    puts "Wrote ./contest/printer"

    if { $todo } {
	TODO "Wrote ./contest/printer to be\
	      `$printer';" \
	     "Edit ./contest/printer to change." \
	     "Execute `chmod a-rw ./contest/printer'\
	      to disable." \
	     "You may want to use\
	      ./contest/printer_map" \
	     "instead of ./contest/printer:" \
	     "see `hpcm/contestant/bin/printer_pipe\
	      -doc'."
    }
}

# Make $c_d/printer_map
#
if { $printer_map_option } {
    if { ! [info exists printer_map] } {

        TODO "Set the printer_map global variable" \
	     "in hpcm_judging.rc and run\
	      `makecontest -printer_map'"

    } elseif {    ! [file exists $c_d/printer_map] \
               ||    [read_entire_file \
	       		  $c_d/printer_map] \
	          != $printer_map } {

	set printer_jobs_option yes

	write_file $c_d/printer_map $printer_map
	grant_access $c_d/printer_map
	puts "Wrote ./contest/printer_map"
    }
}

# Make $c_d/printer_jobs
#
if { $printer_jobs_option \
     && ! [file exists $c_d/printer_jobs] } {
    close [open $c_d/printer_jobs w]
    grant_access $c_d/printer_jobs rw
    puts "Wrote ./contest/printer_jobs"
}

# Make $c_d/javahelp
#
if { $javahelp_option } {
    if { ! [info exists javahelp] } {

        TODO "Set the javahelp global variable" \
	     "in hpcm_judging.rc and run\
	      `makecontest -javahelp'"

    } elseif {    ! [file exists $c_d/javahelp] \
               ||    [read_entire_file \
	       		  $c_d/javahelp] \
	          != $javahelp } {
	write_file $c_d/javahelp $javahelp
	grant_access $c_d/javahelp
	puts "Wrote ./contest/javahelp"
    }
}

# Make $c_d/stlhelp
#
if { $stlhelp_option } {
    if { ! [info exists stlhelp] } {

        TODO "Set the stlhelp global variable" \
	     "in hpcm_judging.rc and run\
	      `makecontest -stlhelp'"

    } elseif {    ! [file exists $c_d/stlhelp] \
               ||    [read_entire_file \
	       		  $c_d/stlhelp] \
	          != $stlhelp } {
	write_file $c_d/stlhelp $stlhelp
	grant_access $c_d/stlhelp
	puts "Wrote ./contest/stlhelp"
    }
}

# Call makeweb if necessary.
#
if { $web_option } {
    exec makeweb "{{directory $j_d/web+}}"
    rename_directory $j_d/web
}

# Start contest if necessary.
#
if {    $startcontest_option \
     && [file exists $c_d/problems] \
     && [file exists $c_d/help/problems] \
     && (    ! [regexp {r.x} \
     		       [get_access $c_d/problems]] \
	  || ! [regexp {r..} \
       		       [get_access \
			    $c_d/help/problems]] ) } {

    # Check Startcontest_PID and delete it if its
    # process is no longer running.
    # 
    if { [file exists $j_d/Startcontest_PID] } {
	 set pid [read_file $j_d/Startcontest_PID]
	 set display [display_process_tree $pid]
	 if { ! [process_found $display] } {
	     file delete -force $j_d/Startcontest_PID
	}
    }

    if { ! [file exists $j_d/Startcontest_PID] } {
	puts "Executing: startcontest start"
        exec startcontest start >@ stdout
    }
}

# Execute scoreboard ssh file if desired.
#
if { $scoreboard_ssh_option } {

    set file_list {}
    foreach zzz $scoreboard_ssh {
	if {    ! [file exists $j_d/${zzz}_identity] \
	     || ! [file exists \
			$j_d/${zzz}_identity.pub] } {
	    file delete -force $j_d/${zzz}_identity
	    file delete -force $j_d/${zzz}_identity.pub
	    exec ssh-keygen -t rsa -N "" \
			    -f $j_d/${zzz}_identity
	    puts "Made ./${zzz}_identity"
	    puts "Made ./${zzz}_identity.pub"
	}
	if {    ! [file exists \
			$j_d/${zzz}_authorized_keys] \
	     ||   [file mtime \
			$j_d/${zzz}_identity.pub]
		> [file mtime \
			$j_d/${zzz}_authorized_keys] } {
	    if { [file exists \
		       $j_d/${zzz}_authorized_keys] } {
		file delete -force \
		     $j_d/${zzz}_authorized_keys
		puts "Deleted old\
		      ./${zzz}_authorized_keys"
	    }
	    set pub [read_file $j_d/${zzz}_identity.pub]
	    write_file $j_d/${zzz}_authorized_keys \
		"command=\"head -1000\
		           >public_html/DDDD/$zzz;\
			   chmod 644\
			   public_html/DDDD/$zzz\" $pub"
	    puts "Made ./${zzz}_authorized_keys"
	    lappend file_list ./${zzz}_authorized_keys
	}
    }
    if { [llength $file_list] > 0 } {
	TODO "Append the following files to the\
	      ~/.ssh/authorized_keys files of the" \
	     "accounts to which the scoreboard is to\
	      be sent via ssh, and replace" \
	     "each public_html/DDDD/* in each addition\
	      by the correct file name:" \
	     "" \
	     "    [indent_list 4 $file_list]" \
	     "" \
	     "The file zzz_authorized_keys is to be\
	      used for accounts YYY" \
	     "if `!zzz<YYY>' appears in the\
	      scoreboard_addresses global variable" \
	     "or a similar global variable."
    }
}

# Move scoreboard.1head if necessary.
#
if {    $scoreboard_option \
     && [file exists $j_d/scoreboard.1head] \
     && [file isdirectory $j_d/contest] \
     && ! [file exists $c_d/scoreboard.1head] } {
    file rename -force -- $j_d/scoreboard.1head \
    			  $c_d/scoreboard.1head
    puts "Moved ./scoreboard.1head"
    puts "   to ./contest/scoreboard.1head"
}

# Execute makescoreboard if necessary.
#
if { $scoreboard_option } {

    # Check Scoreboard_PID and delete it if its
    # process is no longer running.
    # 
    if { [file exists $j_d/Scoreboard_PID] } {
	 set pid [read_file $j_d/Scoreboard_PID]
	 set display [display_process_tree $pid]
	 if { ! [process_found $display] } {
	     file delete -force $j_d/Scoreboard_PID
	}
    }

    if { ! [file exists $j_d/Scoreboard_PID] } {
	puts "Executing: makescoreboard start"
        exec makescoreboard start >@ stdout
    }
}

# Finish TODO
#
if { $TODO_ch != "" } {
    close $TODO_ch
    if { $TODO_existed } {
        puts "IMPORTANT: The ./TODO file has both old\
	      and new instructions for you in it."
    } else {
        puts "IMPORTANT: The ./TODO file has\
	      new instructions for you in it."
    }
} elseif { $TODO_existed } {
    puts "IMPORTANT: The ./TODO file has\
	  old instructions for you in it."
    puts "           There a no new instructions."
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
