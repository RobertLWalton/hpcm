#!/bin/sh
#
# Make the subdirectories, symbolic links, and indices
# of a judging directory and its associated contest
# directory.
#
# File:		makejudgingdir
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sat Oct  7 07:56:32 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/10/07 12:19:48 $
#   $RCSfile: makecontest,v $
#   $Revision: 1.19 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_mode none
catch {

set document "
cd judging_directory
makejudgingdir options index_specification ...

  Options:
    -email	Sets up an email contest.  Equals -info,
    		-solutions, and -mail.
    -formal     Sets up a formal contest.  Equals all
    		options but -info, -trashable, and -txt.
    -informal   Sets up an informal contest.  Equals all
    		options but -problems, -demos, -info,
		-trashable, and -txt.  Either the -info
		option, or both the -demos and -problems
		options, should be added.
    -info	Make ./info, ./info/help/index,
    		./info/help/problems, ./info/help/demos.
    -solutions  Make ./solutions
    -problems	Make ./contest/problems.  Includes .txt
    		files for non-`all' directory entries
		only if -txt given.
    -demos	Make ./contest/demos.  Includes .txt
    		files for non-`all' directory entries
		only if -txt given.
    -txt	Include .txt files in ./contest/
		problems or ./contest/demo. 
    -help	Make ./contest/help,
    		     ./contest/help/index,
    		     ./contest/help/problems,
    		     ./contest/help/demos
    -help2	Make ./help2
    -this_contest    Make ./help, ./help/index,
		          ./help/this_contest
    -mail	Make ./mail
    -bin	Make ./contest/bin
    -secure	Make ./contest/secure/passwords,
		     ./contest/secure/hpcm_sendmail.rc
    -who_where  Make ./contest/who_where
    -trashable  Make ./contest/trashable
    -printer    Make ./contest/printer
    -home	Make ./contest/home

  Index Specification:

    index_file\[: index_directory\], name1s=name1t, \\
	  option1s:'option11t option12t ...', \\
	  name2s=name2t, ...

  Pre-Existing Files and Links:

    ./hpcm_judging.rc	 Parameters file.
    ./contest		 Link to contest directory.
    ./contest/contestant Link to hpcm/contestant.
    ./contest/home	 Link to directory owned by
    			 prototype account.

    Given a judging directory as the current directory,
    complete with hpcm_judging.rc file, this program
    makes subdirectories, links, and problem index files
    in the judging directory and optional associated
    contest directory, according to instructions in the
    index specifications and options.  The form of the
    index specifications and options is given above.
    The `./contest' directory, if any, should be symbol-
    ically linked to the actual contest directory before
    this program is run.  If the `./contest' directory
    is needed, the `./contest/contestant' directory
    should be symbolically linked to the `..../hpcm/
    contestant' directory and the `./contest/home'
    directory should be symbolically linked to a direc-
    tory that has been set up by the `SETUP_PROTYTPE'
    program and is owned by the prototype account.

    This program appends instructions for its user to
    edit certain files and run certain programs to the
    ./TODO file, and prints this file at the end of this
    program (unless it is empty).

    The index files are read and used to generate a list
    of items to be included in the ./info and ./contest
    directories.  Each item is a file or directory, and
    corresponds to an item entry in an index file.  The
    item entry has the form:

    	*** item_name item_option ...
	    Text describing the item.

    Items have names which, after optional substitutions
    described below, must begin with `help/', `demos/',
    or `problems/', depending the subdirectory of ./info
    or ./contest into which the item is to be included.
    Only the three subdirectories just mentioned are
    allowed.  The item entry of each included item is
    copied into an output index file, which is the
    `help/index' file if the item name begins with
    `help/', the `help/problems' file if the item name
    begins with `problems/', or the `help/ demos' file
    if the item name begins with `demos/'.

    When an item entry is copied to an output index,
    the `***' in the first line of the entry is replace
    by 3 space characters, the item name is replaced by
    the name after substitutions, and the options are
    removed.

    The input index files also contain header entries
    that precede item entries.  When an item entry is
    copied into an output index, header entries immedi-
    ately preceding it are copied into the same output
    index.  More specifically, a header entry is copied
    if it is separated from the item entry being copied
    only by other item entries that were not included
    in the particular output index being copied to.

    When an item is included in the ./info directory,
    a symbolic link is made to the item if it has the
    item `all' option, or if it is a file.  If it is
    a directory with no `all' option, a new directory
    is created containing a symbolic link to any
    Makefile and any .txt file in the directory.  The
    .txt link is included only if the -txt program
    option is given.

    When an item is included in the ./contest directory,
    files are copied and new directories are made.
    Access is granted using a+r and a+rx directory and
    file modes, except that
    
    		./contest/problems 
    		./contest/help/problems

    are left with og-rx mode.  The `startcontest' prog-
    ram sets the mode of these to a+rx.

    If we consider the directory pairs:

    	./info/demos		./contest/demos
    	./info/problems		./contest/problems
    	./info/help		./contest/help

    then if both directories of a pair are made, both
    are identical after symbolic links are followed.
    In particular, the UNIX `diff -r' command should
    report the directories in a pair to be identical.

    Directory items may also be included in the
    ./solutions directory.  In this directory the item
    name is stripped of any directory prefix; e.g., the
    name `public_demo/count' becomes `count'.  The
    inclusion here is by symbolic link from directory to
    directory: e.g. `./solutions/count' is symbolically
    linked to the `public_demo/count' item directory
    (within the appropriate index directory: see below).

    If this program is building a ./info directory, it
    actually builds a ./info+ directory instead.  Then
    it does a `diff -r ./info ./info+', discarding the
    printed output, to determine if the new directory
    is any different from the previous directory.  If
    it is not different, the ./info+ directory is re-
    moved and nothing else is done.  If the two direc-
    tories are different, the following renaming
    occurs:

    		./info-	    becomes    ./info--
    		./info	    becomes    ./info-
    		./info+	    becomes    ./info

    A similar strategem is followed for ./solutions,
    ./contest/problems, ./contest/demos, and .contest/
    help.

    The item entries and header entries are in input
    index files, each of which is referenced in a sep-
    arate index specification.  The format of an index
    specification is given above: it is a sequence of
    arguments, all but the last of which end in either a
    `:' or a `,'.  The `:' indicates the next argument
    is an index directory name (see below) and the `,'
    indicates the next argument is a substitution (also
    see below).

    Each input index file is associated with an index
    directory.  An unedited version of the index file is
    normally found in its index directory.  Sometimes an
    edited copy of this index file is placed in the
    current judging directory, with the editing consist-
    ing of changes to the item entry options described
    below which control what is included in the new
    info, contest, and solutions directories.  Often,
    however, an edited copy of the index file need not
    be made, because item entry option mapping, describ-
    ed below, is sufficient.

    An index directory may be given in a specification
    by ending the first argument of the specification,
    which names the index input file, with a `:', and
    giving the name of the index directory as the second
    argument in the specification (with an optional end-
    ing `,').  If no index directory is given in an
    index specification, the directory that contains
    the index file is used as the index directory.

    The index file consists of two types of entries:
    header entries and item entries.  Item entries begin
    with a line that starts with `***', followed by
    whitespace, and optionally preceded by whitespace.
    Header entries begin with a line that starts with
    neither whitespace nor `***'.  A header entry stops
    at the next line that begins an item entry, or at
    the end of file.  An item entry stops at the next
    line that begins a header or item entry, or at the
    end of file.

    The first line of an item entry has the form:

    	*** item_name item_option ...

    The item name is the name of the item file or direc-
    tory relative to the index directory (the directory
    normally containing the unedited index file).  The
    possible item options are:

      include	  Include item in the ./info and
      		  ./contest directories, and in the
		  ./solutions directory if the
		  `nosolution' item option is absent
		  and the item name after substitutions
		  begins with `demos/' or `problems/'.
      nosolution  Do NOT include the item in the 
                  ./solutions directory, even if the
		  item name after substitutions begins
		  with `demos/' or `problems/'.
      all	  If the `include' item option is pre-
      		  sent and this item names a directory,
                  include all readable files from this
		  item directory in ./info or ./contest.
		  Otherwise only the Makefile and *.txt
		  file in the item directory will be
		  included, with the *.txt file being
		  included only if the `-txt' program
		  option is given to the `makejudging-
		  dir' program.

    The `include' option is rarely encoded directly in
    the index files.  Instead options categorizing the
    entries are made up by the author of an index file
    and mapped by the index specification to the
    `include' option.  Mapping is done by option substi-
    tution that occurs before the options are finally
    processed.  A substitution of the form:

    	option1s:'option11t option12t ...'

    in the index specification replaces option1s by the
    options in the list `option11t option12t ...'.
    Substitution is NOT recursive: it is done only on
    options appearing in the item entries in the index
    files, and not on options that are the result of
    substitution.  After substitutions are done, unknown
    options are ignored.

    If an item is included in the new ./info directory,
    the item entry is included in an output index within
    the ./info directory.   The indeces are

    	   index		for items named

      ./info/help/index	    ./info/help/...
      ./info/help/demos	    ./info/demos/...
      ./info/help/problems  ./info/problems/...

    There is a similar inclusion for the ./contest
    directory.

    When an item entry is included in an index file, the
    header entry preceding it is included if it is
    separated from the item entry only by item entries
    that were not included in that index file.  Thus a
    header entry is associated with the consecutive item
    entries which follow it, and the header entry is
    included in an index file if and only if any of
    these item entries is included.  The header entry
    may end up being included in several index files if
    the item entries following it are included in
    several different index files.

    The program options -problems and -demos can be used
    by omission to prevent the ./contest/problems and
    ./contest/demos directories from being created, but
    if the -help option is present, the -problems and
    -demos options do not affect the content of the
    ./contest/help/problems and ./contest/help/demos
    index files.  The -info and -help program options
    are be used together without -problems or -demos
    to build a ./contest/help directory identical in
    content to the ./info/help directory.

    When an item is included in the solutions directory,
    the item must itself be a directory, and the name of
    the item in the solutions directory is the last
    component of the item name.  This means that all
    problems in the system should have unique single
    component names.  The name of a problem is also
    the basename of the solution file submitted for the
    problem.

    The name of an item is a modification of the name
    of the item as it appears in the input index file
    item entry.  The modification results from subtitu-
    tions specified in the index specificaion.  Specifi-
    cally, a substitution of the form `nameXs=nameXt'
    may be applied to the item name.  If the item name
    begins with the nameXs string, that string will be
    replaced by nameXt.  If there are several possible
    substitutions, the longest nameXs will be selected,
    and if there are several longest, the first will be
    selected.

    Thus, for example, given an index specification of
    the form

    	my_index: foo/bar, public/=problems/, \\
	          public/shelf/=problems/old/

    then

      public/frap	   becomes    problems/frap
      public/shelf/frap    becomes    problems/old/frap

    with the changed names being used as the names of
    the items within the ./info and ./contest
    directories and as the names of the item in any
    output index files.

    We proceed to describe the program options not di-
    rectly involved with making ./info, ./contest/help,
    ./contest/problems, or ./contest/demos.

    The -this_contest program option creates the follow-
    ing if they do not exist:

	./help			directory
	./help/index		file
	./help/this_contest	file

    Note these are in the judging directory proper, and
    not in the ./info or ./contest subdirectories.  The
    ./help/index file is an input index file that contains
    an entry for ./help/this_contest.  The latter file
    is information about the current contest.  If created,
    a ./TODO is written to edit this file.  The -this_
    contest option is processed before any input index
    files are read, so ./help/index may be used as an
    input index file in the same call to this program
    that creates the ./help/index file.

    If used the ./help/index file should be the refer-
    enced by the first index specification given to this
    program.  It contains header entries that start the
    output `help/index' and mention the `help/problems'
    and `help/demos' output indices.

    The -mail program option causes the ./mail directory
    to be made if it does not exist.  If it is made, its
    mode is set to a+x as is the mode of its parent and
    its parent's parent.  This last is necessary because
    the JAVA interpreter turns relative file names into
    absolute file names, requiring `a+x' permissions
    in the path from the root to the object file.

    The -help2 program option creates the ./contest/
    help2 directory if it does not exist.  It is simply
    linked to the ./contest/help directory.
    
    Note that the `help' command searches ./contest/
    help1, ./contest/help2, ./contest/help3, and
    ./contest/help4 in order for help files.

    The -bin program option creates the ./contest/bin
    directory if it does not exist.  It is simply linked
    to the ./contest/contestant/bin directory, and a
    note to run
    
    		cd .../hpcm; make
		
    is written into ./TODO, in order to be sure all
    the programs and modes are correct so the .../hpcm/
    contestant/bin directory can be used.

    The -bin program option also checks the security
    of the ./contest/contestant/bin/hpcm_sandbox and
    ./contest/contestant/bin/hpcm_sendmail programs
    and writes a ./TODO if either is insecure.

    The -secure program option makes the following if
    they do not exist:

	./contest/secure		    directory
	./contest/secure/hpcm_sendmail.rc   file
	./contest/secure/passwords	    file

    If any of these are made their modes are set to
    go-rw.  If the ./secure/passwords file is made,
    instructions for editing it are written to ./TODO,
    but the file made automatically is empty.  If the
    ./secure/hpcm_sendmail.rc file is made, instructions
    for editing it and the ~/.procmailrc file are writ-
    ten into ./TODO.

    The ./secure/passwords file consists of lines of
    the form

    	account_name\[:password\[:comment\]\]

    The account_name `none' or the password `none' may
    be used to denote a missing account or password.

    The -secure program option also causes any existing
    ./secure/passwords file to be inspected for lines
    with empty passwords.  If any are found, random
    passwords are generated and in place of the missing
    passwords.  The password `none' may be used in a
    line to prevent a password from being generated and
    prevent the hpcm_set_passwords program from setting
    the password of the line's account.

    The -who_where program option makes the ./contest/
    who_where file if it does not exists, using the
    ./secure/passwords file as a source of information
    about what accounts should exist.   If the `pass-
    words' file is newer than an existing `who_where'
    file, the extra accounts in the `passwords' file are
    added to the `who_where' file.  Whenever the `who_
    where' file is created or modified, a ./TODO to edit
    the file is written.  There may be accounts in the
    `who_where' file that are not in the `passwords'
    file.

    The -trashable program option creates the ./contest/
    trashable file from the ./secure/passwords file.
    The `trashable' file is just a list of accounts in
    the `passwords' file.  It is updated whenever the
    `passwords' file is newer than the `trashable' file.
    Whenever a `trashable' file is created, a ./TODO
    is written to delete the file as soon as all the
    accounts that should be trashed are trashed, in
    order to prevent further account trashing (the
    `TRASH_ACCOUNT' program will not work if the account
    in which it is run is not named in the `trashable'
    file).

    The -printer program option makes the ./contest/
    printer file if it does not exist, and writes a
    ./TODO to edit the file when it is made.

    The -home program option just checks to see if
    the directory ./contest/home exists and the files
    empty.ls, setup.ls, and setup.tar exist in that
    directory and are readable.  If not, instructions
    are written to ./TODO.

    If anything is made in ./contest, a+x is set for
    that directory and its parent.

    Although we have used the names `./info', `./mail',
    `./contest', and `./help' in this description, the
    actual directory names used are the values of the
    `info_directory', `mail_directory', `contest_
    directory', and `help_directory' variables set by
    hpcm_judging.rc.  The file names within these
    directories are literally as given in this docu-
    ment.

    Unlike most HPCM judging programs, errors made by
    this program are not written to log files, but are
    announced on standard error."

# Argi is the index of the current argument, for use in
# lindex.
#
set argi 0

# Set options, consuming option arguments.
#
set info_option			no
set solutions_option		no
set problems_option		no
set demos_option 		no
set txt_option			no
set help_option			no
set help2_option		no
set this_contest_option		no
set mail_option			no
set bin_option			no
set secure_option		no
set who_where_option		no
set trashable_option		no
set printer_option		no
set home_option			no
#
while { "yes" } {
    if { $argi >= $argc } break;
    switch -- [lindex $argv $argi] {
        -email		{ set info_option 	yes
			  set solutions_option	yes
			  set mail_option	yes }
        -formal		{ set solutions_option	yes
			  set problems_option	yes
			  set demos_option	yes
			  set help_option	yes
			  set help2_option	yes
			  set this_contest_option \
			  			yes
			  set mail_option	yes
			  set bin_option	yes
			  set secure_option	yes
			  set who_where_option	yes
			  set printer_option	yes
			  set home_option	yes }
        -informal	{ set solutions_option	yes
			  set help_option	yes
			  set help2_option	yes
			  set this_contest_option \
			  			yes
			  set mail_option	yes
			  set bin_option	yes
			  set secure_option	yes
			  set who_where_option	yes
			  set printer_option	yes
			  set home_option	yes }
        -info		{ set info_option 	yes }
        -solutions	{ set solutions_option 	yes }
        -problems	{ set problems_option 	yes }
        -demos		{ set demos_option 	yes }
        -txt		{ set txt_option 	yes }
        -help		{ set help_option 	yes }
        -help2		{ set help2_option 	yes }
	-this_contest	{ set this_contest_option \
						yes }
        -mail		{ set mail_option 	yes }
        -bin		{ set bin_option 	yes }
        -secure		{ set secure_option 	yes }
        -who_where	{ set who_where_option 	yes }
        -trashable	{ set trashable_option 	yes }
        -printer	{ set printer_option 	yes }
        -home		{ set home_option 	yes }
	default		{ break }
    }
    incr argi
}

# Set up TODO
#
set TODO_ch ""
set TODO_existed [expr { [file exists TODO] \
                         && [file size TODO] > 0 }]
proc TODO { args } {
    global TODO_ch
    if { $TODO_ch == "" } {
    	set TODO_ch [open TODO a]
    }
    puts $TODO_ch "--------"
    foreach line $args {
    	puts $TODO_ch "    $line"
    }
}

# Set up TODO_hpcm_make
#
set TODO_hpcm_make_done no
proc TODO_hpcm_make {} {
    global TODO_hpcm_make_done
    if { $TODO_hpcm_make_done == "no" } {
    	set TODO_hpcm_make_done yes
	TODO "run `make' in `hpcm' directory"
    }
}

# Make 10 character random password.
#
random seed
proc make_password {} {
    return [format {%03d%03d%04d} \
		   [random 1000] \
		   [random 1000] \
		   [random 10000]]
}

# If no arguments left or first remaining argument
# begins with `-', print documentation and exit with
# error.
#
if { $argi >= $argc \
     || [regexp {^-} [lindex $argv $argi]] } {
    puts $document
    exit 1
}

# Universal abbreviations to shorten lines.
#
set c_d $contest_directory

# Check for some elementary errors, such as ./contest
# not existing if it is needed.
#
if {    $problems_option \
     || $demos_option \
     || $help_option \
     || $help2_option \
     || $bin_option \
     || $secure_option \
     || $who_where_option \
     || $trashable_option \
     || $printer_option \
     || $home_option } {
    if {    ! [file isdirectory $c_d] \
         || ! [file executable $c_d] \
         || ! [file readable $c_d] } {
	error "$c_d' is not a useable directory"
    }
    puts "Granting a+x access to $c_d"
    grant_access $c_d x
}
if { $bin_option } {
    if {    ! [file isdirectory "$c_d/contestant"] \
         || ! [file executable "$c_d/contestant"] \
         || ! [file readable "$c_d/contestant"] } {
	error "`$c_d/contestant' is not a useable\
	       directory"
    }
}
if { $home_option } {
    if {    ! [file isdirectory "$c_d/home"] \
         || ! [file executable "$c_d/home"] \
         || ! [file readable "$c_d/home"] } {
	error "`$c_d/home' is not a useable directory"
    }
}

# Array specifying option substitutions.  For each
# op1 to be substituted for, the value of
#
#	option_array(op1)
#
# is the list of options that is the substitution.

# Expand a list of options and return the result.
#
proc expand_options { option_list } {

    global option_array

    set result ""
    foreach option $option_list {
        if { [info exists option_array($option)] } {
	    set result \
	        [concat $result \
			$option_array($option)]
	} else {
	    lappend result $option
	}
    }

    return $result
}

# List of substitutions to be made in the names of the
# current input index file.  Each item of the list has
# the form `{source target}' which specifies that if a
# name begins with the string `source' that string
# should be replaced by the string `target'.
#
set substitutions ""

# Make the longest substitution possible in the
# name argument and return the result (or if
# there are no substitutions return the name
# argument).  If there is a length tie, apply
# the first substitution.
#
proc make_substitutions { name } {

    global substitutions

    set result $name
    set best_end -2

    foreach substitution $substitutions {
        set source [lindex $substitution 0]
	set end [string length $source]
	incr end -1

	if { [string range $name 0 $end] == $source \
	     && $best_end < $end } {
	    set target [lindex $substitution 1]
	    set best_end $end
	    incr end
	    set result [string range $name $end end]
	    set result $target$result
	}
    }

    return $result
}


# Process index specification using global variables
# as parameters:
#
#   index_file		the input index file name
#   index_directory	index directory name
#   help_index_chs	output help/index file channel
#			list; "" if none
#   demos_index_chs	output help/demos file channel
#			list; "" if none
#   problems_index_chs	output help/problems file
#			channel list; "" if none
#   option_array	option substitutions
#			(see above)
#   substitutions	filename substitutions
#			(see above)
#   info_option		options
#   solutions_option
#   problems_option
#   demos_option
#   help_option
#   info_directory	directory names
#   contest_directory (c_d)
#   solutions_directory

# Helper function.

# If ${targetdir}index_ch is "", see if it should be
# something else, and return its correct value.
#
proc get_index_chs { targetdir } {

    global info_option help_option \
           info_directory c_d \
           help_index_chs problems_index_chs \
	   demos_index_chs \

    set chs ""
    if { $info_option || $help_option } {
	switch $targetdir {
	help		{ set file index
			  set head "Help Index" }
	problems	{ set file problems
			  set head "Problems Index" }
	demos		{ set file demos
			  set head "Demos Index" }
	}
	if { $info_option } {
	    lappend chs \
	    	    [open $info_directory+/help/$file w]
	}
	if { $help_option } {
	    lappend chs [open $c_d/help+/$file w]
	}

	set ${targetdir}_index_chs $chs

	foreach ch $chs {
	    puts $ch [format {%-28s%28s} $head \
	    		     [clock format \
			     	    [clock seconds]]]
	    puts $ch ""
	    puts $ch ""
	}
    }
    return $chs
}

# Copy readable files and subdirectories recursively.
#
proc recursive_file_copy { source destination } {
    foreach src [glob -nocomplain $source/*] {
	if { ! [file readable $src] } continue
    	set des "$destination/[file tail $src]"
	if { [file isfile $src] } {
	    file copy $src $des
	} else {
	    recursive_file_copy $src $des
	}
	grant_access $des
    }
}

proc process_index_specification {} {

    global index_file index_directory \
           help_index_chs problems_index_chs \
	   demos_index_chs \
           info_option solutions_option \
	   problems_option demos_option \
	   help_option \
           info_directory solutions_directory \
	   problems_directory demos_directory c_d


    # Be sure index directory is absolute name, else
    # symbolic links will fail.
    #
    if { ! [regexp {^/} $index_directory] } {
	set index_directory [pwd]/$index_directory
    }
    # Replace /*/../ by / recursively.
    while { [regsub {/[^/]*/\.\./} $index_directory \
		    {/} index_directory] == 1 } {}

    # Read the input index file and process its entries.
    #
    set index_ch [open $index_file r]
    set in_header		no
    set in_item			no

    set index_chs		""

    set header_entry		""
    set help_header_used	no
    set demos_header_used	no
    set problems_header_used	no

    set help_index_written	no
    set demos_index_written	no
    set problems_index_written	no

    while { "yes" } {

        # Read next input index line.
	#
	set line [gets $index_ch]
        if { [eof $index_ch] } break;

	if { [llength $line] >= 1 \
	     && [lindex $line 0] == "***" } {

	    # Beginning item entry.

	    set in_header	no

	    set name [lindex $line 1]
	    set options \
	        [expand_options [lreplace $line 0 1]]
	    set source $index_directory/$name
	    set ws "\[\ \t\]*"
	    regexp "^($ws\\*\\*\\*$ws)(\[^\ \t\]|\$)" \
		   $line forget indent forget2
	    regsub {\*\*\*} $indent {   } indent

	    if { [lsearch -exact $options include] \
	         < 0 } {

		# Item is not included.

	    	set in_item	no

	    } else {

	    	# Item is included.

		set in_item	yes

		set target [make_substitutions $name]

		if { ! [regexp {^([^/]*)/+([^/].*)$} \
		               $target forget \
			       targetdir targettail] \
		     || [lsearch -exact \
				 {help demos problems} \
				 $targetdir] < 0 \
		     || [lsearch -exact {. ..} \
		                 $targettail] >= 0 } {
		    error "Bad item name directory\
		    	   after substitution: $target"
		}

	        set index_chs \
		    [set ${targetdir}_index_chs]

		if { $index_chs == "" } {
		    set index_chs \
		    	[get_index_chs $targetdir]
		}

		if { [set ${targetdir}_header_used] \
		     == "no" } {
		    set ${targetdir}_header_used yes
		    if { $item_header != "" } {
		        foreach ch $index_chs {
			    puts $ch $item_header
			}
		    }
		}
		foreach ch $index_chs {
		    puts $ch "$indent$target"
		}

		set ${targetdir}_index_written yes

		# Process info option.
		#
		if { $info_option } {

		    set destination \
		    	$info_directory+/$target

		    if { [lsearch -exact $options all] \
			 >= 0 \
			 || [file isfile $source] } {
			file mkdir \
			     [file dirname $destination]
			link_file $source $destination
		    } else {
			file mkdir $destination
			link_file $source/Makefile \
				  $destination/Makefile
			set problem [glob $source/*.txt]
			if { [llength $problem] != 1 } {
			    error "Too many or too few\
				   $source/*.txt files"
			}
			set problem [lindex $problem 0]
			set problem [file tail $problem]
			link_file $source/$problem \
				  $destination/$problem
		    }
		}

		# Process $targetdir option.
		#
		if { [set ${targetdir}_option] } {

		    set destination \
		        "$targetdir+/$targettail"
		    set destination \
		        "$c_d/$destination"
		    if { [file isfile $source] } {
			file mkdir \
			     [file dirname \
			           $destination]
			file copy $source \
				  $destination
		    } elseif { [file isdirectory \
		    		     $source] } {
			file mkdir $destination
			
			if { [lsearch -exact $options \
				             all] \
			     >= 0 } {
			    recursive_file_copy \
				$source \
				$destination
			} else {
			    file copy $source/Makefile \
				      $target/Makefile
			    grant_access \
			    	$target/Makefile

			    if { $txt_option } {
				set problem \
				    [glob $source/*.txt]
				if { [llength \
				          $problem] \
				     != 1 } {
				    error \
					"Too many or\
					 too few\
					 $source/*.txt\
					 files"
				}
				set problem \
				    [file tail $problem]
				file copy \
				    $source/$problem \
				    $target/$problem
				grant_access \
				    $target/$problem
			    }
			}
		    }
		    set d $targettail
		    while { "yes" } {
		    	grant_access $c_d/$targetdir+/$d
			set d [file dirname $d]
			if { $d == "." } break
		    }
		}

		# Process solutions option.
		#
		if { $solutions_option \
		     && [lsearch -exact \
		     		 {problems demos} \
				 $targetdir] >= 0 \
		     && [lsearch -exact \
		     	         $options \
				 nosolution] < 0 } {
		    if { ! [file isdirectory $source] \
		    		} {
			error "$source solution is not\
			       a directory"
		    }
		    set s_d $solutions_directory+
		    link_file $source \
			      "$s_d/[file tail \
			      		  $targettail]"
		}
	    }

	} elseif { $in_header } {

	    # Line inside header.

	    set item_header "$item_header\n$line"

	} elseif { [regexp "^\[^\ \t\]" $line] } {

	    # Beginning of header entry.

	    set item_header		$line
	    set in_header		yes
	    set in_item			no
	    set help_header_used	no
	    set demos_header_used	no
	    set problems_header_used	no

	} elseif { $in_item } {

	    # Line inside included item.

	    foreach ch $index_chs {
		puts $ch $line
	    }
	}
    }

    # If we copied any index entries, put out 2 blank
    # lines to separate this input index file's entries
    # from those of the next input index file.
    #
    foreach dir {help problems demos} {
        if { [set ${dir}_index_written] } {
	    foreach ch [set ${dir}_index_chs] {
	    	puts $ch ""
	    	puts $ch ""
	    }
	}
    }

    close $index_ch
}

# Set up info+, solutions+, problems+, demos+, and
# help+ directories.
#
if { $info_option } {
    if { [file exists $info_directory+] } {
        puts "Deleting $info_directory+"
	exec rm -rf $info_directory+ >@ stdout
    }
    file mkdir $info_directory+
    file mkdir $info_directory+/help
}
foreach dir {problems demos help} {
    if { [set ${dir}_option] } {
	if { [file exists $c_d/$dir+] } {
	    puts "Deleting $c_d/$dir+"
	    exec rm -rf $c_d/$dir+ >@ stdout
	}
	file mkdir $c_d/$dir+
    }
}
if { $solutions_option } {
    if { [file exists $solutions_directory+] } {
        puts "Deleting $solutions_directory+"
	exec rm -rf $solutions_directory+ >@ stdout
    }
    file mkdir $solutions_directory+
}

# Make help directory.
#
if { $this_contest_option \
      && ! [file isdirectory $help_directory] } {
    file mkdir $help_directory
}

# Make help/index file.
#
if { $this_contest_option \
      && ! [file isreadable $help_directory/index] } {
    set index_ch [open $help_directory/index w]

    puts $index_ch "    help/index"
    puts $index_ch "        This file."
    puts $index_ch ""
    puts $index_ch "    help/demos"
    puts $index_ch "        Index of contest\
			    demonstration problems."
    puts $index_ch ""
    puts $index_ch "    help/problems"
    puts $index_ch "        Index of contest problems."
    puts $index_ch ""

    # The following must be last so its inclusion
    # causes the preceding to be included.

    puts $index_ch "*** help/this_contest"
    puts $index_ch "        Information about this\
    			    contest."
    puts $index_ch ""

    close $index_ch
    grant_access $help_directory/index
}

# Make help/this_contest file.
#
if { $this_contest_option \
      && ! [file isreadable \
      		 $help_directory/this_contest] } {
    set tc_ch [open $help_directory/this_contest w]

    puts $tc_ch [format {%-28s%28s} \
    			"About This Contest" \
		        [clock format \
			       [clock seconds]]]
    puts $tc_ch ""

    close $tc_ch ""
    grant_access $help_directory/this_contest
    TODO "edit $help_directory/this_contest"
}

# Set up channel lists.
#
set help_index_chs	""
set demos_index_chs	""
set problems_index_chs	""

# Process arguments, forming index specifications
# encoded in global variables, and call process_index_
# specification (see above) for each specification.
#
set mode file
#
# Mode indicates what next argument should be: file,
# directory, or substitution.
#
foreach arg [lreplace $argv 0 [expr { $argi - 1 }]] {

    # Process next argument.  Whether argument ends in
    # `,' or `:' tells mode of next argument.
    #
    if { $mode == "file" } {
    	if { [regexp {^(.*):$} $arg forget arg] } {
	    set mode directory
    	} else {
	    if { [regexp {^(.*),$} $arg forget arg] } {
		set mode substitution
	    }
	    set index_directory [file dirname $arg]
	}
	set index_file $arg
	set substitutions ""
	foreach opt [array names option_array] {
	    unset option_array($opt)
	}
    } elseif { $mode == "directory" } {
    	if { [regexp {^(.*),$} $arg forget arg] } {
	    set mode substitution
	} else {
	    set mode file
	}
	set index_directory $arg
    } elseif { $mode == "substitution" } {
    	if { ! [regexp {^(.*),$} $arg forget arg] } {
	    set mode file
	}
	if { [regexp {^([^=]*)=([^=]*)$} $arg forget \
	               source destination] } {
	    lappend substitutions \
		    [list $source $destination]
	} elseif { [regexp {^([^:]*):([^:]*)$} \
	                   $arg forget \
	               source destination] } {
	    set option_array($source) \
	        [string trim $destination]
	} else {
	    error "Badly formatted substitution:\
	           `$arg'"
	}
    }

    if { $mode == "file" } {
    	process_index_specification
    }
}
if { $mode != "file" } {
    error "Last argument ends with `,' or `:'"
}

# Finish up index output files.
#
foreach dir {problems help demos} {
    foreach ch [set ${dir}_index_chs] {
        close $ch
    }
}
if { [file exists $c_d/help+/index] } {
    grant_access $c_d/help+/index]
}
if { [file exists $c_d/help+/demos] } {
    grant_access $c_d/help+/demos]
}

# Rename directories iff $directory+ differs from
# $directory as determined by `diff -r'.  If a directory
# is not renamed, delete it.  Return `yes' if directory
# renamed, and `no' if deleted.
#
proc rename_directory { directory } {
    
    if { ! [catch { exec diff -r $directory \
                         $directory+ > /dev/null } ] \
         } {
    	puts "New $directory does not differ from\
	      previous version."
	exec rm -rf $directory+ >@stdout
	return no
    } else {

	if { [file exists $directory--] } {
	    exec rm -rf $directory-- >@ stdout
	}
	if { [file exists $directory-] } {
	    puts "Renaming $directory- to $directory--"
	    file rename $directory- $directory--
	}
	if { [file exists $directory] } {
	    puts "Renaming $directory to $directory-"
	    file rename $directory $directory-
	}
	if { [file exists $directory+] } {
	    puts "Renaming $directory+ to $directory"
	    file rename $directory+ $directory
	}
	return yes
    }
}

if { $info_option } {
    rename_directory $info_directory
}
if { $problems_option } {
    rename_directory $c_d/problems
}
if { $help_option } {
    rename_directory $c_d/help
}
if { $demos_option } {
    rename_directory $c_d/demos
}
if { $solutions_option } {
    rename_directory $solutions_directory
}

if { ( $problems_option \
       && ! [regexp {r.x} \
       		    [get_access $c_d/problems]] ) \
     || \
     ( $help_option \
       && ! [regexp {r..} [get_access \
       			      $c_d/help/problems]] ) } {
    TODO "run `startcontest' when contest starts" \
         "to chmod a+rx $c_d/problems" \
	 "and/or $c_d/help/problems"
}

# Make mail directory.
#
if { $mail_option \
      && ! [file isdirectory $mail_directory] } {
    file mkdir $mail_directory
    grant_access $mail_directory x
}

# Make $c_d/help2 directory.
#
if { $help2_option \
     && ! [file isdirectory $c_d/help2] } {
    if { ! [catch {
	      set help2_type \
		  [file type $c_d/help2] }] } {
	if { $help2_type == "link" } {
	    puts "Deleting $c_d/help2"
	    file delete -force $c_d/help2
	} else {
	    error "$c_d/help2 exists but is not a\
	           directory"
	}
    }
    link_file ./help $c_d/help2
}

# Make $c_d/bin directory.
#
if { $bin_option \
     && ! [file isdirectory $c_d/bin] } {
    if { ! [file isdirectory $c_d/contestant/bin] } {
    	error "bin: $c_d/contestant/bin is not a\
	       directory"
    }
    if { ! [file executable $c_d/contestant/bin] } {
    	error "bin: $c_d/contestant/bin has no x\
	       permission"
    }
    if { ! [catch { set bin_type \
			[file type $c_d/bin] }] } {
	if { $bin_type == "link" } {
	    puts "Deleting $c_d/bin"
	    file delete -force $c_d/bin
	} else {
	    error "$c_d/bin exists but is not a\
	           directory"
	}
    }

    puts "Linking $c_d/bin to $c_d/contestant/bin"
    link_file contestant/bin $c_d/bin

    TODO_hpcm_make
}

# Make secure directory.
#
if { $secure_option \
     && ! [file isdirectory $c_d/secure] } {
    file mkdir $c_d/secure
    deny_access $c_d/secure
}

# Make or edit secure/passwords file.
#
if { $secure_option } {
    if { ! [file readable $c_d/secure/passwords] } {
	close [open $c_d/secure/passwords w]
	deny_access $c_d/secure/passwords
	TODO "edit $c_d/secure/passwords"
    } else {
        set passwords_ch [open $c_d/secure/passwords r]
	set lines ""
	set changed no
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    if { [regexp {^([^:]+)(|:|::.*)$} $line \
			 forget account forget2] } {
		set password [make_password]
		set rest ""
		regexp {^[^:]+:(:.*)$} $line \
		       forget rest
	        set line "$account:$password$rest"
		set changed yes
	    }
	    lappend lines $line
	}
	close $passwords_ch
	if { $changed} {
	    set passwords_ch \
	        [open $c_d/secure/passwords w]
	    foreach line $lines {
	        puts $passwords_ch $line
	    }
	    close $passwords_ch
	    TODO "inspect $c_d/secure/passwords" \
		 "to which passwords have been added"
	}
    }
}

# Make secure/hpcm_sendmail.rc file.
#
if { $secure_option \
     && ! [file readable \
     		$c_d/secure/hpcm_sendmail.rc] } {
    set rc_ch [open $c_d/secure/hpcm_sendmail.rc w]
    puts $rc_ch \
	 "To: [make_password]<[id user]@[id host]>"
    puts $rc_ch "Key: [make_password]"
    set key_name [file tail [pwd]]
    regexp {^(.*)(-|_)[^-_]*$} $key_name \
	   forget key_name forget2
    puts $rc_ch "Key-Name: $key_name"
    close $rc_ch
    deny_access $c_d/secure/hpcm_sendmail.rc
    TODO "edit $c_d/secure/hpcm_sendmail.rc" \
	 "either remove the Key and Key-Name" \
	 "or edit the hpcm_judging.rc\
	  authorization variables"
}

# Make $c_d/who_where
#
if { $who_where_option } {
    set wwcepe "WHO:WHERE:COACH-EMAIL:PRACTICE-EMAIL"
    if { ! [file readable $c_d/secure/passwords] } {
        error "$c_d/secure/passwords does not exist\
	       for -who_where option"
    } elseif { ! [file readable $c_d/who_where] } {
	set who_where_ch [open $c_d/who_where w]
	set passwords_ch [open $c_d/secure/passwords r]
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    regexp {^([^:]*):} $line forget account
	    if { $account != "none" } {
		puts $who_where_ch "$account:wwcepe"
	    }
	}
	close $passwords_ch
	close $who_where_ch
	grant_access $c_d/who_where

	TODO "edit $c_d/who_where"
    } elseif { [file mtime $c_d/who_where] \
	       < [file mtime $c_d/secure/passwords] } {

	set who_where_ch [open $c_d/who_where r]
	while { "yes" } {
	    set line [gets $who_where_ch]
	    if { [eof $who_where_ch] } break
	    regexp {^([^:]*):} $line forget account
	    set who_where_array($account) yes
	}
	close $who_where_ch

	set new_account_list ""

	set passwords_ch [open $c_d/secure/passwords r]
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    regexp {^([^:]*)(:|$)} $line \
	           forget account forget2
	    if { ! [info exists \
	                 who_where_array($account)] \
		 && $account != "none" } {
		lappend new_account_list $account
	    }
	}
	close $passwords_ch

	if { $new_account_list != "" } {
	    set who_where_ch [open $c_d/who_where w]
	    foreach account $new_account_list {
		puts $who_where_ch "$account:wwcepe"
	    }
	    close $who_where_ch

	    TODO "edit $c_d/who_where"
	}
    }
}

# Make $c_d/trashable
#
if { $trashable_option } {
    if { ! [file readable $c_d/secure/passwords] } {
        error "$c_d/secure/passwords does not exist\
	       for -trashable option"
    } elseif { ! [file readable $c_d/trashable] \
	       || [file mtime $c_d/trashable] \
	          < [file mtime $c_d/secure/passwords] \
		  	} {
	set trashable_ch [open $c_d/trashable w]
	set passwords_ch [open $c_d/secure/passwords r]
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    regexp {^([^:]*)(:|$)} $line \
	    	   forget account forget2
	    if { $account != "none" } {
		puts $trashable_ch $account
	    }
	}
	close $passwords_ch
	close $trashable_ch
	grant_access $c_d/trashable

	TODO "check and maybe edit $c_d/trashable"
    }
}

# Make $c_d/printer
#
if { $printer_option \
     && ! [file isreadable $c_d/printer] } {
    set printer_ch [open $c_d/printer w]
    if { [info exists env(PRINTER)] } {
	puts $printer_ch $env(PRINTER)
    } else {
	puts $printer_ch UNKNOWN
    }
    close $printer_ch
    grant_access $c_d/printer

    TODO "edit $c_d/printer"
}

# Check for $c_d/home directory.
#
if { $home_option } {
    if {    ! [file isdirectory $c_d/home] \
         || ! [file readable $c_d/home] \
         || ! [file executable $c_d/home] \
         || ! [file readable $c_d/home/empty.ls] \
         || ! [file readable $c_d/home/setup.ls] \
         || ! [file readable $c_d/home/setup.tar] \
		} {
	TODO "run SETUP_PROTYPE in prototype account" \
	     "and rerun `makejudgingdir -home'"
    }
}

# Finish TODO
#
set TODO_written [expr { $TODO_ch != "" }]
if { $TODO_written || $TODO_existed } {
    if { $TODO_written } {
	close $TODO_ch
    }
    set TODO_ch [open TODO r]
    if { $TODO_existed } {
        if { $TODO_written } {
	    puts "==================== old+new TODO:"
	} else {
	    puts "==================== old TODO:"
	}
    } else {
	puts "==================== new TODO:"
    }
    while { "yes" } {
    	set line [gets $TODO_ch]
	if { [eof $TODO_ch] } break
	puts $line
    }
    puts "==================== end of TODO"
    close $TODO_ch
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
