#!/bin/sh
#
# Make the subdirectories, symbolic links, and indices
# of a judging directory and its associated contest
# directory.
#
# File:		makecontest
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Thu Dec 22 09:22:00 EST 2005
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2005/12/22 17:32:38 $
#   $RCSfile: makecontest,v $
#   $Revision: 1.114 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
set contestant_help_directory \
    "[file dirname $argv0]/../../contestant/help"
source $lib_directory/judging_common.tcl
set log_mode none
catch {

# Compute true name of judging_directory, with no
# `/.'s or `/..'s.
#
set wd [pwd]
cd $judging_directory
set judging_directory [pwd]
cd $wd

# Abbreviations used in this program to shorten lines.
#
set j_d $judging_directory
set c_d $j_d/contest

set document "
makecontest option ... index_specification ...

  If no arguments are given, makecontest takes its
  arguments from the makecontest_arguments global
  variable, if that exists.

  Options:
    -formal     Sets up a formal contest.  Equals all
    		options but -info, -trashable,
		-description, and -printer_map.
    -practice   Sets up a practice contest.  Equals all
    		options but -info, -trashable, and
		-printer_map.
    -informal   Sets up an informal contest.  Equals all
    		options but -problems, -demos,
		-trashable, -description, and -printer.
    -email	Sets up an email contest.  Equals -info,
    		-solutions, -mail, and -this_contest.
    -info	Make ./info, ./info/help/index,
    		./info/help/problems, ./info/help/demos.
    -solutions  Make ./solutions
    -contest	Make ./contest
    -bin	Make ./contest/bin
    -home	Make ./contest/home
    -problems	Make ./contest/problems.  Includes
    		problem description files for non-`all'
		directory entries only if -description
		is given.
    -demos	Make ./contest/demos.  Includes
    		problem description files for non-`all'
		directory entries only if -description
		is given.
    -description     Include problem description (.txt,
    		.html, .ps, etc.) files in ./contest/
		problems, ./contest/demos, or ./contest/
		help.
    -help	Make ./contest/help,
    		     ./contest/help/index,
    		     ./contest/help/problems,
    		     ./contest/help/demos
    -help2	Make ./help2
    -this_contest    Make ./help, ./help/index,
		          ./help/this_contest
    -mail	Make ./mail

    -secure	Make ./contest/secure/passwords,
		     ./contest/secure/hpcm_sendmail.rc
    -ssh	Make ./contest/extra_setup.tar contain-
    		ing .ssh/id_rsa.pub, .ssh/id_dsa.pub,
		and .ssh/identity.pub.
    -procmailrc	Update ~/.procmailrc
    -who_where  Make ./contest/who_where
    -trashable  Make ./contest/trashable
    -printer    Make ./contest/printer and
    		     ./contest/printer_jobs
    -printer_map    Make ./contest/printer_map and
    		         ./contest/printer_jobs

  Index Specification:

    index_file\[: index_directory\], name1s=name1t, \\
	  option1s:'option11t option12t ...', \\
	  name2s=name2t, ...

  Pre-Existing Files and Links:

    ./hpcm_judging.rc	 Parameters file.



    Given a judging directory as the current directory,
    complete with hpcm_judging.rc file, this program
    makes subdirectories, links, and index files in the
    judging directory and optional associated contest
    directory, according to instructions in the index
    specifications and options.  The form of the index
    specifications and options is given above.

    This program appends instructions for its user to
    edit certain files and run certain programs to the
    ./TODO file, and prints this file at the end of this
    program (unless the file is empty).

    The -contest program option makes the contest direc-
    tory and the symbolic link `./contest' to that di-
    rectory.  This is needed only for formal and infor-
    mal contests, but not for email contests.  If
    `./contest' does not exist, and name of the judging
    directory is ~/XXX/judging_YYY_PPP where PPP is a
    password, the directory named ~/XXX/contest_YYY is
    made and used as the contest directory.  That is,
    the judging directory name is modified by replacing
    `judging_' by `contest_' at its beginning, and re-
    moving from the end any `_PPP'.  It is an error if
    `./contest' does not exist but the contest directory
    already exists.

    If `./contest' is made, or if anything is made in
    `./contest', a+x is set for that directory and its
    parent.

    The -bin program option makes the symbolic link
    ./contest/bin to `\$hpcm_directory/contestant/bin',
    where the `hpcm_directory' global variable defaults
    to `~/hpcm'.  If this cannot be done, it is not an
    error, but instructions to fix the situation are
    written in the ./TODO file.

    The -home program option makes the symbolic link
    ./contest/home to ~PROTO/home, where PROTO is the
    name of the prototype account that is set up by
    the `SETUP_PROTOTYPE' program.  PROTO is defined
    as the value of the global variable `hpcm_prototype_
    account' if that variable is defined.  Otherwise
    PROTO is the unique account name which has the form
    `*\[_-\]proto' such that the files ~PROTO/home/
    setup.tar, ~PROTO/home/setup.ls, and ~PROTO/home/
    empty.ls exist and are readable, if such a unique
    account name exists.  If the prototype account can-
    not be found, it is not an error, but instructions
    to fix the situation are written in the ./TODO file.

    The index files are read and used to generate a list
    of items to be included in the ./info and ./contest
    directories.  Each item is a file or directory, and
    corresponds to an item entry in an index file.  The
    item entry has the form:

    	*** item_name item_option ...
	    Text describing the item.

    Items have names which, after optional substitutions
    described below, must begin with `help/', `demos/',
    or `problems/', depending the subdirectory of ./info
    or ./contest into which the item is to be included.
    Only the three subdirectories just mentioned are
    allowed.  The item entry of each included item is
    copied into an output index file, which is the
    `help/index' file if the item name begins with
    `help/', the `help/problems' file if the item name
    begins with `problems/', or the `help/demos' file
    if the item name begins with `demos/'.

    When an item entry is copied to an output index,
    the `***' in the first line of the entry is replace
    by 3 space characters, the item name is replaced by
    the name after substitutions, and the item options
    are removed.

    The input index files also contain header entries
    that precede item entries.  When an item entry is
    copied into an output index, the header entry im-
    mediately preceding it is copied into the same out-
    put index.  More specifically, a header entry is
    copied if it is separated from an item entry being
    copied only by other item entries.

    Lastly, any line beginning with `#' in an input
    index file is a comment line that is completely
    ignored, as if it did not exist.

    When an item is included in the ./info directory,
    a symbolic link is made to the item if it is a
    file.  If it is a directory, a new directory
    is created containing a symbolic link to any problem
    source and description files in the directory.  The
    exact definitions of problem source and description
    files are given below.  Problem description file
    links are included within the ./info directory even
    if no -description program option is given.

    When an item is included in the ./contest directory
    (i.e., in ./contest/demos, ./contest/problems, or
    ./contest/help) files are copied and new directories
    are made.  Access is granted using a+r and a+rx file
    and directory modes, except for
    
    		./contest/problems 
    		./contest/help/problems

    which are left with the mode determined by the
    umask (presumably o-rx or og-rx).  The `startcon-
    test' program sets the mode of these to a+rx.  The
    directory items copied are determined by the
    problem_source_files, problem_description_files,
    and problem_excluded_files global variables and the
    `all' option in the index.  See below for details.

    If we consider the directory pairs:

    	./info/demos		./contest/demos
    	./info/problems		./contest/problems
    	./info/help		./contest/help

    then if both directories of a pair are made, both
    are identical after symbolic links are followed,
    except that if there is no -description option,
    problem description files are generally copied into
    ./info subdirectories but not into ./contest subdir-
    ectories.  But if the -description option is given,
    the UNIX `diff -r' command should report the two
    directories in each of the above pairs to be
    identical.

    Directory items may also be included in the
    ./solutions directory.  In this directory the item
    name after substitutions is stripped of any direc-
    tory prefix; e.g., the name `demos/count' becomes
    `count'.  The inclusion here is by symbolic link
    from directory to directory: e.g. `./solutions
    /count' is symbolically linked to the item direc-
    tory.  This means that all demos and problems in the
    contest must have unique single component names
    (except for items with the `nosolution' item option:
    see below).

    If this program is building a ./info directory, it
    actually builds a ./info+ directory instead.  Then
    it does a `diff -r ./info ./info+', and checks the
    output to see if there is any difference between
    ./info and ./info+ except for the first lines of
    the help indices (help/demos, help/problems, and
    help/index).  If there are no differences, the
    ./info+ directory is removed and nothing else is
    done.  If the two directories have other differ-
    ences, the following renaming occurs:

    		./info-	    becomes    ./info--
    		./info	    becomes    ./info-
    		./info+	    becomes    ./info

    A similar stratagem is followed for ./solutions,
    ./contest/problems, ./contest/demos, and .contest/
    help.

    The item entries and header entries are in input
    index files, each of which is referenced in a sep-
    arate index specification.  The format of an index
    specification is given above: it is a sequence of
    arguments, all but the last of which end in either a
    `:' or a `,'.  The `:' indicates the next argument
    is an index directory name (see below) and the `,'
    indicates the next argument is either a name sub-
    stitution or an option substitution (also see
    below).

    Each input index file is associated with an index
    directory.  An unedited version of the index file is
    normally found in its index directory.  Sometimes an
    edited copy of this index file is placed in the
    current judging directory, with the editing consist-
    ing of changes to the item entry options described
    below which control what is included in the new
    info, contest, and solutions directories.  Often,
    however, an edited copy of the index file need not
    be made, because item entry option mapping, describ-
    ed below, is sufficient.

    An index directory may optionally be given in a
    specification by ending the first argument of the
    specification, which names the index input file,
    with a `:', and giving the name of the index direc-
    tory as the second argument in the specification
    (with an optional ending `,').  If no index direc-
    tory is given in an index specification, the direc-
    tory that contains the index file is used as the
    index directory.

    The index file consists of two types of entries:
    header entries and item entries.  Item entries begin
    with a line that starts with `***', followed by
    whitespace, and optionally preceded by whitespace.
    Header entries begin with a line that starts with
    neither whitespace nor `***' followed by whitespace.
    A header entry stops at the next line that begins an
    item entry, or at the end of file.  An item entry
    stops at the next line that begins a header or item
    entry, or at the end of file.

    As noted above, the first line of an item entry has
    the form:

    	*** item_name item_option ...

    The item name is the name of the item file or direc-
    tory relative to the index directory (the directory
    normally containing the unedited index file).  The
    possible item options are:

      include	  Include item in the ./info and
      		  ./contest directories, and in the
		  ./solutions directory if the
		  `nosolution' item option is absent
		  and the item name after substitutions
		  begins with `demos/' or `problems/'.

      nosolution  Do NOT include the item in the 
                  ./solutions directory, even if the
		  item name after substitutions begins
		  with `demos/' or `problems/'.

      all	  This changes the definition of the
      		  global variable problem_source_files
		  to {.*}, which means that all files
		  not excluded by the global variable
		  problem_excluded_files will be
		  source or description files.  See
		  below for details.

      ...	  Other options may be given that are
      		  passed to the PROBLEM.rc file: see
		  below for details.

    The `include' option is rarely encoded directly in
    the index files.  Instead options categorizing the
    entries are made up by the author of an index file
    and mapped by the index specification to the
    `include' option.  Mapping is done by option substi-
    tution that occurs before the options are finally
    processed.  A substitution of the form:

    	option1s:'option11t option12t ...'

    in the index specification replaces option1s by the
    options in the list `option11t option12t ...'.
    As a special case, if `option1s' is `ALL', the
    options in the list `option11t option12t ...' are
    always added to the substitution result without
    replacing any option in the original option list.
    Substitution is NOT recursive: it is done only on
    options appearing in the item entries in the index
    files, and not on options that are the result of
    substitution.  After substitutions are done, unknown
    options are ignored.

    If an item has the `include' option after option
    substitutions, the item entry is included in an out-
    put index within the ./info directory.   The indices
    are

    	   index		for items named

      ./info/help/index	    ./info/help/...
      ./info/help/demos	    ./info/demos/...
      ./info/help/problems  ./info/problems/...

    There is a similar inclusion for the ./contest dir-
    ectory.

    When an item entry is included in an output index,
    the header entry preceding it is included if it is
    separated from the item entry only by item entries
    that were not included in that output index.  Thus
    a header entry is associated with the consecutive
    item entries that follow it, and the header entry is
    included in an output index if and only if any of
    these item entries is included.  The header entry
    may end up being included in several output indices
    if the item entries following it are included in
    several different output indices.

    The program options -demos, -problems, and -help can
    be used by omission to prevent the ./contest/demos,
    ./contest/problems, or ./contest/help directories
    from being created, but program options never affect
    the content of any output indices that are created.

    The name of an item is a modification of the name
    of the item as it appears in the input index file
    item entry.  The modification results from substitu-
    tions specified in the index specification.  Spec-
    ifically, a substitution of the form `nameXs=nameXt'
    may be applied to the item name.  If the item name
    begins with the nameXs string, that string will be
    replaced by nameXt.  If there are several possible
    substitutions, the longest nameXs will be selected,
    and if there are several longest, the first will be
    selected.

    Thus, for example, given an index specification of
    the form

    	my_index: foo/bar, public/=problems/, \\
	          public/shelf/=problems/old/

    then

      public/foo2	   becomes    problems/foo2
      public/shelf/foo1    becomes    problems/old/foo1

    with the changed names being used as the names of
    the items within the ./info and ./contest
    directories and as the names of the item in any
    output index files.

    Substitutions are not recursive: the result of a
    substitution is NOT subject to further substitu-
    tions.

    When an index item names a problem, demo, or help
    directory, it is necessary to determine the problem,
    demo, or help source and description files.  In this
    case the directory is inspected for a file named
    `PROBLEM.rc', where `PROBLEM' is the last component
    of the directory name.  If that file exists it is
    sourced into a local procedure (so it will not
    define global variables other than those needed by
    makecontest).  The PROBLEM.rc file may reference the
    variables

    	PROBLEM		Name of problem.
	EXTENSION	Equals \"UNDEFINED\"
	OPTIONS		The options in the index item,
			as a TCL list, after expansion.

   The PROBLEM.rc file may define the following vari-
   ables:

	problem_description_files
   	problem_source_files
   	problem_excluded_files

    The values of these variables are TCL lists of
    regular expressions.  Default values are provided
    for these variables by hpcm_judging.rc, and these
    in turn default as follows:

	problem_description_files:
	    [indent_list 12 $problem_description_files]
   	problem_source_files:
	    [indent_list 12 $problem_source_files]
   	problem_excluded_files:
	    [indent_list 12 $problem_excluded_files]

    The description and source file lists are lists of
    description or source file names relative to the
    index item directory.  To be listed a file must have
    a name whose LAST component matches a regular ex-
    pression in the problem_description_files or pro-
    blem_source_files global variable values, and NOT
    have ANY name component that matches a regular
    expression in problem_excluded_files.  If a file
    would be in both the description and file lists, it
    is deleted from the source list, so it is in only
    the description file list.
    
    The difference between source and description files
    is that source files are always copied into
    ./contest/{problems,demos,help}, whereas description
    files are copied only if the -description option is
    given to makecontest.
    
    The `all' option in an index item changes the
    problem_source_files value to {.*} and the problem_
    description_files value to {}.  This effectively
    eliminates the effect these two global variables and
    includes all files not excluded by the problem_
    excluded_files global variable, regardless of the
    setting of the -description option.

    The name `PROBLEM.rc' is something of a misnomer for
    help files.  In this case `PROBLEM' is merely the
    last component of the index item directory name.  It
    is very rare for a help file directory to need a .rc
    file.

    By convention, a problem or demo source file that
    has the extension `.ISF' is intended as the initial
    version of a writable contestant file that the con-
    testant will submit and may alter before submitting.
    The writable contestant file itself has the name of
    the initialization file with the `.ISF' stripped
    from its end.  Thus a source file named `foo.c.ISF'
    should be copied into a writable contestant file
    named `foo.c' that will be submitted (by the con-
    testant executing `make submit').  `.ISF' stands for
    `initial submittable file'.

    This current program does nothing special with files
    having the `.ISF' extension.  It is the `hpcm_get'
    and `hpcm_extract' programs that automatically copy
    a file with a name such as `xxx.ISF' into a writable
    file named `xxx'.

    We proceed to describe the program options not di-
    rectly involved with making ./info, ./contest/help,
    ./contest/problems, or ./contest/demos.

    The -this_contest program option creates the follow-
    ing if they do not exist:

	./help			directory
	./help/index		file
	./help/this_contest	file

    Note these are in the judging directory proper, and
    not in the ./info or ./contest subdirectories.  The
    ./help/index file is an INPUT index file that con-
    tains an entry for ./help/this_contest.  The latter
    file is information about the current contest.  If
    the file is created, a ./TODO is written to edit
    ./help/this_contest.  The -this_contest option is
    processed before any input index files are read, so
    ./help/index may be used as an input index file in
    the same call to `makecontest' that creates the
    ./help/index file.

    The ./help/this_contest file is initialized to a
    copy of the file named hpcm/contestant/help/ccc/ccc_
    this_contest_prototype, where ccc is the contest
    type (email, informal, or formal).

    If used, the ./help/index file should be the refer-
    enced by the first index specification given to this
    program.  It contains a header entry designed to
    start the output index `help/index', and with this
    header entry, all the help index files, `help/
    demos', `help/problems', and `help/index', are men-
    tioned at the beginning of `help/index'.

    The -mail program option causes the ./mail directory
    to be made if it does not exist.  If it is made, its
    mode is set to a+x as is the mode of its parent and
    its parent's parent.  This last is necessary because
    the JAVA interpreter turns relative file names into
    absolute file names, requiring `a+x' permissions
    in the path from the root to the object file.

    The -help2 program option creates the ./contest/
    help2 directory if it does not exist.  It is simply
    linked to the ./contest/help directory.

    Note that the contestant's `help' command searches
    ./contest/help1, ./contest/help2, ./contest/help3,
    and ./contest/help4 in order for help files.  Thus
    files put in ./contest/help1 will override those
    in ./contest/help that is linked to ./contest/help2.

    The -secure program option makes the following if
    they do not exist:

	./contest/secure		    directory
	./contest/secure/hpcm_sendmail.rc   file
	./contest/secure/passwords	    file

    If any of these are made their modes are set to
    go-rw.  If the ./contest/secure/passwords file is
    made, instructions for editing it are written to
    ./TODO, but the file automatically made is empty.

    The ./contest/secure/passwords file consists of
    lines of the form

    	account:password:who:c-email:t-email:comment

    Here `account' is a the login name of the contes-
    tant, `who' is a description of who the contestant
    is, and the `c-email' and `t-email' fields are the
    email addresses used to contact the coach and to
    contact the team members using the account, respec-
    tively.  The account name `none' may be used to
    indicate a line is not associated with an account,
    and the password `none' may be used to indicate the
    password is to be assigned by other means.

    The -secure program option also causes any existing
    ./contest/secure/passwords file to be inspected for
    lines with empty passwords.  If any are found,
    random passwords are generated and inserted in place
    of the missing passwords.  The password `none' may
    be used in a line to prevent a random password from
    being generated and to prevent the hpcm_set_
    passwords program from setting the password of the
    line's account.

    The -ssh program option makes the file `./contest/
    extra_setup.tar' containing the file `.ssh/
    authorized_keys' which is the concatenation of all
    the files `~/.ssh/identity.pub, `~/.ssh/id_rsa.pub',
    and `~/.ssh/id_dsa.pub' that exist.  If none of
    these files exist, it is not an error, but instruc-
    tions to fix the situation are written in the ./TODO
    file.

    The -procmailrc program updates the ~/.procmailrc
    file with one entry for each autojudge address.  If
    `./contest/secure/hcpm_sendmail.rc' exists, one
    autojudge address is made from its contents.  The
    other autojudge addresses are listed in the
    `autojudge_addresses' global variable.  If there are
    no autojudge addresses, it is not an error, but
    instructions to fix the situation are written in the
    ./TODO file.

    The -who_where program option makes the ./contest/
    who_where file if it does not exist, or updates it
    if it does exist and the ./contest/secure/passwords
    file is newer.  The ./contest/who_where file is a
    copy of the ./contest/secure/passwords file with the
    passwords replaced by where values.  If any new
    places to insert a `where' value are made in the
    ./contest/who_where file, a ./TODO to edit the file
    is written.  There may be accounts in the `who_
    where' file that are not in the `passwords' file.
    Lines with account name `none' in the `passwords'
    file are not copied to the `who_where' file.

    The -trashable program option creates the ./contest/
    trashable file from the ./contest/secure/passwords
    file.  The `trashable' file is just a list of the
    accounts in the `passwords' file, not including the
    account name `none'.  The `trashable' file is up-
    dated by the -trashable option whenever the
    `passwords' file is newer than the `trashable' file.
    Whenever a `trashable' file is created, a ./TODO
    is written to delete the file as soon as all the
    accounts that should be trashed are trashed, in
    order to prevent further account trashing (the
    `TRASH_ACCOUNT' program will not work if the account
    in which it is run is not named in the `trashable'
    file).

    The -printer program option makes the ./contest/
    printer file if that file does not exist, and writes
    a ./TODO to edit the file when it is made.  It also
    makes the ./contest/printer_jobs file if that does
    not exist when ./contest/printer is made, and writes
    a ./TODO to consider deleting this file.

    The -printer_map program option is similar to the
    -printer option but makes a ./contest/printer_map
    file instead of a ./contest/printer file.  Note that
    if both the ./contest/printer and ./contest/printer_
    map files exist, contestant programs ignore ./con-
    test/printer.

    Although we have used the names `./info', `./mail',
    `./contest', and `./help' in this description, the
    actual directories are the info, mail, contest,
    help, etc. subdirectories of the judging_directory.
    The file names within these directories are literal-
    ly as given in this document.

    Like other HPCM programs, `makecontest' can be
    run from anywhere in the judge's directory subtree
    which is rooted by the directory containing the
    `hpcm_judging.rc' file.

    Unlike most HPCM judging programs, errors made by
    this program are not written to log files, but are
    announced on the standard error output."

# If no arguments are given, use the value of the
# makecontest_arguments global variable if that
# exists.
#
if {    $argc == 0 \
     && [info exists makecontest_arguments] } {
    set argv $makecontest_arguments
    set argc [llength $argv]
}

# Argi is the index of the current argument, for use in
# lindex.
#
set argi 0

# Set options, consuming option arguments.
#
set info_option			no
set solutions_option		no
set contest_option		no
set bin_option			no
set home_option			no
set problems_option		no
set demos_option 		no
set description_option		no
set help_option			no
set help2_option		no
set this_contest_option		no
set mail_option			no
set secure_option		no
set ssh_option			no
set procmailrc_option		no
set who_where_option		no
set trashable_option		no
set printer_option		no
set printer_map_option		no
#
set contest_type		""
#
while { $argi < $argc } {
    switch -- [lindex $argv $argi] {
        -formal		{ set solutions_option	yes
			  set contest_option	yes
			  set bin_option	yes
			  set home_option	yes
			  set problems_option	yes
			  set demos_option	yes
			  set help_option	yes
			  set help2_option	yes
			  set this_contest_option \
			  			yes
			  set mail_option	yes
			  set secure_option	yes
			  set procmailrc_option	yes
			  set who_where_option	yes
			  set printer_option	yes
			  set contest_type formal }
        -practice	{ set solutions_option	yes
			  set contest_option	yes
			  set bin_option	yes
			  set home_option	yes
			  set problems_option	yes
			  set demos_option	yes
			  set description_option \
			  			yes
			  set help_option	yes
			  set help2_option	yes
			  set this_contest_option \
			  			yes
			  set mail_option	yes
			  set secure_option	yes
			  set procmailrc_option	yes
			  set who_where_option	yes
			  set printer_option	yes
			  set contest_type practice }
        -informal	{ set info_option	yes
			  set contest_option	yes
			  set bin_option	yes
			  set home_option	yes
			  set solutions_option	yes
			  set help_option	yes
			  set help2_option	yes
			  set this_contest_option \
			  			yes
			  set mail_option	yes
			  set secure_option	yes
			  set procmailrc_option	yes
			  set who_where_option	yes
			  set printer_map_option \
			  			yes
			  set contest_type informal }
        -email		{ set info_option 	yes
			  set solutions_option	yes
			  set mail_option	yes
			  set this_contest_option \
			  			yes
			  set procmailrc_option	yes
			  set contest_type email }
        -info		{ set info_option 	yes }
        -solutions	{ set solutions_option 	yes }
        -contest	{ set contest_option 	yes }
        -bin		{ set bin_option 	yes }
        -home		{ set home_option 	yes }
        -problems	{ set problems_option 	yes }
        -demos		{ set demos_option 	yes }
        -description	{ set description_option \
						yes }
        -help		{ set help_option 	yes }
        -help2		{ set help2_option 	yes }
	-this_contest	{ set this_contest_option \
						yes }
        -mail		{ set mail_option 	yes }
        -secure		{ set secure_option 	yes }
        -ssh		{ set ssh_option 	yes }
	-procmailrc	{ set procmailrc_option	yes }
        -who_where	{ set who_where_option 	yes }
        -trashable	{ set trashable_option 	yes }
        -printer	{ set printer_option 	yes }
        -printer_map	{ set printer_map_option \
						yes }
	default		{ break }
    }
    incr argi
}

# If first remaining argument begins with `-', print
# documentation and exit with error.
#
if {    $argi < $argc \
     && [regexp {^-} [lindex $argv $argi]] } {
    puts $document
    exit 1
}

# Set up TODO
#
set TODO_file $j_d/TODO
set TODO_ch ""
set TODO_existed [expr { [file exists $TODO_file] \
                         && [file size $TODO_file] > 0 \
			 }]
proc TODO { args } {
    global TODO_file TODO_ch
    if { $TODO_ch == "" } {
    	set TODO_ch [open $TODO_file a]
	puts $TODO_ch \
	     "====================\
	      [clock format [clock seconds]] TODOs:"
    }
    puts $TODO_ch "--------"
    foreach line $args {
    	puts $TODO_ch "    $line"
    }
}

# Make 10 character random password.
#
random seed
proc make_password {} {
    return [format {%02x%02x%02x%02x%02x} \
		   [random 256] \
		   [random 256] \
		   [random 256] \
		   [random 256] \
		   [random 256]]
}

# The judging directory name relative to the home
# directory, for use in .procmailrc.  Note that j_d is
# absolute with no `/.'s or `/..'s: see above.
#
set j_d_relative $j_d
set hd $env(HOME)
if { ! [regexp "^$env(HOME)/(.*)\$" $j_d_relative \
               forget j_d_relative] } {
    error "$j_d_relative does not begin with $hd/"
}

# Make $c_d directory.
#
if { $contest_option } {
    if { [catch { file type $c_d }] } {
        set dir [file dirname $j_d]
    	# Note j_d has no /.'s or /..'s; see above.
	set tail [file tail $j_d]
	if { ! [regexp {^judging_(.*)$} $tail \
		       forget tail] } {
	    error "$j_d last component does not\
	           begin with `judging_' and ./contest\
		   does not exist"
	}
	regexp {^(.*)_[^_]+$} $tail forget tail
	if { ! [catch { file type \
	                     $dir/contest_$tail }] } {
	    error "$dir/contest_$tail exists and\
	           ./contest does not exist"
	}
	mkdir $dir/contest_$tail
	link_file $dir/contest_$tail $j_d/contest
	puts "Made $dir/contest_$tail"
	puts "     and linked ./contest to it"
    }
    if { ! [file isdirectory $c_d] } {
        error "$c_d is not a directory"
    }
}

# Check if ./contest does not exist when it is needed.
# If ./contest is needed, grant a+x access to it and its
# parent.
#
if {    $contest_option \
     || $bin_option \
     || $home_option \
     || $problems_option \
     || $demos_option \
     || $help_option \
     || $help2_option \
     || $secure_option \
     || $who_where_option \
     || $trashable_option \
     || $printer_option \
     || $printer_map_option } {
    if {    ! [file isdirectory $c_d] \
         || ! [file executable $c_d] \
         || ! [file readable $c_d] } {
	error "$c_d is not a useable directory"
    }
    puts "Granting a+x access"
    puts "         to $c_d"
    puts "         and its parent"
    grant_access $c_d x
    grant_access $c_d/.. x
}

# Make $c_d/bin directory.
#
if { $bin_option } {
    if {    [catch { file type $c_d/bin }] \
         && [file isdirectory \
	          $hpcm_directory/contestant/bin] } {
	link_file $hpcm_directory/contestant/bin \
	          $c_d/bin
	puts "Linked ./contest/bin to"
	puts "       $hpcm_directory/contestant/bin"
    }
    if { ! [file exists $c_d/bin] } {
        TODO "$c_d/bin does not exist." \
	     "Link ./contest/bin to\
	      ..../hpcm/contestant/bin"
    } elseif { ! [file isdirectory $c_d/bin] } {
        TODO "./contest/bin is not a directory." \
	     "Link it to ..../hpcm/contestant/bin"
    } elseif { ! [regexp {r.x} [get_access $c_d/bin]] \
    			} {
        TODO "./contest/bin is not a+rx." \
	     "Run `make' in ~/hpcm"
    }
}

# Make $c_d/home directory.
#
if { $home_option } {
    if { [catch { file type $c_d/home }] } {
        if {    [info exists hpcm_prototype_account] \
	     && $hpcm_prototype_account != "" } {
	    set phd [account_home_directory \
	               $hpcm_prototype_account]
	} else {
	    set hds {}
	    foreach hd [account_home_directories \
	    		    {[_-]proto}] {
		if {    [file readable $hd/home] \
		     && [file executable $hd/home] \
		     && [file readable \
		              $hd/home/empty.ls] \
		     && [file readable \
		              $hd/home/setup.ls] \
		     && [file readable \
		              $hd/home/setup.tar] } {
		    lappend hds $hd
		}
	    }
	    set phd ""
	    if { [llength $hds] == 1 } {
	        set phd [lindex $hds 0]
	    } elseif { [llength $hds] == 0 } {
	        set phd_error \
		    "No suitable *\[_-\]proto account\
		     found."
	    } else {
	        set phd_error \
		    "Too many prototype accounts found:\
		     $hds."
	    }
	}
	if { $phd != "" } {
	    link_file $phd/home $c_d/home
	    puts "Linked ./contest/home to" \
	    puts "      $phd/home"
	    set phd_error \
		"./contest/home is improper link."
	}
    } else {
        set phd_error \
	    "./contest/home is improper link."
    }

    if {    ! [file readable $c_d/home] \
         || ! [file executable $c_d/home] \
         || ! [file readable $c_d/home/empty.ls] \
         || ! [file readable $c_d/home/setup.ls] \
         || ! [file readable $c_d/home/setup.tar] } {
	TODO "$phd_error" \
	     "Be sure an appropriate\
	      prototype account exists:" \
	     "See `SETUP_PROTOTYPE -doc'" \
	     "Then symbolically link ./contest/home" \
	     "to ~prototype_account/home," \
	     "and rerun `makecontest -home'."
    }
    if { [file exists $c_d/home] \
         && ! [regexp {r.x} [get_access $c_d/home]] } {
    	TODO "While logged into prototype account," \
	     "chmod a+rx target-of-./contest/home"
    }
}

# Array specifying option substitutions.  For each
# op1 to be substituted for, the value of
#
#	option_array(op1)
#
# is the list of options that is the substitution.

# Expand a list of options and return the result.
#
proc expand_options { option_list } {

    global option_array

    set result ""
    foreach option $option_list {
        if { [info exists option_array($option)] } {
	    set result \
	        [concat $result \
			$option_array($option)]
	} else {
	    lappend result $option
	}
    }

    if { [info exists option_array(ALL)] } {
	set result \
	    [concat $result $option_array(ALL)]
	}

    return $result
}

# List of substitutions to be made in the names of the
# current input index file.  Each item of the list has
# the form `{source target}' which specifies that if a
# name begins with the string `source' that string
# should be replaced by the string `target'.
#
set substitutions ""

# Make the longest substitution possible in the
# name argument and return the result (or if
# there are no substitutions return the name
# argument).  If there is a length tie, apply
# the first substitution.
#
proc make_substitutions { name } {

    global substitutions

    set result $name
    set best_end -2

    foreach substitution $substitutions {
        set source [lindex $substitution 0]
	set end [string length $source]
	incr end -1

	if { [string range $name 0 $end] == $source \
	     && $best_end < $end } {
	    set target [lindex $substitution 1]
	    set best_end $end
	    incr end
	    set result [string range $name $end end]
	    set result $target$result
	}
    }

    return $result
}


# Process index specification using global variables
# as parameters:
#
#   index_file		the input index file name
#   index_directory	index directory name
#   help_index_chs	output help/index file channel
#			list; "" if none;  If there is
#			a help/index file, there may
#			in fact be two (one in ./info
#			and one in ./contest), so all
#			its lines must be written into
#			up to two channels, that are
#			listed here.
#   demos_index_chs	Ditto for help/demos file.
#   problems_index_chs	Ditto for help/problems file.
#   option_array	option substitutions
#			(see above)
#   substitutions	filename substitutions
#			(see above)
#   info_option		options
#   solutions_option
#   problems_option
#   demos_option
#   help_option
#   j_d			directory names
#   c_d

# Helper function called when ${targetdir}index_ch is ""
# to compute and return the correct value of this
# variable.
#
proc get_index_chs { targetdir } {

    global info_option help_option j_d c_d \
           help_index_chs problems_index_chs \
	   demos_index_chs \

    set chs ""
    if { $info_option || $help_option } {
	switch $targetdir {
	help		{ set file index
			  set head "Help Index" }
	problems	{ set file problems
			  set head "Problems Index" }
	demos		{ set file demos
			  set head "Demos Index" }
	}
	if { $info_option } {
	    lappend chs \
	    	    [open $j_d/info+/help/$file w]
	}
	if { $help_option } {
	    lappend chs [open $c_d/help+/$file w]
	}

	set ${targetdir}_index_chs $chs

	foreach ch $chs {
	    puts $ch [format {%-28s%28s} $head \
	    		     [clock format \
			     	    [clock seconds]]]
	    puts $ch ""
	    puts $ch ""
	}
    }
    return $chs
}

# Main function to process an index specification.
#
# Subfunction to read problem.rc file.
#
proc read_rc_file { file problem options } {
    global PROBLEM EXTENSION OPTIONS \
           problem_source_files \
	   problem_description_files \
	   problem_excluded_files
    set PROBLEM $problem
    set EXTENSION UNDEFINED
    set OPTIONS $options
    source_file $file
}
# Subfunction that returns true if item matches any
# regexp in a list of regexps.
#
proc index_match { item regexps } {
    foreach regexp $regexps {
        if { [regexp "^($regexp)\$" $item] } {
	    return 1
	}
    }
    return 0
}
#
# Subfunction to compute {description,source}_files.
# Directory names end in / or are empty.
#
proc index_find \
	{ dir subdir description_files_name \
	             source_files_name } {

    global problem_description_files \
    	   problem_source_files \
    	   problem_excluded_files

    upvar $description_files_name description_files
    upvar $source_files_name source_files

    foreach name [glob -directory $dir$subdir \
	               -nocomplain -- *] {

	set name [file tail $name]
	if { [index_match $name \
	                  $problem_excluded_files] } \
	    continue
	    
        if { [file isdirectory $dir$subdir$name] } {
	    index_find $dir $subdir$name/ \
	    		       description_files \
			       source_files
	} elseif { [file exists $dir$subdir$name] } {
	    if { [index_match \
	              $name \
		      $problem_description_files] } {
	        lappend description_files $subdir$name
	    } elseif { [index_match \
			    $name \
			    $problem_source_files] \
		     } {
	        lappend source_files $subdir$name
	    }
	}
    }
}
#
# Subfunction to grant access to a file and the
# subdirectories of a directory that contain it.
#
proc index_grant { dir file } {
    while { $file != "" && $file != "." } {
        grant_access $dir/$file
	set file [file dirname $file]
    }
}
#
# Subfunction to copy list of files from a source
# directory to a target directory, making target
# subdirectories as necessary.  If link is true,
# link instead of copy.  If copying, use index_
# grant to grant access to copy.
#
proc index_copy { source dest files link } {
    foreach file $files {
	file mkdir [file dirname $dest/$file]
	if { $link } {
	    link_file $source/$file $dest/$file
	} else {
	    copy_file $source/$file $dest/$file
	    index_grant $dest $file
	}
    }
}
#
proc process_index_specification {} {

    global index_file index_directory \
           help_index_chs problems_index_chs \
	   demos_index_chs \
           info_option solutions_option \
	   problems_option demos_option \
	   help_option description_option \
           j_d c_d \
	   problem_source_files \
	   problem_description_files \
	   problem_excluded_files

    # Save hpcm_judging.rc defined values of global
    # variables reset by PROBLEM.rc file.
    #
    set default_source_files \
        $problem_source_files
    set default_description_files \
        $problem_description_files
    set default_excluded_files \
        $problem_excluded_files

    # Be sure index directory is absolute name, else
    # symbolic links will fail.
    #
    if { ! [regexp {^/} $index_directory] } {
	set index_directory [pwd]/$index_directory
    }
    set index_directory \
        [scrub_filename $index_directory]

    # Read the input index file and process its entries.
    #
    set index_ch [open $index_file r]

    # Are we in header, in item, or neither (in a
    # skipped item or at beginning of file).
    #
    set in_header		no
    set in_item			no

    # The xxxx_index_chs value for a current index
    # item.
    #
    set index_chs		""

    # Last header entry encountered, and switches to
    # tell if it has been used in various indices.
    #
    set header_entry		""
    set help_header_used	no
    set demos_header_used	no
    set problems_header_used	no

    # Switches to tell if any items have been written
    # into the various indices.
    #
    set help_index_written	no
    set demos_index_written	no
    set problems_index_written	no

    while { "yes" } {

        # Read next input index line.
	#
	set line [gets $index_ch]
        if { [eof $index_ch] } break;

	# Skip comments.
	#
	if { [regexp {^#} $line] } continue;

	if {    ! [catch { set len [llength $line] }] \
	     && $len >= 1 \
	     && [lindex $line 0] == "***" } {

	    # Beginning of item entry.

	    set in_header	no

	    set name [lindex $line 1]
	    set options \
	        [expand_options [lrange $line 2 end]]
	    set source $index_directory/$name

	    # Check name for legality.
	    #
	    if { [regexp {(^|/)(\.|-)} $name] } {
	    	error "Illegal item name `$name' in\
		       `$index_file'."
	    }

	    # Compute `indent', the part of the first
	    # item entry line before the item name,
	    # with `***' replaced by three spaces.
	    #
	    set ws "\[\ \t\]*"
	    regexp "^($ws\\*\\*\\*$ws)(\[^\ \t\]|\$)" \
		   $line forget indent forget2
	    regsub {\*\*\*} $indent {   } indent

	    if { ! [lcontain $options include] } {

		# Item is not included.

	    	set in_item	no

	    } else {

	    	# Item is included.

		set in_item	yes

		set target [make_substitutions $name]

		# Check target for legality.
		#
		if { [regexp {(^|/)(\.|-)} $target] } {
		    error "Illegal item name `$name'\
		           after substitutions,\n\
			   \    in `$index_file'."
		}

		# Compute and check targetdir and
		# targettail such that $target ==
		# $targetdir/+$targettail and $targetdir
		# is the first component of the name
		# $target, and has no /'s.
		#
		# Targetdir must == `help', `demos', or
		# `problems'.
		#
		if { ! [regexp {^([^/]*)/+([^/].*)$} \
		               $target forget \
			       targetdir targettail] \
		     || ! [lcontain \
			     {help demos problems} \
			     $targetdir] } {
		    error "Bad item name directory\
		    	   after substitution: $target"
		}

	        # Compute output index channels associ-
		# ated with targetdir.
		#
	        set index_chs \
		    [set ${targetdir}_index_chs]

		if { $index_chs == "" } {
		    set index_chs \
		    	[get_index_chs $targetdir]
		}

		# Write headers to output indices if
		# appropriate.
		#
		if { [set ${targetdir}_header_used] \
		     == "no" } {
		    set ${targetdir}_header_used yes
		    if { $header_entry != "" } {
		        foreach ch $index_chs {
			    puts $ch $header_entry
			}
		    }
		}

		# Write first line of item entry, after
		# editing, to output indices, if appro-
		# priate.
		#
		foreach ch $index_chs {
		    puts $ch "$indent$target"
		}

		set ${targetdir}_index_written yes

		# Compute source and description files
		# if $source is a directory.
		#
		if { [file isdirectory $source] } {

		    # Compute needed global variables.
		    #
		    set problem_description_files \
		        $default_description_files
		    set problem_source_files \
		        $default_source_files
		    set problem_excluded_files \
		        $default_excluded_files
		    set PROBLEM [file tail $source]
		    read_rc_file \
		        $source/$PROBLEM.rc \
			$PROBLEM $options
		    if { [lcontain $options all] } {
		        set problem_source_files {.*}
		        set problem_description_files {}
		    }
		    set source_files {}
		    set description_files {}
		    index_find $source/ "" \
		        description_files source_files
		}

		# Process info option.
		#
		if { $info_option } {

		    set destination \
		    	$j_d/info+/$target

		    if { [file isfile $source] } {
			file mkdir \
			     [file dirname $destination]
			link_file $source $destination
		    } elseif { [file isdirectory \
		    		     $source] } {
			file mkdir $destination
			index_copy \
			    $source $destination \
			    [concat \
			       $source_files \
			       $description_files] \
			    1
		    } else {
		        error "Source `$source' is\
			       neither a file nor a\
			       directory."
		    }
		}

		# Process $targetdir option.
		#
		if { [set ${targetdir}_option] } {

		    set destination "$c_d/$targetdir+"
		    set destination \
		        "$destination/$targettail"
		    if { [file isfile $source] } {
			file mkdir \
			     [file dirname $destination]
			copy_file $source $destination
			index_grant $c_d/$targetdir+ \
				    $targettail
		    } elseif { [file isdirectory \
		    		     $source] } {
			file mkdir $destination
			index_grant $c_d/$targetdir+ \
				    $targettail
			
			set files $source_files
			if { $description_option } {
			    eval lappend files \
			         $description_files
			}
			index_copy \
			    $source $destination \
			    $files 0
		    } else {
		        error "Source `$source' is\
			       neither a file nor a\
			       directory."
		    }
		}

		# Process solutions option.
		#
		if { $solutions_option \
		     && [lcontain {problems demos} \
				  $targetdir] \
		     && ! [lcontain $options \
				    nosolution] } {
		    if { ! [file isdirectory $source] \
		    		} {
			error "$source solution is not\
			       a directory"
		    } elseif { [regexp {/} \
		    		       $targettail] } {
			error "`$targettail' is to be\
			       linked into the\
			       solutions directory but\
			       contains a `/'"
		    }
		    set s_d $j_d/solutions+
		    link_file $source $s_d/$targettail
		}
	    }

	} elseif { $in_header } {

	    # Line inside header.

	    set header_entry "$header_entry\n$line"

	} elseif { [regexp "^\[^\ \t\]" $line] } {

	    # Beginning of header entry.

	    set header_entry		$line
	    set in_header		yes
	    set in_item			no
	    set help_header_used	no
	    set demos_header_used	no
	    set problems_header_used	no

	} elseif { $in_item } {

	    # Line inside included item.

	    foreach ch $index_chs {
		puts $ch $line
	    }
	}
    }

    # If we copied any index entries, put out 2 blank
    # lines to separate this input index file's entries
    # from those of the next input index file.
    #
    foreach dir {help problems demos} {
        if { [set ${dir}_index_written] } {
	    foreach ch [set ${dir}_index_chs] {
	    	puts $ch ""
	    	puts $ch ""
	    }
	}
    }

    close $index_ch

    # Restore hpcm_judging.rc defined values of global
    # variables reset by PROBLEM.rc file.
    #
    set problem_source_files \
        $default_source_files
    set problem_description_files \
        $default_description_files
    set problem_excluded_files \
        $default_excluded_files
}

# Set up info+, solutions+, problems+, demos+, and
# help+ directories.
#
if { $info_option } {
    if { [file exists $j_d/info+] } {
        puts "Deleting $j_d/info+"
	file delete -force -- $j_d/info+
    }
    file mkdir $j_d/info+
    file mkdir $j_d/info+/help
}
foreach dir {problems demos help} {
    if { [set ${dir}_option] } {
	if { [file exists $c_d/$dir+] } {
	    puts "Deleting out-of-date $c_d/$dir+"
	    file delete -force -- $c_d/$dir+
	}
	file mkdir $c_d/$dir+
	if { $dir != "problems" } {
	    grant_access $c_d/$dir+
	}
    }
}
if { $solutions_option } {
    if { [file exists $j_d/solutions+] } {
        puts "Deleting $j_d/solutions+"
	file delete -force -- $j_d/solutions+
    }
    file mkdir $j_d/solutions+
}

# Make help directory.
#
if { $this_contest_option \
      && ! [file isdirectory $j_d/help] } {
    file mkdir $j_d/help
}

# Make help/index file.
#
if { $this_contest_option \
      && ! [file readable $j_d/help/index] } {
    set index_ch [open $j_d/help/index w]

    puts $index_ch "
To display the file listed as `help/topic' below use the
command:
                      help topic

E.g., `help index' displays this file.


Indices:
--------

    help/index
        This file.

    help/demos
        Index of contest demonstration problems.

    help/problems
        Index of contest problems.



Introductory Information:
-------------------------


*** this_contest include
        Information about this contest.
"

    close $index_ch
}

# Make help/this_contest file.
#
if { $this_contest_option \
      && ! [file readable \
      		 $j_d/help/this_contest] } {
    set tc_ch [open $j_d/help/this_contest w]

    puts $tc_ch [format {%-28s%28s} \
    			"About This Contest" \
		        [clock format \
			       [clock seconds]]]
    puts $tc_ch ""

    # Remember contest type, in effect, in $j_d/help/
    # this_contest_prototype.
    #
    if { ! [file exists \
                 $j_d/help/this_contest_prototype] } {
        if { $contest_type == "" } {
	    error "Cannot make $j_d/help/this_contest\
	           because contest type not specified."
	}
	set directory \
	    $contestant_help_directory/$contest_type
	set file ${contest_type}_this_contest_prototype
	link_file $directory/$file \
	          $j_d/help/this_contest_prototype
    }

    put_file $j_d/help/this_contest_prototype $tc_ch

    close $tc_ch

    TODO "Edit $j_d/help/this_contest." \
         "Then rerun makecontest to recompute help\
	  files."

    # For Email contest say something about .procmailrc.
    #
    if { ! [file isdirectory $c_d] } {
	TODO "Using the contest password you edited\
              into $j_d/help/this_contest," \
	     "edit ~/.procmailrc to contain:" \
	     "" \
	     ":0" \
	     "* ^To:.*password.*<" \
	     "| receivemail $j_d_relative | \\" \
	     "  dispatchmail $j_d_relative"
	TODO "You may want to add the following to\
	      the BEGINNING of your ~/.procmailrc" \
	     "file if you have not ALREADY done so.\
	     \  This will capture all mail the" \
	     "judge receives in ~/hpcm_mbox." \
	     "" \
	     ":0 c:" \
	     "hpcm_mbox"
    }
}

# Set up channel lists.
#
set help_index_chs	""
set demos_index_chs	""
set problems_index_chs	""

# Process arguments, forming index specifications
# encoded in global variables, and call process_index_
# specification (see above) for each specification.
#
set mode file
#
# Mode indicates what next argument should be: file,
# directory, or substitution.
#
foreach arg [lrange $argv $argi end] {

    # Process next argument.  Whether argument ends in
    # `,' or `:' tells mode of next argument.
    #
    if { $mode == "file" } {
    	if { [regexp {^(.*):$} $arg forget arg] } {
	    set mode directory
    	} else {
	    if { [regexp {^(.*),$} $arg forget arg] } {
		set mode substitution
	    }
	    set index_directory [file dirname $arg]
	}
	set index_file $arg
	set substitutions ""
	if { [array exists option_array] } {
	    unset option_array
	}
    } elseif { $mode == "directory" } {
    	if { [regexp {^(.*),$} $arg forget arg] } {
	    set mode substitution
	} else {
	    set mode file
	}
	set index_directory $arg
    } elseif { $mode == "substitution" } {
    	if { ! [regexp {^(.*),$} $arg forget arg] } {
	    set mode file
	}
	if { [regexp {^([^=]*)=([^=]*)$} $arg forget \
	               source destination] } {
	    lappend substitutions \
		    [list $source $destination]
	} elseif { [regexp {^([^:]*):([^:]*)$} \
	                   $arg forget \
	               source destination] } {
	    set option_array($source) \
	        [string trim $destination]
	} else {
	    error "Badly formatted substitution:\
	           `$arg'"
	}
    }

    if { $mode == "file" } {
    	process_index_specification
    }
}
if { $mode != "file" } {
    error "Last argument ends with `,' or `:'"
}

# Finish up index output files.
#
foreach dir {problems help demos} {
    foreach ch [set ${dir}_index_chs] {
        close $ch
    }
}
if { [file exists $c_d/help+/index] } {
    grant_access $c_d/help+/index
}
if { [file exists $c_d/help+/demos] } {
    grant_access $c_d/help+/demos
}

# Diff two directories.  If the only differences are the
# first lines of help indices, return `no'.  Else return
# `yes'.  Returning `yes' when one should have returned
# `no' introduces a lack of optimization, but no func-
# tional error.
#
proc diff_dirs { dir1 dir2 } {
    catch { diff_directories $dir1 $dir2 } out
    set out [split $out "\n"]

    while { [llength $out] > 0 } {
	set diffexp \
	  {^diff -r .*/([^/ ]*) .*/([^/ ]*)$}
	if { [regexp $diffexp [lindex $out 0] \
	             forget index1 index2] \
	     && $index1 == $index2 \
	     && [lcontain {demos problems index} \
			  $index1] } {
	    if { [lindex $out 1] != "1c1" } {
	    	return yes
	    } elseif { ! [regexp {^< [^ ]* Index} \
				  [lindex $out 2]] } {
	    	return yes
	    } elseif { [lindex $out 3] != "---" } {
	    	return yes
	    } elseif { ! [regexp {^> [^ ]* Index} \
				  [lindex $out 4]] } {
	    	return yes
	    }
	    set out [lrange $out 5 end]
	} elseif { [lindex $out 0] == \
		   "child process exited abnormally" } {
	    set out [lrange $out 1 end]
	} else {
	    return yes
	}
    }

    return no
}

# Rename directories iff $directory+ differs from
# $directory as determined by `diff_dirs'.  If a
# directory is not renamed, delete it.  Return `yes' if
# directory renamed, and `no' if deleted.
#
proc rename_directory { directory } {

    if { [diff_dirs $directory $directory+] \
         == "no" } {
    	puts "New $directory"
	puts "    does not differ from previous\
	      version."
	file delete -force -- $directory+
	return no
    } else {

	if { [file exists $directory--] } {
	    file delete -force -- $directory--
	}
	if { [file exists $directory-] } {
	    puts "Renaming $directory-"
	    puts "      to $directory--"
	    file rename $directory- $directory--
	    deny_access $directory--
	}
	if { [file exists $directory] } {
	    puts "Renaming $directory"
	    puts "      to $directory-"
	    file rename $directory $directory-
	    deny_access $directory-
	}
	if { [file exists $directory+] } {
	    puts "Renaming $directory+"
	    puts "      to $directory"
	    file rename $directory+ $directory
	}
	return yes
    }
}

if { $info_option } {
    rename_directory $j_d/info
}
if { $problems_option } {
    rename_directory $c_d/problems
}
if { $help_option } {
    rename_directory $c_d/help
}
if { $demos_option } {
    rename_directory $c_d/demos
}
if { $solutions_option } {
    rename_directory $j_d/solutions
}

if { ( $problems_option \
       && ! [regexp {r.x} \
       		    [get_access $c_d/problems]] ) \
     || \
     ( $help_option \
       && ! [regexp {r..} [get_access \
       			      $c_d/help/problems]] ) } {
    TODO "Run `startcontest' when contest starts" \
         "to chmod a+rx ./contest/problems" \
	 "and/or ./contest/help/problems." \
	 "Or run `startcontest delay' before contest\
	  starts."
}

# Make mail directory.
#
if { $mail_option \
      && ! [file isdirectory $j_d/mail] } {
    file mkdir $j_d/mail
    grant_access $j_d/mail x
    grant_access $j_d/mail/.. x
    grant_access $j_d/mail/../.. x
}

# Make $c_d/help2 directory.
#
if { $help2_option \
     && ! [file isdirectory $c_d/help2] } {
    if { ! [catch {
	      set help2_type \
		  [file type $c_d/help2] }] } {
	if { $help2_type == "link" } {
	    puts "Deleting $c_d/help2"
	    file delete -force -- $c_d/help2
	} else {
	    error "$c_d/help2 exists but is not a\
	           directory"
	}
    }
    link_file help $c_d/help2
}

# Make secure directory.
#
if { $secure_option \
     && ! [file isdirectory $c_d/secure] } {
    file mkdir $c_d/secure
    deny_access $c_d/secure
}

# Make or edit secure/passwords file.
#
if { $secure_option } {
    if { ! [file readable $c_d/secure/passwords] } {
	close [open $c_d/secure/passwords w]
	deny_access $c_d/secure/passwords
	set apw account:password:who
    	set ctc coaches-email:team-email:comment
	TODO "Edit ./contest/secure/passwords;" \
	     "each of its lines has the format:" \
	     "`$apw:$ctc'."
    } else {
        set passwords_ch [open $c_d/secure/passwords r]
	set lines ""
	set changed no
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    if { [regexp {^([^:]+)(|:|::.*)$} $line \
			 forget account forget2] } {
		set password [make_password]
		set rest ""
		regexp {^[^:]+:(:.*)$} $line \
		       forget rest
	        set line "$account:$password$rest"
		set changed yes
	    }
	    lappend lines $line
	}
	close $passwords_ch
	if { $changed} {
	    set passwords_ch \
	        [open $c_d/secure/passwords w]
	    foreach line $lines {
	        puts $passwords_ch $line
	    }
	    close $passwords_ch
	    TODO "Inspect ./contest/secure/passwords" \
		 "to which passwords have been added."
	}
    }
}

# Make secure/hpcm_sendmail.rc file.
#
if { $secure_option \
     && ! [file readable \
     		$c_d/secure/hpcm_sendmail.rc] } {
    set rc_ch [open $c_d/secure/hpcm_sendmail.rc w]
    set to_password [make_password]
    puts $rc_ch \
         "To: $to_password<[account_name]@[host_name]>"
    set key [make_password]
    puts $rc_ch "Key: $key"
    set key_name [file tail $j_d_relative]
    regexp {^(.*)(-|_)[^-_]*$} $key_name \
	   forget key_name forget2
    puts $rc_ch "Key-Name: $key_name"
    close $rc_ch
    deny_access $c_d/secure/hpcm_sendmail.rc


    # Check contest/bin/hpcm_sendmail mode.
    #
    if {    [file exists $c_d/bin/hpcm_sendmail] \
	 && ! [regexp {..s} \
	              [get_access \
		           $c_d/bin/hpcm_sendmail]] } {
	TODO "chmod u+s,a+x ./contest/bin/hpcm_sendmail"
    }
}

# Check secure directory and file modes minimally.
#
if { $secure_option } {
    if {    [file exists $c_d/secure] \
         && ! [regexp -- {---} \
	              [get_access $c_d/secure]] } {
        TODO "chmod o-rwx ./contest/secure"
    }
    if {    [file exists $c_d/secure/hpcm_sendmail.rc] \
         && ! [regexp -- {---} \
	              [get_access \
		        $c_d/secure/hpcm_sendmail.rc]] \
					} {
        TODO "chmod o-rwx\
	      ./contest/secure/hpcm_sendmail.rc"
    }
    if {    [file exists $c_d/secure/passwords] \
         && ! [regexp -- {---} \
	              [get_access \
		           $c_d/secure/passwords]] } {
        TODO "chmod o-rwx ./contest/secure/passwords"
    }
}

# Update ~/.procmailrc
#
if { $procmailrc_option } {
    set addresses $autojudge_addresses
    set to [lindex [read_sendmail_rc] 0]
    if { $to != "" } {
    	lappend addresses $to
    }
    if { [llength $addresses] == 0 } {
        TODO "There are no autojudge addresses" \
	     "Set the autojudge_addresses variable"
    }
    set passwords {}
    foreach to $addresses {
	set password ""
	regexp {^([^<]*)<} $to forget password
	set password [string trim $password]
	if { $password == "" } {
	    error \
	      "Cannot find autojudge password in\
	       address `$to'\nthat is\
	       in ./contest/secure/hpcm_sendmail.rc\
	       or autojudge_addresses"
	}
	if { ! [lcontain $passwords $password] } {
	    lappend passwords $password
	}
    }

    set add_mbox yes
    set mbox {(^|[ \t])hpcm_mbox($|[ \t])}
    set password ""
    set to_line ". . ."
    set dis {receivemail[ \t]+([^ \t]+)($|[ \t])}
    set original_passwords $passwords
    if { ! [catch { set ch [open ~/.procmailrc r] }] } {
        while { "yes" } {
	    set line [gets $ch]
	    if { [eof $ch] } break

	    if { [regexp {^[ \t]*#} $line] } {
	    	# comment line
	    } elseif { [regexp {^:} $line] } {
	    	# start of procmailrc entry
	        set password ""
		set to_line ". . ."
	    } elseif { [regexp {To:.*$} $line to] } {
		set password ""
	        regexp {^To:\.\*([^<]*)(<|$)} $to \
		       forget password
		set password [string trim $password]
		set to_line $line
		puts "PASSWORD $password"
		puts "TO_LINE $to_line"
	    } elseif {    [regexp $dis $line \
	                          forget dir] \
		       &&    [string trim $dir] \
		          == $j_d_relative } {
		set i [lsearch -exact \
			       $passwords $password]
		if { $password == "" } {
		    TODO "Bad entry in ~/.procmail" \
		    	 "    $to_line" \
			 "    $line" \
			 "    . . ." \
			 " Remove or fix entry."
		} elseif {   [lsearch \
		                -exact $password \
				$original_passwords] \
			   < 0 } {
		    TODO "Extra entry in ~/.procmail" \
		    	 "    $to_line" \
			 "    $line" \
			 "    . . ." \
			 "Remove entry or add address\
			  to autojudge_addresses\
			  global variable."
		} elseif { $i >= 0 } {
		    set passwords \
		        [lreplace $passwords $i $i]
		}
	    } elseif { [regexp $mbox $line] } {
	        set add_mbox no
	    }
	}
	close $ch
    }

    if { $add_mbox || [llength $passwords] > 0 } {
	set file [read_entire_file ~/.procmailrc]
	if { $add_mbox } {
	    set file ":0 c:\nhpcm_mbox\n\n$file"
	    puts "The following has been prepended\
		  to ~/.procmailrc:"
	    puts "    :0 c:"
	    puts "    hpcm_mbox"
	}
	foreach password $passwords {
	    set file "$file\n\n:0\n*\
		      ^To:.*$password\n|\
		      receivemail $j_d_relative | \\\n \
		      dispatchmail $j_d_relative"
	    puts "The following has been appended\
		  to ~/.procmailrc:"
	    puts "    :0"
	    puts "    * ^To:.*$password"
	    puts "    | receivemail $j_d_relative | \\"
	    puts "      dispatchmail $j_d_relative"
	}
	write_file ~/.procmailrc $file
    }
}

# Make $c_d/who_where
#
if { $who_where_option } {
    if { ! [file readable $c_d/secure/passwords] } {
        error "$c_d/secure/passwords does not exist\
	       for -who_where option"
    } elseif { ! [file readable $c_d/who_where] } {
	set who_where_ch [open $c_d/who_where w]
	set passwords_ch [open $c_d/secure/passwords r]
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    regexp {^([^:]*):} $line forget account
	    set rest ""
	    regexp {^[^:]*:[^:]*:(.*)$} $line \
	           forget rest
	    if { $account != "none" } {
		puts $who_where_ch \
		     "$account:WHERE:$rest"
	    }
	}
	close $passwords_ch
	close $who_where_ch
	grant_access $c_d/who_where

	TODO "Edit ./contest/who_where to specify\
				location" \
	     "of teams, by replacing `WHERE' for each" \
	     "account with a SHORT description of the" \
	     "team's location."
    } elseif { [file mtime $c_d/who_where] \
	       < [file mtime $c_d/secure/passwords] } {

	# Read $c_d/secure/passwords, decomposing the
	# lines into `$account:$password:$rest', saving
	# $rest in $passwords_array($account), and
	# making a list of accounts in the order their
	# lines were encountered in $passwords_accounts
	# 
	set passwords_ch [open $c_d/secure/passwords r]
	set passwords_accounts ""
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    regexp {^([^:]*)(:|$)} $line \
	           forget account forget2
	    set rest ""
	    regexp {^[^:]*:[^:]*:(.*)$} $line \
	           forget rest

	    if { $account != "none" } {
		set passwords_array($account) $rest
		lappend passwords_accounts $account
	    }
	}
	close $passwords_ch

	# The lines for the new who_where file are
	# put in the list $new_who_where.  $changed
	# is set `yes' if this is a change from the
	# old who_where file, and `no' otherwise.
	#
	set new_who_where ""
	set changed no

	# Read the old who_where file.  Copy the lines
	# into $new_who_where, changing the $rest part
	# to that taken from passwords, and recording
	# any actual changes in $changed.  Delete
	# $passwords_array($account) for any account
	# encountered in the old who_where file.
	#
	set who_where_ch [open $c_d/who_where r]
	while { "yes" } {
	    set line [gets $who_where_ch]
	    if { [eof $who_where_ch] } break

	    regexp {^([^:]*)(:|$)} $line \
	           forget account forget2
	    set where ""
	    regexp {^[^:]*:([^:]*)(:|$)} $line \
	    	   forget where forget2
	    set rest ""
	    regexp {^[^:]*:[^:]*:(.*)$} $line \
	           forget rest
	    if { [info exists \
	               passwords_array($account)] } {
	        set prest \
		    $passwords_array($account)
		if { $prest != $rest } {
		    lappend new_who_where \
		    	    "$account:$where:$prest"
		    set changed yes
		} else {
		    lappend new_who_where $line
		}
		unset passwords_array($account)
	    } else {
	        lappend new_who_where $line
	    }
	}
	close $who_where_ch

	# For the accounts in the order encountered in
	# the $c_d/secure/passwords file, if the account
	# is not in $new_who_where yet, add it.
	#
	foreach account $passwords_accounts {
	    if { [info exists \
	               passwords_array($account)] } {
		set prest $passwords_array($account)
		lappend new_who_where \
		        "$account:WHERE:$prest"
		set changed yes
	    }
	}

        # If $changed is `yes', write $new_who_where.
	#
	if { $changed } {
	    file delete -force -- $c_d/who_where
	    set who_where_ch [open $c_d/who_where w]
	    foreach line $new_who_where {
		puts $who_where_ch $line
	    }
	    close $who_where_ch
	    grant_access $c_d/who_where

	    TODO "Edit ./contest/who_where to specify\
					location" \
		 "of teams, by replacing `WHERE' for\
		 			each" \
		 "account with a SHORT description of\
		 			the" \
		 "team's location."
	}
    }
}

# Make $c_d/trashable
#
if { $trashable_option } {
    if { ! [file readable $c_d/secure/passwords] } {
        error "$c_d/secure/passwords does not exist\
	       for -trashable option"
    } elseif { ! [file readable $c_d/trashable] \
	       || [file mtime $c_d/trashable] \
	          < [file mtime $c_d/secure/passwords] \
		  	} {
	if { [file exists $c_d/trashable] } {
	    file delete -force -- $c_d/trashable
	}
	set trashable_ch [open $c_d/trashable w]
	set passwords_ch [open $c_d/secure/passwords r]
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    regexp {^([^:]*)(:|$)} $line \
	    	   forget account forget2
	    if { $account != "none" } {
		puts $trashable_ch $account
	    }
	}
	close $passwords_ch
	close $trashable_ch
	grant_access $c_d/trashable

	TODO "Remember to delete ./contest/trashable" \
	     "when your are done trashing accounts."
    }
}

# Printer_jobs pseudoswitch
#
set printer_jobs_option no

# Make $c_d/printer
#
if { $printer_option \
     && ! [file exists $c_d/printer] } {

    set printer_jobs_option yes

    if { [info exists env(PRINTER)] } {
	set printer $env(PRINTER)
    } else {
	set printer UNKNOWN
    }

    write_file $c_d/printer $printer
    grant_access $c_d/printer

    TODO "Wrote ./contest/printer to be `$printer';" \
         "edit ./contest/printer to change." \
	 "You may want to use ./contest/printer_map" \
	 "instead of ./contest/printer:" \
	 "see `hpcm/contestant/bin/printer_pipe -doc'."
}

# Make $c_d/printer_map
#
if { $printer_map_option \
     && ! [file exists $c_d/printer_map] } {

    set printer_jobs_option yes

    write_file $c_d/printer_map {.* !~/PRINTER}
    grant_access $c_d/printer_map

    TODO "Wrote ./contest/printer_map to be\
    		`.* !~/PRINTER';" \
         "edit ./contest/printer_map to change." \
	 "You may want to use ./contest/printer\
	    instead of $c_d/printer_map:" \
	 "see `hpcm/contestant/bin/printer_pipe -doc'."
}

# Make $c_d/printer_jobs
#
if { $printer_jobs_option \
     && ! [file readable $c_d/printer_jobs] } {
    close [open $c_d/printer_jobs w]
    grant_access $c_d/printer_jobs rw

    TODO "Delete ./contest/printer_jobs if you do not" \
         "want it to list all printer jobs."
}

# Finish TODO
#
set TODO_written [expr { $TODO_ch != "" }]
if { $TODO_written || $TODO_existed } {
    if { $TODO_written } {
	close $TODO_ch
    }
    set TODO_ch [open $TODO_file r]
    if { $TODO_existed } {
        if { $TODO_written } {
	    puts "==================== old+new TODO:"
	} else {
	    puts "==================== old TODO:"
	}
    } else {
	puts "==================== new TODO:"
    }
    while { "yes" } {
    	set line [gets $TODO_ch]
	if { [eof $TODO_ch] } break
	puts $line
    }
    puts "==================== end of TODO"
    close $TODO_ch
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
