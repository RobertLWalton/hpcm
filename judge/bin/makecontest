#!/bin/sh -f
#
# Make the subdirectories, symbolic links, and info
# index of a judging directory, and make the associated
# contest directory.
#
# File:		makejudgingdir
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Sep 24 23:11:51 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/09/25 03:45:55 $
#   $RCSfile: makecontest,v $
#   $Revision: 1.9 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_mode none
catch {

set document "
cd judging_directory
makejudgingdir options index_spec ...

  Options:
    -practice	Equals -info, -solutions, -mail
    -contest    Equals all options but -info and
		-trashable
    -info	Make ./info
    -solutions  Make ./solutions
    -problems	Make ./contest/problems
    -mail	Make ./mail
    -help	Make ./contest/help1/problems.help,
		     ./contest/help1/this_contest.help,
		     ./contest/help2 link
    -bin	Make ./contest/bin link
    -secure	Make ./contest/secure/passwords,
		     ./contest/secure/hpcm_sendmail.rc
    -who_where  Make ./contest/who_where
    -printer    Make ./contest/printer
    -setup      Import stuff from /tmp/hpcm_setup to
		./contest.  This should include
		empty.ls, setup.ls, and setup.tar
    -trashable  Make ./trashable
    -prototype  Make ./prototype

  Index Specification:

    index_file\[: index_directory\], name1s=name1t, \\
	  option1s:'option11t option12t ...', \\
	  name2s=name2t, ...

  Pre-Existing Files and Links:

    ./hpcm_judging.rc	 Parameters file.
    ./contest		 Link to contest directory.
    ./contest/contestant Link to hpcm/contestant.

    Given a judging directory as the current directory,
    complete with hpcm_judging.rc file, this program
    makes subdirectories, links, and problem index files
    in the judging directory and optional associated
    contest directory, according to instructions in the
    index specifications and options.  The form of the
    index specifications and options is given above.
    The `./contest' directory, if any, should be symbol-
    ically linked to the actual contest directory before
    this program is run.  In some cases `./contest
    /contestant' should be symbolically linked to the
    `..../hpcm/contestant' directory before this program
    is run.

    This program appends instructions for its user to
    edit certain files to the ./TODO file, and prints
    this file at the end of this program.

    The index files are read and concatenated to form
    the `index' file in any new info directory and a
    `problems.help' file in any new problems directory,
    with unused entries omitted.
    
    If an info directory is being made, symbolic links
    are made from it to problem directories referenced
    in the index file.  Ditto for the solutions
    directory.  The problems directory is similar but
    instead of making links, selected files are copied
    into subdirectories of the problems directory.

    If the program is building a ./info directory, it
    actually builds a ./info+ directory instead.  Then
    it does a `diff -r ./info ./info+', discarding the
    printed output, to determine if the new directory
    is any different from the previous directory.  If
    it is not different, the ./info+ directory is re-
    moved and nothing else is done.  If the two direc-
    tories are different, the following renaming
    occurs:

    		./info-	    becomes    ./info--
    		./info	    becomes    ./info-
    		./info+	    becomes    ./info

    A similar strategem is followed for ./solutions
    and ./contest/problems directories.

    Other files and directories are made if they do
    not exist or are out of date.  If this program does
    not have adequate information to make a file or
    directory, it writes instructions to the user in
    ./TODO.

    Each input index file is associated with an index
    directory.  An unedited version of the index file is
    normally found in its index directory.  Sometimes an
    edited copy of this index file is placed in the
    current judging directory, with the editing consist-
    ing of changes to the item entry options described
    below which control what is included in the new info
    and solutions directories.

    If no index directory is given in an index specifi-
    cation, it defaults to the directory that contains
    the index file given in the index specification.

    The index file consists of two types of entries:
    header entries and item entries.  Item entries begin
    with a line that starts with `***', followed by
    whitespace, and optionally preceded by whitespace.
    Header entries begin with a line that starts with
    neither whitespace nor `***'.  A header entry stops
    at the next line that begins an item entry, or at
    the end of file.  An item entry stops at the next
    line that begins a header or item entry, or at the
    end of file.

    The first line of an item entry has the form:

    	*** name options

    The item name is the name of a file or directory
    relative to the index directory (the directory
    normally containing the unedited index file).  The
    possible options are:

      info	  Include item in ./info directory.
      solutions	  Include item in ./solutions directory.
      problems	  Include item in ./contest/problems
      		  directory.
      all	  If info or problems option present,
                  include all readable files from this
		  item in the info or problems sub-
		  directory for this item.  Otherwise
		  if the item is a directory, only the
		  Makefile and *.txt file in the item
		  directory will be included in the
		  info or problems directory.

    These options are rarely encoded directly in the
    index files.  Instead options categorizing the
    entries are made up by the author of the index file
    and mapped by the index specification onto the above
    options.  Mapping is done by option substitution
    that occurs before the options are finally pro-
    cessed.  A substitution of the form:

    	option1s:'option11t option12t ...'

    in the index specification replaces option1s by the
    options in the list `option11t option12t ...'.
    Substitution is recursive.  After option substitu-
    tion, unknown options are ignored.

    If an item is included in the new info directory,
    the item entry is included in the index of that
    directory.  Otherwise the item entry is omitted.
    All header entries are included, no matter what.
    However, if no items at all from any of the input
    index files are included in the new info directory,
    the new index file for that directory is deleted,
    so that new info directory is completely empty.

    If an item is included in a new problems directory,
    the index item entry is included in a problems.help
    file that is included in the problems directory.
    No header items are included in the problems.help
    file.  However, if no items at all from any of the
    input index files are included in the new problems
    directory, no problems.help file is created, and
    the new problems directory is completely empty.

    When an item is included in the solutions directory,
    the item must itself be a directory, and the name of
    the item in the solutions directory is the last
    component of the item name.  This means that all
    problems in the system should have unique single
    component names.

    Ditto for the problems directory.

    When an item is included in the info directory its
    name in the info directory is a modified version of
    the item name.  Specifically, a substitution of the
    form nameXs=nameXt may be applied to the item name.
    If the item name begins with the nameXs string, that
    string will be replaced by nameXt.  If there are
    several possible substitutions, the longest nameXs
    will be selected, and if there are several longest,
    the first will be selected.
    
    Thus, for example, given an index specification of
    the form

    	my_index: foo/bar, public/=, \\
	          public/shelf/=old/

    then

    	public/frap	     becomes	frap
	public/shelf/frap    becomes	old/frap

    with the changed names being used as the names of
    the items within the info directory.

    When an item entry is copied to the index file of
    the new info directory, or to a problems.help file,
    the `***' in the first line of the entry is replace
    by 3 space characters, the item name is replaced by
    the name of the item directory within the info dir-
    ectory for ./info/index or the problems directory
    for ./problems/problems.help, and the options are
    removed.

    When ./mail is made (by -mail) its mode is set to
    a+x.

    When ./contest/help1 is made (by -help) its mode is
    set to a+rx.  Then ./contest/help1 /problems.help is
    symbolically linked to ./contest/problems/problems
    .help, and a default ./contest/help1/this_contest
    .help file is made.  None of these things is done if
    the directories and files to be made already exist.
    If the this_contest.help file is made, an instruc-
    tion to edit it is appended to the ./TODO file.

    The ./help2 directory is made by symbolically link-
    ing it to ./contestant/help.  Note that the help
    command searches ./help1, ./help2, ./help3, and
    ./help4 in order for help files.

    The ./bin directory is made by symbolically link-
    ing it to ./contestant/bin.

    When the ./secure directory is made (by -secure) its
    mode is set to go-rwx, as is the mode of every file
    made in this directory.  When the ./secure/passwords
    file is made, instructions for editing it are
    written to ./TODO, but the file made automatically
    is empty.  If the ./secure/hpcm_sendmail.rc file is
    made, instructions for editing it and the
    ~/.procmailrc file are written into ./TODO.

    If -secure is given and any line in ./secure
    /passwords has an empty password, a random password
    is generated and inserted in that file.

    When ./who_where is made, additions to any existing
    file are appended listing accounts in ./secure
    /passwords that were not in the previous ./who_
    where, and instructions for editing are written into
    TODO.  Instructions are also written if any fields
    of any previous who_where file have not been filled
    in.

    When ./printer is to be made, it is set by guess and
    instructions to edit it are written to ./TODO.

    If -setup is given, any files or directories in
    /tmp/hpcm_setup that do not match existing files or
    directories in . are copied to .  /tmp/hpcm_setup
    is maintained by running SETUP_PROTOTYPE in the
    prototype contestant account.  A check is made to be
    sure any copied file or directory is a+r and any
    executable file or directory is a+x.

    The ./trashable file is a list of contestant
    accounts made from ./secure/passwords.  The
    ./prototype file is the list of prototype contes-
    tant accounts (usually only one).  To run TRASH_
    ACCOUNT an account must be listed in ./trashable.
    To run TRASH_PROBLEMS it must be listed in
    ./prototye or ./trashable.  To run SETUP_PROTOTYE
    it must be listed in ./prototype.  Generally
    ./trashable is made when needed and then deleted
    to ensure that contestants cannot damage themselves
    by perversly running TRASH_ACCOUNT or TRASH_
    PROBLEMS.

    If anything is made in ./contest, a+x is set for
    that directory and all its ancestors.  If anything
    is linked to ./contestant, ditto.  If ./mail is
    made, ditto.  Note that `cd .../hpcm; make' should
    be run to set up the contestant directory.  If any
    file or directory modes seem wrong, notes are
    written to ./TODO.

    The `./mail' directory name above is actually
    specified as a hpcm_judging.rc parameter, and could
    be set to something else.  Ditto for `./info' and
    `./solutions'.  All other names are NOT determined
    by hpcm_judging.rc, and are literally as given
    above.
    
    Unlike most HPCM judging programs, errors made by
    this program are not written to log files, but are
    announced on standard error."

# Argi is the index of the current argument, for use in
# lindex.
#
set argi 0

# Set options, consuming option arguments.
#
set info_option		no
set solutions_option	no
set problems_option	no
set mail_option		no
set help_option		no
set bin_option		no
set secure_option	no
set who_where_option	no
set printer_option	no
set setup_option	no
set trashable_option	no
set prototype_option	no
#
while { "yes" } {
    if { $argi >= $argc } break;
    switch -- [lindex $argv $argi] {
        -practice	{ set info_option 	yes
			  set solutions_option	yes
			  set mail_option	yes }
        -contest	{ set solutions_option	yes
			  set problems_option	yes
			  set mail_option	yes
			  set help_option	yes
			  set bin_option	yes
			  set secure_option	yes
			  set who_where_option	yes
			  set printer_option	yes
			  set setup_option	yes
			  set prototype_option	yes }
        -info		{ set info_option 	yes }
        -solutions	{ set solutions_option 	yes }
        -problems	{ set problems_option 	yes }
        -mail		{ set mail_option 	yes }
        -help		{ set help_option 	yes }
        -bin		{ set bin_option 	yes }
        -secure		{ set secure_option 	yes }
        -who_where	{ set who_where_option 	yes }
        -printer	{ set printer_option 	yes }
        -setup		{ set setup_option 	yes }
        -trashable	{ set trashable_option 	yes }
        -prototype	{ set prototype_option 	yes }
	default		{ break }
    }
    incr argi
}

# If no arguments left or first remaining argument
# begins with `-', print documentation and exit with
# error.
#
if { $argi >= $argc \
     || [regexp {^-} [lindex $argv $argi]] } {
    puts $document
    exit 1
}

# Check for some elementary errors, such as ./contest
# not existing if it is needed.
#
if { $problems_option \
     || $help_option \
     || $bin_option \
     || $secure_option \
     || $who_where_option \
     || $setup_option \
     || $trashable_option \
     || $prototype_option } {
    if { ! [file isdirectory "contest"] \
         || ! [file executable "contest"] \
         || ! [file readable "contest"] } {
	error "`./contest' is not a useable directory"
    }
}
if { $help_option \
     || $bin_option } {
    if { ! [file isdirectory "contest/contestant"] \
         || ! [file executable "contest/contestant"] \
         || ! [file readable "contest/contestant"] } {
	error "`./contest/contestant' is not a useable\
	       directory"
    }
}

# Set up info+ and solutions+ directories and new
# index file.
#
if { [file exists $info_directory+] } {
    exec rm -rf $info_directory+ >@ stdout
}
if { [file exists $solutions_directory+] } {
    exec rm -rf $solutions_directory+ >@ stdout
}
file mkdir $info_directory+
file mkdir $solutions_directory+
set newindex_ch [open $info_directory+/index w]

# Array specifying option substitutions.  For each
# op1 to be substituted for, the value of
#
#	option_array(op1)
#
# is the list of options that is the substitution.

# Expand a list of options and return the result.
# Do not let the depth of expansion run away.
#
proc expand_options { option_list { depth 0 } } {

    global option_array

    if { $depth > 100 } {
    	error "Infinite recursive option substitution"
    }

    set result ""
    foreach option $option_list {
        if { [info exists option_array($option)] } {
	    set result \
	        [concat $result \
		        [expand_options \
			    $option_array($option) \
			    [expr { $depth + 1 }]]]
	} else {
	    lappend result $option
	}
    }

    return $result
}

# List of substitutions to be made in the names
# of the current input index file.  Each item of
# the list has the form `{source target}' which
# specifies that if a name begins with the
# string `source' that string should be replaced
# by the string `target'.
#
set substitutions ""

# Make the longest substitution possible in the
# name argument and return the result (or if
# there are no substitutions return the name
# argument).  If there is a length tie, apply
# the first substitution.
#
proc make_substitutions { name } {

    global substitutions

    set result $name
    set best_end -1

    foreach substitution $substitutions {
        set source [lindex $substitution 0]
	set end [string length $source]
	incr end -1

	if { [string range $name 0 $end] == $source \
	     && $best_end < $end } {
	    set target [lindex $substitution 1]
	    set best_end $end
	    incr end
	    set result [string range $name $end end]
	    set result $target$result
	}
    }

    return $result
}


# Process index specification using global variables
# as parameters:
#
#   index_file		the input index file name
#   index_directory	index directory name
#   newindex_ch		output index file channel
#   option_array	option substitutions
#			(see above)
#   substitutions	filename substitutions
#			(see above)
#
proc process_index_specification {} {

    global index_file index_directory newindex_ch \
           info_directory solutions_directory

    # Be sure index directory is absolute name, else
    # symbolic links will fail.
    #
    if { ! [regexp {^/} $index_directory] } {
	set index_directory [pwd]/$index_directory
    }

    # Read the input index file and process its entries.
    #
    set index_ch [open $index_file r]
    set mode copy
    set did_copy no

    while { "yes" } {

        # Read next input index line.
	#
	set line [gets $index_ch]
        if { [eof $index_ch] } break;

	if { [llength $line] >= 1 \
	     && [lindex $line 0] == "***" } {

	    # Beginnning item entry.

	    set name [lindex $line 1]
	    set options \
	        [expand_options [lreplace $line 0 1]]

	    # Process info option.
	    #
	    if { [lsearch -exact $options info] >= 0 } {

	        set source $index_directory/$name
		set target [make_substitutions $name]

		set mode copy
		set ws "\[\ \t\]*"
		regexp \
		    "^($ws\\*\\*\\*$ws)(\[^\ \t\]|$)" \
		    $line forget indent forget2
		regsub {\*\*\*} $indent {   } indent
		puts $newindex_ch "$indent$target"
		set did_copy yes

		set target $info_directory+/$target

		if { [lsearch -exact $options all] \
		     >= 0 \
		     || [file isfile $source] } {
		    file mkdir [file dirname $target]
		    link_file $source $target
		} else {
		    file mkdir $target
		    link_file $source/Makefile \
		              $target/Makefile
		    set problem [glob $source/*.txt]
		    if { [llength $problem] != 1 } {
			error "Too many or too few\
			       $source/*.txt files"
		    }
		    set problem [file tail $problem]
		    link_file $source/$problem \
		              $target/$problem
		}
	    } else {
		# Come here if no `info' option.
	    	set mode nocopy
	    }

	    # Process solution option.
	    #
	    if { [lsearch -exact $options solution] \
	         >= 0 } {
	        set source $index_directory/$name
		if { ! [file isdirectory $source] } {
		    error "$source is not a directory"
		}
	        set sdp $solutions_directory+
	        link_file $source \
			  "$sdp/[file tail $name]"
	    }
	} elseif { $mode == "copy" } {

	    # Line inside entry being copied.
	    
	    puts $newindex_ch $line
	} elseif { [regexp "^\[^\ \t\]" $line] } {

	    # Beginning of header entry.

	    puts $newindex_ch $line
	    set mode copy
	    set did_copy yes
	}
    }

    # If we copied any entries, put out 2 blank lines to
    # separate this input index file's entries from
    # those of the next input index file.
    #
    if { $did_copy } {
    	puts $newindex_ch ""
    	puts $newindex_ch ""
    }

    close $index_ch
}

# Process arguments, forming index specifications
# encoded in global variables, and call process_index_
# specification (see above) for each specification.
#
set mode file
#
# Mode indicates what next argument should be: file,
# directory, or substitution.
#
foreach arg [lreplace $argv 0 [expr { $argi - 1 }]] {

    # Process next argument.  Whether argument ends in
    # `,' or `:' tells mode of next argument.
    #
    if { $mode == "file" } {
    	if { [regexp {^(.*):$} $arg forget arg] } {
	    set mode directory
    	} else {
	    if { [regexp {^(.*),$} $arg forget arg] } {
		set mode substitution
	    }
	    set index_directory [file dirname $arg]
	}
	set index_file $arg
	set substitutions ""
	foreach opt [array names option_array] {
	    unset option_array($opt)
	}
    } elseif { $mode == "directory" } {
    	if { [regexp {^(.*),$} $arg forget arg] } {
	    set mode substitution
	} else {
	    set mode file
	}
	set index_directory $arg
    } elseif { $mode == "substitution" } {
    	if { ! [regexp {^(.*),$} $arg forget arg] } {
	    set mode file
	}
	if { [regexp {^([^=]*)=([^=]*)$} $arg forget \
	               source destination] } {
	    lappend substitutions \
		    [list $source $destination]
	} elseif { [regexp {^([^:]*):([^:]*)$} \
	                   $arg forget \
	               source destination] } {
	    set option_array($source) \
	        [string trim $destination]
	} else {
	    error "Badly formatted substitution:\
	           `$arg'"
	}
    }

    if { $mode == "file" } {
    	process_index_specification
    }
}

# Finish up output index file.
#
if { $mode != "file" } {
    error "Last argument ends with `,' or `:'"
}
close $newindex_ch
if { [llength [glob -nocomplain \
                    $info_directory+/*]] == 1 } {
    file delete -force $info_directory+/index
}

# Make mail directory.
#
file mkdir $mail_directory
exec chmod a+x $mail_directory >@ stdout

# Move directories.
#
if { [file exists $solutions_directory-] } {
    exec rm -rf $solutions_directory- >@ stdout
}
if { [file exists $info_directory-] } {
    exec rm -rf $info_directory- >@ stdout
}
if { [file exists $solutions_directory] } {
    file rename $solutions_directory \
                $solutions_directory-
}
if { [file exists $info_directory] } {
    file rename $info_directory $info_directory-
}
file rename $solutions_directory+ $solutions_directory
file rename $info_directory+ $info_directory

exit 0

# Include common error catching code:
#
} caught_output
caught_error
