#!/bin/sh
#
# Make the subdirectories, symbolic links, and indices
# of a judging directory and its associated contest
# directory.
#
# File:		makejudgingdir
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Jan 27 09:01:30 EST 2002
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2002/01/27 14:05:32 $
#   $RCSfile: makecontest,v $
#   $Revision: 1.78 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# List of last component names of subdirectories that
# are NOT to be recursively copied.
#
set omitted_directories {CVS RCS}

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_mode none
catch {

set document "
makejudgingdir option ... index_specification ...

  Options:
    -email	Sets up an email contest.  Equals -info,
    		-solutions, -mail, and -this_contest.
    -formal     Sets up a formal contest.  Equals all
    		options but -info, -trashable,
		-description, and -printer_map.
    -informal   Sets up an informal contest.  Equals all
    		options but -problems, -demos,
		-trashable, -description, and -printer.
    -info	Make ./info, ./info/help/index,
    		./info/help/problems, ./info/help/demos.
    -solutions  Make ./solutions
    -problems	Make ./contest/problems.  Includes
    		problem description files for non-`all'
		directory entries only if -description
		is given.
    -demos	Make ./contest/demos.  Includes
    		problem description files for non-`all'
		directory entries only if -description
		is given.
    -description     Include problem description (.txt,
    		.html, .ps, etc.) files in ./contest/
		problems or ./contest/demos. 
    -help	Make ./contest/help,
    		     ./contest/help/index,
    		     ./contest/help/problems,
    		     ./contest/help/demos
    -help2	Make ./help2
    -this_contest    Make ./help, ./help/index,
		          ./help/this_contest
    -mail	Make ./mail
    -bin	Make ./contest/bin
    -secure	Make ./contest/secure/passwords,
		     ./contest/secure/hpcm_sendmail.rc
    -who_where  Make ./contest/who_where
    -trashable  Make ./contest/trashable

    -printer    Make ./contest/printer and
    		     ./contest/printer_jobs
    -printer_map    Make ./contest/printer_map and
    		         ./contest/printer_jobs
    -home	Make ./contest/home

  Index Specification:

    index_file\[: index_directory\], name1s=name1t, \\
	  option1s:'option11t option12t ...', \\
	  name2s=name2t, ...

  Pre-Existing Files and Links:

    ./hpcm_judging.rc	 Parameters file.
    ./contest		 Link to contest directory.
    ./contest/contestant Link to hpcm/contestant.
    ./contest/home	 Link to directory owned by
    			 prototype account.



    Given a judging directory as the current directory,
    complete with hpcm_judging.rc file, this program
    makes subdirectories, links, and index files in the
    judging directory and optional associated contest
    directory, according to instructions in the index
    specifications and options.  The form of the index
    specifications and options is given above.

    The `./contest' directory, if any, should be symbol-
    ically linked to the actual contest directory before
    this program is run.  If the `./contest' directory
    is needed, the `./contest/contestant' directory
    should be symbolically linked to the `..../hpcm/
    contestant' directory and the `./contest/home'
    directory should be symbolically linked to a direc-
    tory that has been set up by the `SETUP_PROTOTYPE'
    program and is owned by the prototype account.

    This program appends instructions for its user to
    edit certain files and run certain programs to the
    ./TODO file, and prints this file at the end of this
    program (unless it is empty).

    The index files are read and used to generate a list
    of items to be included in the ./info and ./contest
    directories.  Each item is a file or directory, and
    corresponds to an item entry in an index file.  The
    item entry has the form:

    	*** item_name item_option ...
	    Text describing the item.

    Items have names which, after optional substitutions
    described below, must begin with `help/', `demos/',
    or `problems/', depending the subdirectory of ./info
    or ./contest into which the item is to be included.
    Only the three subdirectories just mentioned are
    allowed.  The item entry of each included item is
    copied into an output index file, which is the
    `help/index' file if the item name begins with
    `help/', the `help/problems' file if the item name
    begins with `problems/', or the `help/demos' file
    if the item name begins with `demos/'.

    When an item entry is copied to an output index,
    the `***' in the first line of the entry is replace
    by 3 space characters, the item name is replaced by
    the name after substitutions, and the options are
    removed.

    The input index files also contain header entries
    that precede item entries.  When an item entry is
    copied into an output index, the header entry im-
    mediately preceding it is copied into the same out-
    put index.  More specifically, a header entry is
    copied if it is separated from the item entry being
    copied only by other item entries.

    Lastly, any line beginning with `#' in an input
    index file is a comment line that is completely
    ignored, as if it did not exist.

    When an item is included in the ./info directory,
    a symbolic link is made to the item if it has the
    item `all' option, or if it is a file.  If it is
    a directory with no `all' option, a new directory
    is created containing a symbolic link to any problem
    source and description files in the directory.  The
    exact definitions of problem source and description
    files are given below, but by default, Makefile is
    the only source file, and files such as *.txt files
    files are description files.  Problem description
    file links are included within the ./info directory
    even if no -description program option is given.

    When an item is included in the ./contest directory
    (i.e., in ./contest/demos, ./contest/problems, or
    ./contest/help) files are copied and new directories
    are made.  Access is granted using a+r and a+rx file
    and directory modes, except that
    
    		./contest/problems 
    		./contest/help/problems

    are left with og-rx mode.  The `startcontest' prog-
    ram sets the mode of these to a+rx.  For a directory
    item with no `all' option, the item's problem source
    files are copied, and the item's problem description
    files are copied if and only if the -description op-
    tion is given.  For directory items with the `all'
    option, the directory is copied recursively, except
    no subdirectories whose last component name is `CVS'
    or `RCS' are copied.

    If we consider the directory pairs:

    	./info/demos		./contest/demos
    	./info/problems		./contest/problems
    	./info/help		./contest/help

    then if both directories of a pair are made, both
    are identical after symbolic links are followed,
    except that if there is no -description option,
    problem description files are generally copied into
    ./info/demos and ./info/problems subdirectories but
    not into ./contest /demos or ./contest/problems
    subdirectories.  But if the -description option is
    given, the UNIX `diff -r' command should report the
    two directories in each of the above pairs to be
    identical.

    Directory items may also be included in the
    ./solutions directory.  In this directory the item
    name after substitutions is stripped of any direc-
    tory prefix; e.g., the name `demos/count' becomes
    `count'.  The inclusion here is by symbolic link
    from directory to directory: e.g. `./solutions
    /count' is symbolically linked to the item direc-
    tory.  This means that all demos and problems in the
    contest must have unique single component names
    (except for items with the `nosolution' item option:
    see below).  The name of a solvable demo or problem
    is also the basename of the solution file submitted
    for the demo or problem.

    If this program is building a ./info directory, it
    actually builds a ./info+ directory instead.  Then
    it does a `diff -r ./info ./info+', and checks the
    output to see if there is any difference between
    ./info and ./info+ except for the first lines of
    the help indices (help/demos, help/problems, and
    help/index).  If there are no differences, the
    ./info+ directory is removed and nothing else is
    done.  If the two directories have other differ-
    ences, the following renaming occurs:

    		./info-	    becomes    ./info--
    		./info	    becomes    ./info-
    		./info+	    becomes    ./info

    A similar stratagem is followed for ./solutions,
    ./contest/problems, ./contest/demos, and .contest/
    help.

    The item entries and header entries are in input
    index files, each of which is referenced in a sep-
    arate index specification.  The format of an index
    specification is given above: it is a sequence of
    arguments, all but the last of which end in either a
    `:' or a `,'.  The `:' indicates the next argument
    is an index directory name (see below) and the `,'
    indicates the next argument is either a name sub-
    stitution or an option substitution (also see
    below).

    Each input index file is associated with an index
    directory.  An unedited version of the index file is
    normally found in its index directory.  Sometimes an
    edited copy of this index file is placed in the
    current judging directory, with the editing consist-
    ing of changes to the item entry options described
    below which control what is included in the new
    info, contest, and solutions directories.  Often,
    however, an edited copy of the index file need not
    be made, because item entry option mapping, describ-
    ed below, is sufficient.

    An index directory may optionally be given in a
    specification by ending the first argument of the
    specification, which names the index input file,
    with a `:', and giving the name of the index direc-
    tory as the second argument in the specification
    (with an optional ending `,').  If no index direc-
    tory is given in an index specification, the direc-
    tory that contains the index file is used as the
    index directory.

    The index file consists of two types of entries:
    header entries and item entries.  Item entries begin
    with a line that starts with `***', followed by
    whitespace, and optionally preceded by whitespace.
    Header entries begin with a line that starts with
    neither whitespace nor `***' followed by whitespace.
    A header entry stops at the next line that begins an
    item entry, or at the end of file.  An item entry
    stops at the next line that begins a header or item
    entry, or at the end of file.

    As noted above, the first line of an item entry has
    the form:

    	*** item_name item_option ...

    The item name is the name of the item file or direc-
    tory relative to the index directory (the directory
    normally containing the unedited index file).  The
    possible item options are:

      include	  Include item in the ./info and
      		  ./contest directories, and in the
		  ./solutions directory if the
		  `nosolution' item option is absent
		  and the item name after substitutions
		  begins with `demos/' or `problems/'.

      nosolution  Do NOT include the item in the 
                  ./solutions directory, even if the
		  item name after substitutions begins
		  with `demos/' or `problems/'.

      all	  If the `include' item option is pre-
      		  sent and this item names a directory,
                  include all readable files from this
		  item directory in ./info or ./contest.
		  Files are included from subdirectories
		  recursively, except that subdirector-
		  ies whose last component is `CVS' or
		  `RCS' are ignored when copying to
		  ./contest subdirectories.

		  Otherwise, if the item does not have
		  an `all' option, only the Makefile and
		  problem description files in the item
		  directory will be included, with the
		  problem description files being in-
		  cluded always for ./info subdirector-
		  ies, but only if the `-description'
		  program option is given to the
		  `makejudgingdir' program for ./contest
		  subdirectories.

      .XXX	  Where `.XXX' is any extension listed
      		  in the `allowed_extensions' global
		  variable.  Options of this form are
		  used in conjunction with files named
		  `$files_file.XXX' to determine the\
		  	problem
		  source and description files of a di-
		  rectory: see below.


    The `include' option is rarely encoded directly in
    the index files.  Instead options categorizing the
    entries are made up by the author of an index file
    and mapped by the index specification to the
    `include' option.  Mapping is done by option substi-
    tution that occurs before the options are finally
    processed.  A substitution of the form:

    	option1s:'option11t option12t ...'

    in the index specification replaces option1s by the
    options in the list `option11t option12t ...'.
    As a special case, if `option1s' is `ALL', the
    options in the list `option11t option12t ...' are
    always added to the substitution result without
    replacing any option in the original option list.
    Substitution is NOT recursive: it is done only on
    options appearing in the item entries in the index
    files, and not on options that are the result of
    substitution.  After substitutions are done, unknown
    options are ignored.

    If an item has the `include' option after option
    substitutions, the item entry is included in an out-
    put index within the ./info directory.   The indices
    are

    	   index		for items named

      ./info/help/index	    ./info/help/...
      ./info/help/demos	    ./info/demos/...
      ./info/help/problems  ./info/problems/...

    There is a similar inclusion for the ./contest dir-
    ectory.

    When an item entry is included in an output index,
    the header entry preceding it is included if it is
    separated from the item entry only by item entries
    that were not included in that output index.  Thus
    a header entry is associated with the consecutive
    item entries that follow it, and the header entry is
    included in an output index if and only if any of
    these item entries is included.  The header entry
    may end up being included in several output indices
    if the item entries following it are included in
    several different output indices.

    The program options -demos, -problems, and -help can
    be used by omission to prevent the ./contest/demos,
    ./contest/problems, or ./contest/help directories
    from being created, but program options never affect
    the content of any output indices that are created.

    The name of an item is a modification of the name
    of the item as it appears in the input index file
    item entry.  The modification results from substitu-
    tions specified in the index specification.  Spec-
    ifically, a substitution of the form `nameXs=nameXt'
    may be applied to the item name.  If the item name
    begins with the nameXs string, that string will be
    replaced by nameXt.  If there are several possible
    substitutions, the longest nameXs will be selected,
    and if there are several longest, the first will be
    selected.

    Thus, for example, given an index specification of
    the form

    	my_index: foo/bar, public/=problems/, \\
	          public/shelf/=problems/old/

    then

      public/foo2	   becomes    problems/foo2
      public/shelf/foo1    becomes    problems/old/foo1

    with the changed names being used as the names of
    the items within the ./info and ./contest
    directories and as the names of the item in any
    output index files.

    When an index item names a problem or demo directory
    and the `all' option is not given, it is necessary
    to determine the problem (or demo) source and de-
    scription files.  In this case the directory is in-
    spected for a file named `$files_file' and for files\
    	with
    names of the form `$files_file.*', and the set of\
    	options
    is inspected for options equal to extensions listed
    in the `allowed_extensions' variable, which defaults
    to:
    	$allowed_extensions

    If the set of options that are allowed extensions is
    not empty, then the files named `$files_file.XXX'\
    	where
    .XXX is an allowed extension that is an option are
    selected to determine the source and description
    files of the directory, and it is an error if there
    are no such files.  If there are no allowed exten-
    sion options, then any file named `$files_file' and\
    	all
    files with names of the form `$files_file.*' are\
    	selected,
    and if there are no such files, a default is use
    that is equivalent to selecting a file whose value
    is:

    	-SOURCE-	Makefile
	-DESCRIPTION-	<problem description files>

    where the problem description files are any files
    whose base name is the base name of the directory
    and whose extension is one of those listed in the
    `problem_description_extensions' global variable
    that defaults to:
    	$problem_description_extensions

    Any selected `$files_file*' file is interpreted as a\
    	TCL
    list (with list elements separated by spaces, tabs,
    or new lines) whose elements are special symbols,
    file names, and { } bracketed sublists.  The special
    symbols consist of upper case letters and the `-'
    character, and begin and end with `-'.  All list
    items following a special symbol S but before the
    next special symbol are governed by S.  This program
    understands the following two special symbols:

    	-SOURCE-	The list items governed by
			-SOURCE- are the problem or demo
			source file names.
    
    	-DESCRIPTION-	The list items governed by
			-DESCRIPTION- are the problem or
			demo description file names.

    List items governed by other special symbols are
    ignored by this program.  There is an implied
    `-REQUIRED-' before the beginning of the list, that
    governs list items appearing before any special
    symbol in the list.  The same special symbol can
    appear multiple times in the list.  A single file
    name can be listed several times as -SOURCE- or
    several times as -DESCRIPTION- but may not be both
    -SOURCE- and -DESCRIPTION-.

    If several `$files_file*' files are selected, they\
    	are
    concatenated before they are interpreted as just
    indicated.  Thus a source (or description) file is
    one listed in any selected `$files_file*' file.

    By convention, a problem or demo source file that
    has the extension `.ISF' is intended as the initial
    version of a writable contestant file that the con-
    testant will submit and may alter before submitting.
    The writable contestant file itself has the name of
    the initialization file with the `.ISF' stripped
    from its end.  Thus a source file named `foo.c.ISF'
    should be copied into a writable contestant file
    named `foo.c' that will be submitted (by the con-
    testant executing `make submit').  `.ISF' stands for
    `initial submittable file'.
    
    This current program does nothing special with files
    having the `.ISF' extension.  It is the `hpcm_get'
    program that automatically copies a file with a name
    such as `xxx.ISF' into a writable file named `xxx'.

    We proceed to describe the program options not di-
    rectly involved with making ./info, ./contest/help,
    ./contest/problems, or ./contest/demos.

    The -this_contest program option creates the follow-
    ing if they do not exist:

	./help			directory
	./help/index		file
	./help/this_contest	file

    Note these are in the judging directory proper, and
    not in the ./info or ./contest subdirectories.  The
    ./help/index file is an INPUT index file that con-
    tains an entry for ./help/this_contest.  The latter
    file is information about the current contest.  If
    the file is created, a ./TODO is written to edit
    ./help/this_contest.  The -this_contest option is
    processed before any input index files are read, so
    ./help/index may be used as an input index file in
    the same call to `makejudgingdir' that creates the
    ./help/index file.

    If used, the ./help/index file should be the refer-
    enced by the first index specification given to this
    program.  It contains a header entry designed to
    start the output index `help/index', and with this
    header entry, all the help index files, `help/
    demos', `help/problems', and `help/index', are men-
    tioned at the beginning of `help/index'.

    The -mail program option causes the ./mail directory
    to be made if it does not exist.  If it is made, its
    mode is set to a+x as is the mode of its parent and
    its parent's parent.  This last is necessary because
    the JAVA interpreter turns relative file names into
    absolute file names, requiring `a+x' permissions
    in the path from the root to the object file.

    The -help2 program option creates the ./contest/
    help2 directory if it does not exist.  It is simply
    linked to the ./contest/help directory.

    Note that the contestant's `help' command searches
    ./contest/help1, ./contest/help2, ./contest/help3,
    and ./contest/help4 in order for help files.

    The -bin program option creates the ./contest/bin
    directory if it does not exist.  It is simply linked
    to the ./contest/contestant/bin directory, and a
    note to run
    
    		cd .../hpcm; make
		
    is written into ./TODO, in order to be sure all
    the programs and modes are correct so the .../hpcm/
    contestant/bin directory can be used.

    The -bin program option also checks the security
    of the ./contest/contestant/bin/hpcm_sandbox and
    ./contest/contestant/bin/hpcm_sendmail programs
    and writes a ./TODO if either is insecure.

    The -secure program option makes the following if
    they do not exist:

	./contest/secure		    directory
	./contest/secure/hpcm_sendmail.rc   file
	./contest/secure/passwords	    file

    If any of these are made their modes are set to
    go-rw.  If the ./contest/secure/passwords file is
    made, instructions for editing it are written to
    ./TODO, but the file automatically made is empty.
    If the ./contest/secure/hpcm_sendmail.rc file is
    made, instructions for editing it and the
    ~/.procmailrc file are written into ./TODO.

    The ./contest/secure/passwords file consists of
    lines of the form

    	account:password:who:c-email:t-email:comment

    Here `account' is a the login name of the contes-
    tant, `who' is a description of who the contestant
    is, and the `c-email' and `t-email' fields are the
    email addresses used to contact the coach and to
    contact the team members using the account, respec-
    tively.  The account name `none' may be used to
    indicate a line is not associated with an account,
    and the password `none' may be used to indicate the
    password is to be assigned by other means.

    The -secure program option also causes any existing
    ./contest/secure/passwords file to be inspected for
    lines with empty passwords.  If any are found,
    random passwords are generated and inserted in place
    of the missing passwords.  The password `none' may
    be used in a line to prevent a random password from
    being generated and to prevent the hpcm_set_
    passwords program from setting the password of the
    line's account.

    The -who_where program option makes the ./contest/
    who_where file if it does not exist, or updates it
    if it does exist and the ./contest/secure/passwords
    file is newer.  The ./contest/who_where file is a
    copy of the ./contest/secure/passwords file with the
    passwords replaced by where values.  If any new
    places to insert a `where' value are made in the
    ./contest/who_where file, a ./TODO to edit the file
    is written.  There may be accounts in the `who_
    where' file that are not in the `passwords' file.
    Lines with account name `none' in the `passwords'
    file are not copied to the `who_where' file.

    The -trashable program option creates the ./contest/
    trashable file from the ./contest/secure/passwords
    file.  The `trashable' file is just a list of the
    accounts in the `passwords' file, not including the
    account name `none'.  The `trashable' file is up-
    dated by the -trashable option whenever the
    `passwords' file is newer than the `trashable' file.
    Whenever a `trashable' file is created, a ./TODO
    is written to delete the file as soon as all the
    accounts that should be trashed are trashed, in
    order to prevent further account trashing (the
    `TRASH_ACCOUNT' program will not work if the account
    in which it is run is not named in the `trashable'
    file).

    The -printer program option makes the ./contest/
    printer file if neither it nor ./contest/printer_map
    exist, and writes a ./TODO to edit the file when it
    is made.  It also makes the ./contest/printer_jobs
    file if that does not exist when ./contest/printer
    is made, and writes a ./TODO to consider deleting
    this file.

    The -printer_map program option is similar to the
    -printer option but makes a ./contest/printer_map
    file instead of a ./contest/printer file if neither
    of these files exists.

    The -home program option just checks to see if
    the directory ./contest/home exists and the files
    empty.ls, setup.ls, and setup.tar exist in that
    directory and are readable.  If not, instructions
    are written to ./TODO.

    If anything is made in ./contest, a+x is set for
    that directory and its parent.

    Although we have used the names `./info', `./mail',
    `./contest', and `./help' in this description, the
    actual directory names used are the values of the
    `info_directory', `mail_directory', `contest_
    directory', and `help_directory' variables set by
    hpcm_judging.rc.  The file names within these
    directories are literally as given in this docu-
    ment.

    Like other HPCM programs, `makejudgingdir' can be
    run from anywhere in the judge's directory subtree
    which is rooted by the directory containing the
    `$judging_parameters_file' file.

    Unlike most HPCM judging programs, errors made by
    this program are not written to log files, but are
    announced on standard error."

# Argi is the index of the current argument, for use in
# lindex.
#
set argi 0

# Set options, consuming option arguments.
#
set info_option			no
set solutions_option		no
set problems_option		no
set demos_option 		no
set description_option		no
set help_option			no
set help2_option		no
set this_contest_option		no
set mail_option			no
set bin_option			no
set secure_option		no
set who_where_option		no
set trashable_option		no
set printer_option		no
set printer_map_option		no
set home_option			no
#
while { "yes" } {
    if { $argi >= $argc } break;
    switch -- [lindex $argv $argi] {
        -email		{ set info_option 	yes
			  set solutions_option	yes
			  set mail_option	yes
			  set this_contest_option \
			  			yes }
        -formal		{ set solutions_option	yes
			  set problems_option	yes
			  set demos_option	yes
			  set help_option	yes
			  set help2_option	yes
			  set this_contest_option \
			  			yes
			  set mail_option	yes
			  set bin_option	yes
			  set secure_option	yes
			  set who_where_option	yes
			  set printer_option	yes
			  set home_option	yes }
        -informal	{ set info_option	yes
			  set solutions_option	yes
			  set help_option	yes
			  set help2_option	yes
			  set this_contest_option \
			  			yes
			  set mail_option	yes
			  set bin_option	yes
			  set secure_option	yes
			  set who_where_option	yes
			  set printer_map_option \
			  			yes
			  set home_option	yes }
        -info		{ set info_option 	yes }
        -solutions	{ set solutions_option 	yes }
        -problems	{ set problems_option 	yes }
        -demos		{ set demos_option 	yes }
        -description	{ set description_option \
						yes }
        -help		{ set help_option 	yes }
        -help2		{ set help2_option 	yes }
	-this_contest	{ set this_contest_option \
						yes }
        -mail		{ set mail_option 	yes }
        -bin		{ set bin_option 	yes }
        -secure		{ set secure_option 	yes }
        -who_where	{ set who_where_option 	yes }
        -trashable	{ set trashable_option 	yes }
        -printer	{ set printer_option 	yes }
        -printer_map	{ set printer_map_option \
						yes }
        -home		{ set home_option 	yes }
	default		{ break }
    }
    incr argi
}

# If no arguments left or first remaining argument
# begins with `-', print documentation and exit with
# error.
#
if { $argi < $argc \
     && [regexp {^-} [lindex $argv $argi]] } {
    puts $document
    exit 1
}

# Set up TODO
#
set TODO_file $judging_directory/TODO
set TODO_ch ""
set TODO_existed [expr { [file exists $TODO_file] \
                         && [file size $TODO_file] > 0 \
			 }]
proc TODO { args } {
    global TODO_file TODO_ch
    if { $TODO_ch == "" } {
    	set TODO_ch [open $TODO_file a]
	puts $TODO_ch \
	     "====================\
	      [clock format [clock seconds]] TODOs:"
    }
    puts $TODO_ch "--------"
    foreach line $args {
    	puts $TODO_ch "    $line"
    }
}

# Make 10 character random password.
#
random seed
proc make_password {} {
    return [format {%02x%02x%02x%02x%02x} \
		   [random 256] \
		   [random 256] \
		   [random 256] \
		   [random 256] \
		   [random 256]]
}

# Universal abbreviations to shorten lines.
#
set c_d $contest_directory

# The judging directory name relative to the home
# directory, for use in .procmailrc.
#
set j_d $judging_directory
if { ! [regexp {^/} $j_d] } {
set j_d "[pwd]/$j_d"
}
while { [regsub {/([^/.]|\.[^/.])[^/]*/\.\./} \
	    $j_d {/} j_d] > 0 } {}
while { [regsub {/\./} $j_d {/} j_d] > 0 } {}
regsub {/\.$} $j_d {} j_d
while { [regsub {//} $j_d {/} j_d] > 0 } {}
if { [info exists env(HOME)] } {
    set hd $env(HOME)
    regexp "^$hd/(.*)\$" $j_d forget j_d
}


# Check for some elementary errors, such as ./contest
# not existing if it is needed.  If ./contest is needed,
# grant a+x access to it and its parent.
#
if {    $problems_option \
     || $demos_option \
     || $help_option \
     || $help2_option \
     || $bin_option \
     || $secure_option \
     || $who_where_option \
     || $trashable_option \
     || $printer_option \
     || $printer_map_option \
     || $home_option } {
    if {    ! [file isdirectory $c_d] \
         || ! [file executable $c_d] \
         || ! [file readable $c_d] } {
	error "$c_d' is not a useable directory"
    }
    puts "Granting a+x access to $c_d and its parent"
    grant_access $c_d x
    grant_access $c_d/.. x
}
if { $bin_option } {
    if {    ! [file isdirectory "$c_d/contestant"] \
         || ! [file executable "$c_d/contestant"] } {
	error "`$c_d/contestant' is not an executable\
	       directory"
    }
}

# Array specifying option substitutions.  For each
# op1 to be substituted for, the value of
#
#	option_array(op1)
#
# is the list of options that is the substitution.

# Expand a list of options and return the result.
#
proc expand_options { option_list } {

    global option_array

    set result ""
    foreach option $option_list {
        if { [info exists option_array($option)] } {
	    set result \
	        [concat $result \
			$option_array($option)]
	} else {
	    lappend result $option
	}
    }

    if { [info exists option_array(ALL)] } {
	set result \
	    [concat $result $option_array(ALL)]
	}

    return $result
}

# List of substitutions to be made in the names of the
# current input index file.  Each item of the list has
# the form `{source target}' which specifies that if a
# name begins with the string `source' that string
# should be replaced by the string `target'.
#
set substitutions ""

# Make the longest substitution possible in the
# name argument and return the result (or if
# there are no substitutions return the name
# argument).  If there is a length tie, apply
# the first substitution.
#
proc make_substitutions { name } {

    global substitutions

    set result $name
    set best_end -2

    foreach substitution $substitutions {
        set source [lindex $substitution 0]
	set end [string length $source]
	incr end -1

	if { [string range $name 0 $end] == $source \
	     && $best_end < $end } {
	    set target [lindex $substitution 1]
	    set best_end $end
	    incr end
	    set result [string range $name $end end]
	    set result $target$result
	}
    }

    return $result
}


# Process index specification using global variables
# as parameters:
#
#   index_file		the input index file name
#   index_directory	index directory name
#   help_index_chs	output help/index file channel
#			list; "" if none
#   demos_index_chs	output help/demos file channel
#			list; "" if none
#   problems_index_chs	output help/problems file
#			channel list; "" if none
#   option_array	option substitutions
#			(see above)
#   substitutions	filename substitutions
#			(see above)
#   info_option		options
#   solutions_option
#   problems_option
#   demos_option
#   help_option
#   info_directory	directory names
#   contest_directory (c_d)
#   solutions_directory

# Helper function called when ${targetdir}index_ch is ""
# to compute and return the correct value of this
# variable.
#
proc get_index_chs { targetdir } {

    global info_option help_option \
           info_directory c_d \
           help_index_chs problems_index_chs \
	   demos_index_chs \

    set chs ""
    if { $info_option || $help_option } {
	switch $targetdir {
	help		{ set file index
			  set head "Help Index" }
	problems	{ set file problems
			  set head "Problems Index" }
	demos		{ set file demos
			  set head "Demos Index" }
	}
	if { $info_option } {
	    lappend chs \
	    	    [open $info_directory+/help/$file w]
	}
	if { $help_option } {
	    lappend chs [open $c_d/help+/$file w]
	}

	set ${targetdir}_index_chs $chs

	foreach ch $chs {
	    puts $ch [format {%-28s%28s} $head \
	    		     [clock format \
			     	    [clock seconds]]]
	    puts $ch ""
	    puts $ch ""
	}
    }
    return $chs
}

# Helper function to copy readable files and subdirec-
# tories recursively.
#
proc recursive_file_copy { source destination } {

    global omitted_directories

    foreach src [glob -nocomplain -- $source/*] {
	if { ! [file readable $src] } continue
    	set tail [file tail $src]
    	set des "$destination/$tail"
	if { [file isfile $src] } {
	    file copy $src $des
	} elseif { [lcontain $omitted_directories \
			     $tail] } {
	    # do not copy
	} elseif { [file isdirectory $src] } {
	    file mkdir $des
	    recursive_file_copy $src $des
	}
	grant_access $des
    }
}

# Main function to process an index specification.
#
proc process_index_specification {} {

    global index_file index_directory \
           help_index_chs problems_index_chs \
	   demos_index_chs \
           info_option solutions_option \
	   problems_option demos_option \
	   help_option description_option \
           info_directory solutions_directory \
	   c_d problem_description_extensions \
	   allowed_extensions files_file

    set pdexts $problem_description_extensions

    # Be sure index directory is absolute name, else
    # symbolic links will fail.
    #
    if { ! [regexp {^/} $index_directory] } {
	set index_directory [pwd]/$index_directory
    }
    # Replace /*/../ by / recursively.
    while { [regsub \
	     {/([^/.]|\.[^/.])[^/]*/\.\./} \
	     $index_directory {/} index_directory] \
	    > 0 } {}
    while { [regsub {/\./} $index_directory {/} \
                    index_directory] > 0 } {}
    regsub {/\.$} $index_directory {} index_directory
    while { [regsub {//} $index_directory {/} \
                    index_directory] > 0 } {}

    # Read the input index file and process its entries.
    #
    set index_ch [open $index_file r]
    set in_header		no
    set in_item			no

    set index_chs		""

    set header_entry		""
    set help_header_used	no
    set demos_header_used	no
    set problems_header_used	no

    set help_index_written	no
    set demos_index_written	no
    set problems_index_written	no

    set item_header ""

    while { "yes" } {

        # Read next input index line.
	#
	set line [gets $index_ch]
        if { [eof $index_ch] } break;

	# Skip comments.
	#
	if { [regexp {^#} $line] } continue;

	if { [llength $line] >= 1 \
	     && [lindex $line 0] == "***" } {

	    # Beginning item entry.

	    set in_header	no

	    set name [lindex $line 1]
	    set options \
	        [expand_options [lreplace $line 0 1]]
	    set source $index_directory/$name

	    # Check name for legality.
	    #
	    if { [regexp {(^|/)(\.|-)} $name] } {
	    	error "Illegal item name `$name' in\
		       `$index_file'."
	    }

	    # Compute `indent', the part of the first
	    # item entry line before the item name,
	    # with `***' replaced by three spaces.
	    #
	    set ws "\[\ \t\]*"
	    regexp "^($ws\\*\\*\\*$ws)(\[^\ \t\]|\$)" \
		   $line forget indent forget2
	    regsub {\*\*\*} $indent {   } indent

	    if { ! [lcontain $options include] } {

		# Item is not included.

	    	set in_item	no

	    } else {

	    	# Item is included.

		set in_item	yes

		set target [make_substitutions $name]

		# Check target for legality.
		#
		if { [regexp {(^|/)(\.|-)} $target] } {
		    error "Illegal item name `$name'\
		           after substitutions,\n\
			   \    in `$index_file'."
		}

		# Compute and check targetdir and
		# targettail such that $target ==
		# $targetdir/+$targettail and $targetdir
		# is the first component of the name
		# $target, and has no /'s.
		#
		# Targetdir must == `help', `demos', or
		# `problems'.
		#
		if { ! [regexp {^([^/]*)/+([^/].*)$} \
		               $target forget \
			       targetdir targettail] \
		     || ! [lcontain \
			     {help demos problems} \
			     $targetdir] } {
		    error "Bad item name directory\
		    	   after substitution: $target"
		}

	        # Compute output index channels associ-
		# ated with targetdir.
		#
	        set index_chs \
		    [set ${targetdir}_index_chs]

		if { $index_chs == "" } {
		    set index_chs \
		    	[get_index_chs $targetdir]
		}

		# Write headers to output indices if
		# appropriate.
		#
		if { [set ${targetdir}_header_used] \
		     == "no" } {
		    set ${targetdir}_header_used yes
		    if { $item_header != "" } {
		        foreach ch $index_chs {
			    puts $ch $item_header
			}
		    }
		}

		# Write first line of item entry, after
		# editing, to output indices, if appro-
		# priate.
		#
		foreach ch $index_chs {
		    puts $ch "$indent$target"
		}

		set ${targetdir}_index_written yes

		# Compute source and description files
		# if no `all' option.
		#
		set all_option [lcontain $options all]
		if { ! $all_option } {

		    # Compute allowed extension options.
		    #
		    set exts \
		        [intersect $allowed_extensions \
				   $options]

		    # Compute selected files.
		    #
		    set sff $source/$files_file
		    set files [glob -nocomplain \
			            $sff $sff.*]
		    if { [llength $exts] != 0 } {
		        set ext_files ""
			foreach ext $exts {
			    if { [lcontain \
			            $files \
				    $sff.$ext] } {
			    	lappend ext_files \
					$sff.$ext
			    }
			}
			if { [llength $ext_files] \
				== 0 } {
			    error "No problem $sff.XXX \
			    	   files for XXX in\
				   $exts"
			}
			set files $ext_files
		    }

		    # Compute concatenated value of
		    # selected files.
		    #
		    if { [llength $files] == 0 } {
		    	set value \
			    "-SOURCE- Makefile\
			     -DESCRIPTION-"
			set base [file tail $source]
			set sb $source/$base
			foreach ext $pdexts {
			    if { [file exists $sb$ext] \
			    		} {
				lappend value $base$ext
			    }
			}
		    } else {
		        set value ""
			foreach file $files {
			    lappend value -REQUIRED-
			    set value \
			        [concat \
				   $value\
				   [read_entire_file \
				      $file]]
			}
		    }

		    # Process concatenated value of
		    # selected files.
		    #
		    set mode none
		    foreach item $value {
		        switch -- $item {
			    -SOURCE- {
			    	set mode source
			    }
			    -DESCRIPTION- {
			    	set mode description
			    }
			    default {
			        if { [regexp \
				        {^-[-A-Z]*-$} \
					$item] } {
				    set mode none
				} elseif { $mode != \
					     "none" } {
				    set ma ${mode}_array
				    set ${ma}($item) yes
				}
			    }
			}
		    }
		    set source_files \
		        [array names source_array]
		    set description_files \
		        [array names description_array]
		    set both \
		        [intersect $source_files \
			           $description_files]
		    if { [llength $both] != 0 } {
		        error "Some files are both\
			       source and description:\
			       $both"
		    }
		}

		# Process info option.
		#
		if { $info_option } {

		    set destination \
		    	$info_directory+/$target

		    if { $all_option \
			 || [file isfile $source] } {
			file mkdir \
			     [file dirname $destination]
			link_file $source $destination
		    } elseif { [file isdirectory \
		    		     $source] } {
			file mkdir $destination
			foreach file \
				[concat \
				   $source_files \
				   $destination_files] {
			    link_file $source/$file \
				      $destination/$file
			}
		    } else {
		        error "Source `$source' is\
			       neither a file or a\
			       directory."
		    }
		}

		# Process $targetdir option.
		#
		if { [set ${targetdir}_option] } {

		    set dest "$targetdir+/$targettail"
		    set dest "$c_d/$dest"
		    if { [file isfile $source] } {
			file mkdir \
			     [file dirname $dest]
			file copy $source $dest
		    } elseif { [file isdirectory \
		    		     $source] } {
			file mkdir $dest
			
			if { $all_option } {
			    recursive_file_copy \
				$source $dest
			} else {
			    set files $source_files
			    if { $description_option } {
			        set \
				  files \
				  [concat \
				     $files \
				     $description_files]
			    }
			    foreach files $files {
				file copy \
				     $source/$file \
				     $dest/$file
				grant_access $dest/$file
			    }
			}
		    } else {
		        error "Source `$source' is\
			       neither a file or a\
			       directory."
		    }
		    set d $targettail
		    while { "yes" } {
		    	grant_access $c_d/$targetdir+/$d
			set d [file dirname $d]
			if { $d == "." } break
		    }
		}

		# Process solutions option.
		#
		if { $solutions_option \
		     && [lcontain {problems demos} \
				  $targetdir] \
		     && ! [lcontain $options \
				    nosolution] } {
		    if { ! [file isdirectory $source] \
		    		} {
			error "$source solution is not\
			       a directory"
		    } elseif { [regexp {/} \
		    		       $targettail] } {
			error "`$targettail' is to be\
			       linked into the\
			       solutions directory but\
			       contains a `/'"
		    }
		    set s_d $solutions_directory+
		    link_file $source \
			      "$s_d/[file tail \
			      		  $targettail]"
		}
	    }

	} elseif { $in_header } {

	    # Line inside header.

	    set item_header "$item_header\n$line"

	} elseif { [regexp "^\[^\ \t\]" $line] } {

	    # Beginning of header entry.

	    set item_header		$line
	    set in_header		yes
	    set in_item			no
	    set help_header_used	no
	    set demos_header_used	no
	    set problems_header_used	no

	} elseif { $in_item } {

	    # Line inside included item.

	    foreach ch $index_chs {
		puts $ch $line
	    }
	}
    }

    # If we copied any index entries, put out 2 blank
    # lines to separate this input index file's entries
    # from those of the next input index file.
    #
    foreach dir {help problems demos} {
        if { [set ${dir}_index_written] } {
	    foreach ch [set ${dir}_index_chs] {
	    	puts $ch ""
	    	puts $ch ""
	    }
	}
    }

    close $index_ch
}

# Set up info+, solutions+, problems+, demos+, and
# help+ directories.
#
if { $info_option } {
    if { [file exists $info_directory+] } {
        puts "Deleting $info_directory+"
	file delete -force -- $info_directory+
    }
    file mkdir $info_directory+
    file mkdir $info_directory+/help
}
foreach dir {problems demos help} {
    if { [set ${dir}_option] } {
	if { [file exists $c_d/$dir+] } {
	    puts "Deleting out-of-date $c_d/$dir+"
	    file delete -force -- $c_d/$dir+
	}
	file mkdir $c_d/$dir+
	if { $dir != "problems" } {
	    grant_access $c_d/$dir+
	}
    }
}
if { $solutions_option } {
    if { [file exists $solutions_directory+] } {
        puts "Deleting $solutions_directory+"
	file delete -force -- $solutions_directory+
    }
    file mkdir $solutions_directory+
}

# Make help directory.
#
if { $this_contest_option \
      && ! [file isdirectory $help_directory] } {
    file mkdir $help_directory
}

# Make help/index file.
#
if { $this_contest_option \
      && ! [file readable $help_directory/index] } {
    set index_ch [open $help_directory/index w]

    puts $index_ch "
To display the file listed as `help/topic' below use the
command:
                      help topic

E.g., `help index' displays this file.


Indices:
--------

    help/index
        This file.

    help/demos
        Index of contest demonstration problems.

    help/problems
        Index of contest problems.



Introductory Information:
-------------------------


*** this_contest include
        Information about this contest.
"

    close $index_ch
}

# Make help/this_contest file.
#
if { $this_contest_option \
      && ! [file readable \
      		 $help_directory/this_contest] } {
    set tc_ch [open $help_directory/this_contest w]

    puts $tc_ch [format {%-28s%28s} \
    			"About This Contest" \
		        [clock format \
			       [clock seconds]]]

    # Take a guess at the type of contest and output
    # the appropriate draft of a this_contest file.
    #
    if { ! [file isdirectory $c_d] } {

    	# Email contest.
	#
	puts $tc_ch "

THIS FILE IS UNEDITED AND INACCURATE!

Information about this contest, including the score-
board, is posted at

    www.xxx.yyy.edu/~foo/fum/private/ppppp

Do NOT put this URL in a public web page, as pppp is
a password.

The email address of this contest is:

	ppppp<[account_name]@[host_name]>

Sending a message to this address with the subject field
value `get help' and an empty message body will get all
the `help' files that document this contest.  In the
reply to the `get help' message, all these `help' files
will be separated by lines that begin with `---<>'.

This is an `email' contest.  Look at the file `help/
email_contest' for more details about email contests.
The file you are reading now is the `help/this_contest'
file.

If you look at the `help/email/email_unix_tools' file,
you will find instuctions for extracting all the files
from the mail message reply that contains them, if you
have a UNIX system with the correct shell program.

In order to get good scores on problems, you must AVOID
getting a problem description (as described in the help
files) UNTIL you are READY to swiftly solve it.

Good hunting!"

    } elseif { ! [file isdirectory $c_d/problems] \
               && $problems_option == "no" } {

    	# Informal contest.
	#
	puts $tc_ch "

THIS FILE IS UNEDITED AND INACCURATE!

The command `help' will display this file.

This is a `informal' contest.  The command

	help informal_contest

displays more details about informal contests.

You have been given a password and an account name.  If
you have an xterminal, the xcsh command will make more
windows: see `help xterminals'.

The command `hpcm_get' will get a demonstration problem
into your directory ~/demos/count (~ denotes your home
directory).  Read ~/demos/count/README and ~/demos/
count/Makefile and practice submitting the demonstration
problem.

To find out what problems are available use the command
`help problems'.  The command `hpcm_get problems/foo'
will get the problem named `foo' into your directory
`~/problems/foo' where you can work on it.  See `help
solving'.

The command `scoreboard' will display the scoreboard.
The time of a problem is the time between when it is
gotten with hpcm_get and the time a solution is submit-
ted.

To display a list of the help files available use the
command `help index'.  Note that if something in the
index has the name `help/topic' you use the command
`help topic' to view it.

To send a question to the contest manager edit the
question into a file qqq and use the command:

	hpcm_sendmail < qqq

The print commands may or may not be supported for an
informal contest.  If `lpq' lists a printer, the com-
mands are supported.  You may be able to set your own
printer by creating a file named `~/PRINTER' containing
the name of the printer, or containing an email address
to which the print commands will email postscript files.

The problem descriptions are files in the problem direc-
tories that have one of the extensions .txt, .html,
.htm, .ps, etc.  These can be emailed to your home
computer.  The print commands will not currently print
.html, .htm, or .ps files.  But you can email these
files to your home computer where they can be displayed
with a browser.

In order to get good scores on problems, you must AVOID
getting a problem description (with hpcm_get) UNTIL you
are READY to swiftly solve it.

Good hunting!"

    } else {	# ./contest/problems will exist.

    	# Formal contest.
	#
	puts $tc_ch "

THIS FILE IS UNEDITED AND INACCURATE!

The command `help' will display this file.

This is a `formal' contest.  The command

	help formal_contest

displays more details about formal contests.

The contest managers will log in for you.  You will NOT
be given a password.  If you have an xterminal, the xcsh
command will make more windows: see `help xterminals'.

The command `hpcm_get' will get a demonstration problem
into your directory ~/demos/count (where ~ denotes your
home directory).  Read ~/demos/count/README and ~/demos/
count/Makefile and practice submitting the demonstra-
tion problem.

Hpcm_get will also get all the contest problems into
your `~/problems' directory AFTER the contest official-
ly starts.  At the contest start time, you will be given
a printout of all the problem descriptions.  The command
`help problems' will display a list of all the problems
AFTER the contest starts.  Also see `help solving'.

The command `scoreboard' will display the scoreboard.
The time of a problem is the time between the start
time of the contest and the time a solution is submit-
ted.

To display a list of the help files available use the
command `help index'.  Note that if something in the
index has the name `help/topic' you use the command
`help topic' to view it.

To send a question to the contest manager edit the
question into a file qqq and use the command:

	hpcm_sendmail < qqq

Output of the print commands (see `help print') will
be brought to you.  Please do NOT try to find the
printer.  For more information see `help print'.

Good hunting!"

    }

    close $tc_ch

    TODO "Edit $help_directory/this_contest." \
         "Then rerun makejudgingdir to recompute\
	       help files."

    # For Email contest say something about .procmailrc.
    #
    if { ! [file isdirectory $c_d] } {
	TODO "Using the contest password you edited\
              into $help_directory/this_contest," \
	     "edit ~/.procmailrc to contain:" \
	     "" \
	     ":0" \
	     "* ^To:.*password.*<" \
	     "| receivemail $j_d | \\" \
	     "  dispatchmail $j_d"
	TODO "You may want to add the following to\
	      the BEGINNING of your ~/.procmailrc" \
	     "file if you have not ALREADY done so.\
	     \  This will capture all mail the" \
	     "judge receives in ~/hpcm_mbox." \
	     "" \
	     ":0 c:" \
	     "hpcm_mbox"
    }
}

# Set up channel lists.
#
set help_index_chs	""
set demos_index_chs	""
set problems_index_chs	""

# Process arguments, forming index specifications
# encoded in global variables, and call process_index_
# specification (see above) for each specification.
#
set mode file
#
# Mode indicates what next argument should be: file,
# directory, or substitution.
#
foreach arg [lreplace $argv 0 [expr { $argi - 1 }]] {

    # Process next argument.  Whether argument ends in
    # `,' or `:' tells mode of next argument.
    #
    if { $mode == "file" } {
    	if { [regexp {^(.*):$} $arg forget arg] } {
	    set mode directory
    	} else {
	    if { [regexp {^(.*),$} $arg forget arg] } {
		set mode substitution
	    }
	    set index_directory [file dirname $arg]
	}
	set index_file $arg
	set substitutions ""
	foreach opt [array names option_array] {
	    unset option_array($opt)
	}
    } elseif { $mode == "directory" } {
    	if { [regexp {^(.*),$} $arg forget arg] } {
	    set mode substitution
	} else {
	    set mode file
	}
	set index_directory $arg
    } elseif { $mode == "substitution" } {
    	if { ! [regexp {^(.*),$} $arg forget arg] } {
	    set mode file
	}
	if { [regexp {^([^=]*)=([^=]*)$} $arg forget \
	               source destination] } {
	    lappend substitutions \
		    [list $source $destination]
	} elseif { [regexp {^([^:]*):([^:]*)$} \
	                   $arg forget \
	               source destination] } {
	    set option_array($source) \
	        [string trim $destination]
	} else {
	    error "Badly formatted substitution:\
	           `$arg'"
	}
    }

    if { $mode == "file" } {
    	process_index_specification
    }
}
if { $mode != "file" } {
    error "Last argument ends with `,' or `:'"
}

# Finish up index output files.
#
foreach dir {problems help demos} {
    foreach ch [set ${dir}_index_chs] {
        close $ch
    }
}
if { [file exists $c_d/help+/index] } {
    grant_access $c_d/help+/index
}
if { [file exists $c_d/help+/demos] } {
    grant_access $c_d/help+/demos
}

# Diff two directories.  If the only differences are the
# first lines of help indices, return `no'.  Else return
# `yes'.  Returning `yes' when one should have returned
# `no' introduces a lack of optimization, but no func-
# tional error.
#
proc diff_dirs { dir1 dir2 } {
    catch { diff_directories $dir1 $dir2 } out
    set out [split $out "\n"]

    while { [llength $out] > 0 } {
	set diffexp \
	  {^diff -r .*/([^/ ]*) .*/([^/ ]*)$}
	if { [regexp $diffexp [lindex $out 0] \
	             forget index1 index2] \
	     && $index1 == $index2 \
	     && [lcontain {demos problems index} \
			  $index1] } {
	    if { [lindex $out 1] != "1c1" } {
	    	return yes
	    } elseif { ! [regexp {^< [^ ]* Index} \
				  [lindex $out 2]] } {
	    	return yes
	    } elseif { [lindex $out 3] != "---" } {
	    	return yes
	    } elseif { ! [regexp {^> [^ ]* Index} \
				  [lindex $out 4]] } {
	    	return yes
	    }
	    set out [lrange $out 5 end]
	} elseif { [lindex $out 0] == \
		   "child process exited abnormally" } {
	    set out [lrange $out 1 end]
	} else {
	    return yes
	}
    }

    return no
}

# Rename directories iff $directory+ differs from
# $directory as determined by `diff_dirs'.  If a
# directory is not renamed, delete it.  Return `yes' if
# directory renamed, and `no' if deleted.
#
proc rename_directory { directory } {

    if { [diff_dirs $directory $directory+] \
         == "no" } {
    	puts "New $directory does not differ from\
	      previous version."
	file delete -force -- $directory+
	return no
    } else {

	if { [file exists $directory--] } {
	    file delete -force -- $directory--
	}
	if { [file exists $directory-] } {
	    puts "Renaming $directory- to $directory--"
	    file rename $directory- $directory--
	    deny_access $directory--
	}
	if { [file exists $directory] } {
	    puts "Renaming $directory to $directory-"
	    file rename $directory $directory-
	    deny_access $directory-
	}
	if { [file exists $directory+] } {
	    puts "Renaming $directory+ to $directory"
	    file rename $directory+ $directory
	}
	return yes
    }
}

if { $info_option } {
    rename_directory $info_directory
}
if { $problems_option } {
    rename_directory $c_d/problems
}
if { $help_option } {
    rename_directory $c_d/help
}
if { $demos_option } {
    rename_directory $c_d/demos
}
if { $solutions_option } {
    rename_directory $solutions_directory
}

if { ( $problems_option \
       && ! [regexp {r.x} \
       		    [get_access $c_d/problems]] ) \
     || \
     ( $help_option \
       && ! [regexp {r..} [get_access \
       			      $c_d/help/problems]] ) } {
    TODO "Run `startcontest' when contest starts" \
         "to chmod a+rx $c_d/problems" \
	 "and/or $c_d/help/problems."
}

# Make mail directory.
#
if { $mail_option \
      && ! [file isdirectory $mail_directory] } {
    file mkdir $mail_directory
    grant_access $mail_directory x
    grant_access $mail_directory/.. x
    grant_access $mail_directory/../.. x
}

# Make $c_d/help2 directory.
#
if { $help2_option \
     && ! [file isdirectory $c_d/help2] } {
    if { ! [catch {
	      set help2_type \
		  [file type $c_d/help2] }] } {
	if { $help2_type == "link" } {
	    puts "Deleting $c_d/help2"
	    file delete -force -- $c_d/help2
	} else {
	    error "$c_d/help2 exists but is not a\
	           directory"
	}
    }
    link_file help $c_d/help2
}

# Make $c_d/bin directory.
#
if { $bin_option \
     && ! [file isdirectory $c_d/bin] } {
    if { ! [file isdirectory $c_d/contestant/bin] } {
    	error "bin: $c_d/contestant/bin is not a\
	       directory"
    }
    if { ! [file executable $c_d/contestant/bin] } {
    	error "bin: $c_d/contestant/bin has no x\
	       permission"
    }
    if { ! [file readable $c_d/contestant/bin] } {
    	error "bin: $c_d/contestant/bin has no r\
	       permission"
    }
    if { ! [catch { set bin_type \
			[file type $c_d/bin] }] } {
	if { $bin_type == "link" } {
	    puts "Deleting $c_d/bin"
	    file delete -force -- $c_d/bin
	} else {
	    error "$c_d/bin exists but is not a\
	           directory"
	}
    }

    puts "Linking $c_d/bin to $c_d/contestant/bin"
    link_file contestant/bin $c_d/bin

    TODO "Run `make' in `hpcm' directory."
}

# Make secure directory.
#
if { $secure_option \
     && ! [file isdirectory $c_d/secure] } {
    file mkdir $c_d/secure
    deny_access $c_d/secure
}

# Make or edit secure/passwords file.
#
if { $secure_option } {
    if { ! [file readable $c_d/secure/passwords] } {
	close [open $c_d/secure/passwords w]
	deny_access $c_d/secure/passwords
	set apw account:password:who
    	set ctc coaches-email:team-email:comment
	TODO "Edit $c_d/secure/passwords;" \
	     "each of its lines has the format:" \
	     "`$apw:$ctc'."
    } else {
        set passwords_ch [open $c_d/secure/passwords r]
	set lines ""
	set changed no
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    if { [regexp {^([^:]+)(|:|::.*)$} $line \
			 forget account forget2] } {
		set password [make_password]
		set rest ""
		regexp {^[^:]+:(:.*)$} $line \
		       forget rest
	        set line "$account:$password$rest"
		set changed yes
	    }
	    lappend lines $line
	}
	close $passwords_ch
	if { $changed} {
	    set passwords_ch \
	        [open $c_d/secure/passwords w]
	    foreach line $lines {
	        puts $passwords_ch $line
	    }
	    close $passwords_ch
	    TODO "Inspect $c_d/secure/passwords" \
		 "to which passwords have been added."
	}
    }
}

# Make secure/hpcm_sendmail.rc file.
#
if { $secure_option \
     && ! [file readable \
     		$c_d/secure/hpcm_sendmail.rc] } {
    set rc_ch [open $c_d/secure/hpcm_sendmail.rc w]
    set to_password [make_password]
    puts $rc_ch \
         "To: $to_password<[account_name]@[host_name]>"
    set key [make_password]
    puts $rc_ch "Key: $key"
    set key_name [file tail $j_d]
    regexp {^(.*)(-|_)[^-_]*$} $key_name \
	   forget key_name forget2
    puts $rc_ch "Key-Name: $key_name"
    close $rc_ch
    deny_access $c_d/secure/hpcm_sendmail.rc

    TODO "Edit $c_d/secure/hpcm_sendmail.rc;" \
	 "either remove the Key and Key-Name" \
	 "and edit hpcm_judging.rc\
	  authentication variables to contain:" \
	 "    set use_authentication no" \
	 "or edit hpcm_judging.rc\
	  authentication variables to contain:" \
	 "" \
	 "    set use_authentication yes" \
	 "    array set authentication_keys {" \
	 "        $key_name $key" \
	 "    }"

    TODO "Edit ~/.procmailrc to contain:" \
         "" \
	 ":0" \
	 "* ^To:.*$to_password" \
	 "| receivemail $j_d | \\" \
  	 "  dispatchmail $j_d"
    TODO "You may want to add the following to\
	  the BEGINNING of your ~/.procmailrc" \
	 "file if you have not ALREADY done so.\
	 \  This will capture all mail the" \
	 "judge receives in ~/hpcm_mbox." \
	 "" \
	 ":0 c:" \
	 "hpcm_mbox"
}

# Check contest/bin/hpcm_sendmail mode.
#
if { $secure_option \
     && [file exists $c_d/bin/hpcm_sendmail]
     && [expr { [file attributes \
                      $c_d/bin/hpcm_sendmail \
		      -permissions] \
	        & 04000 }] == 0 } {
    TODO "chmod u+s $c_d/bin/hpcm_sendmail"
}

# Make $c_d/who_where
#
if { $who_where_option } {
    if { ! [file readable $c_d/secure/passwords] } {
        error "$c_d/secure/passwords does not exist\
	       for -who_where option"
    } elseif { ! [file readable $c_d/who_where] } {
	set who_where_ch [open $c_d/who_where w]
	set passwords_ch [open $c_d/secure/passwords r]
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    regexp {^([^:]*):} $line forget account
	    set rest ""
	    regexp {^[^:]*:[^:]*:(.*)$} $line \
	           forget rest
	    if { $account != "none" } {
		puts $who_where_ch \
		     "$account:WHERE:$rest"
	    }
	}
	close $passwords_ch
	close $who_where_ch
	grant_access $c_d/who_where

	TODO "Edit $c_d/who_where to specify location" \
	     "of teams, by replacing `WHERE' for each" \
	     "account with a SHORT description of the" \
	     "team's location."
    } elseif { [file mtime $c_d/who_where] \
	       < [file mtime $c_d/secure/passwords] } {

	# Read $c_d/secure/passwords, decomposing the
	# lines into `$account:$password:$rest', saving
	# $rest in $passwords_array($account), and
	# making a list of accounts in the order their
	# lines were encountered in $passwords_accounts
	# 
	set passwords_ch [open $c_d/secure/passwords r]
	set passwords_accounts ""
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    regexp {^([^:]*)(:|$)} $line \
	           forget account forget2
	    set rest ""
	    regexp {^[^:]*:[^:]*:(.*)$} $line \
	           forget rest

	    if { $account != "none" } {
		set passwords_array($account) $rest
		lappend passwords_accounts $account
	    }
	}
	close $passwords_ch

	# The lines for the new who_where file are
	# put in the list $new_who_where.  $changed
	# is set `yes' if this is a change from the
	# old who_where file, and `no' otherwise.
	#
	set new_who_where ""
	set changed no

	# Read the old who_where file.  Copy the lines
	# into $new_who_where, changing the $rest part
	# to that taken from passwords, and recording
	# any actual changes in $changed.  Delete
	# $passwords_array($account) for any account
	# encountered in the old who_where file.
	#
	set who_where_ch [open $c_d/who_where r]
	while { "yes" } {
	    set line [gets $who_where_ch]
	    if { [eof $who_where_ch] } break

	    regexp {^([^:]*)(:|$)} $line \
	           forget account forget2
	    set where ""
	    regexp {^[^:]*:([^:]*)(:|$)} $line \
	    	   forget where forget2
	    set rest ""
	    regexp {^[^:]*:[^:]*:(.*)$} $line \
	           forget rest
	    if { [info exists \
	               passwords_array($account)] } {
	        set prest \
		    $passwords_array($account)
		if { $prest != $rest } {
		    lappend new_who_where \
		    	    "$account:$where:$prest"
		    set changed yes
		} else {
		    lappend new_who_where $line
		}
		unset passwords_array($account)
	    } else {
	        lappend new_who_where $line
	    }
	}
	close $who_where_ch

	# For the accounts in the order encountered in
	# the $c_d/secure/passwords file, if the account
	# is not in $new_who_where yet, add it.
	#
	foreach account $passwords_accounts {
	    if { [info exists \
	               passwords_array($account)] } {
		set prest $passwords_array($account)
		lappend new_who_where \
		        "$account:WHERE:$prest"
		set changed yes
	    }
	}

        # If $changed is `yes', write $new_who_where.
	#
	if { $changed } {
	    file delete -force -- $c_d/who_where
	    set who_where_ch [open $c_d/who_where w]
	    foreach line $new_who_where {
		puts $who_where_ch $line
	    }
	    close $who_where_ch
	    grant_access $c_d/who_where

	    TODO "Edit $c_d/who_where to specify\
					location" \
		 "of teams, by replacing `WHERE' for\
		 			each" \
		 "account with a SHORT description of\
		 			the" \
		 "team's location."
	}
    }
}

# Make $c_d/trashable
#
if { $trashable_option } {
    if { ! [file readable $c_d/secure/passwords] } {
        error "$c_d/secure/passwords does not exist\
	       for -trashable option"
    } elseif { ! [file readable $c_d/trashable] \
	       || [file mtime $c_d/trashable] \
	          < [file mtime $c_d/secure/passwords] \
		  	} {
	if { [file exists $c_d/trashable] } {
	    file delete -force -- $c_d/trashable
	}
	set trashable_ch [open $c_d/trashable w]
	set passwords_ch [open $c_d/secure/passwords r]
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    regexp {^([^:]*)(:|$)} $line \
	    	   forget account forget2
	    if { $account != "none" } {
		puts $trashable_ch $account
	    }
	}
	close $passwords_ch
	close $trashable_ch
	grant_access $c_d/trashable

	TODO "Remember to delete $c_d/trashable" \
	     "when your are done trashing accounts."
    }
}

# Printer_jobs pseudoswitch
#
set printer_jobs_option no

# Make $c_d/printer
#
if { $printer_option \
     && ! [file readable $c_d/printer] \
     && ! [file readable $c_d/printer_map] } {

    set printer_jobs_option yes

    if { [info exists env(PRINTER)] } {
	set printer $env(PRINTER)
    } else {
	set printer UNKNOWN
    }

    write_file $c_d/printer $printer
    grant_access $c_d/printer

    TODO "Wrote $c_d/printer to be `$printer';" \
         "edit $c_d/printer to change." \
	 "You may want to use $c_d/printer_map\
	    instead of $c_d/printer:" \
	 "see `hpcm/contestant/bin/printer_pipe -doc'."
}

# Make $c_d/printer_map
#
if { $printer_map_option \
     && ! [file readable $c_d/printer] \
     && ! [file readable $c_d/printer_map] } {

    set printer_jobs_option yes

    write_file $c_d/printer_map {.* !~/PRINTER}
    grant_access $c_d/printer_map

    TODO "Wrote $c_d/printer_map to be\
    		`.* !~/PRINTER';" \
         "edit $c_d/printer_map to change." \
	 "You may want to use $c_d/printer\
	    instead of $c_d/printer_map:" \
	 "see `hpcm/contestant/bin/printer_pipe -doc'."
}

# Make $c_d/printer_jobs
#
if { $printer_jobs_option \
     && ! [file readable $c_d/printer_jobs] } {
    close [open $c_d/printer_jobs w]
    grant_access $c_d/printer_jobs rw

    TODO "Delete $c_d/printer_jobs if you do not" \
         "want it to list all printer jobs."
}

# Check for $c_d/home directory.
#
if { $home_option } {
    if {    ! [file isdirectory $c_d/home] \
         || ! [file readable $c_d/home] \
         || ! [file executable $c_d/home] \
         || ! [file readable $c_d/home/empty.ls] \
         || ! [file readable $c_d/home/setup.ls] \
         || ! [file readable $c_d/home/setup.tar] \
		} {
	TODO "Run SETUP_PROTOTYPE in prototype\
	      account" \
	     "and rerun `makejudgingdir -home'." \
	     "See `SETUP_PROTOTYPE -doc' for\
	      instructions."
    }
    if { [file exists $c_d/home] \
         && ! [regexp {r.x} [get_access $c_d/home]] } {
    	TODO "chmod a+rx $c_d/home"
    }
}

# Finish TODO
#
set TODO_written [expr { $TODO_ch != "" }]
if { $TODO_written || $TODO_existed } {
    if { $TODO_written } {
	close $TODO_ch
    }
    set TODO_ch [open $TODO_file r]
    if { $TODO_existed } {
        if { $TODO_written } {
	    puts "==================== old+new TODO:"
	} else {
	    puts "==================== old TODO:"
	}
    } else {
	puts "==================== new TODO:"
    }
    while { "yes" } {
    	set line [gets $TODO_ch]
	if { [eof $TODO_ch] } break
	puts $line
    }
    puts "==================== end of TODO"
    close $TODO_ch
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
