#!/bin/sh
#
# Make the subdirectories, symbolic links, and indices
# of a judging directory and its associated contest
# directory.
#
# File:		makecontest
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Tue Aug  8 14:55:20 EDT 2017
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# The next lines start tclsh \
trap "echo makecontest: Terminated by Signal" \
    HUP INT QUIT; \
tclsh "$0" "$@"; exit $status

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
set contestant_help_directory \
    "[file dirname $argv0]/../../contestant/help"
set log_disable yes
source $lib_directory/judging_common.tcl
catch {

# Compute true name of judging_directory, with no
# `/.'s or `/..'s.
#
set judging_directory [truename $judging_directory]

# Abbreviations used in this program to shorten lines.
#
set j_d $judging_directory
set c_d $j_d/contest

set document "
makecontest option ... index_specification ...

  If no arguments are given, makecontest takes its
  arguments from the makecontest_arguments global
  variable, if that exists.

  Options:
    -local	Equals all options needed to have local
		contestant accounts; specifically, the
		following: -contest, -bin,
		-test_submissions, -home, -help,
		-help2, -this_contest, -solutions,
		-mail, -print_files, -problems_solution_
		files, -demos_solution_files, -secure,
		-procmailrc, -who_where, -trashable,
		-contest_commands, -judging_commands,
		-scoreboard_commands, -make_test.
    -email	Equals all options needed to have email
		contestant accounts; specifically, the
		following: -info, -solutions, -mail,
		-this_contest, -procmailrc, -print_
		files, -problems_solution_files, -demos_
		solution_files, -judging_commands,
		-scoreboard_commands, -make_test.
    -formal     Same as -local plus -problems, -demos,
		and -demos_solutions.
    -informal   Same as -local, -info, and
                -demos_solutions.

    -info	Make ./info, ./info/help/index,
		./info/help/problems, ./info/help/demos.

    -solutions  Make ./solutions

    -contest	Make ./contest
    -bin	Make ./contest/bin
    -test_submissions  Make ./contest/test_submissions
    -home	Make ./contest/home
    -problems	Make ./contest/problems.  Includes
		problem description files for non-`all'
		directory entries only if -description
		is given.
    -demos	Make ./contest/demos.  Includes
		problem description files for non-`all'
		directory entries only if -description
		is given.
    -demos_solutions  Make ./contest/demos/solutions if
    		./contest/demos exists, and make ./info/
		demos/solutions if ./info/demos exists.
    -description     Include problem description (.txt,
		.html, .ps, etc.) files in ./contest/
		problems, ./contest/demos, or ./contest/
		help.
    -help	Make ./contest/help,
		     ./contest/help/index,
		     ./contest/help/problems,
		     ./contest/help/demos
    -help2	Make ./help2

    -secure	Make ./contest/secure/passwords,
		     ./contest/secure/hpcm_sendmail.rc
    -ssh	Make ./contest/extra_setup.tar contain-
		ing a .ssh/authorized_keys file that
		contains .ssh/id_rsa.pub, .ssh/id_
		dsa.pub, and .ssh/identity.pub.

    -this_contest    Make ./help, ./help/index,
			  ./help/this_contest,
			  ./help/this_contest_parameter,
			  ./help/this_contest_original
    -print_files  Make ./help_print_files,
		       ./problems_print_files,
		       ./demos_print_files.

    -problems_solution_files
		Make ./problems_solution_files.
    -demos_solution_files
		Make ./demos_solution_files.

    -mail	Make ./mail
    -procmailrc	Update ~/.procmailrc
		and make ./Contest_Address

    -who_where  Make ./contest/who_where
    -trashable  Make ./contest/trashable with non-
		existing accounts
    -trashall   Make ./contest/trashable with all
		accounts

    -contest_commands  From elements of the contest_
		commands global variable make the file
		./contest/NAME and also the following
		files in ./contest/secure/bin:
			NAME
			NAME_identity
			NAME_identity.pub
			NAME_authorized_keys
			NAME_procmailrc
    -judging_commands  From elements of the judging_
		commands global variable make files:
		./secure/bin/NAME
		./secure/bin/NAME_identity
		./secure/bin/NAME_identity.pub
		./secure/bin/NAME_authorized_keys
		./secure/bin/NAME_procmailrc
    -scoreboard_commands  Append scoreboard_commands
		global variable to the judging_commands
		global variable.  Implies -judging_
		commands.

    -printer    Using the optional `contest_printer'
		global variable make ./contest/printer,
		and also make ./contest/printer_jobs
    -printer_map  Using the optional `contest_printer_
		map' global variable make ./contest/
		printer_map, and also make ./contest/
		printer_jobs
    -public_files  Using the optional `public_files'
		global variable make public files
		(usually in contest/).

    -javahelp	Make ./contest/javahelp
    -c++help	Make ./contest/c++help
    -pythonhelp	Make ./contest/pythonhelp

    -web	Make ./web and ./web.tar

    -make_test  From the optional `make_test' global
		variable make ./make_test.

    -startcontest   Run the startcontest program if
		    necessary.
    -scoreboard     Run the makescoreboard program if
		    necessary.

  Index Specification:

    index_file\[: index_directory\], name1s=name1t, \\
	  option1s:'option11t option12t ...', \\
	  name2s=name2t, ...

  Pre-Existing Files and Links:

    ./			 The judging directory.
    ./hpcm_judging.rc	 Parameters file.



    Given a judging directory (denoted as `./' in this
    documentation) complete with hpcm_judging.rc file,
    the `makecontest' program makes subdirectories,
    links, and index files in the judging directory and
    optional associated contest directory, according to
    instructions in the index specifications and
    options.  The form of the index specifications and
    options is given above.

    This program appends instructions for its user to
    edit certain files and run certain programs to the
    ./TODO file, and prints an announcement at the end
    of the program if this file is not empty.  Informa-
    tion items in the ./TODO file are call `TODO's.


Index Specifications
----- --------------

    Most of the options cause particular directories or
    files to be made.  In particular the following
    options cause the given directories and their
    contents to be made:

	-help		./contest/help
	-demos		./contest/demos
	-problems	./contest/problems
	-info		./info/help
			./info/demos
			./info/problems
	-solutions	./solutions

    The index specifications determine the contents of
    these directories.  Each index specification names
    an input index file that is read and used to gener-
    ate a list of items to be included in the above
    directories.  Each item is a file or directory, and
    corresponds to an item entry in an input index file.
    The item entry has the form:

	*** item_name item_option ...
	    Text describing the item.

    The index specification contains substitutions that
    modify the item_name and the item_options.  We will
    describe how substitutions are done below, after
    describing everything else about index specifica-
    tions, index files, and index entries.

    Before substitutions the item_name names the item,
    a file or directory, relative to the input index
    directory (see below).  After substitutions, the
    item_name names the item relative to the ./info or
    ./contest directories.  The item_name after substi-
    tutions must begin with `help/', `demos/', or
    `problems/'.

    After substitutions for both the item_name and
    options, the options which have effect are:

      include/noinclude
	  An item is included in the ./info and
	  ./contest directories if the `include' option
	  is present, the `noinclude' option is absent,
	  and the item name begins with `help/',
	  `demos/', or `problems/'.
	  
	  Thus the default is to not include, and an
	  explicit `noinclude' overrides `include'.

	  An item entry is said to be `included' if it
	  is being included in the ./info and ./contest
	  directories under these rules.

      solution/nosolution
	  An item is included in the ./solutions direc-
	  tory if the `solution' option is present or
	  the `nosolution' option is absent, if the
	  item is being included in the ./info and
	  ./contest directories are per above, and if
	  the item name begins with `demos/' or
	  `problems/'.

	  Thus the default is to include in the
	  ./solutions directory items included as per
	  the above rules in ./{info,contest}/{demos,
	  problems}, and an explicit `solution' over-
	  rides `nosolution'.

      all/notall
	  The definition of the global variable problem_
	  source_files is changed to {.*} and the defi-
	  nition of problem_description_files is
	  changed to {} for this item, if the `all'
	  option is present and the `notall' option is
	  absent.  If these changes are made, all files
	  not excluded by the global variable problem_
	  excluded_files will be source files for this
	  item.  See below for details.

	  Thus the default is to make no changes, and
	  an explicit `notall' overrides `all'.

    Note that all options after substitution are made
    available to the PROBLEM.rc file as the value of
    the OPTIONS global variable.


  Output Indices
  ------ -------

    Each included item entry is copied into an output
    index file determined by the item name after substi-
    tutions.  The output index files exist within the
    ./contest and ./info directories and have the fol-
    lowing names relative to these directories:

	Relative Output     Include item if
	Index File Name	    after substitution:
	---------------     -------------------
	help/index	    item name is help/...
	help/demos	    item name is demos/...
	help/problems	    item name is problems/...

    If both ./contest and ./info directories exist,
    there may be two identical copies of each output
    index file, one in ./contest and one in ./info.

    When an item entry is copied, the `***' in the first
    line of the entry is replace by 3 space characters,
    the item name is replaced by the name after substi-
    tutions, and the item options are removed.

    In addition to item entries, an input index file
    contains header entries.  Header entries begin with
    a line that starts with neither whitespace nor `***'
    followed by whitespace.  A header entry stops at the
    next line that begins an item entry, or at the end
    of file.  An item entry stops at the next line that
    begins a header or item entry, or at the end of
    file.

    When an item entry is copied to an output index
    file, the first header entry before the item entry
    in its index input file is copied just before the
    item, if that header entry has not previously been
    copied into the output index file.  A header entry
    may be copied into many output index files.

    Lastly, any line beginning with `#' in an input
    index file is a comment line that is completely
    ignored, as if it did not exist.

  Index Specification Syntax
  ----- ------------- ------

    An index specification determines one input index
    file, an associated input index directory, and a set
    of substitution patterns.  The specification is a
    sequence of arguments to the `makecontest' program.
    All these arguments but the last end in either a `:'
    or a `,'.  The `:' indicates the next argument is an
    input index directory name and the `,' indicates the
    next argument is a substitution pattern (see below).

    Each input index file is associated with an input
    index directory.  If this is named DDD, and an item
    entry within the input index file has item name III
    before substitution, then the name of the item
    itself is DDD/III.  This is either a file or a
    directory; that is, the item is either a file or
    a directory.

    An input index directory may optionally be given in
    a specification by ending the first argument of the
    specification, which names the input index file,
    with a `:', and giving the name of the input index
    directory as the second argument in the specifica-
    tion (with an optional ending `,').  If the first
    argument does not end in `:', the directory that
    contains the index file is used as the input index
    directory.

    An unedited version of an input index file is nor-
    mally found in its associated index directory, and
    is normally used directly, with option substitution
    patterns being used to determine which item entries
    are to be included.  However, one can always put an
    edited version of the input index file in the judg-
    ing directory and specify the associated input index
    directory by using a `:' in the index specification.

  PROBLEM.rc Global Variables
  ---------- ------ ---------

    An index item can be either a file or a directory.
    When it is a directory, not all files in the direc-
    tory will be copied into the ./contest directory
    tree or linked into the ./info directory tree.  The
    files in the item directory are classified into
    three kinds: `source', `description', and `other'.
    The `other' files are not copied or linked.  The
    `source' files are always copied or linked.  The
    `description' files are always linked into the
    ./info directory tree, but are copied into the
    ./contest directory tree only if the `-description'
    option is given.

    Determination of which files are source and which
    are description, within a directory item, is made
    using global variable values which may be set by a
    file named `PROBLEM.rc' within the directory, where
    `PROBLEM' is the last component of the directory
    name.  If that file exists it is sourced into a
    local procedure (so it will not define global vari-
    ables other than those needed by makecontest).  The
    PROBLEM.rc file may reference the variables

	PROBLEM		Name of problem.
	EXTENSION	Equals \"UNDEFINED\"
	OPTIONS		The options in the index item,
			after option substitutions, as
			a TCL list.

    The name `PROBLEM.rc' is something of a misnomer for
    help files.  In this case `PROBLEM' is merely the
    last component of the index item directory name.  It
    is very rare for a help file directory to need a .rc
    file: usually such directories have the `all' op-
    tion.

    The PROBLEM.rc file may define the following vari-
    ables:

	problem_description_files
	problem_source_files
	problem_binary_source_files
	problem_data_source_files
	problem_solution_files
	problem_excluded_files
	problem_make_files
	problem_print_files

    The values of these variables are TCL lists of
    regular expressions.  Default values are provided
    for these variables by hpcm_judging.rc, and these
    in turn default as follows:

	problem_description_files:
	    [indent_list 12 $problem_description_files]
	problem_source_files:
	    [indent_list 12 $problem_source_files]
	problem_binary_source_files:
	    [indent_list 12 \
	     $problem_binary_source_files]
	problem_data_source_files:
	    [indent_list 12 $problem_data_source_files]
	problem_solution_files:
	    [indent_list 12 $problem_solution_files]
	problem_excluded_files:
	    [indent_list 12 $problem_excluded_files]
	problem_make_files:
	    Undefined.
	problem_print_files:
	    Undefined.

    The problem_make_files variable, if set, gives in-
    structions for making files in the problem direc-
    tory.  These are executed by `makecontest' as per
    the description of this variable in the `Problem .rc
    Files' section of hpcm/judge/lib/hpcm_judging.rc.
    These instructions may make new files in the item
    directory, and these files may then be selected for
    including by the rules described below.

    Then if the file PROBLEM.md5sum exists the MD5
    checksums of the files listed in it are checked.
    The PROBLEM.md5sum file can be used to verify that
    any .in and .test files just made are as expected.

    The description and source file lists are lists of
    description or source file names relative to the
    index item directory.  To be listed a file must have
    a name whose LAST component matches a regular ex-
    pression in the problem_description_files or pro-
    blem_source_files global variable values, and NOT
    have ANY name component that matches a regular
    expression in problem_excluded_files.  If a file
    would be in both the description and source file
    lists, it is deleted from the source list, so it
    is in only the description file list.  The regular
    expressions are TCL regular expressions.

    The ONLY difference between source and description
    files is that source files are always copied into
    ./contest/{problems,demos,help}, whereas description
    files are copied only if the -description option is
    given to makecontest.
    
    The `all' post-substitution option in an index item
    changes the problem_source_files value for the index
    item to {.*} and the problem_description_files value
    to {}.  This eliminates the effect of these two
    global variables and includes all files not excluded
    by the problem_excluded_files global variable, re-
    gardless of the setting of the -description option.

    The print files are files to be printed and given to
    contestants BEFORE the contest starts.  The list of
    print files for an item is copied into a file named
    ./problem_print_files, ./demos_print_files, or
    ./help_print_files by the -print_files option (see
    below).  If the problem_print_files global variable
    exists, its value is the list of print files in the
    item directory, where file names in the global vari-
    able are relative to the item directory.  Otherwise
    the sorted list of description files is used as the
    list of print files.

    The solution files are files to be put on the web
    AFTER the contest ends, or for demonstration pro-
    blems, the files put into the ./contest/demos/
    solutions directory .  This list is computed in the
    same way as the source and description file lists
    are computed: all files within a directory item
    whose LAST name component matches a TCL regular
    expression in problem_solution_files and NONE of
    whose components match a regular expression in
    problem_excluded_files is a solution file.  See the
    -problems_solution_files and -demos_solution_files
    options below.

    By convention, a problem or demo source file that
    has the extension `.ISF' is intended as the initial
    version of a writable contestant file that the con-
    testant will submit and may alter before submitting.
    The writable contestant file itself has the name of
    the initialization file with the `.ISF' stripped
    from its end.  Thus a source file named `foo.c.ISF'
    should be copied into a writable contestant file
    named `foo.c' that will be submitted (by the con-
    testant executing `make submit').  `.ISF' stands for
    `initial submittable file'.

    Makecontest does nothing special with files having
    the `.ISF' extension.  It is the `hpcm_get' and
    `hpcm_extract' programs that automatically copy a
    file with a name such as `xxx.ISF' into a writable
    file named `xxx'.


  Item Name Substitution Patterns
  ---- ---- ------------ --------

    Item names undergo substitutions specified by index
    specification arguments of the form `nameXs=nameXt'.
    If the item name begins with the nameXs string, that
    string will be replaced by nameXt.  If there are
    several possible substitutions, the longest nameXs
    will be selected, and if there are several longest,
    the first will be selected.

    Thus, for example, given an index specification of
    the form

	my_index: foo/bar, public/=problems/, \\
		  public/shelf/=problems/old/

    then

      public/foo2	   becomes    problems/foo2
      public/shelf/foo1    becomes    problems/old/foo1

    Substitutions are not recursive: the result of a
    substitution is NOT subject to further substitu-
    tions.

  Option Substitution Patterns
  ------ ------------ --------

    The `include' option is rarely encoded directly in
    the index files.  Instead options categorizing the
    entries are made up by the author of an index file
    and mapped by the index specification to the
    `include' option.  Mapping is done by option substi-
    tution that occurs before the options are finally
    processed.  An option substitution pattern of the
    form:

	option1s:'option11t option12t ...'

    in the index specification replaces option1s by the
    options in the list `option11t option12t ...'.
    As a special case, if `option1s' is `ALL', the
    options in the list `option11t option12t ...' are
    always added to the substitution result without
    replacing any option in the original option list.
    Substitution is NOT recursive: it is done only on
    options appearing in the item entries in the index
    files, and not on options that are the result of
    substitution.  After substitutions are done, unknown
    options are ignored, and duplicate options are
    treated as if they occurred only once.

    In mapping item options, the unsubstituted item_name
    is also mapped like an option and the result treated
    as options.  This permits substitutions like

	item_name:include

    to include an item by name.  Thus an item_name is
    used twice, once as the name of the item, and once
    as an item option.

The -contest Option
--- -------- ------

    Contests in which contestants have local accounts
    must have a contest directory to hold files readable
    and executable by the contestants.  Files in the
    judging directory are not accessible to contestants.

    The -contest program option makes the contest direc-
    tory and the symbolic link `./contest' to that di-
    rectory.  This is needed for contests with local
    contestant accounts, but not for contests with only
    email accounts.  If `./contest' does not exist, and
    the name of the judging directory is ~/XXX/judging_
    YYY_PPP where PPP is a password, the directory named
    ~/XXX/contest_YYY is made and used as the contest
    directory.  That is, the judging directory name is
    modified by replacing `judging_' by `contest_' at
    the beginning of its last component, and removing
    from the end any `_PPP'.  If the judging directory
    name is ~/XXX/judging_YYY and there is no `_PPP',
    the contest directory name ~/XXX/contest_YYY is used
    (YYY must not contain a `_').  It is an error if
    `./contest' does not exist but the contest directory
    already exists.

    If `./contest' is made, or if anything is made in
    `./contest', a+x is set for that directory and its
    parent.


The -bin Option
--- ---- ------

    The bin subdirectory of the contest directory holds
    programs executable by the contestant.

    The -bin program option makes the symbolic link
    ./contest/bin to `\$hpcm_directory/contestant/bin',
    where the `hpcm_directory' global variable defaults
    to `~/hpcm'.  If this cannot be done, it is not an
    error, but a TODO to fix the situation is written.


The -test_submissions Option
--- ----------------- ------

    Ditto but for .../test_submissions instead of
    .../bin.


The -home Option
--- ----- ------

    The `home' subdirectory of the contest directory
    holds files that would normally be in the home
    directory of each contestant account.  Instead,
    symbolic links in the home directory of each con-
    testant account target files in the `home' direc-
    tory of the contest directory.  This permits one of
    these files to be changed for all contestants at the
    same time by editing a single file.

    The `home' subdirectory of the contest directory
    is symbolically linked to the `home' subdirectory
    of the prototype account, where the target files
    mentioned above are kept.  See the hpcm/contestant/
    bin/SETUP_PROTOTYPE program.

    The -home program option makes the symbolic link
    ./contest/home to ~PROTO/home, where PROTO is the
    name of the prototype account that is set up by
    the `SETUP_PROTOTYPE' program.  PROTO is defined
    as the value of the global variable `hpcm_prototype_
    account' if that variable is defined.  Otherwise
    PROTO is the unique account name which has the form
    `*\[_-\]proto' such that the directory ~PROTO/home
    is readable and executable and the files ~PROTO/
    home/setup.tar, ~PROTO/home/setup.ls, and ~PROTO/
    home/empty.ls exist and are readable, if such a
    unique account name exists.  If the prototype
    account cannot be found, it is not an error, but
    a TODO to fix the situation is written.


The -info Option
--- ----- ------

    The ./info directory is the place from which the
    `autoinfo' program that processes `get XXX' emails
    gets files.

    The -info option creates the ./info directory and
    is subdirectories, ./info/help, ./info/demos, and
    ./info/problems.  The specific contents of these
    subdirectories is determined by index specifica-
    tions: see above.

    When an item is included in the ./info directory,
    a symbolic link is made to the item if it is a
    file.  If it is a directory, a new directory
    is created containing a symbolic link to any problem
    source and description files in the directory.  The
    exact definitions of problem source and description
    files are given in `PROBLEM.rc Global Variables'
    above.  Problem description file links are included
    within the ./info directory even if no -description
    program option is given.

The -help, -demos, and -problems Options
--- ------ ------- --- --------- -------

    The ./contest/help, ./contest/demos, and ./contest/
    problems directories are the places from which the
    contestant local accounts get help files, demo
    files, and problem source and optionally description
    files, respectively.  These directories are made by
    the -help, -demos, and -problems options, respec-
    tively.  The specific contents of these directories
    is determined by index specifications: see above.

    When an index item is included in one of these
    directories, files are copied and new directories
    are made.  Symbolic links cannot be used because
    their targets would not have a+r permissions.
    Access is granted to copied files and new director-
    ies using a+r and a+rx permissions, except for
    
		./contest/problems 
		./contest/help/problems

    which are left with permissions determined by the
    umask (presumably o-rx or og-rx).  The `startcon-
    test' program sets permissions of ./contest/problems
    to a+rx and permissions of ./contest/help/problems
    to a+r.

    For directory items the files within the item direc-
    tory that are copied are determined by the problem_
    source_files, problem_binary_source_files, problem_
    data_source_files, problem_description_files, and
    problem_excluded_files global variables and the
    `all' option in the index.  See `PROBLEM.rc Global
    Variables' above for details.

    As a special case, the -help option makes ./contest/
    help/this_contest to be either a copy of ./help/
    this_contest if that is readable, or to be a symbo-
    lic link to ./contest/help/index otherwise.  The
    contestant's `help' command can then be configured
    to display ./contest/help/this_contest.

The -solutions Option
--- ---------- ------

    The ./solutions directory is the place from which
    the `autojudge' program gets the files it uses to
    test a submission.  This directory is made by the
    -solutions option.  It contains all items that have
    substituted item names beginning with demos/ or
    problems/, and have the `solution' option or do NOT
    have the `nosolution' option after option substitu-
    tion.  It is an error if such an item is a file and
    not a directory.
 
    For each such item a symbolic link is created in the
    ./solutions directory to the item directory, and
    this link is given as its name the name of the last
    component of the substituted item name.  e.g., the
    name `demos/count' produces `./solutions/count'.
    This means that all demos and problems items in the
    contest must have unique last components (except for
    items with the `nosolution' item option).


help, demos, problems, and solutions Directory Notes
----- ------ --------- --- --------- --------- -----

    If we consider the directory pairs:

	./info/demos		./contest/demos
	./info/problems		./contest/problems
	./info/help		./contest/help

    then if both directories of a pair are made, both
    are identical after symbolic links are followed,
    except that if there is no -description option,
    problem description files are generally copied into
    ./info subdirectories but not into ./contest subdir-
    ectories.  But if the -description option is given,
    the UNIX `diff -r' command should report the two
    directories in each of the above pairs to be
    identical.

    If `makecontest' is building a ./info directory, it
    actually builds a ./info+ directory instead.  Then
    it does a `diff -r ./info ./info+', and checks the
    output to see if there is any difference between
    ./info and ./info+ except for the first lines of
    the help indices (help/demos, help/problems, and
    help/index).  If there are no differences, the
    ./info+ directory is removed and nothing else is
    done.  If the two directories have other differ-
    ences, the following renaming occurs:

		./info-	    becomes    ./info--
		./info	    becomes    ./info-
		./info+	    becomes    ./info

    A similar stratagem is followed for ./solutions,
    ./contest/problems, ./contest/demos, and .contest/
    help.

The -this_contest Option
--- ------------- ------

    The `this_contest' help file gives contest specific
    information and must be created uniquely for each
    contest.  The -this_contest program option does this
    by making the following:

	./help				directory
	./help/index			file
	./help/this_contest		file
	./help/this_contest_parameter	file
	./help/this_contest_original	file

    Note these are in the judging directory proper, and
    not in the ./info or ./contest subdirectories.

    The ./help/index file is an INPUT index file and if
    used should be referenced by the first help file
    index specification given to `makecontest'.  It
    begins with a header entry designed to start the
    `help/index' output index file.  This header entry
    mentions the `help/demos', `help/problems', and
    `help/index' help files that are not listed in input
    index files but are instead made by `makecontest'.
    After this header ./help/index has an item entry
    for `this_contest', i.e., for ./help/this_contest,
    which is the `this_contest' help file.

    The -this_contest option is processed before any
    input index files are read, so ./help/index may be
    used as an input index file in the same call to
    `makecontest' that creates the ./help/index file.

    The ./help/this_contest file is initially written to
    be a copy of the `this_contest' global variable.
    Then it may be edited either by changing the global
    variable value, or by editing ./help/this_contest
    directly.  The various ./help/this_contest* files
    are designed to allow either of these procedures to
    be used, and to suppress copying the global variable
    value to ./help/this_contest once the latter has
    been edited.

    The ./help/this_contest* files, when written, are
    always written to be a copy of the `this_contest'
    global variable.  The ./help/this_contest_original
    file is written only if it does not exist.  The
    ./help/this_contest_parameter file is written if it
    does not exist or if it exists but is not equal to
    the value of the `this_contest' global variable.
    The ./help/this_contest file is written only if it
    does not exist, or if it equals ./help/this_contest_
    parameter and the latter is to be written.

    If ./help/this_contest is written, a TODO is written
    indicating what has been done and reminding you that
    you can edit ./help/this_contest.


The -mail Option
--- ----- ------

    The ./mail directory holds submissions.  This direc-
    tory is made by the -mail program option if it does
    not exist.  If it is made, its mode is set to a+x as
    is the mode of its parent and its parent's parent.
    This last is necessary because the JAVA interpreter
    turns relative file names into absolute file names,
    requiring `a+x' permissions in the path from the
    root to the object file when a submission is execu-
    ted by the autojudge.


The -help2 Option
--- ------ ------

    The -help2 program option creates the ./contest/
    help2 directory if it does not exist.  It is simply
    linked to the ./contest/help directory.

    Note that the contestant's `help' command searches
    ./contest/help1, ./contest/help2, ./contest/help3,
    and ./contest/help4 in order for help files.  Thus
    files put in ./contest/help1 will override those
    in ./contest/help that is linked to ./contest/help2.


The -print_files Option
--- ------------ ------

    The -print_files program option makes the ./help_
    print_files, ./problem_print_files, and ./demos_
    print_files files which each list files that may
    be fprint'ed and given to contestants BEFORE the
    contest starts.  These lists begin with the help/
    index, help/problems, and help/demos index files
    respectively, and then list all the files listed in
    those indices, plus all files selected as print
    files in directory items (see PROBLEM.rc Global
    Variables above).  However, if help/this_contest is
    listed in help_print_files, it is moved to the front
    of the help_print_files list.
    
    WARNING: the command `makecontest -print_files' will
    make nearly empty lists as this command does not
    have the index specifications necessary to make the
    lists properly.


The -{problems,demos}_solution_files Options
--- -------------------------------- -------

    The -problems_solution_files program option makes
    the ./problems_solution_files file that lists files
    in the solutions subdirectory that can be posted on
    the web to define solutions to non-demonstration
    problems.  The -demos_solution_files option does the
    same for demonstration problems.  The files listed
    are defined by the problem_solution_files and
    problem_excluded_files global variables.  See
    PROBLEM.rc Global Variables above.

    NOTE: the files listed are in the ./solutions
    directory so the XXX_solution_files options imply
    the -solution option.

    WARNING: the command `makecontest -XXX_solution_
    files' will make an empty list as this command does
    not have the index specifications necessary to make
    the list properly.


The -demos_solutions Option
--- ---------------- ------

This option makes the ./contest/demos/solutions direc-
tory if ./contest/demos exists, and the ./info/demos/
solutions directory if ./info/demos exists.  The demos/
solutions directories contain the solution files for the
demonstration problems so local contestants can read
them.  The files are just those listed in demos_
solution_files.  This option implies -demos_solution_
files and -solutions.


The -secure Option
--- ------- ------

    The -secure program option makes the following if
    they do not exist:

	./contest/secure		    directory
	./contest/secure/hpcm_sendmail.rc   file
	./contest/secure/passwords	    file

    If any of these are made their modes are set to
    go-rwx.  If the ./contest/secure/passwords file is
    made, a TODO for editing it is written, but the
    file automatically made is effectively empty.

    The hpcm_sendmail.rc file is used by the privileged
    hpcm_sendmail program when it is run by contestant
    local accounts.  It contains the judge's address and
    a key used to cryptographically sign email being
    sent from the contestant to the judge.  The judge's
    address in hpcm_sendmail.rc is the first address in
    the `autojudge_addresses' global variable, if that
    variable is non-empty, and is otherwise made automa-
    tically using a random number and the local account
    and host names.  The key is made automatically using
    a random number.

    The ./contest/secure/passwords file consists of
    lines of the form

	account:password:who:c-email:t-email:comment

    Here `account' is a the login name of the contes-
    tant, `who' is a description of who the contestant
    is, and the `c-email' and `t-email' fields are the
    email addresses used to contact the coach and to
    contact the team members using the account, respec-
    tively.  The `t-email' field is normally unset and
    unused.  The account name `none' may be used to
    indicate a line is not associated with an account,
    and the password `none' may be used to indicate the
    password is to be assigned by other means.

    The -secure program option also causes any existing
    ./contest/secure/passwords file to be inspected for
    lines with empty passwords.  If any are found,
    random passwords are generated and inserted in place
    of the missing passwords.  The password `none' may
    be used in a line to prevent a random password from
    being generated and to prevent the hpcm_set_
    passwords program from setting the password of the
    line's account.  If a new password is generated for
    an existing account, a TODO is written telling how
    to reset the account's password.


The -ssh Option
--- ---- ------

    The -ssh program option makes the file ./contest/
    extra_setup.tar whose contents are copied into each
    contestant account by the hpcm/contestant/bin/TRASH_
    ACCOUNT program that initializes contestant ac-
    counts.  The extra_setup.tar file contains just the
    file .ssh/authorized_keys which is the concatenation
    of all the files ~/.ssh/{identity,id_rsa,id_dsa}.pub
    that exist.  If none of these files exist, it is not
    an error, but a TODO to fix the situation is writ-
    ten.  In order to make the tar file, ./.ssh and
    ./ssh/authorized_keys are made.

    The ~/.ssh/{identity,id_rsa,id_dsa}.pub files are
    also copied by the -ssh option into the ./contest/
    .ssh directory, which is made if necessary, so these
    files will be available to the `hpcm/contestant/bin/
    authorize' program.


The -procmailrc Option
--- ----------- ------

    The ~/.procmailrc file is used to route incoming
    email to the `receivemail' and `dispatchmail' pro-
    grams.  The -procmailrc option updates ~/.procmailrc
    with one entry for each autojudge address password,
    where an autojudge address has the form `PPP<AAA>'
    and PPP is the password.  If ./contest/secure/
    hpcm_sendmail.rc exists, one autojudge address is
    taken from its contents.  The other autojudge
    addresses are listed in the `autojudge_addresses'
    global variable.  The ./contest/secure/hpcm_
    sendmail.rc autojudge address if it exists, or the
    first autojudge_addresses address otherwise, is
    written to the ./Contest_Address file.  If there are
    no autojudge addresses, it is not an error, but a
    TODO to fix the situation is written.

    The -procmailrc program option also ensures that
    the entry

		:0 c:
		hpcm_mbox

    is in the ~/.procmailrc file to put a copy of all
    incoming mail into the ~/hpcm_mbox file, just in
    case such a record is needed.  This entry must be
    before other entries that route mail.

    Lastly the -procmailrc program option puts any of
    its changes to .procmailrc before any entry
    starting with

    		:0 h

    preceded by a blank line.  Such an entry may be put
    at the end of .procmailrc to catch email not routed
    to the autojudge.

The -who_where Option
--- ---------- ------

    The ./contest/who_where file is a copy of the
    ./contest/secure/passwords file with passwords re-
    placed by `where' values.  This replacement is done
    by manually editing the ./contest/who_where file.
    The `where' values are used in the ./contest/
    printer_jobs file to designate the location of a
    contestant.  If the who_where file is not edited,
    its `where' values are \"WHERE\", which tells pro-
    grams to use the account name instead of the WHERE
    location to identify contestants.

    The -who_where program option makes the ./contest/
    who_where file if it does not exist, or updates it
    if it does exist and the ./contest/secure/passwords
    file is newer.  If any new accounts are inserted
    into the `who_where' file, a TODO to edit the file
    is written.  There may be accounts in the `who_
    where' file that are not in the `passwords' file.
    Lines with account name `none' in the `passwords'
    file are not copied to the `who_where' file.


The -trashable and -trashall Options
--- ---------- --- --------- -------

    The -trashable program option creates the ./contest/
    trashable file from the ./contest/secure/passwords
    file.  The `trashable' file is just a list of the
    accounts in the `passwords' file, not including the
    account name `none', and not including the names of
    any accounts that already exist.  The -trashall
    option is like the -trashable option but includes
    all accounts other than `none', whether or not an
    account already exists.

    An account needs to be listed in the `trashable'
    file in order for the `TRASH_ACCOUNT' program be
    able to initialize the files in the account.  This
    feature is intended to prevent accidental reini-
    tializing of accounts.

    If -trashable is given when all accounts exist, the
    `trashable' file is deleted.

    If the `trashable' file is changed to something non-
    empty, a TODO is written on how to set up accounts.


The -{contest,judging,scoreboard}_commands Options
--- -------------------------------------- -------

    The -contest_commands option makes files from the
    list elements of the contest_commands global vari-
    able.  See that variable in hpcm/lib/hpcm_judging.rc
    for details.

    The -judging_commands option makes files from the
    list elements of the judging_commands global vari-
    able.  See that variable in hpcm/lib/hpcm_judging.rc
    for details.

    The -scoreboard_commands program option appends the
    value of the scoreboard_commands global variable to
    the judging_commands global variable.  See documen-
    tation on scoreboard_commands in hpcm/judge/lib/
    hpcm_judging.rc.  Implies -judging_commands.


The -printer and -printer_map Options
--- -------- --- ------------ -------

    The -printer program option makes the ./contest/
    printer file if that file does not exist or is
    writable.  This file is the name of the printer,
    which is the value of the `contest_printer' global
    variable if that exists, else is the value of the
    `PRINTER' environment variable if that exists, else
    is the value `UNKNOWN' which means the file needs to
    be edited.  If the `contest_printer' global variable
    does not exist, a TODO is written to suggest editing
    the .contest/printer file just made.  The file is
    not written if it would not be changed.

    The -printer_map program option is similar to the
    -printer option but makes a ./contest/printer_map
    file instead of a ./contest/printer file and always
    uses the value of the `contest_printer_map' global
    variable.  The ./contest/printer_map file maps con-
    testant account names to printers.  If the `contest_
    printer_map' variable is not set, the file is not
    written but a TODO is written.

    Note that if both the ./contest/printer and
    ./contest/printer_map files exist, contestant
    programs ignore ./contest/printer.

    If either the ./contest/printer or ./contest/
    printer_map files are written, the ./contest/
    printer_jobs file is also made if it does not
    exist.

The -public_files Option
--- ------------- ------

    The -public_files program option calls

        write_public_files FILENAME \$VARIABLE

    for every list element of the form

    	{ FILENAME VARIABLE }

    in the `public_files' global variable, where 
    VARIABLE is a global variable.  It is necessary to
    use this indirect method of calling write_public_
    files to ensure that the `contest/' directory is
    created before public files are written.


The -javahelp, -c++help, and -pythonhelp Options
--- ---------- --------- --- ----------- -------

    The ./contest/XXXhelp file maps executions of the
    contestant `XXXhelp' program to executions of
    available browsers.  The -XXXhelp program option
    writes this file, making the file equal to the value
    of the `XXXhelp' global variable.  The file is
    written if it does not exist or if it does not equal
    the `XXXhelp' variable value.  If the `XXXhelp'
    variable is not set, the file is not written but a
    TODO is written.

    Currently XXX may be `java', `c++', or `python'.
    Note: + can be used in a variable name like c++help
    but \$c++help must be written \${c++help}.


The -web Option
--- ---- ------

    The -web program option invokes the makeweb program
    to make the ./web directory.  This directory is made
    to be copied to a web page somewhere.

    More specifically, ./web+ is made, compared with
    ./web, and if not the same, then ./web- is renamed
    to ./web--, ./web to ./web-, and ./web+ to ./web.

    Whenever ./web becomes more recent than ./web.tar,
    a new ./web.tar is made and a TODO is written to
    move ./web via ./web.tar to the appropriate remote
    host.


The -make_test Option
--- ---------- ------

    The -make_test program option makes the ./make_test
    file to be a copy of the `make_test' global variable
    if the variable exists and does not already equal
    the contents of the file.  This file can be included
    by the judging directory `Makefile', and allows the
    judging directory `hpcm_judging.rc' file to set up
    `make' targets for testing the contest.


The -startcontest and -scoreboard Options
--- ------------- --- ----------- -------

    The -startcontest program option executes the
    `startcontest start' command unless this has already
    been done, or if it has been done but a background
    process waiting to start the contest has died.

    The -scoreboard program option executes the
    `makescoreboard start' command unless this has
    already been done, or if the background process that
    maintains the scoreboard has died.  This option also
    moves any scoreboard.1head file from the judging
    directory to the contest directory if the contest
    directory exists and does not have this file.

Makecontest Execution Notes
----------- --------- -----

    Although we have used names such as `./info',
    `./mail', `./contest', and `./help' in this descrip-
    tion, we mean by `'./' the judging_directory, and
    NOT the current directory.  Like other HPCM pro-
    grams, `makecontest' can be run from anywhere in the
    directory subtree rooted at the judging directory,
    i.e., the directory containing the `hpcm_judging.rc'
    file.

    Unlike most HPCM judging programs, errors made by
    this program are not written to log files, but are
    announced on the standard error output.
"

# If no arguments are given, use the value of the
# makecontest_arguments global variable if that
# exists.
#
if {    $argc == 0 \
     && [info exists makecontest_arguments] } {
    set argv $makecontest_arguments
    set argc [llength $argv]
}

# Argi is the index of the current argument, for use in
# lindex.
#
set argi 0

# Set options, consuming option arguments.
#
set info_option				no
set solutions_option			no
set contest_option			no
set bin_option				no
set test_submissions_option		no
set home_option				no
set problems_option			no
set practice_option			no
set demos_option			no
set demos_solutions_option		no
set description_option			no
set help_option				no
set help2_option			no
set this_contest_option			no
set mail_option				no
set print_files_option			no
set problems_solution_files_option	no
set practice_solution_files_option	no
set demos_solution_files_option		no
set secure_option			no
set ssh_option				no
set procmailrc_option			no
set who_where_option			no
set trashable_option			no
set trashall_option			no
set contest_commands_option		no
set judging_commands_option		no
set printer_option			no
set printer_map_option			no
set public_files_option			no
set javahelp_option			no
set c++help_option			no
set pythonhelp_option			no
set web_option				no
set make_test_option			no
set scoreboard_commands_option		no
set startcontest_option			no
set scoreboard_option			no
#
while { $argi < $argc } {
    switch -- [lindex $argv $argi] {
	-local {
	    set contest_option			yes
	    set bin_option			yes
	    set test_submissions_option		yes
	    set home_option			yes
	    set solutions_option		yes
	    set help_option			yes
	    set help2_option			yes
	    set this_contest_option		yes
	    set mail_option			yes
	    set print_files_option		yes
	    set problems_solution_files_option	yes
	    set practice_solution_files_option	yes
	    set demos_solution_files_option	yes
	    set secure_option			yes
	    set procmailrc_option		yes
	    set who_where_option		yes
	    set trashable_option		yes
	    set contest_commands_option		yes
	    set judging_commands_option		yes
	    set scoreboard_commands_option	yes
	    set make_test_option		yes
	}
	-email {
	    set info_option			yes
	    set solutions_option		yes
	    set this_contest_option		yes
	    set mail_option			yes
	    set print_files_option		yes
	    set problems_solution_files_option	yes
	    set practice_solution_files_option	yes
	    set demos_solution_files_option	yes
	    set procmailrc_option		yes
	    set judging_commands_option		yes
	    set scoreboard_commands_option	yes
	    set make_test_option		yes
	}
	-formal	{
	    set contest_option			yes
	    set bin_option			yes
	    set test_submissions_option		yes
	    set home_option			yes
	    set solutions_option		yes
	    set help_option			yes
	    set help2_option			yes
	    set this_contest_option		yes
	    set mail_option			yes
	    set print_files_option		yes
	    set problems_solution_files_option	yes
	    set practice_solution_files_option	yes
	    set demos_solution_files_option	yes
	    set secure_option			yes
	    set procmailrc_option		yes
	    set who_where_option		yes
	    set trashable_option		yes
	    set contest_commands_option		yes
	    set judging_commands_option		yes
	    set scoreboard_commands_option	yes
	    set make_test_option		yes
	    set problems_option			yes
	    set practice_option			yes
	    set demos_option			yes
	    set demos_solutions_option		yes
	}
	-informal {
	    set contest_option			yes
	    set bin_option			yes
	    set test_submissions_option		yes
	    set home_option			yes
	    set solutions_option		yes
	    set help_option			yes
	    set help2_option			yes
	    set this_contest_option		yes
	    set mail_option			yes
	    set print_files_option		yes
	    set problems_solution_files_option	yes
	    set practice_solution_files_option	yes
	    set demos_solution_files_option	yes
	    set secure_option			yes
	    set procmailrc_option		yes
	    set who_where_option		yes
	    set trashable_option		yes
	    set contest_commands_option		yes
	    set judging_commands_option		yes
	    set scoreboard_commands_option	yes
	    set make_test_option		yes
	    set info_option			yes
	    set demos_solutions_option		yes
	}
	-info		{ set info_option	yes }
	-solutions	{ set solutions_option	yes }
	-contest	{ set contest_option	yes }
	-bin		{ set bin_option	yes }
	-test_submissions {
	    set test_submissions_option	yes }
	-home		{ set home_option	yes }
	-problems	{ set problems_option	yes }
	-practice	{ set practice_option	yes }
	-demos		{ set demos_option	yes }
	-demos_solutions {
	    set demos_solutions_option		yes
	    set demos_solution_files_option	yes
	    set solutions_option		yes
	}
	-description	{ set description_option yes }
	-help		{ set help_option	yes }
	-help2		{ set help2_option	yes }
	-this_contest   { set this_contest_option yes }
	-mail		{ set mail_option	yes }
	-print_files	{ set print_files_option yes }
	-problems_solution_files {
	    set problems_solution_files_option	yes
	    set solutions_option		yes
	}
	-practice_solution_files {
	    set practice_solution_files_option	yes
	    set solutions_option		yes
	}
	-demos_solution_files {
	    set demos_solution_files_option	yes
	    set solutions_option		yes
	}
	-secure		{ set secure_option	yes }
	-ssh		{ set ssh_option	yes }
	-procmailrc	{ set procmailrc_option	yes }
	-who_where	{ set who_where_option	yes }
	-trashable	{ set trashable_option	yes }
	-trashall	{ set trashall_option	yes }
	-contest_commands 
	    { set contest_commands_option yes }
	-judging_commands
	    { set judging_commands_option yes }
	-printer	{ set printer_option	yes }
	-printer_map	{ set printer_map_option yes }
	-public_files	{ set public_files_option yes }
	-javahelp	{ set javahelp_option	yes }
	-c++help	{ set c++help_option	yes }
	-pythonhelp	{ set pythonhelp_option	yes }
	-web		{ set web_option	yes }
	-make_test	{ set make_test_option	yes }
	-scoreboard_commands {
	    set scoreboard_commands_option	yes
	    set judging_commands_option		yes
	}
	-startcontest   { set startcontest_option yes }
	-scoreboard	{ set scoreboard_option yes }
	default		{ break }
    }
    incr argi
}

# If first remaining argument begins with `-', print
# documentation and exit with error.
#
if {    $argi < $argc \
     && [regexp {^-} [lindex $argv $argi]] } {
    exec << $document less -F >&@ stdout
    exit 1
}

# Announce judging directory.
#
puts "The Judging Directory, hereafter referred to as\
      `.', is:"
puts "    $j_d"


# Set up TODO
#
set TODO_file $j_d/TODO
set TODO_ch ""
set TODO_existed [expr { [file exists $TODO_file] \
			 && [file size $TODO_file] > 0 \
			 }]
proc TODO { args } {
    global TODO_file TODO_ch
    if { $TODO_ch == "" } {
	set TODO_ch [open $TODO_file a]
	puts $TODO_ch \
	     "==================== [local_date] TODOs:"
    }
    puts $TODO_ch "--------"
    foreach line $args {
	puts $TODO_ch "    $line"
    }
}

# Make 10 character random password.
#
proc make_password {} {
    return \
      [format {%02x%02x%02x%02x%02x} \
	      [expr { int ( rand() * 256 ) % 256 }] \
	      [expr { int ( rand() * 256 ) % 256 }] \
	      [expr { int ( rand() * 256 ) % 256 }] \
	      [expr { int ( rand() * 256 ) % 256 }] \
	      [expr { int ( rand() * 256 ) % 256 }]]
}

# The judging directory name relative to the home
# directory, for use in .procmailrc.  Note that j_d is
# absolute with no `/.'s or `/..'s: see above.
#
set j_d_relative $j_d
set hd $env(HOME)
if { ! [regexp "^$hd/(.*)\$" $j_d_relative \
	       forget j_d_relative] } {
    error "$j_d_relative does not begin with $hd/"
}

# Make $c_d directory.
#
if { $contest_option } {
    # The following does error checking if nothing else.
    #
    set_contest_directory

    # If contest_directory does not yet exist,
    # make it.
    #
    if { ! [file isdirectory $contest_directory] } {
	file mkdir $contest_directory
	puts "Made directory $contest_directory"
    }

    # If ./contest does not yet exist, make it.
    #
    if { [catch { file type $c_d }] } {
	link_file $contest_directory $c_d
	puts "Linked ./contest to $contest_directory"
    }
}

# Check if ./contest does not exist when it is needed.
# If ./contest is needed, grant a+x access to it and its
# parent.
#
if {    $contest_option \
     || $bin_option \
     || $test_submissions_option \
     || $home_option \
     || $problems_option \
     || $practice_option \
     || $demos_option \
     || $help_option \
     || $help2_option \
     || $secure_option \
     || $ssh_option \
     || $who_where_option \
     || $trashable_option \
     || $trashall_option \
     || $contest_commands_option \
     || $printer_option \
     || $printer_map_option \
     || $public_files_option \
     || $javahelp_option \
     || ${c++help_option} \
     || $pythonhelp_option \
     || $startcontest_option } {
    if {    ! [file isdirectory $c_d] \
	 || ! [file executable $c_d] \
	 || ! [file readable $c_d] } {
	error "./contest is not a useable directory"
    }
    if {    ! [regexp ..x [get_access $c_d]] \
	 || ! [regexp ..x [get_access $c_d/..]] } {
	puts "Granting a+x access"
	puts "         to ./contest"
	puts "         and its parent"
	grant_access $c_d x
	grant_access $c_d/.. x
    }
}

# Make $c_d/XXX directory for XXX = bin,
# test_submissions.
#
foreach XXX "bin test_submissions" {
    set contestant_d $hpcm_directory/contestant
    if { [set ${XXX}_option] } {
	if {    [catch { file type $c_d/$XXX }] \
	     && [file isdirectory \
		      $contestant_d/$XXX] } {
	    link_file $contestant_d/$XXX $c_d/$XXX
	    puts "Linked ./contest/$XXX"
	    puts "    to $contestant_d/$XXX"
	}
	if { ! [file exists $c_d/$XXX] } {
	    TODO "./contest/$XXX does not exist." \
		 "Link ./contest/$XXX to\
		  ..../hpcm/contestant/$XXX"
	} elseif { ! [file isdirectory $c_d/$XXX] } {
	    TODO "./contest/$XXX is not a directory." \
		 "Link it to ..../hpcm/contestant/$XXX"
	} elseif { ! [regexp {r.x} \
	                     [get_access $c_d/$XXX]] \
			    } {
	    TODO "./contest/$XXX is not a+rx." \
		 "Run `make' in ~/hpcm"
	}
    }
}

# Make $c_d/home directory.
#
if { $home_option } {
    if { [catch { file type $c_d/home }] } {
	if {    [info exists hpcm_prototype_account] \
	     && $hpcm_prototype_account != "" } {
	    set phd [account_home_directory \
		       $hpcm_prototype_account]
	} else {
	    set hds {}

	    # Warning, you must put - first in [-_], as
	    # if you use *[_-]proto it accepts all names
	    # whose last character is from _ through ]
	    # or is p, r, o, t, or o.
	    #
	    foreach hd [account_home_directories \
			    {*[-_]proto}] {
		if {    [file readable $hd/home] \
		     && [file executable $hd/home] \
		     && [file readable \
			      $hd/home/empty.ls] \
		     && [file readable \
			      $hd/home/setup.ls] \
		     && [file readable \
			      $hd/home/setup.tar] } {
		    lappend hds $hd
		}
	    }
	    set phd ""
	    if { [llength $hds] == 1 } {
		set phd [lindex $hds 0]
	    } elseif { [llength $hds] == 0 } {
		set phd_error \
		    "No suitable *\[_-\]proto account\
		     found."
	    } else {
		set phd_error \
		    "Too many prototype accounts found:\
		     $hds."
	    }
	}
	if { $phd != "" } {
	    link_file $phd/home $c_d/home
	    puts "Linked ./contest/home"
	    puts "    to $phd/home"
	    set phd_error \
		"./contest/home is improper link."
	}
    } else {
	set phd_error \
	    "./contest/home is improper link."
    }

    if {    ! [file readable $c_d/home] \
	 || ! [file executable $c_d/home] \
	 || ! [file readable $c_d/home/empty.ls] \
	 || ! [file readable $c_d/home/setup.ls] \
	 || ! [file readable $c_d/home/setup.tar] } {
	TODO "$phd_error" \
	     "Be sure an appropriate\
	      prototype account exists:" \
	     "See `SETUP_PROTOTYPE -doc'" \
	     "Then symbolically link ./contest/home" \
	     "to ~prototype_account/home," \
	     "and rerun `makecontest -home'."
    }
    if { [file exists $c_d/home] \
	 && ! [regexp {r.x} [get_access $c_d/home]] } {
	TODO "While logged into prototype account," \
	     "chmod a+rx target-of-./contest/home"
    }
}

# Array specifying option substitutions.  For each
# op1 to be substituted for, the value of
#
#	option_array(op1)
#
# is the list of options that is the substitution.

# Expand a list of options and return the result.
#
proc expand_options { option_list } {

    global option_array

    set result ""
    foreach option $option_list {
	if { [info exists option_array($option)] } {
	    set result \
		[concat $result \
			$option_array($option)]
	} else {
	    lappend result $option
	}
    }

    if { [info exists option_array(ALL)] } {
	set result \
	    [concat $result $option_array(ALL)]
	}

    return $result
}

# List of substitutions to be made in the names of the
# current input index file.  Each item of the list has
# the form `{source target}' which specifies that if a
# name begins with the string `source' that string
# should be replaced by the string `target'.
#
set substitutions ""

# Make the longest substitution possible in the
# name argument and return the result (or if
# there are no substitutions return the name
# argument).  If there is a length tie, apply
# the first substitution.
#
proc make_substitutions { name } {

    global substitutions

    set result $name
    set best_end -2

    foreach substitution $substitutions {
	set source [lindex $substitution 0]
	set end [string length $source]
	incr end -1

	if { [string range $name 0 $end] == $source \
	     && $best_end < $end } {
	    set target [lindex $substitution 1]
	    set best_end $end
	    incr end
	    set result [string range $name $end end]
	    set result $target$result
	}
    }

    return $result
}


# Process index specification using global variables
# as parameters:
#
#   index_file		the input index file name
#   index_directory	index directory name
#   help_index_chs	output help/index file channel
#			list; "" if none;  If there is
#			a help/index file, there may
#			in fact be two (one in ./info
#			and one in ./contest), so all
#			its lines must be written into
#			up to two channels, that are
#			listed here.
#   demos_index_chs	Ditto for help/demos file.
#   problems_index_chs	Ditto for help/problems file.
#   practice_index_chs	Ditto for help/practice file.
#   option_array	option substitutions
#			(see above)
#   substitutions	filename substitutions
#			(see above)
#   info_option		options
#   solutions_option
#   problems_option
#   practice_option
#   demos_option
#   help_option
#   j_d			directory names
#   c_d

# Helper function called when ${targetdir}index_ch is ""
# to compute and return the correct value of this
# variable.
#
proc get_index_chs { targetdir } {

    global info_option help_option j_d c_d \
	   help_index_chs problems_index_chs \
	   practice_index_chs demos_index_chs

    set chs ""
    if { $info_option || $help_option } {
	switch $targetdir {
	help		{ set file index
			  set head "Help Index" }
	problems	{ set file problems
			  set head "Problems Index" }
	practice	{ set file practice
			  set head "Practice Index" }
	demos		{ set file demos
			  set head "Demos Index" }
	}
	if { $info_option } {
	    lappend chs \
		    [open $j_d/info+/help/$file w]
	}
	if { $help_option } {
	    lappend chs [open $c_d/help+/$file w]
	}

	set ${targetdir}_index_chs $chs

	foreach ch $chs {
	    puts $ch [format {%-28s%28s} $head \
			     [local_date]]
	    puts $ch ""
	    puts $ch ""
	}
    }
    return $chs
}

# Main function to process an index specification.
#
# Subfunction to read problem.rc file.
#
proc read_rc_file { file problem options } {
    global PROBLEM EXTENSION OPTIONS \
	   problem_source_files \
	   problem_binary_source_files \
	   problem_data_source_files \
	   problem_solution_files \
	   problem_description_files \
	   problem_excluded_files \
	   problem_make_files \
	   problem_print_files \
	   problem_rc
    set PROBLEM $problem
    set EXTENSION UNDEFINED
    set OPTIONS $options
    source_file $file
    if { [info exists problem_rc($PROBLEM)] } {
	eval $problem_rc($PROBLEM)
    }
}
# Subfunction that returns true if item matches any
# regexp in a list of regexps.
#
proc index_match { item regexps } {
    foreach regexp $regexps {
	if { [regexp "^($regexp)\$" $item] } {
	    return 1
	}
    }
    return 0
}
#
# Subfunction to compute {description,source,solution}_
# files.  Directory and subdirectory names end in / or
# are empty.
#
proc index_find \
	{ dir subdir description_files_name \
		     source_files_name \
		     binary_source_files_name \
		     data_source_files_name \
		     solution_files_name } {

    global problem_description_files \
	   problem_source_files \
	   problem_binary_source_files \
	   problem_data_source_files \
	   problem_solution_files \
	   problem_excluded_files

    upvar $description_files_name description_files
    upvar $source_files_name source_files
    upvar $binary_source_files_name binary_source_files
    upvar $data_source_files_name data_source_files
    upvar $solution_files_name solution_files

    foreach name [glob -directory $dir$subdir \
		       -nocomplain -- *] {

	set name [file tail $name]
	if { [index_match $name \
			  $problem_excluded_files] } \
	    continue
	    
	if { [file isdirectory $dir$subdir$name] } {
	    index_find $dir $subdir$name/ \
			       description_files \
			       source_files \
			       binary_source_files \
			       data_source_files \
			       solution_files
	} elseif { [file exists $dir$subdir$name] } {
	    if { [index_match \
		      $name \
		      $problem_description_files] } {
		lappend description_files $subdir$name
	    } elseif { [index_match \
			    $name \
			    $problem_source_files] \
		     } {
		lappend source_files $subdir$name
	    } elseif { [index_match \
			 $name \
			 $problem_binary_source_files] \
		     } {
		lappend binary_source_files $subdir$name
	    } elseif { [index_match \
			 $name \
			 $problem_data_source_files] \
		     } {
		lappend data_source_files $subdir$name
	    }
	    if { [index_match \
		      $name \
		      $problem_solution_files] } {
		lappend solution_files $subdir$name
	    }
	}
    }
}
#
# Subfunction to grant access to a file and the
# subdirectories of a directory that contain it.
#
proc index_grant { dir file } {
    while { $file != "" && $file != "." } {
	grant_access $dir/$file
	set file [file dirname $file]
    }
}
#
# Subfunction to copy list of files from a source
# directory to a target directory, making target
# subdirectories as necessary.  Use index_grant to
# grant access to copy.
#
proc index_copy { source dest files } {
    foreach file $files {
	file mkdir [file dirname $dest/$file]
	copy_file $source/$file $dest/$file
	index_grant $dest $file
    }
}
#
# Subfunction to link list of files from a source
# directory to a target directory, making target
# subdirectories as necessary.
#
proc index_link { source dest files } {
    foreach file $files {
	file mkdir [file dirname $dest/$file]
	link_file $source/$file $dest/$file
    }
}
#
# Subfunction to copy list of binary files from a
# source directory to a target directory, making
# target subdirectories as necessary.  Encode the
# copies using encode_file and give the copies
# the indicated extension.
#
proc index_encode { source dest files extension } {
    foreach file $files {
	file mkdir [file dirname $dest/$file]
	encode_file $source/$file \
	            $dest/$file${extension}+
	copy_file $dest/$file${extension}+ \
		  $dest/$file${extension}
	file delete $dest/$file${extension}+
    }
}
#
proc process_index_specification {} {

    global index_file index_directory \
	   help_index_chs problems_index_chs \
	   practice_index_chs demos_index_chs \
	   help_print_files problems_print_files \
	   practice_print_files demos_print_files \
	   problems_solution_files \
	   practice_solution_files \
	   demos_solution_files \
	   info_option solutions_option \
	   problems_option practice_option \
	   demos_option \
	   help_option description_option \
	   j_d c_d \
	   problem_description_files \
	   problem_source_files \
	   problem_binary_source_files \
	   problem_data_source_files \
	   problem_solution_files \
	   problem_excluded_files \
	   problem_make_files \
	   problem_print_files \
	   problem_rc

    # Save hpcm_judging.rc defined values of global
    # variables reset by PROBLEM.rc file.
    #
    set default_description_files \
	$problem_description_files
    set default_source_files \
	$problem_source_files
    set default_binary_source_files \
	$problem_binary_source_files
    set default_data_source_files \
	$problem_data_source_files
    set default_solution_files \
	$problem_solution_files
    set default_excluded_files \
	$problem_excluded_files

    # Be sure index directory is absolute name, else
    # symbolic links will fail.
    #
    if { ! [regexp {^/} $index_directory] } {
	set index_directory [pwd]/$index_directory
    }
    set index_directory \
	[truename $index_directory]

    # Read the input index file and process its entries.
    #
    set index_ch [open $index_file r]

    # Are we in header, in item, or neither (in a
    # skipped item or at beginning of file).
    #
    set in_header		no
    set in_item			no

    # The xxxx_index_chs value for a current index
    # item.
    #
    set index_chs		""

    # Last header entry encountered, and switches to
    # tell if it has been used in various indices.
    # The header entry is a list of lines.
    #
    set header_entry		{}
    set help_header_used	no
    set demos_header_used	no
    set problems_header_used	no
    set practice_header_used	no

    # Switches to tell if any items have been written
    # into the various indices.
    #
    set help_index_written	no
    set demos_index_written	no
    set problems_index_written	no
    set practice_index_written	no

    while { "yes" } {

	# Read next input index line.
	#
	set line [gets $index_ch]
	if { [eof $index_ch] } break;

	# Skip comments.
	#
	if { [regexp {^#} $line] } continue;

	if {    ! [catch { set len [llength $line] }] \
	     && $len >= 1 \
	     && [lindex $line 0] == "***" } {

	    # Beginning of item entry.

	    set in_header	no

	    set name [lindex $line 1]
	    set options \
		[expand_options [lrange $line 1 end]]
	    set source $index_directory/$name

	    # Check name for legality.
	    #
	    if { [regexp {(^|/)(\.|-)} $name] } {
		error "Illegal item name `$name' in\
		       `$index_file'."
	    }

	    # Compute `indent', the part of the first
	    # item entry line before the item name,
	    # with `***' replaced by three spaces.
	    #
	    set ws "\[\ \t\]*"
	    regexp "^($ws\\*\\*\\*$ws)(\[^\ \t\]|\$)" \
		   $line forget indent forget2
	    regsub {\*\*\*} $indent {   } indent

	    set target [make_substitutions $name]

	    # Check target for legality.
	    #
	    if { [regexp {(^|/)(\.|-)} $target] } {
		error "Illegal item name `$name'\
		       after substitutions,\n\
		       \    in `$index_file'."
	    }

	    if { [lcontain $options noinclude] } {

		# Item is not included.

		set in_item	no

	    } elseif { ! [lcontain $options include] } {

		# Item is not included.

		set in_item	no

	    } else {

		# Item is included.

		set in_item	yes

		# Compute and check targetdir and
		# targettail such that $target ==
		# $targetdir/+$targettail and $targetdir
		# is the first component of the name
		# $target, and has no /'s.
		#
		# Targetdir must == `help', `demos',
		# `problems', or `practice'.
		#
		if { ! [regexp {^([^/]*)/+([^/].*)$} \
			       $target forget \
			       targetdir targettail] \
		     || ! [lcontain \
			     {help demos problems \
			                 practice} \
			     $targetdir] } {
		    error "Bad item name directory\
			   after substitution: $target"
		}

		# Compute output index channels associ-
		# ated with targetdir.
		#
		set index_chs \
		    [set ${targetdir}_index_chs]

		if { $index_chs == "" } {
		    set index_chs \
			[get_index_chs $targetdir]
		}

		# Write headers to output indices if
		# appropriate.
		#
		if { [set ${targetdir}_header_used] \
		     == "no" } {
		    set ${targetdir}_header_used yes

		    set refined_header {}
		    set last_is_blank 1
		    set hignore 0
		    foreach hline $header_entry {
		        set is_blank \
			    [regexp {^[ \t]*$} \
			            $hline]

			if { $hignore } {
			    if {    ! $last_is_blank \
			         || $is_blank } {
			        set last_is_blank \
				    $is_blank
				continue
			    }
			    set hignore 0
			}

			if { ! $last_is_blank } {
			    lappend refined_header \
			            $hline
		        } elseif { \
			      [catch \
				 { llength $hline }] } {
			    lappend refined_header \
			            $hline
		        } elseif { [lindex $hline 0] \
			           == "*TITLE*" } {
			    set hignore 1
		        } elseif { [lindex $hline 0] \
			           == "*OPTIONAL*" } {
			    set hoptions \
				[expand_options \
				  [lrange $hline 1 end]]
			    if {    [lcontain \
			               $hoptions \
				       noinclude] \
				 || ! [lcontain \
				         $hoptions \
					 include] } {
				set hignore 1
			    }
			} else {
			    lappend refined_header \
			            $hline
			}

			set last_is_blank $is_blank
		    }

		    if {    [llength $refined_header] \
		         != 0 } {
			foreach ch $index_chs {
			    foreach hline \
			            $refined_header {
				puts $ch $hline
			    }
			}
		    }
		}

		# Write first line of item entry, after
		# editing, to output indices, if appro-
		# priate.
		#
		foreach ch $index_chs {
		    puts $ch "$indent$target"
		}

		set ${targetdir}_index_written yes

		# Compute source, description, and solu-
		# tion files if $source is a directory.
		#
		if { [file isdirectory $source] } {

		    # Compute needed global variables.
		    #
		    set problem_description_files \
			$default_description_files
		    set problem_source_files \
			$default_source_files
		    set problem_binary_source_files \
			$default_binary_source_files
		    set problem_data_source_files \
			$default_data_source_files
		    set problem_solution_files \
			$default_solution_files
		    set problem_excluded_files \
			$default_excluded_files
		    catch { unset problem_make_files }
		    catch { unset problem_print_files }
		    set PROBLEM [file tail $source]
		    read_rc_file \
			$source/$PROBLEM.rc \
			$PROBLEM $options
		    if { [info exists \
			       problem_make_files] } {
			execute_makes \
			    $problem_make_files \
			    $source \
			    "problem_make_files value\
			     for $PROBLEM"
		    }
		    set md5file $source/$PROBLEM.md5sum
		    if { [file exists $md5file] } {
			puts "Checking $md5file"
			set md5out \
			    [check_md5sums $source \
			        $PROBLEM.md5sum]
			if { $md5out != "" } { 
			    eval TODO \
			         [list "Fix $md5file\
				        error:"] \
				 [split $md5out "\n"]
			}
		    }
		    if { [lcontain $options all] \
			 && \
			 ! [lcontain $options notall] \
		       } {
			set problem_source_files {.*}
			set problem_description_files {}
		    }
		    set source_files {}
		    set binary_source_files {}
		    set data_source_files {}
		    set description_files {}
		    set solution_files {}
		    index_find $source/ "" \
			description_files \
			source_files \
			binary_source_files \
			data_source_files \
			solution_files
		    if { [info exists \
			       problem_print_files] } {
			set print_files \
			    $problem_print_files
		    } else {
			set print_files \
			    [lsort $description_files]
		    }
		}

		# Process info option.
		#
		if { $info_option } {

		    set destination \
			$j_d/info+/$target

		    if { [file isfile $source] } {
			file mkdir \
			     [file dirname $destination]
			link_file $source $destination
		    } elseif { [file isdirectory \
				     $source] } {
			file mkdir $destination
			index_link \
			    $source $destination \
			    [concat \
			       $source_files \
			       $description_files]
			index_encode \
			    $source $destination \
			    $binary_source_files \
			    .BIN
			index_encode \
			    $source $destination \
			    $data_source_files \
			    .DAT
		    } else {
			error "Source `$source' is\
			       neither a file nor a\
			       directory."
		    }
		}

		# Process $targetdir option.
		#
		if { [set ${targetdir}_option] } {

		    set destination "$c_d/$targetdir+"
		    set destination \
			"$destination/$targettail"
		    if { [file isfile $source] } {
			file mkdir \
			     [file dirname $destination]
			copy_file $source $destination
			index_grant $c_d/$targetdir+ \
				    $targettail
		    } elseif { [file isdirectory \
				     $source] } {
			file mkdir $destination
			index_grant $c_d/$targetdir+ \
				    $targettail
			
			set files [concat \
			    $source_files \
			    $binary_source_files \
			    $data_source_files]
			if { $description_option } {
			    lappend_lists files \
				$description_files
			}
			index_copy \
			    $source $destination \
			    $files
		    } else {
			error "Source `$source' is\
			       neither a file nor a\
			       directory."
		    }
		}

		# Process solutions option.
		#
		if {    $solutions_option \
		     && [lcontain {problems practice \
		                   demos} \
				  $targetdir] \
		     && ( [lcontain $options solution] \
			  || \
			  ! [lcontain $options \
				    nosolution] ) } {
		    if { ! [file isdirectory $source] \
				} {
			error "$source solution is not\
			       a directory"
		    } elseif { [regexp {/} \
				       $targettail] } {
			error "`$targettail' is to be\
			       linked into the\
			       solutions directory but\
			       contains a `/'"
		    }
		    set s_d $j_d/solutions+
		    link_file $source $s_d/$targettail
		}

		# Add to print file lists.
		#
		if { $solutions_option } {
		    set s $j_d/solutions+/$targettail
		} else {
		    set s $j_d/solutions/$targettail
		}
		if { $info_option } {
		    set i $j_d/info+/$target
		} else {
		    set i $j_d/info/$target
		}
		if { [set ${targetdir}_option] } {
		    set t $j_d/contest
		    set t $t/$targetdir+/$targettail
		} else {
		    set t $j_d/contest/$target
		}
		if {    [lcontain {problems practice \
		                            demos} \
				  $targetdir] \
		     && [file exists $s] } {
		    set print_target \
			solutions/$targettail
		} elseif { [file exists $i] } {
		    set print_target info/$target
		} elseif { [file exists $t] } {
		    set print_target contest/$target
		} else {
		    set print_target UNKNOWN/$target
		}
		if { [file isdirectory $source] } {
		    foreach f $print_files {
			lappend \
			    ${targetdir}_print_files \
			    $print_target/$f
		    }
		} else {
		    lappend ${targetdir}_print_files \
			    $print_target
		}

		# Add to XXX solution file list.
		#
		if { [file isdirectory $source] } {
		    foreach f $solution_files {
			 if {    $targetdir \
			      == "problems" } {
			    lappend \
			      problems_solution_files \
			      solutions/$targettail/$f
			 } elseif {    $targetdir \
				    == "practice" } {
			    lappend \
			      practice_solution_files \
			      solutions/$targettail/$f
			 } elseif {    $targetdir \
				    == "demos" } {
			    lappend \
				demos_solution_files \
				solutions/$targettail/$f
			 }
		    }
		}
	    }
	
	    # Process solutions option for non-included
	    # items.
	    #
	    if {    $solutions_option \
		 && $in_item == "no" \
		 && ( [lcontain $options solution] \
		      && \
		      ! [lcontain $options \
				  nosolution] ) } {
		if { ! [file isdirectory $source] \
			    } {
		    error "$source solution is not\
			   a directory"
		}
		set targettail [file tail $target]
		set s_d $j_d/solutions+
		link_file $source $s_d/$targettail
	    }

	} elseif { $in_header } {

	    # Line inside header.

	    lappend header_entry $line

	} elseif { [regexp "^\[^\ \t\]" $line] } {

	    # Beginning of header entry.

	    set header_entry		[list $line]
	    set in_header		yes
	    set in_item			no
	    set help_header_used	no
	    set demos_header_used	no
	    set problems_header_used	no
	    set practice_header_used	no

	} elseif { $in_item } {

	    # Line inside included item.

	    foreach ch $index_chs {
		puts $ch $line
	    }
	}
    }

    # If we copied any index entries, put out 2 blank
    # lines to separate this input index file's entries
    # from those of the next input index file.
    #
    foreach dir {help problems practice demos} {
	if { [set ${dir}_index_written] } {
	    foreach ch [set ${dir}_index_chs] {
		puts $ch ""
		puts $ch ""
	    }
	}
    }

    close $index_ch

    # Restore hpcm_judging.rc defined values of global
    # variables reset by PROBLEM.rc file.
    #
    set problem_source_files \
	$default_source_files
    set problem_binary_source_files \
	$default_binary_source_files
    set problem_data_source_files \
	$default_data_source_files
    set problem_solution_files \
	$default_solution_files
    set problem_description_files \
	$default_description_files
    set problem_excluded_files \
	$default_excluded_files
}

# Set up info+, solutions+, problems+, practice+,
# demos+, and help+ directories.
#
if { $info_option } {
    if { [file exists $j_d/info+] } {
	puts "Deleting ./info+"
	file delete -force -- $j_d/info+
    }
    file mkdir $j_d/info+
    file mkdir $j_d/info+/help
}
foreach dir {problems practice demos help} {
    if { [set ${dir}_option] } {
	if { [file exists $c_d/$dir+] } {
	    puts "Deleting out-of-date ./contest/$dir+"
	    file delete -force -- $c_d/$dir+
	}
	file mkdir $c_d/$dir+
	if { $dir != "problems" } {
	    grant_access $c_d/$dir+
	}
    }
}
if { $solutions_option } {
    if { [file exists $j_d/solutions+] } {
	puts "Deleting ./solutions+"
	file delete -force -- $j_d/solutions+
    }
    file mkdir $j_d/solutions+
}

# Process -this_contest.
#
if { $this_contest_option } {
    set TODO_lines {}

    # Make help directory.
    #
    if { ! [file isdirectory $j_d/help] } {
	file mkdir $j_d/help
	puts "Made ./help"
    }

    # Make help/index file.
    #
    if { ! [file readable $j_d/help/index] } {
	write_file $j_d/help/index [string trim "
To display the file listed as `help/topic' below use the
command:
		      help topic

E.g., `help index' displays this file.


Indices:
--------

    help/index
	This file.

    help/demos
	Index of contest demonstration problems.

    help/practice
	Index of contest practice problems.

    help/problems
	Index of contest problems.



Introductory Information:
-------------------------


*** this_contest include
	Information about this contest.
"]
	lappend TODO_lines "  ./help/index"
	puts "Wrote ./help/index"
    }

    # Compute header for help/this_contest* files.
    #
    set header \
	[format "%-28s%28s\n\n" \
		"About This Contest" \
		[local_date]]

    # Compute content for help/this_contest* files.
    #
    set content [string trim $this_contest]

    # Make help/this_contest_original file.
    #
    if { ! [file readable \
		$j_d/help/this_contest_original] } {
	write_file $j_d/help/this_contest_original \
		   "$header$content"
	lappend TODO_lines \
		"  ./help/this_contest_original"
	puts "Wrote ./help/this_contest_original"
    }

    # Save help/this_contest_parameter file.
    #
    set tcpexists \
	[file readable $j_d/help/this_contest_parameter]
    if { $tcpexists } {
	set tcpcontent \
	    [read_entire_file \
		 $j_d/help/this_contest_parameter]
	regexp {^About This Contest[^\n]*\n\n(.*)$} \
	       $tcpcontent forget tcpcontent
    }

    # Make help/this_contest_parameter file.
    #
    if {    ! $tcpexists \
	 || $content != $tcpcontent } {
	write_file $j_d/help/this_contest_parameter \
		   "$header$content"
	lappend TODO_lines \
		"  ./help/this_contest_parameter"
	puts "Wrote ./help/this_contest_parameter"
    }

    # Save help/this_contest file.
    #
    set tcexists \
	[file readable $j_d/help/this_contest]
    if { $tcexists } {
	set tccontent \
	    [read_entire_file $j_d/help/this_contest]
	regexp {^About This Contest[^\n]*\n\n(.*)$} \
	       $tccontent forget tccontent
    }

    # Make help/this_contest file.
    #
    if {    ! $tcexists
	 || (    $tcpexists \
	      && $tcpcontent == $tccontent \
	      && $content != $tccontent ) } {
	write_file $j_d/help/this_contest \
		   "$header$content"
	lappend TODO_lines "  ./help/this_contest"
	eval TODO Made $TODO_lines \
	     {"You may want to edit\
	       ./help/this_contest" \
	      "and rerun `makecontest -help' if\
	       ./contest exists" \
	      "and then rerun `makecontest -web'\
	       if web.tar exists"}
	puts "Wrote ./help/this_contest"
    }
}

# Set up print file lists.
#
set help_print_files ""
set problems_print_files ""
set practice_print_files ""
set demos_print_files ""
set problems_solution_files ""
set practice_solution_files ""
set demos_solution_files ""

# Set up channel lists.
#
set help_index_chs	""
set demos_index_chs	""
set problems_index_chs	""
set practice_index_chs	""

# Process arguments, forming index specifications
# encoded in global variables, and call process_index_
# specification (see above) for each specification.
#
set mode file
#
# Mode indicates what next argument should be: file,
# directory, or substitution.
#
foreach arg [lrange $argv $argi end] {

    # Process next argument.  Whether argument ends in
    # `,' or `:' tells mode of next argument.
    #
    if { $mode == "file" } {
	if { [regexp {^(.*):$} $arg forget arg] } {
	    set mode directory
	} else {
	    if { [regexp {^(.*),$} $arg forget arg] } {
		set mode substitution
	    }
	    set index_directory [file dirname $arg]
	}
	set index_file $arg
	set substitutions ""
	if { [array exists option_array] } {
	    unset option_array
	}
    } elseif { $mode == "directory" } {
	if { [regexp {^(.*),$} $arg forget arg] } {
	    set mode substitution
	} else {
	    set mode file
	}
	set index_directory $arg
    } elseif { $mode == "substitution" } {
	if { ! [regexp {^(.*),$} $arg forget arg] } {
	    set mode file
	}
	if { [regexp {^([^=]*)=([^=]*)$} $arg forget \
		       source destination] } {
	    lappend substitutions \
		    [list $source $destination]
	} elseif { [regexp {^([^:]*):([^:]*)$} \
			   $arg forget \
		       source destination] } {
	    set option_array($source) \
		[string trim $destination]
	} else {
	    error "Badly formatted substitution:\
		   `$arg'"
	}
    }

    if { $mode == "file" } {
	process_index_specification
    }
}
if { $mode != "file" } {
    error "Last argument ends with `,' or `:'"
}

# Finish up index output files.
#
foreach dir {problems practice help demos} {
    foreach ch [set ${dir}_index_chs] {
	close $ch
    }
}
if { [file exists $c_d/help+/index] } {
    grant_access $c_d/help+/index
}
if { [file exists $c_d/help+/demos] } {
    grant_access $c_d/help+/demos
}

# If -help make or remake ./contest/help/this_contest
#
if { $help_option } {
    if { [file readable $j_d/help/this_contest] } {
        set contents \
	    [read_entire_file $j_d/help/this_contest]
	write_file_if_different \
	    $c_d/help+/this_contest $contents
	grant_access $c_d/help+/this_contest
    } else {
        if { [catch { \
	        set name \
		    [file link \
			  $c_d/help+/this_contest] }] \
	     || $name != "index" } {
	    file delete $c_d/help+/this_contest
	    file link -symbolic \
	         $c_d/help+/this_contest index
	}
    }
}

# Make ./contest/demos/solutions and/or .info/demos/
# solutions directories if necessary.  The demos
# directory is ./contest/demos+ at this point, and the
# info/demos directory is ./info+/demos.
#
if { $demos_solutions_option } {

    foreach d_d [list $c_d/demos+ $j_d/info+/demos] {

        if { ! [file isdirectory $d_d] } continue

	set demos {}
	foreach d [glob -nocomplain $d_d/*] {
	    set demo [file tail $d]
	    lappend demos $demo
	}

	set ds $d_d/solutions
	file mkdir $ds
	grant_access $ds

	foreach f $demos_solution_files {
	    set d [file tail [file dirname $f]]
	    if { ! [lcontain $demos $d] } continue
	    set file [file tail $f]
	    if { $f != "solutions/$d/$file" } {
		error \
		  "bad file $f in demos_solution_files"
	    }
	    file mkdir $d_d/solutions/$d
	    grant_access $d_d/solutions/$d
	    copy_file solutions+/$d/$file \
		      $d_d/solutions/$d/$file
	    grant_access $d_d/solutions/$d/$file
	}
    }
}


# Diff two directories.  If the only differences are the
# first lines of help indices, return `no'.  Else return
# `yes'.  Returning `yes' when one should have returned
# `no' introduces a lack of optimization, but no func-
# tional error.
#
proc diff_dirs { dir1 dir2 } {
    catch { diff_directories $dir1 $dir2 } out
    set out [split $out "\n"]

    while { [llength $out] > 0 } {
	set diffexp \
	  {^diff -r .*/([^/ ]*) .*/([^/ ]*)$}
	if { [regexp $diffexp [lindex $out 0] \
		     forget index1 index2] \
	     && $index1 == $index2 \
	     && [lcontain {demos problems practice \
	                         index} \
			  $index1] } {
	    if { [lindex $out 1] != "1c1" } {
		return yes
	    } elseif { ! [regexp {^< [^ ]* Index} \
				  [lindex $out 2]] } {
		return yes
	    } elseif { [lindex $out 3] != "---" } {
		return yes
	    } elseif { ! [regexp {^> [^ ]* Index} \
				  [lindex $out 4]] } {
		return yes
	    }
	    set out [lrange $out 5 end]
	} elseif { [lindex $out 0] == \
		   "child process exited abnormally" } {
	    set out [lrange $out 1 end]
	} else {
	    return yes
	}
    }

    return no
}

# Rename directories iff $j_d/$directory+ differs from
# $j_d/$directory as determined by `diff_dirs'.  If a
# directory is not renamed, delete it.  Return `yes' if
# directory renamed, and `no' if deleted.  Note that
# `directory' argument is relative to j_d.
#
proc rename_directory { directory } {

    global j_d

    if { [diff_dirs $j_d/$directory $j_d/$directory+] \
	 == "no" } {
	file delete -force -- $j_d/$directory+
	return no
    } else {

	if { [file exists $j_d/$directory--] } {
	    file delete -force -- $j_d/$directory--
	}
	if { [file exists $j_d/$directory-] } {
	    puts "Renaming $directory-"
	    puts "      to $directory--"
	    file rename $j_d/$directory- \
	                $j_d/$directory--
	    deny_access $j_d/$directory--
	}
	if { [file exists $j_d/$directory] } {
	    puts "Renaming $directory"
	    puts "      to $directory-"
	    file rename $j_d/$directory $j_d/$directory-
	    deny_access $j_d/$directory-
	}
	if { [file exists $j_d/$directory+] } {
	    puts "Renaming $directory+"
	    puts "      to $directory"
	    file rename $j_d/$directory+ $j_d/$directory
	}
	return yes
    }
}

if { $info_option } {
    rename_directory info
}
if { $problems_option } {
    if { [regexp {r.x} [get_access $c_d/problems]] } {
	grant_access $c_d/problems+
    }
    rename_directory contest/problems
}
if { $practice_option } {
    if { [regexp {r.x} [get_access $c_d/practice]] } {
	grant_access $c_d/practice+
    }
    rename_directory contest/practice
}
if { $help_option } {
    if { [regexp {r..} \
		 [get_access $c_d/help/problems]] } {
	grant_access $c_d/help+/problems
    }
    rename_directory contest/help
}
if { $demos_option } {
    rename_directory contest/demos
}
if { $solutions_option } {
    rename_directory solutions
}

# Output `output' to `file' with renames if `file' would
# be changed.  Specifically, if `file' exists and equals
# `output' do nothing.  Otherwise move `file-' to
# `file--', `file' to `file-', and write `output' to
# `file'.  Here `file' is the name relative to `j_d'.
#
proc output_file { file output } {
    global j_d

    set f $j_d/$file
    if {    ! [file readable $f] \
	 || [read_entire_file $f] != $output } {
	file delete -force -- $f--
	if { [file exists $f-] } {
	    puts "Renaming ./${file}-"
	    puts "      to ./${file}--"
	    file rename $f- $f--
	}
	if { [file exists $f] } {
	    puts "Renaming ./${file}"
	    puts "      to ./${file}-"
	    file rename $f $f-
	}
	write_file $f $output
	puts "Wrote ./${file}"
    }
}

# Output print files if necessary
#
if { $print_files_option } {
    if { [file isdirectory $j_d/info/help] } {
	set target info/help
    } elseif { [file isdirectory $j_d/contest/help] } {
	set target contest/help
    } else {
	set target UNKNOWN/help
    }
    foreach dir {problems practice demos help} {
	if { $dir == "help" } {
	    set output $target/index

	    # Move this_contest to front of help list.
	    #
	    set i [lsearch -regexp $help_print_files \
				   {/this_contest$}]
	    if { $i >= 0 } {
		set tc [lindex $help_print_files $i]
		set output "$tc\n$output"
		set help_print_files \
		    [lreplace $help_print_files $i $i]
	    }
	} else {
	    set output $target/$dir
	}
	foreach f [set ${dir}_print_files] {
	    set output "$output\n$f"
	}
	output_file ${dir}_print_files $output
    }
}

# Output problems solution files if necessary
#
if { $problems_solution_files_option } {
    set output ""
    foreach f $problems_solution_files {
	set output "$output\n$f"
    }
    set output [string range $output 1 end]
    output_file problems_solution_files $output
}

# Output practice solution files if necessary
#
if { $practice_solution_files_option } {
    set output ""
    foreach f $practice_solution_files {
	set output "$output\n$f"
    }
    set output [string range $output 1 end]
    output_file practice_solution_files $output
}

# Output demos solution files if necessary
#
if { $demos_solution_files_option } {
    set output ""
    foreach f $demos_solution_files {
	set output "$output\n$f"
    }
    set output [string range $output 1 end]
    output_file demos_solution_files $output
}

# Make mail directory.
#
if { $mail_option \
      && ! [file isdirectory $j_d/mail] } {
    file mkdir $j_d/mail
    puts "Made directory ./mail"
    grant_access $j_d/mail x
    grant_access $j_d x
    grant_access $j_d/.. x
    puts "Granting a+x access"
    puts "         to $j_d"
    puts "         and its parent"
}

# Make $c_d/help2 directory.
#
if { $help2_option \
     && ! [file isdirectory $c_d/help2] } {
    if { ! [catch {
	      set help2_type \
		  [file type $c_d/help2] }] } {
	if { $help2_type == "link" } {
	    puts "Deleting ./contest/help2"
	    file delete -force -- $c_d/help2
	} else {
	    error "./contest/help2 exists but is not a\
		   directory"
	}
    }
    link_file help $c_d/help2
    puts "Linked ./contest/help2"
    puts "    to ./contest/help"
}

# Make secure directory.
#
if { $secure_option \
     && ! [file isdirectory $c_d/secure] } {
    file mkdir $c_d/secure
    deny_group_access $c_d/secure
    puts "Made directory ./contest/secure"
}

# Make or edit secure/passwords file.
#
if { $secure_option } {
    if { ! [file readable $c_d/secure/passwords] } {
	set apw account:password:who
	set ctc coaches-email:team-email:comment
	set ch [open $c_d/secure/passwords w]
	puts $ch "# If you add an existing account to\
		    this file,"
	puts $ch "# execute `makecontest' and THEN\
		    execute `makecontest -trashall'"
	puts $ch "#"
	puts $ch "# $apw:$ctc"
	puts $ch ""
	close $ch
	deny_group_access $c_d/secure/passwords
	puts "Wrote ./contest/secure/passwords"
	TODO "Edit ./contest/secure/passwords;" \
	     "each of its lines has the format:" \
	     "`$apw:$ctc'." \
	     "Then rerun `makecontest'" \
	     "This will fill in missing passwords." \
	     "Use `none' as a password if you do not\
	      want a password that is set by" \
	     "hpcm_setup_acounts when that is run\
	      later."
    } else {
	set passwords_ch [open $c_d/secure/passwords r]
	set lines ""
	set changed no
	set account_exists no
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    if {    ! [regexp {^[ \t]*(#|$)} $line] \
		 && [regexp {^([^:]+)(|:|::.*)$} $line \
			    forget account forget2] } {
		set password [make_password]
		set rest ""
		regexp {^[^:]+:(:.*)$} $line \
		       forget rest
		set line "$account:$password$rest"
		set changed yes
		if { [account_home_directory \
			  $account] != "" } {
		    set account_exists yes
		}
	    }
	    lappend lines $line
	}
	close $passwords_ch

	if { $changed} {
	    set passwords_ch \
		[open $c_d/secure/passwords w]
	    foreach line $lines {
		puts $passwords_ch $line
	    }
	    close $passwords_ch
	    puts "Wrote ./contest/secure/passwords"

	    if {    $account_exists \
		 && $trashall_option == "no" } {
		set trashall_option yes
		set trashable_option no
		TODO "Passwords have been added to" \
		     "$c_d/secure/passwords" \
		     "for accounts that already\
		      exist." \
		     "" \
		     "Therefore the -trashall option\
		      has been forced."
	    } elseif {    $account_exists == "no" \
		       && $trashable_option == "no" \
		       && $trashall_option == "no" } {
		set trashable_option yes
		TODO "Passwords have been added to" \
		     "$c_d/secure/passwords" \
		     "but only for accounts that do NOT\
		      already exist." \
		     "" \
		     "Therefore the -trashable option\
		      has been forced."
	    }
	}
    }
}

# Make secure/hpcm_sendmail.rc file.
#
if { $secure_option \
     && ! [file readable \
		$c_d/secure/hpcm_sendmail.rc] } {
    set rc_ch [open $c_d/secure/hpcm_sendmail.rc w]
    if { [llength $autojudge_addresses] > 0 } {
	set to [lindex $autojudge_addresses 0]
    } else {
	set to \
	  "[make_password]<[account_name]@[host_name]>"
    }
    puts $rc_ch "To: $to"
    set key [make_password]
    puts $rc_ch "Key: $key"
    set key_name [file tail $j_d_relative]
    regexp {^(.*)(-|_)[^-_]*$} $key_name \
	   forget key_name forget2
    puts $rc_ch "Key-Name: $key_name"
    close $rc_ch
    deny_group_access $c_d/secure/hpcm_sendmail.rc
    puts "Wrote ./contest/secure/hpcm_sendmail.rc"


    # Check contest/bin/hpcm_sendmail mode.
    #
    if {    [file exists $c_d/bin/hpcm_sendmail] \
	 && ! [regexp {..s} \
		      [get_access \
			   $c_d/bin/hpcm_sendmail]] } {
	TODO "chmod u+s,a+x ./contest/bin/hpcm_sendmail"
    }
}

# Check secure directory and file modes minimally.
#
if { $secure_option } {
    if {    [file exists $c_d/secure] \
	 && ! [regexp -- {---} \
		      [get_access $c_d/secure]] } {
	TODO "chmod o-rwx ./contest/secure"
    }
    if {    [file exists $c_d/secure/hpcm_sendmail.rc] \
	 && ! [regexp -- {---} \
		      [get_access \
			$c_d/secure/hpcm_sendmail.rc]] \
					} {
	TODO "chmod o-rwx\
	      ./contest/secure/hpcm_sendmail.rc"
    }
    if {    [file exists $c_d/secure/passwords] \
	 && ! [regexp -- {---} \
		      [get_access \
			   $c_d/secure/passwords]] } {
	TODO "chmod o-rwx ./contest/secure/passwords"
    }
}

# Make ./contest/extra_setup.tar and ./contest/.ssh
#
if { $ssh_option } {
    set keys ""
    set key_changed no
    foreach f { identity.pub id_rsa.pub id_dsa.pub } {
	set src $env(HOME)/.ssh/$f
	set des $c_d/.ssh/$f
	set dir $c_d/.ssh
	if { [file readable $src] } {
	    set keys "$keys\n[read_entire_file $src]"
	    if { ! [file isdirectory $dir] } {
		file mkdir $dir
		grant_access $dir
		puts "Made ./contest/.ssh"
	    }
	    if { ! [file readable $des] \
		 || \
		 ! [compare_files $src $des] } {
		file delete -force $des
		copy_file $src $des
		grant_access $des
		puts "Wrote ./contest/.ssh/$f"
		set key_changed yes
	    }
	} elseif { [file readable $des] } {
	    file delete -force $des
	    puts "Deleted ./contest/.ssh/$f"
	    set key_changed yes
	}
	   
    }
    if { $keys == "" } {
	TODO "Cannot make ./contest/extra_setup.tar\
		     or ./contest/.ssh" \
	     "    because none of the files\
	      ~/.ssh/identity.pub, ~/.ssh/id_rsa.pub" \
	     "    or ~/.ssh/id_dsa.pub exist." \
	     "Run ssh-keygen and then `makecontest\
	      -ssh'."
    } elseif { $key_changed } {
	set keys [string range $keys 1 end]
	file delete -force -- $j_d/.ssh
	file mkdir $j_d/.ssh
	deny_group_access $j_d/.ssh
	write_file $j_d/.ssh/authorized_keys $keys
	deny_group_access $j_d/.ssh/authorized_keys
	set wd [pwd]
	cd $j_d
	exec tar cf ./contest/extra_setup.tar .ssh
	cd $wd
	grant_access $c_d/extra_setup.tar
	puts "Wrote ./contest/extra_setup.tar"
    }
}

# Update ~/.procmailrc
#
if { $procmailrc_option } {
    set addresses $autojudge_addresses
    set to [lindex [read_sendmail_rc] 0]
    if { $to != "" } {
	lappend addresses $to
    } else {
	set to [lindex $addresses 0]
    }
       
    if { [llength $addresses] == 0 } {
	TODO "There are no autojudge addresses" \
	     "Set the autojudge_addresses variable" \
	     "and run `makecontest -procmailrc'"
    }
    set to [string trim $to]
    if {    $to != "" \
	 && (    ! [file exists $j_d/Contest_Address] \
	      ||    [read_file $j_d/Contest_Address] \
		 != $to ) } {
	if { [file exists $j_d/Contest_Address] } {
	    puts "Deleted ./Contest_Address"
	    file delete -force $j_d/Contest_Address
	}
	write_file $j_d/Contest_Address $to
	puts "Wrote ./Contest_Address"
    }
    set passwords {}
    foreach to $addresses {
	set password ""
	regexp {^([^<]*)<} $to forget password
	set password [string trim $password]
	if { $password == "" } {
	    error \
	      "Cannot find autojudge password in\
	       address `$to'\nthat is\
	       in ./contest/secure/hpcm_sendmail.rc\
	       or autojudge_addresses"
	}
	if { ! [lcontain $passwords $password] } {
	    lappend passwords $password
	}
    }

    set add_mbox yes
    set mbox {(^|[ \t])hpcm_mbox($|[ \t])}
    set password ""
    set to_line ". . ."
    set dis {receivemail[ \t]+([^ \t]+)($|[ \t])}
    set original_passwords $passwords
    if { ! [catch { set ch [open ~/.procmailrc r] }] } {
	while { "yes" } {
	    set line [gets $ch]
	    if { [eof $ch] } break

	    if { [regexp {^[ \t]*#} $line] } {
		# comment line
	    } elseif { [regexp {^:} $line] } {
		# start of procmailrc entry
		set password ""
		set to_line ". . ."
	    } elseif { [regexp {To:.*$} $line to] } {
		set password ""
		regexp {^To:\.\*([^<]*)(<|$)} $to \
		       forget password
		set password [string trim $password]
		set to_line $line
	    } elseif {    [regexp $dis $line \
				  forget dir] \
		       &&    [string trim $dir] \
			  == $j_d_relative } {
		set i [lsearch -exact \
			       $passwords $password]
		if { $password == "" } {
		    TODO "Bad entry in ~/.procmail" \
			 "    $to_line" \
			 "    $line" \
			 "    . . ." \
			 " Remove or fix entry."
		} elseif {   [lsearch -exact \
		                $original_passwords \
				$password] \
			   < 0 } {
		    TODO "Extra entry in ~/.procmail" \
			 "    $to_line" \
			 "    $line" \
			 "    . . ." \
			 "Remove entry or add address\
			  to autojudge_addresses\
			  global variable."
		} elseif { $i >= 0 } {
		    set passwords \
			[lreplace $passwords $i $i]
		}
	    } elseif { [regexp $mbox $line] } {
		set add_mbox no
	    }
	}
	close $ch
    }

    if { $add_mbox || [llength $passwords] > 0 } {
	set file [read_entire_file ~/.procmailrc]
	set end_file ""
	set file_regexp \
	    "\\A(.*)(\n\n:0\[ \t\]+h\[ \t\]*\n.*)\\Z"
	regexp $file_regexp $file forget file end_file
	if { $add_mbox } {
	    set file ":0 c:\nhpcm_mbox\n\n$file"
	    puts "The following has been prepended\
		  to ~/.procmailrc:"
	    puts "    :0 c:"
	    puts "    hpcm_mbox"
	}
	foreach password $passwords {
	    set file "$file\n\n:0\n*\
		      ^To:.*$password\n|\
		      receivemail $j_d_relative | \\\n \
		      dispatchmail $j_d_relative"
	    puts "The following has been appended\
		  to ~/.procmailrc:"
	    puts "    :0"
	    puts "    * ^To:.*$password"
	    puts "    | receivemail $j_d_relative | \\"
	    puts "      dispatchmail $j_d_relative"
	}
	write_file ~/.procmailrc $file$end_file
    }
}

# Make $c_d/who_where
#
if { $who_where_option } {
    if { ! [file readable $c_d/secure/passwords] } {
	error "./contest/secure/passwords does not\
	       exist for -who_where option"
    } elseif { ! [file readable $c_d/who_where] } {
	set who_where_ch [open $c_d/who_where w]
	set passwords_ch [open $c_d/secure/passwords r]
	set empty yes
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    if { [regexp {^[ \t]*(#|$)} $line] } \
		continue
	    regexp {^([^:]*):} $line forget account
	    set rest ""
	    regexp {^[^:]*:[^:]*:(.*)$} $line \
		   forget rest
	    if { $account != "none" } {
		puts $who_where_ch \
		     "$account:WHERE:$rest"
		set empty no
	    }
	}
	close $passwords_ch
	close $who_where_ch

	if { $empty } {
	    file delete -force -- $c_d/who_where
	} else {
	    grant_access $c_d/who_where
	    puts "Wrote ./contest/who_where"

	    TODO "If you want to, edit\
		  ./contest/who_where to specify the\
		  location" \
		 "of teams, by replacing `WHERE' for\
		  each account" \
		 "with a SHORT description of the\
		  team's location."
	}
    } elseif { [file mtime $c_d/who_where] \
	       < [file mtime $c_d/secure/passwords] } {

	# Read $c_d/secure/passwords, decomposing the
	# lines into `$account:$password:$rest', saving
	# $rest in $passwords_array($account), and
	# making a list of accounts in the order their
	# lines were encountered in $passwords_accounts
	# 
	set passwords_ch [open $c_d/secure/passwords r]
	set passwords_accounts ""
	while { "yes" } {
	    set line [gets $passwords_ch]
	    if { [eof $passwords_ch] } break
	    if { [regexp {^[ \t]*(#|$)} $line] } \
		continue
	    regexp {^([^:]*)(:|$)} $line \
		   forget account forget2
	    set rest ""
	    regexp {^[^:]*:[^:]*:(.*)$} $line \
		   forget rest

	    if { $account != "none" } {
		set passwords_array($account) $rest
		lappend passwords_accounts $account
	    }
	}
	close $passwords_ch

	# The lines for the new who_where file are
	# put in the list $new_who_where.  $changed
	# is set `yes' if this is a change from the
	# old who_where file, and `no' otherwise.
	#
	set new_who_where ""
	set changed no

	# Read the old who_where file.  Copy the lines
	# into $new_who_where, changing the $rest part
	# to that taken from passwords, and recording
	# any actual changes in $changed.  Delete
	# $passwords_array($account) for any account
	# encountered in the old who_where file.
	#
	set who_where_ch [open $c_d/who_where r]
	while { "yes" } {
	    set line [gets $who_where_ch]
	    if { [eof $who_where_ch] } break

	    regexp {^([^:]*)(:|$)} $line \
		   forget account forget2
	    set where ""
	    regexp {^[^:]*:([^:]*)(:|$)} $line \
		   forget where forget2
	    set rest ""
	    regexp {^[^:]*:[^:]*:(.*)$} $line \
		   forget rest
	    if { [info exists \
		       passwords_array($account)] } {
		set prest \
		    $passwords_array($account)
		if { $prest != $rest } {
		    lappend new_who_where \
			    "$account:$where:$prest"
		    set changed yes
		} else {
		    lappend new_who_where $line
		}
		unset passwords_array($account)
	    } else {
		lappend new_who_where $line
	    }
	}
	close $who_where_ch

	# For the accounts in the order encountered in
	# the $c_d/secure/passwords file, if the account
	# is not in $new_who_where yet, add it.
	#
	foreach account $passwords_accounts {
	    if { [info exists \
		       passwords_array($account)] } {
		set prest $passwords_array($account)
		lappend new_who_where \
			"$account:WHERE:$prest"
		set changed yes
	    }
	}

	# If $changed is `yes', write $new_who_where.
	#
	if { $changed } {
	    file delete -force -- $c_d/who_where
	    set who_where_ch [open $c_d/who_where w]
	    foreach line $new_who_where {
		puts $who_where_ch $line
	    }
	    close $who_where_ch
	    grant_access $c_d/who_where
	    puts "Wrote ./contest/who_where"

	    TODO "Edit ./contest/who_where to specify\
					location" \
		 "of teams, by replacing `WHERE' for\
					each" \
		 "account with a SHORT description of\
					the" \
		 "team's location."
	}
    }
}

# Make $c_d/trashable
#
if { $trashable_option || $trashall_option } {
    if { ! [file readable $c_d/secure/passwords] } {
	error "./contest/secure/passwords does not\
	       exist for -trashable or -trashall\
	       options"
    }
    set trashable {}
    set passwords_ch [open $c_d/secure/passwords r]
    while { "yes" } {
	set line [gets $passwords_ch]
	if { [eof $passwords_ch] } break
	if { [regexp {^[ \t]*(#|$)} $line] } \
	    continue
	regexp {^([^:]*)(:|$)} $line \
	       forget account forget2
	if { $account == "" } {
	    error "Empty account name in\
		   ./contest/secure/passwords"
	}
	if {    $account != "none" \
	     && ( $trashall_option \
		  || [account_home_directory \
			  $account] == "" ) } {
	    lappend trashable $account
	}
    }
    close $passwords_ch

    if { [llength $trashable] == 0 } {
	if { [file exists $c_d/trashable] } {
	    puts "Deleted ./contest/trashable"
	    file delete -force $c_d/trashable
	}
    } else {
	if {    [file readable $c_d/trashable] \
	     && $trashall_option == "no" } {
	    set old_trashable \
		[read_entire_file $c_d/trashable]
	    if { [catch { llength $old_trashable }] } {
		error "./contest/trashable badly\
		       formatted"
	    }
	} else {
	    set old_trashable {}
	}

	if {    [lsort $old_trashable] \
	     != [lsort $trashable] } {
	    file delete -force $c_d/trashable
	    set trashable_ch [open $c_d/trashable w]
	    foreach account $trashable {
		puts $trashable_ch $account
	    }
	    close $trashable_ch
	    grant_access $c_d/trashable
	    puts "Wrote ./contest/trashable"

	    set tc_d [truename $c_d]
	    set ts_d \
		"[truename $hpcm_directory]/secure/bin"

	    if { $trashall_option } {
		TODO "./contest/trashable\
		      has been re-written to contain\
		      all accounts." \
		     "" \
		     "You should edit it to contain\
		      only the accounts you desire" \
		     "to set passwords of and trash." \
		     "" \
		     "Then you should execute:" \
		     "" \
		     "    su root" \
		     "    $ts_d/hpcm_setup_accounts\
			  -all -force \\" \
		     "        $tc_d" \
		     "    exit" \
		     "    makecontest -trashable" \
		     "" \
		     "to setup the desired accounts.\
		      This will make any of the\
		      desired" \
		     "accounts that do not exist, set\
		      all desired account passwords," \
		     "and trash all desired accounts." \
		     "" \
		     "Instead of `hpcm_setup_accounts\
		      all -force' you can use just" \
		     "hpcm_set_passwords to just\
			  reset passwords in the\
			  desired accounts, or" \
		     "you can use just\
		      hpcm_TRASH_ACCOUNTS to just\
		      trash the desired accounts."
	    } else {
		TODO "./contest/trashable\
		      has been written to contain just\
		      accounts that" \
		     "do not yet exist." \
		     "" \
		     "If you want to reset existing\
		      accounts you should execute" \
		     "`makecontest -trashall'." \
		     "" \
		     "Otherwise you should execute:" \
		     "" \
		     "    su root" \
		     "    $ts_d/hpcm_setup_accounts\
			  \\" \
		     "        $tc_d" \
		     "    exit" \
		     "    makecontest -trashable" \
		     "" \
		     "to setup the new accounts."
	    }
	}
    }
}

# Append scoreboard_commands to judging_commands if
# desired.  Must be done before judging_commands is
# processed.
#
if { $scoreboard_commands_option } {

    # Fix up omitted REMOTE-COMMANDs in
    # scoreboard_commands.
    #
    foreach item $scoreboard_commands {
	if { (    [lindex $item 1] == "ssh" \
	       && [llength $item] == 3 ) \
	     || \
	     (    [lindex $item 1] == "email" \
	       && [llength $item] == 4 ) } {
	    lappend item \
		    "head -c 10000 >./public_html/PAGE;\
		     chmod 644 ./public_html/PAGE"
	}
	lappend judging_commands $item
    }
}

# Process contest_commands and judging_commands.
#
foreach case { contest judging } {

    # Skip if no -CASE_commands option.
    #
    if { ! [set ${case}_commands_option] } continue
    set commands [set ${case}_commands]
    if { [llength $commands] == 0 } continue


    if { $case == "contest" } {
	set dir ./contest
    } else {
	set dir .
    }

    # If necessary make directories.
    #
    if { ! [file isdirectory $dir/secure] } {
	file mkdir $dir/secure
	deny_group_access $dir/secure
	puts "Made directory $dir/secure"
    }
    if { ! [file isdirectory $dir/secure/bin] } {
	file mkdir $dir/secure/bin
	deny_group_access $dir/secure/bin
	puts "Made directory $dir/secure/bin"
    }

    # Process command list items.
    #
    set dirbin $dir/secure/bin
    set bin [truename $dirbin]
    set wrapper $hpcm_directory/secure/src/hpcm_wrapper
    foreach item $commands {
	set name    [lindex $item 0]
	set type    [lindex $item 1]

	switch -- $type {
	sh {
	    if { [llength $item] < 3 } {
		error "Bad item in ${case}_commands:\
		       $item"
	    }
	    set command [lrange $item 2 end]

	    if { ! [file exists $bin/$name] } {

		write_file \
		    $bin/$name \
		    "#!/bin/sh\nexec $command"
		grant_user_access $bin/$name x
		deny_group_access $bin/$name
		puts "Made $dirbin/$name"
	    }
	}
	qps {
	    if { [llength $item] != 3 } {
		error "Bad item in ${case}_commands:\
		       $item"
	    }
	    set queue [lindex $item 2]
	    if { ! [regexp {^/} $queue] } {
		error "Directory name not absolute in\
		       ${case}_commands: $item"
	    }
	    if { ! [file isdirectory $queue] } {
		TODO "mkdir $queue"
	    } elseif { ! [file readable $queue] } {
	        error "$queue is not readable"
	    } elseif { ! [file writable $queue] } {
	        error "$queue is not writable"
	    }

	    if { ! [file exists $bin/$name] } {

		# hpcm_queue name must be absolute.
		#
		set jbin $hpcm_directory/judge/bin
		write_file \
		    $bin/$name \
		    "#!/bin/sh\n\
		     exec $jbin/hpcm_queue $queue .ps"
		grant_user_access $bin/$name x
		deny_group_access $bin/$name
		puts "Made $dirbin/$name"
	    }
	}
	ssh {
	    if {    [llength $item] != 4 \
		 && [llength $item] != 5 } {
		error "Bad item in ${case}_commands:\
		       $item"
	    }
	    set account [lindex $item 2]
	    set remote_command [lindex $item 3]
	    if { ! [regexp {@} $account] } {
		error "ACCOUNT does NOT contain @ in\
		       ${case}_commands item: $item"
	    }
	    if { [regexp {"} $remote_command] } {
		error "REMOTE-COMMAND contains \" in\
		       ${case}_commands item: $item"
	    }
	    if { [llength $item] == 5 } {
		set options [lindex $item 4]
	    } else {
		set options\
		    "-q -o PasswordAuthentication=no\
		     -T -x -i PRIVATEKEY"
	    }
	    regsub -all PRIVATEKEY $options \
		   $bin/${name}_identity options

	    if { ! [file exists $bin/$name] } {

		# We must unset ssh agent socket if we
		# are to get -i option to work right.
		#
		write_file \
		    $bin/$name \
		    "#!/bin/sh\n\
		     unset SSH_AUTH_SOCK;\n\
		     exec ssh $options $account"
		grant_user_access $bin/$name x
		deny_group_access $bin/$name
		puts "Made $dirbin/$name"
	    }

	    if { ! [file exists \
			 $bin/${name}_identity.pub] \
		 && \
		 ! [file exists \
			 $bin/${name}_authorized_keys] \
		 && \
		   [file exists \
			 $bin/${name}_identity] \
	       } {
		file delete -force -- \
		     $bin/${name}_identity
	    }

	    if { ! [file exists $bin/${name}_identity] \
	       } {
		file delete -force -- \
		     $bin/${name}_identity.pub \
		     $bin/${name}_authorized_key
		ssh_keygen $bin/${name}_identity
		deny_group_access $bin/${name}_identity
		deny_group_access \
		    $bin/${name}_identity.pub
		puts "Made $dirbin/${name}_identity"
		puts "Made $dirbin/${name}_identity.pub"
	    }

	    if { ! [file exists \
			 $bin/${name}_authorized_keys] \
	       } {
		write_file \
		    $bin/${name}_authorized_keys \
		    "command=\"$remote_command\"\
		     [read_file \
			 $bin/${name}_identity.pub]"
		deny_group_access \
		    $bin/${name}_authorized_keys
		puts \
		  "Made $dirbin/${name}_authorized_keys"
		TODO "You must append\
		      $dirbin/${name}_authorized_keys" \
		     "to the ~/.ssh/authorized_keys\
		      file" \
		     "of the account $account" \
		     "You may wish to edit the command\
		      parameter in this file," \
		     "which is the command that will be\
		      executed by" \
		     "ssh $account" \
		     "when $dirbin/$name is executed\
		      locally."
	    }
	}
	email {
	    if {    [llength $item] != 3 \
		 && [llength $item] != 5 } {
		error "Bad item in ${case}_commands:\
		       $item"
	    }
	    set address [lindex $item 2]
	    if { [regexp {'} $address] } {
		error "ADDRESS contains ' in\
		       ${case}_commands item: $item"
	    }

	    if { ! [file exists $bin/$name] } {

		write_file \
		    $bin/$name \
		    "#!/bin/sh\n\
		     exec hpcm_remote_sendmail\
			  '$address'"
		grant_user_access $bin/$name x
		deny_group_access $bin/$name
		puts "Made $dirbin/$name"
	    }
	    if { [llength $item] == 5 \
		 &&
		 ! [file exists \
			 $bin/${name}_procmailrc] \
	       } {
		set regexp [lindex $item 3]
		set remote_command [lindex $item 4]

		write_file $bin/${name}_procmailrc "
:0 b:
* ^To:.*${regexp}
| $remote_command"
		puts "Made $dirbin/${name}_procmailrc"

		TODO "You must append\
		      $dirbin/${name}_procmailrc" \
		     "to the ~/.procmailrc file of the\
		      account addressed by" \
		     "$address" \
		     "You may wish to edit the command\
		      after '|' in this file, which\
		      is" \
		     "the command into which will be\
		      piped the body of any email\
		      received" \
		     "whose TO address matches\
		      the regular expression" \
		     "`$regexp'" 
	    }
	}
	default {
	    error "Bad item in ${case}_commands:\
		   $item"
	}
	}

	if { $case == "contest" \
	     && ! [file exists ./contest/$name] } {

	    if { ! [file executable $wrapper] } {
		error "$wrapper is not an existing\
		       executable file"
	    }
	    copy_file $wrapper ./contest/$name
	    grant_user_access ./contest/$name rwxs
	    grant_access ./contest/$name rx
	    puts "Made ./contest/$name"
	}
    }
}

# Printer_jobs pseudoswitch
#
set printer_jobs_option no

# Make $c_d/printer
#
if { $printer_option \
     && (    ! [file exists $c_d/printer]
	  || [file writable $c_d/printer] ) } {

    set printer_jobs_option yes

    if { [info exists contest_printer] } {
	set todo no
    } elseif { [info exists env(PRINTER)] } {
	set contest_printer $env(PRINTER)
	set todo yes
    } else {
	set contest_printer UNKNOWN
	set todo yes
    }

    if {    ! [file exists $c_d/printer] \
	 ||    [read_entire_file $c_d/printer] \
	    != $contest_printer } {

	write_file $c_d/printer $contest_printer
	grant_access $c_d/printer
	puts "Wrote ./contest/printer"

	if { $todo } {
	    TODO "Wrote ./contest/printer to be\
		  `$contest_printer';" \
		 "Edit ./contest/printer to change." \
		 "Execute\
		  `chmod a-rw ./contest/printer'\
		  to disable." \
		 "You may want to use\
		  ./contest/printer_map" \
		 "instead of ./contest/printer:" \
		 "see `hpcm/contestant/bin/printer_pipe\
		  -doc'."
	}
    }
}

# Make $c_d/printer_map
#
if {    $printer_map_option \
     && (    ! [file exists $c_d/printer_map]
	  || [file writable $c_d/printer_map] ) } {

    if { ! [info exists contest_printer_map] } {

	TODO "Set the contest_printer_map global\
	      variable" \
	     "in hpcm_judging.rc and run\
	      `makecontest -printer_map'"

    } elseif { [write_public_file \
                    $c_d/printer_map \
		    $contest_printer_map] } {
	set printer_jobs_option yes
    }
}

# Make $c_d/printer_jobs
#
if { $printer_jobs_option \
     && ! [file exists $c_d/printer_jobs] } {
    close [open $c_d/printer_jobs w]
    grant_access $c_d/printer_jobs rw
    puts "Wrote ./contest/printer_jobs"
}

# Write public files
#
if { $public_files_option } {
    foreach item $public_files {
        set filename [lindex $item 0]
        set variable [lindex $item 1]
	write_public_file $filename [set $variable]
    }
}

# Make $c_d/XXXhelp
#
foreach XXX {java c++ python } {
    if { [set ${XXX}help_option] } {
	if { ! [info exists ${XXX}help] } {

	    TODO "Set the ${XXX}help global variable" \
		 "in hpcm_judging.rc and run\
		  `makecontest -${XXX}help'"

	} elseif {    ! [file exists $c_d/${XXX}help] \
		   ||    [read_entire_file \
			      $c_d/${XXX}help] \
		      != [set ${XXX}help] } {
	    write_file $c_d/${XXX}help [set ${XXX}help]
	    grant_access $c_d/${XXX}help
	    puts "Wrote ./contest/${XXX}help"
	}
    }
}

# Call makeweb if necessary.
#
if { $web_option } {
    file delete -force $j_d/web+
    exec makeweb "{{directory $j_d/web+}}"
    rename_directory web
    if {    ! [file exists $j_d/web.tar] \
	 ||   [file mtime $j_d/web.tar]
	    < [file mtime $j_d/web] } {
	if { [file exists $j_d/web.tar] } {
	    file delete -force $j_d/web.tar
	    puts "Deleted ./web.tar"
	}
	archive_directory $j_d/web
	puts "Wrote ./web.tar"
	TODO "Copy ./web (which is archived as\
	      ./web.tar) to the appropriate" \
	     "location."
    }
}

# Make ./make_test
#
if {    $make_test_option \
     && [info exists make_test] \
     && (    ! [file exists $j_d/make_test] \
	  ||    [read_entire_file $j_d/make_test] \
	     != $make_test ) } {

    write_file $j_d/make_test $make_test
    puts "Wrote ./make_test"
}

# Start contest if necessary.
#
if {    $startcontest_option \
     && [file exists $c_d/problems] \
     && [file exists $c_d/help/problems] \
     && (    ! [regexp {r.x} \
		       [get_access $c_d/problems]] \
	  || ! [regexp {r..} \
		       [get_access \
			    $c_d/help/problems]] ) } {

    # Check Startcontest_PID and delete it if its
    # process is no longer running.
    # 
    if { [file exists $j_d/Startcontest_PID] } {
	 set pid [read_file $j_d/Startcontest_PID]
	 set display [display_process_tree $pid]
	 if { ! [process_found $display] } {
	     file delete -force $j_d/Startcontest_PID
	}
    }

    if { ! [file exists $j_d/Startcontest_PID] } {
	puts "Executing: startcontest start"
	exec startcontest start >@ stdout
    }
}

# Move scoreboard.1head if necessary.
#
if {    $scoreboard_option \
     && [file exists $j_d/scoreboard.1head] \
     && [file isdirectory $j_d/contest] \
     && ! [file exists $c_d/scoreboard.1head] } {
    file rename -force -- $j_d/scoreboard.1head \
			  $c_d/scoreboard.1head
    puts "Moved ./scoreboard.1head"
    puts "   to ./contest/scoreboard.1head"
}

# Execute makescoreboard if necessary.
#
if { $scoreboard_option } {

    # Check Scoreboard_PID and delete it if its
    # process is no longer running.
    # 
    if { [file exists $j_d/Scoreboard_PID] } {
	 set pid [read_file $j_d/Scoreboard_PID]
	 set display [display_process_tree $pid]
	 if { ! [process_found $display] } {
	     file delete -force $j_d/Scoreboard_PID
	}
    }

    if { ! [file exists $j_d/Scoreboard_PID] } {
	puts "Executing: makescoreboard start"
	exec makescoreboard start >@ stdout
    }
}

# Finish TODO
#
if { $TODO_ch != "" } {
    close $TODO_ch
    if { $TODO_existed } {
	puts "IMPORTANT: The ./TODO file has both old\
	      and new instructions for you in it."
    } else {
	puts "IMPORTANT: The ./TODO file has\
	      new instructions for you in it."
    }
} elseif { $TODO_existed } {
    puts "IMPORTANT: The ./TODO file has\
	  old instructions for you in it."
    puts "           There a no new instructions."
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
