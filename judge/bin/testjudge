#! /bin/sh
#
# Test judge on problem code.
#
# File:		testjudge
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Sun Mar 10 13:24:42 EDT 2013
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2013/03/10 17:25:01 $
#   $RCSfile: testjudge,v $
#   $Revision: 1.5 $
#
# The next lines run tclsh \
trap "echo testjudge: Terminated by Signal; exit 1" \
    HUP INT QUIT; \
trap "rm -rf /tmp/testjudge$$" EXIT; \
tclsh "$0" /tmp/testjudge$$ "$@"; exit $status

# Note, the above will delete savedir on exit if it
# is the default value (-keep not given).

set savedir [lindex $argv 0]
set argv [lrange $argv 1 end]

set lib_directory "[file dirname $argv0]/../lib"
set judging_directory .
set log_disable yes
source $lib_directory/judging_common.tcl
catch {

set document "
testjudge \[-keep savedir] \[-ext \".EXT ...\"] \\
          \[directory ...]

    The directories contain the problem solutions to be
    tested within savedir.  If no directories are given,
    the directory list defaults to `.'.  Savedir
    defaults to a subdirectory of /tmp that is unique to
    the current execution of `testjudge'.  The solutions
    to be tested have the extensions given by the -ext
    option if that is present, or by the allowed_
    extensions variable value in .../judge/lib/hpcm_
    judging.rc otherwise.

    First this program makes `savedir' if it does not
    exist, and then if savedir/hpcm_judging.rc does not
    exist, makes savedir/hpcm_judging.rc to source
    .../judge/lib/hpcm_judging.rc.  Then regardless of
    whether savedir/hpcm_judging.rc pre-existed, this
    program appends to it a line to set allowed_exten-
    sions to the list of extensions to be tested.

    Note that if -keep is given, savedir must be
    accessible to everyone (via chmod a+x) if JAVA or
    COMMONLISP are being tested.

    Then for each directory argument dddd which is in
    fact a directory containing a `Makefile', and for
    each solution ppppxxx.eee in that directory, this
    program makes a directory

    	savedir/dddd/test_ppppxxx_eee/

    and in that directory a `Received_Mail' file con-
    taining ppppxxx.eee, and runs `autodispatch' in that
    directory.  Here pppp is the problem name extracted
    from the directory Makefile `P = problem' line, and
    eee is an allowed solution extension.  The from
    address in the `Received_Mail' file is `current-
    account@localhost'.  This program also makes the
    directory savedir/solutions if that does not exist,
    and links

    	savedir/solutions/dddd

    to the directory dddd.

    Lastly, if -keep is NOT given, savedir is deleted
    (it is a subdirectory of /tmp in this case).

    If -keep was given, `manualreply' and `lookat' can
    be run in savedir to look at the results.  Some
    results also appear in the `current-account' mail."

# Process options.
#
set keep 0
set ext 0
set myargv $argv
while { 1 } {
    switch -glob -- [lindex $myargv 0] {
    -doc* {
	puts $document
	exit 1
    }
    -keep {
    	set keep 1
	set myargv [lrange $myargv 1 end]
	set savedir [lindex $myargv 0]
    }
    -ext {
	    set ext 1
	    set myargv [lrange $myargv 1 end]
	    set allowed_extensions [lindex $myargv 0]
	    if { [catch { llength \
	                    $allowed_extensions }] } {
	        error "-ext $allowed_extensions\
		            is not legal"
	    }
    }
    default break
    }
    set myargv [lrange $myargv 1 end]
}
if { [llength $myargv] == 0 } {
    set myargv .
}

set wd [pwd]
set account [exec id -un]
cd $lib_directory
set libdir [pwd]
cd $wd

if { ! [file isdirectory $savedir] } {

    if { [file exists $savedir] } {
        error "$savedir is not a directory"
    }
    puts "mkdir $savedir"
    file mkdir $savedir
    if { ! $keep } {
	file attributes $savedir -permissions a+x
    }

}

if { ! [file exists $savedir/hpcm_judging.rc] } {
    if { ! [catch {file link \
                        $savedir/hpcm_judging.rc}] } {
        file delete $savedir/hpcm_judging.rc
    }
    puts "making $savedir/hpcm_judging.rc"
    set fd [open $savedir/hpcm_judging.rc w]
    puts $fd "source $libdir/hpcm_judging.rc"
    close $fd
}
exec echo "set allowed_extensions \
               {$allowed_extensions}" \
	  >> $savedir/hpcm_judging.rc

if { ! [file isdirectory $savedir/solutions] } {

    if { [file exists $savedir/solutions] } {
        puts "$savedir/solutions is not a directory"
    }
    puts "mkdir $savedir/solutions"
    file mkdir $savedir/solutions
}

set mregexp \
    "^\[ \t]*P\[ \t]*=\[ \t]*(\[^ \t]\[^ \t]*)\[ \t]*\$"
    # for regexp
set mgrepexp \
    "^\[ \t]*P\[ \t]*=\[ \t]*\[^ \t]\[^ \t]*\[ \t]*\$"
    # for grep
foreach directory $myargv {

    cd $wd

    if { ! [file isdirectory $directory] } {
        puts "====================\
	      $directory is not a directory"
	continue
    }

    if { ! [file exists $directory/Makefile] } {
	puts "====================\
	      $directory/Makefile does not exist"
	continue
    }

    cd $directory
    set dir [pwd]

    if { [catch {

	puts -nonewline "=========="
	puts " $dir:"

	puts "make clean"
	exec make clean >&@ stdout

	# Extract problem from `P = problem' line in
	# Makefile
	#
	set pline ""
	if { [catch { set pline \
	                  [exec grep $mgrepexp Makefile]
		    }]\
	    || \
	    ! [regexp $mregexp $pline \
	               forget problem] } {
	    error "CANNOT find P = ... line in Makefile"
	}

	# Make list of PROBLEM*.EXT values (solutions).
	#
	set solutions {}
	set allowed {}
	foreach pext $allowed_extensions {
	    if { ! [regexp "^\\.(.*)\$" $pext \
	                   forget EXT] } {
	        error "bad allowed_extension `$pext'"
	    }

	    lappend allowed $EXT
	    lappend_lists solutions \
	                  [glob -nocomplain \
			        "$problem*.$EXT"]
	}
	if { [llength $solutions] == 0 } {
	    set exts [join $allowed ,]
	    error "no $problem*.{$exts} solutions"
	}

	# Remove $problem.in link if any.
	#
	set type none
	catch { set type [file type $problem.in] }
	if { $type == "link" } {
	    file delete $problem.in
	}

	# Link $savedir/solutions/$problem
	#
	set soldir $savedir/solutions/$problem
	set type none
	catch { set type [file type $soldir] }
	if { $type == "none" } {
	    puts "ln -s $dir $soldir"
	    file link -symbolic $soldir $dir
	} elseif { $type != "link" } {
	    error "$soldir exists but is not a link"
	} elseif { [file link $soldir] != $dir } {
	    puts "rm $soldir"
	    file delete -- $soldir
	    puts "ln -s $dir $soldir"
	    file link -symbolic $soldir $dir
	}

	# Process each value of PROBLEMXXX.EXT
	#
	foreach SOLUTION $solutions {

	    if { [catch {

		# Be sure we are in problem directory
		#
		cd $dir

		regexp "^(.*)\\.(\[^.]*)\$" $SOLUTION \
		       forget PROBLEMXXX EXT
		set testdir \
		    "$savedir/test_${PROBLEMXXX}_$EXT"

		puts -nonewline "===================="
		puts " $testdir:"

		if { [file exists $testdir] } {
		    puts "rm -rf $testdir"
		    file delete -force -- $testdir
		}
		puts "mkdir $testdir"
		file mkdir $testdir
		file attributes $testdir \
		     -permissions a+x

		# Change to subdirectory
		#
		cd $testdir

		# Make Received_Mail
		#
		puts "making Received_Mail"
		set fd [open Received_Mail w]
		puts $fd "From $account@localhost"
		puts $fd "Subject: submit $problem.$EXT"
		puts $fd ""
		exec cat $dir/$SOLUTION >@$fd
		close $fd

		# Execute autodispatch
		puts "executing autodispatch"
		exec autodispatch

	      } out] } {
		puts $out
	    }
	}

    } out] } {
        puts $out
    }
}

exit 0

} caught_output
caught_error
