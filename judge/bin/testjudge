#! /bin/sh
#
# Test judge on problem code.
#
# File:		testjudge
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Sun Mar 10 03:54:29 EDT 2013
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2013/03/10 08:25:29 $
#   $RCSfile: testjudge,v $
#   $Revision: 1.2 $
#
# The next lines run tclsh \
trap "echo testjudge: Terminated by Signal; exit 1" \
    HUP INT QUIT; \
trap "rm -rf /tmp/testjudge$$" EXIT; \
tclsh "$0" /tmp/testjudge$$ "$@"; exit $status

set savedir [lindex $argv 0]
set argv [lrange $argv 1 end]

set lib_directory "[file dirname $argv0]/../lib"
set judging_directory .
set log_disable yes
source $lib_directory/judging_common.tcl
catch {

set document "
testjudge \[-keep savedir] \[-ext \".EXT ...\"] \\
          \[directory ...]

    If no directories are given, the directory list
    defaults to `.'.  Savedir defaults to a subdirectory
    of /tmp.

    First this program makes `savedir' if it does not
    exist, and links hpcm_judging.rc in that directory,
    if this does not exist already, to the hpcm_jud-
    ging.rc file in use by this `testjudge' program.
    Savedir defaults to a subdirectory of /tmp that is
    unique to the current execution of `testjudge'.

    Then for each directory argument dddd and each
    solution pppp.eee in that directory this program
    makes a directory

    	savedir/dddd/test_eee/

    and in that directory a `Received_Mail' file con-
    taining pppp.eee, and runs `autodispatch' in that
    directory.  The from address in the `Received_
    Mail' file is `current-account@localhost'.  This
    program also makes the directory savedir/solutions
    if that does not exist, and links

    	savedir/solutions/dddd

    to the directory dddd.

    Lastly, if -keep is NOT given, savedir is deleted
    (it is a subdirectory of /tmp in this case).

    If -keep was given, `manualreply' and `lookat' can
    be run in savedir to look at the results.  Some
    results also appear in the `current-account' mail."

# Process options.
#
set keep 0
set myargv $argv
while { 1 } {
    switch -glob -- [lindex $myargv 0] {
    -doc* {
	puts $document
	exit 1
    }
    -keep {
    	set keep 1
	set myargv [lrange $myargv 1 end]
	set savedir [lindex $myargv 0]
    }
    -ext {
	    set myargv [lrange $myargv 1 end]
	    set allowed_extensions [lindex $myargv 0]
	    if { [catch { llength \
	                    $allowed_extensions }] } {
	        error "-ext $allowed_extensions\
		            is not legal"
	    }
    }
    default break
    }
    set myargv [lrange $myargv 1 end]
}
if { [llength $myargv] == 0 } {
    set myargv .
}

set wd [pwd]

if { ! [file directory $savedir] } {

    if { [file exists $savedir] } {
        puts "$savedir is not a directory"
    }
    file mkdir $savedir
}

if { ! [file exists $savedir/hpcm_judging.rc] } {
    if { $HPCM_STANDALONE } {
	file link -symbolic \
	     $lib_directory/hpcm_judging.rc \
	     $savedir/hpcm_judging.rc
    } else {
	file link -symbolic \
	     $judging_directory/hpcm_judging.rc \
	     $savedir/hpcm_judging.rc
    }
}

if { ! [file directory $savedir/solutions] } {

    if { [file exists $savedir/solutions] } {
        puts "$savedir/solutions is not a directory"
    }
    file mkdir $savedir/solutions
}

foreach directory $myargv {

    set delete_at_end {}

    cd $wd

    if { ! [file isdirectory $directory] } {
        puts "====================\
	      $directory is not a directory"
	continue
    }

    if { ! [file exists $directory/Makefile] } {
	puts "====================\
	      $directory/Makefile does not exist"
	continue
    }

    cd $directory
    set dir [pwd]

    if { [catch {

	puts -nonewline "=========="
	puts " $dir:"

	puts "make clean"
	exec make clean >&@ $stdout

	# Extract problem from `P = problem' line in
	# Makefile
	#
	set pline ""
	if { [catch { set pline \
	                  [exec grep $mgrepexp Makefile]
		    }]\
	    || \
	    ! [regexp $mregexp $pline \
	               forget problem] } {
	    error "CANNOT find P = ... line in Makefile"
	}

	# Make list of PROBLEM*.EXT values (solutions).
	#
	set solutions {}
	set allowed {}
	foreach pext $allowed_extensions {
	    if { ! [regexp "^\\.(.*)\$" $pext \
	                   forget EXT] } {
	        error "bad allowed_extension `$pext'"
	    }

	    lappend allowed $EXT
	    lappend_lists solutions \
	                  [glob -nocomplain \
			        "$problem*.$EXT"]
	}
	if { [llength $solutions] == 0 } {
	    set exts [join $allowed ,]
	    error "no $problem*.{$exts} solutions"
	}

	# Remove $problem.in link if any.
	#
	set type none
	catch { set type [file type $problem.in] }
	if { $type == "link" } {
	    file delete $problem.in
	}

	# Link $savedir/solutions/$problem
	#
	set soldir $savedir/solutions/$problem
	set type none
	catch { set type [file type $soldir] }
	if { $type == "none" } {
	    puts "ln -s $dir $soldir"
	    file link -symbolic $dir $soldir
	    lappend delete_at_end $soldir
	} elseif { $type != "link" } {
	    error "$soldir exists but is not a link"
	} elseif { [file link $soldir] != $dir } {
	    puts "rm $soldir"
	    file delete -- $soldir
	    puts "ln -s $dir $soldir"
	    file link -symbolic $dir $soldir
	    lappend delete_at_end $soldir
	}

	# Process each value of PROBLEMXXX.EXT
	#
	if { [catch { foreach SOLUTION $solutions {

	    # Be sure we are in problem directory
	    #
	    cd $dir

	    regexp "^(.*)\\.(\[^.]*)\$" $SOLUTION \
	           forget PROBLEMXXX EXT
	    set testdir \
	        "$savedir/test_${PROBLEMXXX}_$EXT"

	    puts -nonewline "===================="
	    puts " $testdir:"

	    if { [file exists $testdir] } {
		puts "rm -rf $testdir"
		file delete -force -- $testdir
	    }
	    puts "mkdir $testdir"
	    file mkdir $testdir
	    lappend delete_at_end $testdir

	    # Change to subdirectory
	    #
	    cd $testdir

	    # Make Received_Mail
	    #
	    puts "making Received_Mail"
	    set fd [open Received_Mail w]
	    puts $fd "From $account@localhost"
	    puts $fd "Subject: submit $problem.$EXT"
	    puts $fd ""
	    exec cat $dir/$SOLUTION >@$fd
	    close $fd

	    # Execute autodispatch
	    puts "executing autodispatch"
	    exec autodispatch

	  } } out] } {
	    puts $out
        }

	# Return to problem directory
	#
	cd $dir

	if { ! $keep && [llength $delete_at_end] > 0 } {
	    puts "rm -rf $delete_at_end"
	    eval file delete -force -- $delete_at_end
	}

    } out] } {
        puts $out
	putsfd $out
    }
}

exit 0

} caught_output
caught_error

