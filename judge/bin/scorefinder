#!/bin/sh
#
# Looks at the subdirectories of the mail directory for
# score files, and prints the scores found.
#
# File:		scorefinder
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Fri Feb  8 04:05:23 EST 2002
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2002/02/08 09:13:20 $
#   $RCSfile: scorefinder,v $
#   $Revision: 1.16 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_globally yes
catch {

set document "
scorefinder \[-gotten\]

    This program examines subdirectories of the mail
    directory that have names of the form:

    	date-<<submitter>>-submission

    It selects subdirectories that have one or both of
    the score files:

    	$auto_score_file
    	$manual_score_file

    For each such subdirectory, this program outputs one
    line of the form:

    	date submitter problem code score

    In this line, the date is taken literally from the
    subdirectory name.  The submitter is taken from the
    directory name and passed through the submitter_
    compress function, which for some contests strips
    any `@' and following characters, and for other con-
    tests compresses what follows the `@'.  The program
    is the submitted file name with its extension re-
    moved; this is found by reading the subject field of
    any $received_file file in the subdirectory, and
    using the problem name `UNKNOWN' if this cannot be
    done or the subject field has the wrong format.  The
    code is one of:

      mc  $manual_score_file	== `Completely Correct'
      mi  $manual_score_file	!= `Completely Correct'
      ac  $auto_score_file	== `Completely Correct'
      ai  $auto_score_file	!= `Completely Correct'

    where the $auto_score_file file is ignored if the
    $manual_score_file file exits.  The score is the
    actual score used to compute the code, quoted by
    \"'s.

    Output lines that would contain ac or ai are sup-
    pressed, and not output, if the $auto_score_file\
    	file
    value does not in its entirety match the regular ex-
    pression in the `reply_auto_scores' global vari-
    able.

    If the -gotten option is present, this program also
    selects subdirectories which contain the file:

    	$gotten_file
    							
    If this file indicates that a file whose last two
    name components are `pppp/pppp.eee' for some problem
    statement file extension `.eee' was gotten at a
    certain date,  this program outputs the line

    	date submitter problem dg

    where the problem is `pppp' and `dg' stands for
    `description gotten'.  Here the date is taken from
    the $gotten_file file `Date:' field.

    The -gotten flag is set automatically if the
    `scoreboard_start_time' variable equals \"\" or
    \"team\".

    This program logs errors in the log directory."


# Don't change argc or argv so error output will work.
#
set my_argc $argc
set my_argv $argv

# Check for and consume -gotten option.
#
set gotten_option no
if { $my_argc >= 1 \
     && [lindex $my_argv 0] == "-gotten" } {
    set gotten_option yes
    set my_argv [lreplace $my_argv 0 0]
    set my_argc [expr { $my_argc - 1 }]
} elseif { $scoreboard_start_time == "" } {
    set gotten_option yes
} elseif { $scoreboard_start_time == "team" } {
    set gotten_option yes
}

# If there are leftover arguments, print document and
# exit with error.
#
if { $my_argc != 0 } {
    puts $document
    exit 1
}

# Loop through the subdirectory names.
#
foreach dir [glob -nocomplain \
	          $mail_directory/*-<<*>>-submission] {

    set subdir [file tail $dir]

    if { ! [regexp {^([^<>]*)-<<(.*)>>-submission$} \
    		   $subdir forget date submitter] } {
    	continue;
    }

    set submitter [submitter_compress $submitter]
    if { $submitter == "" } {
	set submitter UNKNOWN
    }

    # Process any $gotten_file.
    #
    if { [file readable $dir/$gotten_file] } {

    	if { $gotten_option == "no" } continue

	set gotten_ch [open $dir/$gotten_file r]
	set date UNKNOWN
	while { "yes" } {
	    set line [gets $gotten_ch]
	    if { [eof $gotten_ch] } break
	    if { [regexp {^Date:(.*)$} $line \
	    		 forget date] } {
		set date [clock_to_filename_date \
			     [clock scan $date]]
	    } elseif { [regexp {^File:(.*)$} $line \
	    		     forget file] } {
		set file [string trim $file]
		set pde $problem_description_extensions
		if { [regexp \
		  {^(.*/)([^/]*)/([^/]*)\.([^./]*)$} \
			 $file forget forget2 \
			 name1 name2 ext] \
		     && [lcontain $pde .$ext] \
		     && $name1 == $name2 } {
		    puts [list $date $submitter $name1 \
		               dg]
		}
	    }
	}
	close $gotten_ch
    } else {

	set code ""

	# Process any $manual_score_file file.
	#
	if { [file readable $dir/$manual_score_file] } {
	    set score \
		[read_file $dir/$manual_score_file]
	    if { $score == "Completely Correct" } {
		set code mc
	    } elseif { $score != "" } {
		set code mi
	    }
	}

	# If no $manual_score_file file, process any
	# $auto_score_file file.
	#
	if { $code == "" \
	     && [file readable $dir/$auto_score_file] \
	     } {
	    set score \
		[read_file $dir/$auto_score_file]

	    if { [regexp $reply_auto_scores $score] } {
		if { $score == "Completely Correct" } {
		    set code ac
		} elseif { $score != "" } {
		    set code ai
		}
	    }
	}

	if { $code == "" } continue;

	if { $date == "" } {
	    set date UNKNOWN
	}

	set program UNKNOWN
	if { [file readable $dir/$received_file] } {
	    set received_ch [open $dir/$received_file r]
	    read_header $received_ch
	    close $received_ch

	    if {    ! [catch { \
	    		  set sublen \
	    		      [llength \
			           $message_subject] \
			     }] \
	         && $sublen == 2 \
		 && [lindex $message_subject 0] \
		    == "submit" } {
		set program [lindex $message_subject 1]
		set program [file rootname $program]
	    }
	}

	puts [list $date $submitter $program $code \
		   $score]
    }
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
