#!/bin/sh -f
#
# Looks at the subdirectories of the mail directory for
# score files, and prints the scores found.
#
# File:		scorefinder
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sat Sep 16 07:30:46 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/09/28 20:42:16 $
#   $RCSfile: scorefinder,v $
#   $Revision: 1.3 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_globally yes
catch {

set document "
scorefinder \[-gotten\]

    This program examines subdirectories of the mail
    directory that have names of the form:

    	date-<<submitter>>-submission

    It selects subdirectories that have one or both of
    the score files:

    	$auto_score_file
    	$manual_score_file

    For each such, this program outputs one line of the
    form:

    	date submitter problem code score

    In this line, the date is taken literally from the
    subdirectory name.  The submitter is taken from the
    directory name but has any `@' and characters
    following the `@' stripped off.  The program is the
    submitted file name with its extension removed; this
    is found by reading the subject field of any
    $received_file file in the subdirectory, and using
    the problem name `UNKNOWN' if this cannot be done
    or the subject field has the wrong format.  The
    code is one of:

      mc  $manual_score_file	== `Completely Correct'
      mi  $manual_score_file	!= `Completely Correct'
      ac  $auto_score_file	== `Completely Correct'
      ai  $auto_score_file	!= `Completely Correct'

    where the $auto_score_file file is ignored if the
    $manual_score_file file exits.  The score is the
    actual score used to compute the code, quoted by
    \"'s.

    If the -gotten option is present, this program also
    selects subdirectories which contain the file:

    	$gotten_file

    If this file indicates a file named `pppp/pppp.txt'
    was gotten at a certain date,  this program outputs
    the line

    	date submitter problem dg

    where the problem is `pppp' and `dg' stands for
    `description gotten'.  Here the date is taken from
    the $gotten_file file `Date:' field.

    This program logs errors in the log directory."


# Don't change argc or argv so error output will work.
#
set my_argc $argc
set my_argv $argv

# Check for and consume -gotten option.
#
set gotten_option no
if { $my_argc >= 1 \
     && [lindex $my_argv 0] == "-gotten" } {
    set gotten_option yes
    set my_argv [lreplace $my_argv 0 0]
    set my_argc [expr { $my_argc - 1 }]
}

# If there are leftover arguments, print document and
# exit with error.
#
if { $my_argc != 0 } {
    puts $document
    exit 1
}

# Loop through the subdirectory names.
#
foreach dir [glob -nocomplain \
	          $mail_directory/*-<<*>>-submission] {

    set subdir [file tail $dir]

    if { ! [regexp {^(.*)-<<(.*)>>-submission$} \
    		   $subdir forget date submitter] } {
    	continue;
    }

    regexp {^([^@]*)@} $submitter forget submitter
    if { $submitter == "" } {
	set submitter UNKNOWN
    }

    # Process any $gotten_file.
    #
    if { [file readable $dir/$gotten_file] } {

    	if { $gotten_option == "no" } continue

	set gotten_ch [open $dir/$gotten_file r]
	set date UNKNOWN
	while { "yes" } {
	    set line [gets $gotten_ch]
	    if { [eof $gotten_ch] } break
	    if { [regexp {^Date:(.*)$} $line \
	    		 forget date] } {
		set date [clock_to_filename_date \
			     [clock scan $date]]
	    } elseif { [regexp {^File:(.*)$} $line \
	    		     forget file] } {
		set file [string trim $file]
		if { [regexp \
		         {^(|.*/)([^/]*)/([^/]*).txt$} \
			 $file forget forget2 \
			 name1 name2] \
		     && $name1 == $name2 } {
		    puts "$date $submitter $name1 dg"
		}
	    }
	}
	close $gotten_ch
    } else {

	set code ""

	# Process any $manual_score file.
	#
	if { [file readable $dir/$manual_score_file] } {
	    set score 
		[read_file $dir/$manual_score_file]
	    if { $score == "Completely Correct" } {
		set code mc
	    } elseif { $score != "" } {
		set code mi
	    }
	}

	# If no $manual_score file, process any
	# $auto_score file.
	#
	if { $code == "" \
	     && [file readable $dir/$auto_score_file] \
	     } {
	    set score \
		[read_file $dir/$auto_score_file]
	    if { $score == "Completely Correct" } {
		set code ac
	    } elseif { $score != "" } {
		set code ai
	    }
	}

	if { $code == "" } continue;

	if { $date == "" } {
	    set date UNKNOWN
	}

	set program UNKNOWN
	if { [file readable $dir/$received_file] } {
	    set received_ch [open $dir/$received_file r]
	    read_header $received_ch
	    close $received_ch

	    if { [llength $message_subject] == 2 \
		 && [lindex $message_subject 0] \
		    == "submit" } {
		set program [lindex $message_subject 1]
		set program [file rootname $program]
	    }
	}

	puts "$date $submitter $program $code\
	      \"$score\""
    }
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
