#!/bin/sh
#
# Looks at the subdirectories of the mail directory for
# score files, and prints the scores found.
#
# File:		scorefinder
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sat Sep 21 21:33:42 EDT 2002
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2002/09/22 01:36:00 $
#   $RCSfile: scorefinder,v $
#   $Revision: 1.22 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
set log_globally yes
catch {

set document "
scorefinder \[-gotten\]

    This program examines subdirectories of the mail
    directory that have names of the form:

    	date-<<submitter>>-submission

    It selects subdirectories that have a
    
    	$reply_history_file

    file, that have a

    	$received_file

    file whose `Subject:' field has the form

    	Subject: submit problem\[.extension\]

    and that have one or both of the score files:

    	$auto_score_file
    	$manual_score_file

    For each such subdirectory, this program outputs one
    line of the form:

    	date submitter problem code score

    In this line, the date is taken literally from the
    subdirectory name.  The submitter is taken from the
    directory name and passed through the submitter_
    compress function, which for some contests strips
    any `@' and following characters, and for other con-
    tests compresses what follows the `@'.  The problem
    is taken from the $received_file file `Subject'
    field.

    The code is of the form ACF where

    	A = a   if score is from an $auto_score_file\
			file
    	  = m   if score is from a $manual_score_file\
	    		file

	C = c   if score is `Completely Correct'
	  = i   otherwise

	F = f   if the $received_file file exists
	  = n   otherwise

    The $auto_score_file file is ignored if the\
    	$manual_score_file
    file exists.  The score is the actual score used to
    compute the code.  Each output line is a TCL list.

    If the -gotten option is present, this program also
    selects subdirectories which contain the\
    	`$gotten_file'
    file.  For these directories this program outputs
    one line of the form:

    	date submitter pppp g

    for each problem `pppp' such that there is at least
    one line in the `$gotten_file' file of the form

        File: problems/pppp/...

    or

        File: demos/pppp/...

    The -gotten flag is set automatically if the
    `scoreboard_start_time' variable equals \"problem\"
    or \"team\".

    This program logs errors in the log directory."


# Don't change argc or argv so error output will work.
#
set my_argc $argc
set my_argv $argv

# Check for and consume -gotten option.
#
set gotten_option no
if { $my_argc >= 1 \
     && [lindex $my_argv 0] == "-gotten" } {
    set gotten_option yes
    set my_argv [lrange $my_argv 1 end]
    incr my_argc -1
} elseif { $scoreboard_start_time == "problem" } {
    set gotten_option yes
} elseif { $scoreboard_start_time == "team" } {
    set gotten_option yes
}

# If there are leftover arguments, print document and
# exit with error.
#
if { $my_argc != 0 } {
    puts $document
    exit 1
}

# Loop through the subdirectory names.
#
foreach dir [glob -nocomplain \
	          $mail_directory/*-<<*>>-submission] {

    set subdir [file tail $dir]

    if { ! [regexp {^([^<>]*)-<<(.*)>>-submission$} \
    		   $subdir forget date submitter] } {
    	continue;
    }

    if { $date == "" } {
	error "data is empty in `$subdir'"
    }
    set submitter [submitter_compress $submitter]
    if { $submitter == "" } {
	error "submitter compresses to empty in\
	       `$subdir'"
    }

    # Process any $gotten_file.
    #
    if { [file exists $dir/$gotten_file] } {

    	if { $gotten_option } {
	    set gotten_ch [open $dir/$gotten_file r]

	    # Check that first line is `Date:' line.
	    # Date should be same as from directory
	    # name.
	    #
	    set line [gets $gotten_ch]
	    if { ! [eof $gotten_ch] \
	         && ! [regexp {^Date: } $line] } {
	        error "Bad first line in\
		       $dir/$gotten_file:\n    $line"
	    }

	    # Get problem names from `File:' lines
	    # with file names of form demos/problem...
	    # or problems/problem... .  Output a line
	    # for each new problem.
	    #
	    set problems ""
	    while { "yes" } {
	        set line [gets $gotten_ch]
		if { [eof $gotten_ch] } break
		if { ! [regexp {^File: ([^\ \t]*)$} \
			       $line forget name] } {
		    error "Bad line in\
			   $dir/$gotten_file:\n   \
			   $line"
		}
		if { \
		  [regexp \
		   {^(demos|problems)/([^/]*)/} \
		   $name forget forget problem] \
		  && ! [lcontain $problems $problem] } {
		    puts [list $date $submitter \
		    	        $problem g]
		    lappend problems $problem
		}
	    }
	    close $gotten_ch
	}

    } elseif {    [file exists $dir/$received_file] \
               && [file exists \
	                $dir/$reply_history_file] } {

	# Get problem name.
	#
	set received_ch [open $dir/$received_file r]
	read_header $received_ch
	close $received_ch

	if {    ! [catch { \
		      set sublen \
			  [llength \
			       $message_subject] \
			 }] \
	     && $sublen == 2 \
	     && [lindex $message_subject 0] \
		== "submit" } {
	    set problem [lindex $message_subject 1]
	    set problem [file rootname $problem]
	} else {
	    continue
	}

	# Get score.
	#
	set score ""
	if { [file exists $dir/$manual_score_file] } {
	    set score \
		[read_file $dir/$manual_score_file]
	    set code m
	} elseif { [file exists $dir/$auto_score_file] \
		     } {
	    set score \
		[read_file $dir/$auto_score_file]
	    set code a
	}

	if { $score == "" } continue

	if { $score == "Completely Correct" } {
	    set code ${code}c
	} else {
	    set code ${code}i
	}

	if { [file exists $dir/$reply_file] } {
	    set code ${code}f
	} else {
	    set code ${code}n
	}

	puts [list $date $submitter $problem $code \
		   $score]
    }
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
