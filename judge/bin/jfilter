#!/bin/sh
#
# Use judge's input to produce filtered input or output
# or scoring instructions.
#
# File:		jfilter
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Oct  5 08:13:19 EDT 2005
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2005/10/05 12:10:11 $
#   $RCSfile: jfilter,v $
#   $Revision: 1.16 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

set document "
jfilter \[options\] judging_input_file
jfilter \[options\] judging_input_file \\
                  filtered_input_file
jfilter \[options\] judging_input_file \\
                  output_file filtered_output_file

    A judging_input_file (e.g., a .jin file) has scoring
    parameter definition lines and marker lines, and
    judge's input to test a submitted program.  The
    parameter definition and marker lines define both
    scoring instructions for scoring any output produced
    from the judge's input in the file, and a means of
    dividing both the judge's input and all output pro-
    duced therefrom into test cases and into test groups
    of test cases.

    The 1-file-name command reads the judging_input_file
    (e.g., a .jin file) and prints scoring instructions
    that can be passed to the autojudge program.

    The 2-file-name command reads the judging_input_file
    and writes filtered version of that to the filtered_
    input_file.  The filtered version version simply has
    judging parameter definition and marker lines
    removed.

    The 3-file-name command reads the judging_input_file
    and the output_file (e.g., a .out, .fout, .test, or
    .ftest file), and writes a filtered version of the
    output_file to the filtered_output_file.  The fil-
    tered_output_file is the same as the output_file
    except each line is prefaced with one of the follow-
    ing characters:

    	+ Begin a test group and a test case.
	| Begin a test group.
	- Begin a test case.
	. Do not begin a test case or test group.

    The -c and -g options below cause these prefix
    characters to be omitted from the filtered_output_
    file.

    Options modify the above commands as follows:

        -c <group-number>:<case-number>
        -c <case-number>

	    This option permits the filtered file to be
	    just the portion of the judge's input or
	    output file that permits testing of a parti-
	    cular test case.  The filtered file can be
	    used as feedback for a submitter whose sub-
	    mission first failed on the given test case.

	    For the 2- and 3-file-name commands, these
	    cause the commands to output just the por-
	    tion of the judge's input or the portion of
	    the output that relates to testing the
	    designated test case.

	    If the *ONE-GROUP* parameter value is `no'
	    (see below for parameter definitions), then
	    for test cases outside any test group, the
	    portion output consists just of the lines in
	    the designated test case, from the test case
	    beginning line through the last line that is
	    just before the beginning of the next test
	    case or the end of file.  Thus if there are
	    no test groups, only the designated test
	    case is output.

	    For test cases in test groups, the portion
	    output consists of the lines in the test
	    group containing the test case, up to and
	    including the lines in the test case.  If
	    the *ONE-GROUP* parmeter value is `yes',
	    then for test cases outside any group the
	    file is copied from its beginning through
	    the lines in the test case.

	    If the output is the filtered_output_file,
	    the output lines are exact copies of output_
	    file lines, without any prefix characters
	    indicating test group or test case begin-
	    nings.

	    The test case is designated by designating
	    the test group that contains the test case
	    and the test case within the group.  The
	    test group is designated by <group-number>,
	    with groups being numbered 1, 2, 3, ... .
	    Lines before the first group are considered
	    to be in group 0.  The test case is designa-
	    ted by <case-number>, with test cases being
	    numbered 1, 2, 3, ...  within their group.
	    Lines before the beginning of the first case
	    in a group are considered to be in test case
	    0 of that group.

	    If just the <case-number> is given, and the
	    `<group-number>:' is omitted, the <group-
	    number> is 0.  This is useful if the file
	    has no groups.

        -g <group-number>:<case-number>
	-g <case-number>

	    Same as -c, BUT if the test case is in a
	    test group (not in group 0), include all the
	    lines of this entire test group, instead of
	    stopping with the designated case.

	-case-head <output-case-head-regexp>
	-group-head <output-group-head-regexp>
	-separator <output-separator-regexp>
	-output-case-head <output-case-head-regexp>
	-output-group-head <output-group-head-regexp>
	-output-separator <output-separator-regexp>
	-input-case-head <input-case-head-regexp>
	-input-group-head <input-group-head-regexp>
	-input-separator <input-separator-regexp>
	-input-end <input-end-regexp>
	-end <input-end-regexp>
	-case-mark <input-case-mark-regexp>
	-group-mark <input-group-mark-regexp>
	-input-case-mark <input-case-mark-regexp>
	-input-group-mark <input-group-mark-regexp>
	-one-group <yes-or-no>
	-scoring <scoring-instructions>

	    Set the default value of the designated
	    parameter.  These parameters can then be
	    reset by parameter definitions in the
	    judging_input_file.


    The judging_input_file begins zero or more parameter
    definitions, each having one of the following forms:

    *CASE-HEAD* <output-case-head-regexp>
    *GROUP-HEAD* <output-group-head-regexp>
    *SEPARATOR* <output-separator-regexp>

    *OUTPUT-CASE-HEAD* <output-case-head-regexp>
    *OUTPUT-GROUP-HEAD* <output-group-head-regexp>
    *OUTPUT-SEPARATOR* <output-separator-regexp>

    *INPUT-CASE-HEAD* <input-case-head-regexp>
    *INPUT-GROUP-HEAD* <input-group-head-regexp>
    *INPUT-SEPARATOR* <input-separator-regexp>

    *END* <input-end-regexp>
    *INPUT-END* <input-end-regexp>

    *CASE-MARK* <input-case-mark-regexp>
    *GROUP-MARK* <input-group-mark-regexp>

    *INPUT-CASE-MARK* <input-case-mark-regexp>
    *INPUT-GROUP-MARK* <input-group-mark-regexp>

    *ONE-GROUP* <yes-or-no>

    *SCORING* <scoring-instruction> ...

    These consist of a parameter-designator, the first
    thing on the line (e.g., *CASE-HEAD*), followed by
    parameters.  In a parameter designator, `OUTPUT-'
    can be omitted: *CASE-HEAD* and *OUTPUT-CASE-HEAD*
    mean the same thing.  `INPUT-' can be omitted for
    the `MARKS': *CASE-MARK* and *INPUT-CASE-MARK* mean
    the same thing.  `INPUT-' can be omitted for `END':
    *INPUT-END* and *END* mean the same thing.  It is
    not that common to have *INPUT-...* parameters other
    than *END* in a judging_input_file, as typically
    the file just uses the default *INPUT-...* parameter
    values (see below).

    The regexp parameters are TCL regular expressions
    that are matched to lines of files.  Input regexps
    match lines in the judging_input_file, while output
    regexps match lines in the output_file.  A line
    matched by a `head' regexp is called a head line,
    and begins a test group or test case.  A line mat-
    ched by a `separator' regexp is called a separator
    line, and is the last line of a test case that is
    followed by the first line of another test case.
    A line matched by a `mark' is like a head line but
    must be deleted from the filtered version of the
    file: this is only used for the judging_input_file,
    to mark the beginning of test groups and test cases.

    If the last line of the judging_input_file matches
    the input-end-regexp, it is ALWAYS output when any
    filtered input file is made.

    A regexp parameter set to the empty string (all
    whitespace) is `missing', and deactivates use of
    the parameter in line matching.

    The *SCORING* parameters are just exactly what is
    printed on a single line by the 1-file-name command.

    Parameter definitions can be continued across lines
    by writing a sequence of lines with the same para-
    meter-designator.  Thus

    	*CASE-HEAD* xxx
    	*CASE-HEAD* yyy

    is the same as

    	*CASE-HEAD* xxxyyy

    Note that there is no space here between the xxx and
    yyy when they are concatenated.  This is because
    they are regexp parameters.  If they were non-regexp
    parameters, i.e. scoring parameters, a single space
    character would be inserted.  Therefore

    	*SCORING* xxx
    	*SCORING* yyy

    is the same as

    	*SCORING* xxx yyy

    Regexps should begin with `^' if they are to match
    just the beginning of a line.  Otherwise they will
    match any part of a line.

    Regexps are always matched with a -nocase option, so
    letter case in a regexp makes no difference.

    Whitespace is trimmed from the beginning and end of
    any regexp in a parameter definition.  This means
    that if the regexp is to end with a space character,
    it should be postpended by `()', which does nothing
    but mark the end of the regexp.  E.g.,

        *CASE-HEAD* ^foo ()


    The defaults for all parameters are

	*CASE-HEAD* ^
	*GROUP-HEAD*
	*SEPARATOR*

	*INPUT-CASE-HEAD*
	*INPUT-GROUP-HEAD*
	*INPUT-SEPARATOR*

	*CASE-MARK* ^\\*CASE*\\$
	*GROUP-MARK* ^\\*GROUP\\*$
	*SEPARATOR-MARK*

	*ONE-GROUP* no

	*SCORING* space column

    These mean that by default input is separated into
    test groups and test cases by `*GROUP*' and `*CASE*'
    mark lines, every line of output is a separate test
    case, and there are no output test groups.  The
    default scoring instructions say to ignore differ-
    ences in the kind and amount of spacing within an
    output_file line.

    The test group and test case judging input comes
    after any parameter definitions in the judging_
    input_file.  If there are no test groups, the input
    consists of just a sequence of test cases.  If there
    are test groups, test cases are grouped.  A single
    line may begin both a test case and a test group, in
    either input or output, or a test group may begin
    before the first test case in the group.

    Unlike most HPCM judging programs, this program does
    not read any hpcm_judging.rc file and errors made by
    this program are not written to log files."

# Process options.
#
set output_case_head "^"
set output_group_head ""
set output_separator ""
set input_case_head ""
set input_group_head ""
set input_separator ""
set input_end ""
set input_case_mark "\\*CASE\\*"
set input_group_mark "\\*GROUP\\*"
set scoring "space column"
set one_group no
set c ""
set g ""
while { [regexp {^-} [lindex $argv 0]] } {
    switch -- [lindex $argv 0] {
    -doc {
	    puts $document
	    exit 0
	 }
    -case-head		-
    -output-case-head	{ set output_case_head \
    			      [lindex $argv 1] }
    -group-head		-
    -output-group-head	{ set output_group_head \
    			      [lindex $argv 1] }
    -separator		-
    -output-separator	{ set output_separator \
    			      [lindex $argv 1] }
    -input-case-head	{ set input_case_head \
    			      [lindex $argv 1] }
    -input-group-head	{ set input_group_head \
    			      [lindex $argv 1] }
    -input-separator	{ set input_separator \
    			      [lindex $argv 1] }
    -end		-
    -input-end		{ set input_end \
    			      [lindex $argv 1] }
    -case-mark		-
    -input-case-mark	{ set input_case_mark \
    			      [lindex $argv 1] }
    -group-mark		-
    -input-group-mark	{ set input_group_mark \
    			      [lindex $argv 1] }
    -scoring		{ set scoring \
    			      [lindex $argv 1] }
    -one-group		{ set one_group \
    			      [lindex $argv 1] }
    -c			{ set c \
    			      [lindex $argv 1] }
    -g			{ set g \
    			      [lindex $argv 1] }
    default {
    	    puts stderr "BAD option: [lindex $argv 0]"
	    exit 1
	    }
    }

    set argv [lrange $argv 2 end]
}

if { [llength $argv] < 1 || [llength $argv] > 3 } {
    puts stderr "ERROR: too few or too many arguments"
    exit 1
}

if { $c != "" && $g != "" } {
    puts stderr "ERROR: both -c and -g options given"
    exit 1
}

# Set up arguments.
#
set jin_file [lindex $argv 0]
set number_args [llength $argv]
switch $number_args {
    1 {}
    2 { set in_file [lindex $argv 1] }
    3 { set out_file [lindex $argv 1]
        set jout_file [lindex $argv 2] }
}

# Read and process parameter definitions.
#
if { [catch { set jin [open $jin_file r] }] } {
    puts stderr "ERROR: cannot open $jin_file"
    exit 1
}
set jin_line [gets $jin]

set last_designator ""
while { ! [eof $jin] } {
    set designator ""
    set variable ""
    set separator ""
    regexp {^[\ \t]*([^\ \t]+)([\ \t].*|)$} $jin_line \
           forget designator rest
    switch -- $designator {
    *CASE-HEAD*	-
    *OUTPUT-CASE-HEAD*
        { set variable output_case_head }
    *GROUP-HEAD* -
    *OUTPUT-GROUP-HEAD*
        { set variable output_group_head }
    *SEPARATOR* -
    *OUTPUT-SEPARATOR*
        { set variable output_separator }
    *INPUT-CASE-HEAD*
        { set variable input_case_head }
    *INPUT-GROUP-HEAD*
        { set variable input_group_head }
    *INPUT-SEPARATOR*
        { set variable input_separator }
    *END*	-
    *INPUT-END*
        { set variable input_end }
    *CASE-MARK*	-
    *INPUT-CASE-MARK*
        { set variable input_case_mark }
    *GROUP-MARK* -
    *INPUT-GROUP-MARK*
        { set variable input_group_mark }
    *SCORING*
        { set variable scoring
	  set separator " " }
    *ONE-GROUP*
        { set variable one_group }
    default { break }
    }
    set rest [string trim $rest]
    if { $last_designator != $designator } {
        set $variable $rest
    } elseif { $rest != "" } {
        set $variable "[set $variable]$separator$rest"
    }
    set last_designator $designator
    set jin_line [gets $jin]
}

# Process 1 argument case.
#
if { $number_args == 1 } {
    close $jin
    puts $scoring
    exit 0
}

# Pre-process -c and -g options.
#
if { $c != "" && $g != "" } {
    puts stderr "ERROR: both -c and -g options given"
    exit 1
}
set cg "$c$g"
if { $cg != "" } {
    set copy 0
    set selective_copy 1
    set selected_group 0
    if {    ! [regexp {^([0-9]+):([0-9]+)$} $cg forget \
                      selected_group selected_case] \
         && ! [regexp {^([0-9]+)$} $cg forget \
	              selected_case] } {
	puts stderr "ERROR: bad -c or -g option: $cg"
	exit 1
    }
} else {
    set copy 1
    set selective_copy 0
}
if { $one_group != "yes" && $one_group != "no" } {
    puts stderr \
         "ERROR: bad *ONE-GROUP* value: $one_group"
    exit 1
}
if { $one_group } { set copy 1 }

# Process 2 argument case.
#
if { $number_args == 2 } {

    if { [catch { set in [open $in_file w] }] } {
	puts stderr "ERROR: cannot open $in_file"
	exit 1
    }

    # Copy is either always on if there is no selective
    # copying (i.e., no -c or -g option), or is turned
    # on and off appropriately to indicate whether an
    # non-mark line is to be copied.

    # State.
    #
    set group_count 0
    set case_count 0
    set last_line_was_separator \
        [expr { $input_separator != "" }]
    set last_line_was_output 1
    set last_line ""

    while { ! [eof $jin] } {
	set is_mark 0
	set begin_case $last_line_was_separator
	set begin_group 0
	if {    $input_group_mark != "" \
	     && [regexp -nocase -- $input_group_mark \
	                $jin_line] } {
	     set begin_group 1
	     set is_mark 1
	} elseif {    $input_group_head != "" \
	           && [regexp -nocase -- \
		              $input_group_head \
		              $jin_line] } {
	     set begin_group 1
	}
	if {    $input_case_mark != "" \
	     && [regexp -nocase -- $input_case_mark \
	                $jin_line] } {
	     set begin_case 1
	     set is_mark 1
        } elseif {    $input_case_head != "" \
	           && [regexp -nocase -- \
		              $input_case_head \
		              $jin_line] } {
	     set begin_case 1
	}
        if { $begin_group } {
	    incr group_count 1
	    set case_count 0
	    if { $selective_copy } {
	        set copy [expr $group_count \
		               == $selected_group]
	    }
	}
	if { $begin_case } {
	    incr case_count
	    if {    $selective_copy \
		 && $selected_group == 0 \
		 && $group_count == 0 \
		 && $case_count == $selected_case } {
		    set copy 1
	    } elseif {    $c != "" \
	               &&   $case_count \
		          > $selected_case } {
	        set copy 0
	    }
	}

	set last_line_was_separator \
	    [expr {    $input_separator != "" \
	            && [regexp -nocase -- \
		               $input_separator \
		               $jin_line] }]

	if { ! $is_mark && $copy } {
	    puts $in $jin_line
	    set last_line_was_output 1
	} else {
	    set last_line_was_output 0
	}
	set last_line $jin_line

	set jin_line [gets $jin]
    }
    if {    ! $last_line_was_output \
         && $input_end != "" \
	 && [regexp -nocase -- $input_end \
	            $last_line] } {
        puts $in $last_line
    }
    close $jin
    close $in
    exit 0
}

# Process 3 argument case.
#
if { $number_args == 3 } {

    close $jin
    if { [catch { set out [open $out_file r] }] } {
	puts stderr "ERROR: cannot open $out_file"
	exit 1
    }
    if { [catch { set jout [open $jout_file w] }] } {
	puts stderr "ERROR: cannot open $jout_file"
	exit 1
    }

    # State.
    #
    set group_count 0
    set case_count 0
    set last_line_was_separator \
        [expr { $output_separator != "" }]

    set out_line [gets $out]
    while { ! [eof $out] } {
        set group_head 0
	set case_head 0
	if {    $output_group_head != "" \
	     && [regexp -nocase -- $output_group_head \
		        $out_line] } {
	    incr group_count
	    set case_count 0
	    set group_head 1
	    if { $selective_copy } {
	        set copy [expr $group_count \
		               == $selected_group]
	    }
	}
        if {    (    $output_case_head != "" \
	          && [regexp -nocase -- \
		             $output_case_head \
		             $out_line] ) \
	     || $last_line_was_separator } {
	    incr case_count
	    set case_head 1
	    if {    $selective_copy \
		 && $selected_group == 0 \
		 && $group_count == 0 \
		 && $case_count == $selected_case } {
		    set copy 1
	    } elseif {    $c != "" \
	               &&   $case_count \
		          > $selected_case } {
	        set copy 0
	    }
	}

	set last_line_was_separator \
	    [expr {    $output_separator != "" \
	            && [regexp -nocase -- \
		               $output_separator \
		               $out_line] }]
	
	if { $copy && ! $selective_copy } {
	    if { $group_head && $case_head } {
		set out_line "+$out_line"
	    } elseif { $group_head } {
		set out_line "|$out_line"
	    } elseif { $case_head } {
		set out_line "-$out_line"
	    } else {
		set out_line ".$out_line"
	    }
	}
	if { $copy } {
	    puts $jout $out_line
	}

	set out_line [gets $out]
    }
    close $out
    close $jout

    exit 0
}

# Should not come here.
#
puts stderr "Programming error."
exit 1
