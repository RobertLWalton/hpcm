#!/bin/sh
#
# Use judge's input to produce filtered input or output
# or scoring instructions.
#
# File:		jfilter
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Fri Sep  2 01:19:05 EDT 2005
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2005/09/02 05:44:04 $
#   $RCSfile: jfilter,v $
#   $Revision: 1.4 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

set document "
jfilter \[options\] judging_input_file
jfilter \[options\] judging_input_file \\
                    filtered_input_file
jfilter \[options\] judging_input_file \\
                    output_file filtered_output_file

    A judging_input_file (e.g., a .jin file) has scoring
    parameter lines and marker lines, and judge's input
    to test a submitted program.  The parameter and
    marker lines define both scoring instructions for
    scoring any output produced from the judge's input
    in the file, and a means of dividing both the
    judge's input and all output produced therefrom into
    cases and into groups of cases.

    The 1-file-name command reads the judging_input_file
    (e.g., a .jin file) and prints scoring instructions
    that can be passed as arguments to the scorediff
    program.

    The 2-file-name command reads the judging_input_file
    and writes filtered version of that to the filtered_
    input_file.  The filtered version version simply has
    judging parameter and marker lines (defined below)
    removed.

    The 3-file-name command reads the judging_input_file
    and the output_file (e.g., a .out, .fout, .test, or
    .ftest file), and writes a filtered version of the
    output_file to the filtered_output_file.  The fil-
    tered_output_file is the same as the output_file
    except each line is prefaced with one of the follow-
    ing characters:

    	+ Begin a group and a case.
	| Begin a group.
	- Begin a case.
	. Do not begin a case or group.

    The options modify these commands as follows:

        -c <case-number>

	    For the 2- and 3-file-name commands, these
	    cause the commands to output just the
	    portion of the judge's input or the portion
	    of the output that relates to testing the
	    given case number.  Cases are numbered 1, 2,
	    3, ... in the files.

	    If there are no groups in the files, the
	    portion consists just of the lines in the
	    designated case, from the case beginning
	    line through the last line that is just
	    before the beginning of the next group or
	    case or the end of file.

	    If there are groups in the files, the
	    portion consists of the lines in the group
	    containing the case, up to and including
	    the lines in the case.

	-g <case-number>

	    Same as -c BUT, if there are groups in the
	    files, include all the lines of the entire
	    group, instead of stopping with the design-
	    ated case.

	-case-head <output-case-head-regexp>
	-group-head <output-group-head-regexp>
	-separator <output-separator-regexp>
	-output-case-head <output-case-head-regexp>
	-output-group-head <output-group-head-regexp>
	-output-separator <output-case-separator-regexp>
	-input-case-head <input-case-head-regexp>
	-input-group-head <input-group-head-regexp>
	-input-separator <input-separator-regexp>
	-case-mark <input-case-mark-regexp>
	-group-mark <input-group-mark-regexp>
	-separator-mark <input-separator-mark-regexp>
	-input-case-mark <input-case-mark-regexp>
	-input-group-mark <input-group-mark-regexp>
	-input-separator-mark \\
	       <input-separator-mark-regexp>
	-scoring <scoring-instructions>

	    Set the default value of the designated
	    parameter.  These parameters can then be
	    reset by parameter definitions in the
	    judging_input_file.


    The judging_input_file begins zero or more parameter
    definitions, each having one of the following forms:

    *CASE-HEAD* <output-case-head-regexp>
    *GROUP-HEAD* <output-group-head-regexp>
    *SEPARATOR* <output-separator-regexp>

    *OUTPUT-CASE-HEAD* <output-case-head-regexp>
    *OUTPUT-GROUP-HEAD* <output-group-head-regexp>
    *OUTPUT-SEPARATOR* <output-separator-regexp>

    *INPUT-CASE-HEAD* <input-case-head-regexp>
    *INPUT-GROUP-HEAD* <input-group-head-regexp>
    *INPUT-SEPARATOR* <input-separator-regexp>

    *CASE-MARK* <input-case-mark-regexp>
    *GROUP-MARK* <input-group-mark-regexp>
    *SEPARATOR-MARK* <input-separator-mark-regexp>

    *INPUT-CASE-MARK* <input-case-mark-regexp>
    *INPUT-GROUP-MARK* <input-group-mark-regexp>
    *INPUT-SEPARATOR-MARK* <input-separator-mark-regexp>

    *SCORING* <scoring-instruction> ...

    These consist of a parameter-designator, the first
    thing on the line (e.g., *CASE-HEAD*), followed by
    parameters.  In a parameter designator, `OUTPUT-'
    can be omitted: *CASE-HEAD* and *OUTPUT-CASE-HEAD*
    mean the same thing.  `INPUT-' can be omitted for
    the `MARKS': *CASE-MARK* and *INPUT-CASE-MARK* mean
    the same thing.  It is not that common to have
    *INPUT-...* parameters in a judging_input_file.

    The regexp parameters are TCL regular expressions
    that are matched to lines of files.  Input regexps
    match lines in the judging_input_file, which output
    regexps match lines in the output_file.  A line
    matched by a `head' regexp is called a head line,
    and begins a group or case.  A line matched by a
    `separator' regexp is called a separator line,
    and is the last line of a case that is followed
    by the first line of another case.  A line matched
    by a `mark' is like a head line but must be deleted
    from the filtered version of the file: this is only
    used for the judging_input_file, to used mark lines
    to mark the beginning of groups and cases.  And a
    line matched by a `separator mark' is like a separa-
    tor line, but must be deleted in the filtered ver-
    sion of the file.

    A regexp parameter set to the empty string (all
    whitespace) is `missing', and deactivates use of
    the parameter in line matching.

    The *SCORING* parameters are just exactly what is
    printed on a single line by the 1-file-name command.

    Parameter definitions can be continued across lines
    by writing a sequence of lines with the same para-
    meter-designator.  Thus

    	*CASE-HEAD* xxx
    	*CASE-HEAD* yyy

    is the same as

    	*CASE-HEAD* xxxyyy

    Note that there is no space here between the xxx and
    yyy when they are concatenated.  This is because
    they are regexp parameters.  If they were non-regexp
    parameters, i.e. scoring parameters, a single space
    character would be inserted.  Therefore

    	*SCORING* xxx
    	*SCORING* yyy

    is the same as

    	*SCORING* xxx yyy

    Regexps should begin with `^' if they are to match
    just the beginning of a line.  Otherwise they will
    match any part of a line.

    Regexps are always matched with a -nocase option, so
    letter case in a regexp makes no difference.

    Whitespace is trimmed from the beginning and end of any
    regexp in a parameter definition.  This means that if
    the regexp is to end with a space character, it should
    be postpended by `()', which does nothing but mark the
    end of the regexp.  E.g.,

        *CASE-HEAD* ^foo   ()


    The defaults for all parameters are

	*CASE-HEAD* ^
	*GROUP-HEAD*
	*SEPARATOR*

	*INPUT-CASE-HEAD*
	*INPUT-GROUP-HEAD*
	*INPUT-SEPARATOR*

	*CASE-MARK* ^\\*CASE*\\$
	*GROUP-MARK* ^\\*GROUP\\*$
	*SEPARATOR-MARK*

	*SCORING* space column

    These mean that by default input is separated into
    groups and cases by `*GROUP*' and `*CASE*' mark
    lines, every line of output is a separate case, and
    there are no output groups.  The default scoring
    instructions say to ignore differences in the kind
    and amount of spacing within an output_file line.

    The group and case judging input comes after any
    parameter definitions in the judging_input_file.
    If there are no groups, the input consists of just
    a sequence of cases.  If there are groups, cases are
    grouped.  A single line may begin both a case and
    a group, in either input or output, or a group may
    begin before the first case in the group.

    Any lines in the judging_input_file that are after
    the parameter definitions and before anything that
    can be interpreted as a case or group beginning are
    considered to be in error.  If there is no group
    beginning before the first case, then any group
    beginning in the judging_input_file is considered
    to be in error.

    Unlike most HPCM judging programs, this program does
    not read any hpcm_judging.rc file and errors made by
    this program are not written to log files."

# Process options.
#
set output_case_head "^"
set output_group_head ""
set output_separator ""
set input_case_head ""
set input_group_head ""
set input_separator ""
set input_case_mark "\\*CASE\\*"
set input_group_mark "\\*GROUP\\*"
set input_separator_mark ""
set scoring "space column"
set c ""
set g ""
while { [regexp {^-} [lindex $argv 0]} } {
{
    switch [lindex $argv 0] {
    set argname ""
    -doc {
	    puts $document
	    exit 0
	}
    -case-head		-
    -output-case-head	{ set output_case_head \
    			      [lindex $argv 1] }
    -group-head		-
    -output-group-head	{ set output_group_head \
    			      [lindex $argv 1] }
    -separator		
    -output-separator	{ set output_separator \
    			      [lindex $argv 1] }
    -input-case-head	{ set input_case_head \
    			      [lindex $argv 1] }
    -input-group-head	{ set input_group_head \
    			      [lindex $argv 1] }
    -input-separator	{ set input_separator \
    			      [lindex $argv 1] }
    -case-mark		-
    -input-case-mark	{ set input_case_mark \
    			      [lindex $argv 1] }
    -group-mark		-
    -input-group-mark	{ set input_group_mark \
    			      [lindex $argv 1] }
    -separator-mark	-
    -input-separator-mark \
    			{ set input_separator_mark \
    			      [lindex $argv 1] }
    -scoring		{ set scoring \
    			      [lindex $argv 1] }
    -c			{ set c \
    			      [lindex $argv 1] }
    -g			{ set g \
    			      [lindex $argv 1] }
    default {
    	    puts stderr "BAD option: [lindex $argv 0]"
	    exit 1
    	}
    }

    set argv [lrange $argv 2 end]
}

if { [llength $argv] < 1 || [llength $argv] > 3 } {
    puts stderr "ERROR: to few arguments"
    exit 1
}

# Set up arguments.
#
set jin_file [lindex $argv 0]
set in_file ""
set out_file ""
set jout_file ""
set number_args [llength $argv]
switch $number_args {
    1 {}
    2 { set in_file [lindex $argv 1] }
    2 { set out_file [lindex $argv 1]
        set jout_file [lindex $argv 2] }
}

# Read and process parameter definitions.
#
if { [catch { set jin [open $jin_file r] }] } {
    puts stderr "ERROR: cannot open $jin_file"
    exit 1
}
set jin_line [gets $jin]

set last_designator ""
while { ! [eof $jin_line] } {
    set designator ""
    set variable ""
    set separator ""
    regexp {^[\ \t]*([^\ \t]+)([\ \t]|$)} $jin_line \
           forget designator rest
    switch $designator {
    *CASE-HEAD*	-
    *OUTPUT-CASE-HEAD*
        { set variable output_case_head }
    *GROUP-HEAD* -
    *OUTPUT-GROUP-HEAD*
        { set variable output_group_head }
    *SEPARATOR* -
    *OUTPUT-SEPARATOR*
        { set variable output_separator }
    *INPUT-CASE-HEAD*
        { set variable input_case_head }
    *INPUT-GROUP-HEAD*
        { set variable input_group_head }
    *INPUT-SEPARATOR*
        { set variable input_separator }
    *CASE-MARK*	-
    *INPUT-CASE-MARK*
        { set variable input_case_mark }
    *GROUP-MARK* -
    *INPUT-GROUP-MARK*
        { set variable input_group_mark }
    *SEPARATOR-MARK* -
    *INPUT-SEPARATOR-MARK*
        { set variable input_separator_mark }
    *SCORING*
        { set variable scoring
	  set separator " " }
    default { break }
    }
    set rest [string trim $rest]
    if { $last_designator != $designator } {
        set $variable $rest
    } elseif { $rest != "" } {
        set $variable "$variable$separator$rest"
    }
    set last_designator $designator
    set jin_line [gets $jin]
}

# Process 1 argument case.
#
if { $number_args == 1 } {
    close $jin
    puts $scoring
    exit 0
}

# Process 2 argument case.
#
if { $number_args == 2 } {

    set in [open $in_file w]

    # Copy is either always on if there is no selective
    # copying (i.e., no -c or -g option), or is turned
    # on and off appropriately to indicate whether an
    # UNMATCHED line is to be copied.
    #
    set copy 1
    set selective_copy 0
    if { $c != "" || $g != "" } {
	set selective_copy 1
	set copy 0 }
    }

    # State.
    #
    set case_count 0
    set found_case 0
    set found_group 0
    set first_line 1
    set last_line_was_separator \
        [expr {    $input_separator != "" \
	        || $input_separator_mark != "" }]

    # We save lines in a group until we find the case
    # to be selectively copied.
    #
    set saved_group_lines {}

    while { ! [eof $jin] } {
	set is_mark 0
	set copy_this_line $copy
	set begin_case $last_line_was_separator
	set begin_group 0
	if {    $input_group_mark != "" \
	     && [regexp $input_group_mark $jin_line] } {
	     set begin_group 1
	     set is_mark 1
	} elseif {    $input_group_head != "" \
	           && [regexp $input_group_head \
		              $jin_line] } {
	     set begin_group 1
	}
	if {    $input_case_mark != "" \
	     && [regexp $input_case_mark $jin_line] } {
	     set begin_case 1
	     set is_mark 1
        } elseif {    $input_case_head != "" \
	           && [regexp $input_case_head \
		              $jin_line] } {
	     set begin_case 1
	}
        if { $begin_group } {
	    if { ! $found_group && ! $first_line } {
		puts stderr "ERROR: start of first\
		             group follows start of\
			     first case:\n$jin_line"
		exit 1
	    }
	    set found_group 1
	    set saved_group_lines {}
	    if { $selective_copy } {
	        set copy 0
		set copy_this_line 0
	    }
	}
	if { $begin_case } {
	    set found_case 1
	    incr case_count
	    if { ! $found_group } {
	        set saved_group_lines {}
	    }
	    if { $case_count == $g } {
	        foreach s $saved_group_lines {
		    puts $in $s
		}
		set copy 1
		set copy_this_line 1
	    } elseif { $case_count == $c } {
	        set copy 1
		set copy_this_line 1
	    } elseif { $selective_copy } {
	        set copy 0
		set copy_this_line 0
	    }
	}
	if { ! $group_found && ! $case_found } {
	    puts stderr "ERROR: line before start\
	                 of any group or\
			 case:\n$jin_line"
	    exit 1
	}
	if { ! $is_mark } {
	    lappend saved_group_lines $jin_line
	    if { $copy_this_line } {
	        puts $in $jin_line
	    }
	}
        if {    $input_separator != "" \
	     && [regexp $input_separator $jin_line] } {
	     set last_line_was_separator 1
	} else {
	     set last_line_was_separator 0
	}
	set jin_line [gets $jin_line]
	set first_line 0
    }
    close $jin
    close $in
    exit 0
}

# Process 3 argument case.
#
if { $number_args == 3 } {

    close $jin
    set out [open $out_file r]
    set jout [open $jout_file w]
    set line [gets $out_file]
    set force_case 0
    while { ! [eof $out_file] } {
	set g 0
	set c $force_case
	if {    $group_head != "" \
	     && [regexp -nocase $group_head $line] } {
	    set g 1
	}
	if {    $case_head != "" \
	     && [regexp -nocase $case_head $line] } {
	    set c 1
	}
	if {    $case_separator != "" \
	     && [regexp -nocase $case_separator $line] \
	   } {
	    set force_case 1
	} else {
	    set force_case 0
	}
	if { $g && $c } {
	    puts $jout "+$line"
	} elseif { $g$ } {
	    puts $jout "|$line"
	} elseif { $c$ } {
	    puts $jout "-$line"
	} else {
	    puts $jout ".$line"
	}

        set line [gets $out_file]
    }
    close $out
    close $jout

    exit 0
}

# Should not come here.
#
puts stderr "Programming error."
exit 1
