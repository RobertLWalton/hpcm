#! /bin/sh
#
# Test problem code.
#
# File:		testproblems
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Mon Feb  4 06:22:01 EST 2013
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2013/02/04 12:19:34 $
#   $RCSfile: testproblems,v $
#   $Revision: 1.41 $
#
# The next lines run tclsh \
trap "echo testproblems: Terminated by Signal; exit 1" \
    HUP INT QUIT; \
trap "rm -rf /tmp/testproblems$$" EXIT; \
HPCM_SANDBOX_UNSECURE= \
    tclsh "$0" /tmp/testproblems$$ "$@"; exit $status

# Note we set HPCM_SANDBOX_UNSECURE above so we run
# hpcm_sandbox with the current uid and can access
# a local directory without a+x permissions on all its
# ancestors.

set allowed_extensions "c cc java lsp"
set tmp [lindex $argv 0]
set argv [lrange $argv 1 end]

set lib_directory "[file dirname $argv0]/../lib"
set judging_directory .
set log_disable yes
source $lib_directory/judging_common.tcl
catch {

set document "
testproblems \[-p N] \[-keep|-|-contestant] \\
             \[-ext \"EXT ...\"] \[directory ...]

    The command with no arguments is equivalent to

    	testproblems .

    The command with just the argument `-' is equivalent
    to
    	testproblems -keep .

    In general the default directory is `.' and the
    argument `-' is equivalent to `-keep'.

    The `-p N' arguments cause the run to be done N
    times in parallel, as a way of testing timing of on
    multiple CPU computers.  To do this copies of the
    directories are made inside /tmp, and testproblems
    is run on these copies.

    The output without the `-p' option is the output
    of the `make' executions followed by a summary in-
    cluding the diff listings of any files with unex-
    pected differences followed by a list containing the
    names of these files.  With the `-p' option the only
    output is for each run a list of the names of files
    with differences, if any, followed by timing infor-
    mation.

    To first approximation, this program tests a solu-
    tion in file PROBLEM.EXT by making a subdirectory
    named EXT, linking appropriate files into it, and
    running:

		make
		diff *.out *.test

    in the subdirectory.  After an EXT subdirectory is
    completely processed, it is deleted, unless the
    -keep option is used.  The diff outputs are both
    saved and outputted, and all relevant saved output
    for each directory is played back at the end of this
    program's execution.  Errors made during the above
    run are also played back.

    More specifically, for each directory this program
    does the following.  First, it does a cd to the
    directory and extracts the name PROBLEM from the
    `P = PROBLEM' line of the directory's Makefile.
    Then it deletes any symbolic link named PROBLEM.in
    (but will NOT delete a regular file of that name)
    and runs

    		make clean

    Then the set of input names is formed.  Initially
    this is the set of names N such that N.in or N.jin
    exist.  Then if the variable problem_input_names is
    defined in PROBLEM.rc, names not listed in that
    variable's value are removed from the set.  Then if
    the set has a name other than PROBLEM, the name
    PROBLEM is removed from the set if it is in the
    set.

    Next this program uses any problem_make_files value
    in any PROBLEM.rc file in the directory to make or
    remake files in the directory.  If these files exist
    when this program is run, they are deleted and
    remade if they are obsolete.

    After making problem_make_files, this program
    identifies the solution files PROBLEM.EXT that are
    to be tested.  Here EXT is restricted to values
    in a list given by the -ext argument if that is
    given, or the problem_allowed_extensions variable
    in the PROBLEM.rc file, if that is given, or

        $allowed_extensions

    otherwise.  For each EXT in the list such that the
    file PROBLEM.EXT exists, the subdirectory EXT is
    made, files are linked into it, and in that direc-
    tory PROBLEM.EXT is tested.

    Next files are linked from the directory to its
    EXT subdirectory.  This is done using link
    instructions of the form

    	{ F F1 F2 F3 ... }

    which mean that the file name F in the EXT subdi-
    rectory is to be linked to F1 in the directory,
    if that exists, else F2 in the directory, etc.
    An instruction of the form `F' is equivalent to
    `{F F}'.  A link instruction may be required,
    meaning that if F cannot be linked to anything
    subdirectory processing terminates with an error,
    or optional, meaning the link instruction can fail
    without error.

    The link instructions executed are

        * PROBLEM.EXT \[required]

    	* Those listed in problem_{link,copy}_files
	  \[required] or problem_optional_{link,copy}_
	  files \[optional].  Note the ..._copy_files
	  are linked and not copied, because the only
	  reason for copying them is so the sandbox can
	  access them, but this is not an issue for this
	  program disables sandboxing.

	* { Makefile Makefile.EXT Makefile } \[required]
	  Scoring_Filter \[optional]

	* For each N in the set of input names:

	      N.in			\[optional]
	      N.jin			\[optional]
	      N.test N.out N.test	\[optional]
	      N.jtest N.jout N.jtest	\[optional]
	      N.ftest N.fout N.ftest	\[optional]
	      N.jftest N.jfout N.jftest	\[optional]

    Then in the EXT subdirectory for each input name N
    the following are run:
    processed as follows.
    
      * If N.jin exists but N.in does not:

	    jfilter -v N.jin N.in >& N.in#

      * If both N.jin and N.in exist:

	    jfilter -v N.jin N.in+ >& N.in#
	    diff N.in N.in+

      * Always:

	    ln -s N.in PROBLEM.in      # if N != PROBLEM
	    make
	    rm PROBLEM.in              # if N != PROBLEM
	    mv PROBLEM.out N.out       # if N != PROBLEM
	    diff N.out N.test

      * If N.jin exists but Scoring_Filter does not
        exist:

	    jfilter -v N.jin N.out N.jout >& N.jout#
	    diff N.jout N.jtest
	    diff N.jin# N.jout#

      * If Scoring_Filter exists:

	    Scoring_Filter N.in < N.out > N.fout
	    diff N.fout N.ftest

      * If N.jin and Scoring_Filter exist:

	    jfilter -v N.jin N.fout N.jfout >& N.jfout#
	    diff N.jfout N.jftest
	    diff N.jin# N.jfout#

    If errors occur while processing a directory, they
    are announced and processing of the directory is
    terminated.

    Unless the -keep option is given, after finishing a
    directory all files listed in problem_make_files and
    all EXT subdirectories are deleted.

    If a non-directory is given the program, or if a
    directory with no Makefile is given, the program
    merely notes this in the output."

# Process options.
#
# The `-SUB 1 filename' option is used when testproblems
# is called recursively for the `-p' option, and
# causes a list of names of differing files, followed by
# a report of errors running testproblems, if any,
# followed by timing information, to be APPENDED to the
# named file.  There is no other output. `-SUB 2 file-
# name' is similar but does not include the timing in-
# formation.  `-SUB 3 filename' is similar but does not
# include the error report or timing information and
# does have the other output associated with test-
# problems.  When called with -SUB 1, testproblems calls
# `time testproblems -SUB 2 ...' and appends the timing
# info to the named file.  When called with -SUB 2 test-
# problems calls `testproblems > /dev/null -SUB 3 ...'
# and if there is any returned text, which will be
# stderr output, appends that as the error report to the
# named file.  None of these options may be used with
# the -p option, and there is no error checking of
# the -SUB option arguments.
#
set parallel_runs 0
set keep 0
set make 0
set judge 0
set SUB 0
set SUB_filename ""
set myargv $argv
while { 1 } {
    switch -glob -- [lindex $myargv 0] {
    -doc* {
	puts $document
	exit 1
    }
    -keep { set keep 1 }
    -     { set keep 1 }
    -make { set make 1 }
    -judge { set judge 1 }
    -p {
	    set myargv [lrange $myargv 1 end]
	    set parallel_runs [lindex $myargv 0]
	    if { [catch \
	            { expr { $parallel_runs + 1 }}] \
	         || \
		 $parallel_runs <= 0 } {
	        puts "-p $parallel_runs is not legal"
		exit 2
	    }
    }
    -SUB {
	    set myargv [lrange $myargv 1 end]
	    set SUB [lindex $myargv 0]
	    set myargv [lrange $myargv 1 end]
	    set SUB_filename [lindex $myargv 0]
    }
    default break
    }
    set myargv [lrange $myargv 1 end]
}
if { [llength $myargv] == 0 } {
    set myargv .
}

set wd [pwd]

if { $parallel_runs > 0 } {

    file delete -force -- $tmp
    file mkdir $tmp
    grant_access $tmp x
    set i 1
    while { $i <= $parallel_runs } {
        file mkdir $tmp/test$i
	grant_access $tmp/test$i x
	foreach d $myargv {
	    exec cp -pr $d $tmp/test$i
	}
	incr i
    }
    if { $keep } { set k -keep } else { set k "" }
    set i 1
    set pids {}
    while { $i <= $parallel_runs } {
        cd $tmp/test$i
	lappend_lists pids \
	     [eval exec $argv0 \
		   -SUB 1 $tmp/test$i.report \
		   $k $myargv &]
	incr i
    }

    cd $wd

    while { [llength $pids] > 0 } {
        set pid [lindex $pids 0]
	while { [process_found \
	             [display_process_tree $pid]] } {
	    sleep 2
	}
	set pids [lrange $pids 1 end]
    }

    puts "===================== Test of $parallel_runs\
          Parallel Runs"
    exec date >@ stdout
    exec hostname -f >@ stdout
    puts -nonewline "testproblems -p $parallel_runs $k"
    set j 0
    foreach d $myargv {
        if { $j % 5 == 0 } {
	    puts -nonewline " \\\n   "
	}
	puts -nonewline " $d"
	incr j
    }
    puts ""
    puts ""
    set i 1
    while { $i <= $parallel_runs } {
	puts "========== run $i:"
    	exec cat $tmp/test$i.report >@ stdout
	incr i
    }
    file delete -force -- $tmp
    exit 0

} elseif { $SUB == 1 } {
    if { $keep } { set k -keep } else { set k "" }
    # time writes its output to the standard error file
    catch { eval exec time -p $argv0 \
                 -SUB 2 $SUB_filename $k $myargv } \
	  tout
    set fd [open $SUB_filename a]
    puts $fd "\n$tout"
    close $fd
    exit 0
} elseif { $SUB == 2 } {
    if { $keep } { set k -keep } else { set k "" }
    set eout [eval exec $argv0 > /dev/null \
                   -SUB 3 $SUB_filename $k $myargv]
    if { $eout != "" } {
	set fd [open $SUB_filename a]
	puts $fd "\nTESTPROBLEMS ERROR OUTPUT\n\n$eout"
	close $fd
    }
    exit 0
} elseif { $SUB == 0 } {
    file delete -force -- $tmp
    set fd [open $tmp w]
}

set diff_files {}

proc putsfd { string } {
    global fd
    if { [info exists fd] } {
        puts $fd $string
    }
}

proc diff { file1 file2 } {
    global problem diff_files SUB
    puts "diff $file1 $file2"
    catch {
	set diffs [exec diff $file1 $file2]
	  } diffs
    if { [string trim $diffs] != "" } {
	if {    $file1 != "$problem.out" } {
	    set diffs \
		"========== $file1:\n$diffs"
	}
	putsfd $diffs
	puts $diffs
	lappend diff_files \
	        [list $problem $file1 $file2]
    }
}

# Read .rc file to possibly set any problem_make_files,
# and problem_{optional_,}{link,copy}_files global
# variables.
#
proc read_rc_file { file problem } {
    global PROBLEM EXTENSION OPTIONS \
	   problem_make_files \
	   problem_link_files \
	   problem_optional_link_files \
	   problem_copy_files \
	   problem_optional_copy_files

    set PROBLEM $problem
    set EXTENSION UNDEFINED
    set OPTIONS UNDEFINED
    source_file $file
}

# Test that a $problem.rc global variable value is a
# TCL list and complain if it is not.
#
proc check_list { variable_name } {

    global problem
    upvar $variable_name variable

    if { [catch { llength $variable }] } {
	error "$problem.rc\
	       $variable_name value is\
	       not a TCL\
	       list:\n    $variable"
    }
}

foreach x $myargv {

    if { ! [file isdirectory $x] } {
        puts "====================\
	      $x is not a directory"
	continue
    }

    if { ! [file exists $x/Makefile] } {
	puts "====================\
	      $x/Makefile does not exist"
	continue
    }

    putsfd "==================== $x:"
    puts -nonewline "===================="
    puts -nonewline "===================="
    puts -nonewline "===================="
    puts " $x:"

    cd $x
    if { [catch {

	set problem [file tail [pwd]]

	# Do initial clean.
	#
	set type none
	catch { set type [file type $problem.in] }
	if { $type == "link" } {
	    file delete $problem.in
	}
	exec make clean >&@ stdout

	# List of files to be deleted at end if -keep
	# option is absent.
	#
	set delete_at_end {}

	# Compute make_files = problem_make_files value
	# in any $problem.rc file.  Similarly compute
	# link_files = problem_{link,copy}_files and
	# optional_link_files = problem_optional_{link,
	# copy}_files.
	#
	set make_files {}
	set link_files {}
	set optional_link_files {}
	if { [file exists $problem.rc] } {

	    catch { unset problem_make_files }
	    catch { unset problem_link_files }
	    catch { unset problem_optional_link_files }
	    catch { unset problem_copy_files }
	    catch { unset problem_optional_copy_files }
	    read_rc_file $problem.rc $problem

	    if { [info exists problem_make_files] } {
		check_list problem_make_files
	        set make_files $problem_make_files
	    }
	    if { [info exists problem_link_files] } {
		check_list problem_link_files
		set link_files $problem_link_files
	    }
	    if { [info exists \
		       problem_optional_link_files] } {
		check_list \
		    problem_optional_link_files
		set optional_link_files \
		    $problem_optional_link_files
	    }
	    if { [info exists problem_copy_files] } {
		check_list problem_copy_files
		lappend_lists link_files \
		     $problem_copy_files
	    }
	    if { [info exists \
		       problem_optional_copy_files] } {
		check_list \
		    problem_optional_copy_files
		lappend_lists optional_copy_files \
		    $problem_optional_link_files
	    }
	}

	# If there are make_files, (re)make them.
	#
	if { [llength $make_files] > 0 } {

	    set made {}

	    foreach instruction $make_files {
		if { [catch { llength $instruction }] \
		   } {
		    error "$problem.rc\
		           problem_make_files\
			   instruction is not a TCL\
			   list:\n    $instruction"
		}
		set file [lindex $instruction 0]
		if { $file == "" } {
		    error "$problem.rc\
		           problem_make_files\
			   instruction has empty file\
			   name:\n    $instruction"
		}
		if { ! $make } {
		    lappend delete_at_end $file
		}
		lappend made $file
	    }

	    puts "(re)making $made"
	    execute_makes $make_files . \
	                  "problem_make_files value in\
			   $problem.rc"
	}

	# If there are link files or optional link
	# files, link them if they do not exist.  If
	# -judge and they would be linked to another
	# existing file, insist that they are linked
	# to this file, removing any existing file or
	# link and relinking if necessary.  If there
	# is no file and no way to link it, complain
	# if the file is on link_files list (and
	# therefore is not optional).  If not -make
	# option, put all files that might be linked
	# on the delete list.
	#
	set non_optional [llength $link_files]
	    # If >= 0 file is not optional
	foreach instruction \
	        [concat $link_files \
			$optional_link_files] {
	    incr non_optional -1

	    if { [catch { llength $instruction }] \
	       } {
	      error \
	        "$problem.rc\
		 problem_{,optional_}{link,copy}_files\
		 instruction is not a TCL\
		 list:\n    $instruction"
	    }

	    set file [lindex $instruction 0]

	    if { $file == "" } {
	      error \
	        "$problem.rc\
		 problem_{,optional_}{link,copy}_files\
		 instruction has empty file\
		 name:\n    $instruction"
	    }

	    if { [file exists $file] && ! $judge } \
	        continue

	    # Compute desired target; File cannot be its
	    # own target.
	    #
	    set target ""
	    foreach t [lrange $instruction 1 end] {
	        if { [file exists $t] } {
		    set target $t
		    break
		}
	    }

	    if {    $target == "" \
	         && ! [file exists $file] \
		 && $non_optional >= 0 } {
	      error \
	        "$problem.rc problem_{link,copy}_files\
		 instruction requires that $file be\
		 linked but this is not\
		 possible:\n    $instruction"
	    }

	    # If no target and file exists or is
	    # optional, skip it.
	    #
	    if { $target == "" } continue

	    set old_target ""
	    catch { set old_target \
			[file readlink $file] }
	    if { $old_target == $target } continue;

	    # If old_target targets an existing file
	    # we must have -judge at this point.
	    # Similarly if $file exists we must have
	    # -judge at this point.
	    #
	    if {    $old_target != "" \
	         && ! [file exists $old_target] } {
		puts "deleting link of $file to\
		      $old_target as $old_target does\
		      not exist"
		file delete -force -- $file
	    } elseif { $old_target != "" } {
		puts "deleting link of $file to\
		      $old_target as per -judge"
		file delete -force -- $file
	    } elseif { [file exists $file] } {
		puts "deleting $file as per -judge"
		file delete -force -- $file
	    }

	    # At this point $file does not exist
	    # and is not a link.
	    #
	    puts "linking $file to $target"
	    file link -symbolic $file $target

	    if { ! $make } {
		lappend delete_at_end $file
	    }
	}

	# If problem.in or problem.jin exist, only
	# consider them.  Otherwise consider all
	# *.in and *.jin.  Note that if problem.in
	# was a link it was deleted above.
	#
	set inputs ""
	foreach file [glob *.in *.jin] {
	    set f [file rootname $file]
	    if { [lcontain $inputs $f] } continue
	    lappend inputs $f
	}
	if {    [lcontain $inputs $problem] \
	     && [llength $inputs] > 1 } {
	    error "ERROR: $problem.in or $problem.jin\
	           exists\n       along with other .in\
		   or .jin files"
	}
	foreach f [lsort $inputs] {

	    if { $f != $problem } {
	        puts "========== $f:"
	    }
	    file delete -force -- $f.in#
	    if { ! [file exists $f.in] } {
	        puts "jfilter -v $f.jin $f.in >& $f.in#"
	        exec jfilter -v $f.jin $f.in >& $f.in#
		lappend delete_at_end $f.in $f.in#
	    } elseif { [file exists $f.jin] } {
	        file delete -force -- $f.in+
	        puts "jfilter -v $f.jin $f.in+\
		      >& $f.in#"
	        exec jfilter -v $f.jin $f.in+ >& $f.in#
		lappend delete_at_end $f.in+ $f.in#
		diff $f.in $f.in+
	    }
	    if { $f != $problem } {
	        exec ln -s $f.in $problem.in
	    }

	    set make_error \
	        [catch { exec make >@ stdout } \
		       mout]
	    if { $make_error } {
	        if { $f != $problem } {
		    putsfd "========== making $f.out:"
		}
		putsfd $mout
		puts $mout
	    }

	    if { $f != $problem } {
	        file rename $problem.out $f.out
		lappend delete_at_end $f.out
		file delete $problem.in
	    }

	    if { $make_error } continue

	    diff $f.out $f.test

	    if { [file exists Scoring_Filter] } {
		puts "Scoring_Filter $f.in\
		      < $f.out > $f.fout"
		exec Scoring_Filter $f.in \
		     < $f.out > $f.fout
		lappend delete_at_end $f.fout
		if { [file exists $f.ftest] } {
		    diff $f.fout $f.ftest
		}
		if { [file exists $f.jin] } {
		    file delete -force -- $f.jfout#
		    puts "jfilter -v\
			  $f.jin $f.fout $f.jfout\
			  >& $f.jfout#"
		    exec jfilter -v \
			 $f.jin $f.fout $f.jfout \
			 >& $f.jfout#
		    lappend delete_at_end \
		            $f.jfout $f.jfout#
		    if { [file exists $f.jftest] } {
			diff $f.jfout $f.jftest
		    }
		    diff $f.in# $f.jfout#
		}
	    } elseif { [file exists $f.jin] } {
		file delete -force -- $f.jout#
		puts "jfilter -v $f.jin $f.out\
			      $f.jout >& $f.jout#"
		exec jfilter -v $f.jin $f.out \
		     $f.jout >& $f.jout#
		lappend delete_at_end $f.jout $f.jout#
		if { [file exists $f.jtest] } {
		    diff $f.jout $f.jtest
		}
		diff $f.in# $f.jout#
	    }

	    if { ! $keep } {
	        exec make clean >&@ stdout
	    }
	}
	if { ! $keep && [llength $delete_at_end] > 0 } {
	    puts "rm -f $delete_at_end"
	    eval file delete -force -- $delete_at_end
	}
    } out] } {
        puts $out
	putsfd $out
    }
    cd $wd
}

if { $SUB == 3 } {
    set report [open $SUB_filename a]
} else {
    puts ""
    puts "******************** SUMMARY:"
    set report stdout
}


if { $SUB == 0 } {
    close $fd
    exec cat $tmp >@ stdout
    file delete $tmp
}

if { [llength $diff_files] > 0 } {
    puts $report "******************** \
          FILES THAT ARE DIFFERENT:"
    set p ""
    foreach item $diff_files {
        set problem [lindex $item 0]
        set file1 [lindex $item 1]
        set file2 [lindex $item 2]
	if { $p != $problem } {
	    puts $report "  in $problem:"
	    set p $problem
	}
	puts $report \
	     [format {%38s != %-38s} $file1 $file2]
    }
}
if { $SUB == 3 } {
    close $report
}

exit 0

} caught_output
caught_error
