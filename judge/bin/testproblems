#! /bin/sh
#
# Test problem code.
#
# File:		testproblems
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Sat Aug 21 07:44:38 EDT 2010
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2010/08/21 12:29:39 $
#   $RCSfile: testproblems,v $
#   $Revision: 1.37 $
#
# The next lines run tclsh \
trap "echo testproblems: Terminated by Signal; exit 1" \
    HUP INT QUIT; \
trap "rm -rf /tmp/testproblems$$" EXIT; \
HPCM_SANDBOX_UNSECURE= \
    tclsh "$0" /tmp/testproblems$$ "$@"; exit $status

# Note we set HPCM_SANDBOX_UNSECURE above so we run
# hpcm_sandbox with the current uid and can access
# a local directory without a+x permissions on all its
# ancestors.

set tmp [lindex $argv 0]
set argv [lrange $argv 1 end]

set lib_directory "[file dirname $argv0]/../lib"
set judging_directory .
set log_disable yes
source $lib_directory/judging_common.tcl
catch {

set document "
testproblems \[-p N\] \[-keep|-|-make|-judge\] \\
             \[directory ...\]

    The command with no arguments is equivalent to

    	testproblems .

    The command with just the argument `-' is equivalent
    to
    	testproblems -keep .

    In general the default directory is `.' and the
    argument `-' is equivalent to `-keep'.

    The `-p N' arguments cause the run to be done N
    times in parallel, as a way of testing timing of on
    multiple CPU computers.  To do this copies of the
    directories are made inside /tmp, and testproblems
    is run on these copies.

    The output without the `-p' option is the output
    of the `make' executions followed by a summary in-
    cluding the diff listings of any files with unex-
    pected differences followed by a list containing the
    names of these files.  With the `-p' option the only
    output is for each run a list of the names of files
    with differences, if any, followed by timing infor-
    mation.

    To first approximation, this program runs:

		make clean
		make
		diff *.out *.test
		make clean

    in each directory.  It saves the diff outputs in
    addition to outputting them, and then plays back
    all relevant saved output for each directory at the
    end of this program's execution.  Errors made during
    the above run are also played back.  The -keep
    option suppresses the final `make clean'.

    More specifically, for each directory this program
    does the following.  First, it does a cd to the
    directory and extracts the name PROBLEM as the last
    component of the full name of the directory (obtain-
    ed by pwd).  Then it deletes any symbolic link named
    PROBLEM.in (but will NOT delete a regular file of
    that name), and runs

    		make clean

    Next this program uses any problem_make_files value
    in any PROBLEM.rc file in the directory to make or
    remake files in the directory.  If these files exist
    when this program is run, they are deleted and
    remade if they are obsolete.

    After making problem_make_files, files listed in
    any PROBLEM.rc file problem_link_files and problem_
    optional_link_files variables, are linked if the
    files do not exist.  Also problem_copy_files and
    problem_optional_copy_files variables are treated
    the same as problem_link_files and problem_optional_
    link_files (copying makes no sense in this context,
    and it therefore replaced by linking).

    The -judge option forces the links to be set as they
    would be in a judging directory.  This means that
    if a file exists but would link to another file if
    it did not exist, the file is deleted and linked to
    that other file.

    If a file listed in problem_link_files (or problem_
    copy_files) does not exist and cannot be linked
    because all possible targets do not exist, an error
    is announced.

    Unless the -keep or -make options are given, after
    finishing a directory all files listed in problem_
    make_files, problem_link_files, problem_optional_
    link_files, problem_copy_files, and problem_
    optional_copy_files are deleted.  Both the -make
    and -keep options cause these files to be kept
    instead of being deleted.  -make is weaker than
    -keep in that it keeps only these files, and not
    other files.

    Next the .in and .jin files in the directory are
    processed.  If PROBLEM.in was a link it was deleted
    as indicated above.  A set of path roots is chosen
    such that if f is in the set then either f.in or
    f.jin exists.  If either PROBLEM.in or PROBLEM.jin
    exists (after any PROBLEM.in link is deleted),
    only f == PROBLEM is used.  Otherwise all f for
    which either f.in or f.jin exist are used.

    Given f.jin but NOT f.in, the program runs

    	jfilter -v f.jin f.in >& f.in#
	ln -s f.in PROBLEM.in          # if f != PROBLEM
	make
	rm PROBLEM.in                  # if f != PROBLEM
	mv PROBLEM.out f.out           # if f != PROBLEM
	diff f.out f.test
	make clean
	rm f.out		       # if f != PROBLEM
	rm f.in f.in#

    The -keep option suppresses the final `make clean'
    and the final two `rm's.

    Given f.in but no f.jin, this program does the same
    thing as for f.jin, but jfilter is not run and f.in
    is not removed.

    Given both f.in and f.jin, then

    		jfilter -v f.jin f.in+ >& f.in#

    is executed and f.in and f.in+ are diff'ed, instead
    of making f.in from f.jin.  Also f.in is not
    removed.

    If after the above, Scoring_Filter does not exist,

	jfilter -v f.jin f.out f.jout >& f.jout#
	rm f.jout f.jout#

    is execute if f.jin exists.  But if Scoring_Filter
    does exist then

	Scoring_Filter f.in < f.out > f.fout
	jfilter -v f.jin f.fout f.jfout >& f.jfout#
	rm f.fout f.jfout f.jfout#

    is executed, with the jfilter execution and f.jfout
    removal suppressed if f.jin does not exist.

    If f.jout (f.fout, f.jfout) is made and f.jtest
    (f.ftest, f.jftest) exists, these two files are
    diff'ed, and if different the differences are
    reported.  If f.jout# or f.jfout# are made, they
    are similarly diff'ed with f.jin#.

    If errors occur while processing a directory, they
    are announced and processing of the directory is
    terminated without removing the files that would
    normally be removed when processing of the directory
    was finished.

    If a non-directory is given the program, or if a
    directory with no Makefile is given, the program
    merely notes this in the output."

# Process options.
#
# The `-SUB 1 filename' option is used when testproblems
# is called recursively for the `-p' option, and
# causes a list of names of differing files, followed by
# a report of errors running testproblems, if any,
# followed by timing information, to be APPENDED to the
# named file.  There is no other output. `-SUB 2 file-
# name' is similar but does not include the timing in-
# formation.  `-SUB 3 filename' is similar but does not
# include the error report or timing information and
# does have the other output associated with test-
# problems.  When called with -SUB 1, testproblems calls
# `time testproblems -SUB 2 ...' and appends the timing
# info to the named file.  When called with -SUB 2 test-
# problems calls `testproblems > /dev/null -SUB 3 ...'
# and if there is any returned text, which will be
# stderr output, appends that as the error report to the
# named file.  None of these options may be used with
# the -p option, and there is no error checking of
# the -SUB option arguments.
#
set parallel_runs 0
set keep 0
set make 0
set judge 0
set SUB 0
set SUB_filename ""
set myargv $argv
while { 1 } {
    switch -glob -- [lindex $myargv 0] {
    -doc* {
	puts $document
	exit 1
    }
    -keep { set keep 1 }
    -     { set keep 1 }
    -make { set make 1 }
    -judge { set judge 1 }
    -p {
	    set myargv [lrange $myargv 1 end]
	    set parallel_runs [lindex $myargv 0]
	    if { [catch \
	            { expr { $parallel_runs + 1 }}] \
	         || \
		 $parallel_runs <= 0 } {
	        puts "-p $parallel_runs is not legal"
		exit 2
	    }
    }
    -SUB {
	    set myargv [lrange $myargv 1 end]
	    set SUB [lindex $myargv 0]
	    set myargv [lrange $myargv 1 end]
	    set SUB_filename [lindex $myargv 0]
    }
    default break
    }
    set myargv [lrange $myargv 1 end]
}
if { [llength $myargv] == 0 } {
    set myargv .
}

set wd [pwd]

if { $parallel_runs > 0 } {

    file delete -force -- $tmp
    file mkdir $tmp
    grant_access $tmp x
    set i 1
    while { $i <= $parallel_runs } {
        file mkdir $tmp/test$i
	grant_access $tmp/test$i x
	foreach d $myargv {
	    exec cp -pr $d $tmp/test$i
	}
	incr i
    }
    if { $keep } { set k -keep } else { set k "" }
    set i 1
    set pids {}
    while { $i <= $parallel_runs } {
        cd $tmp/test$i
	eval lappend pids \
	     [eval exec $argv0 \
		   -SUB 1 $tmp/test$i.report \
		   $k $myargv &]
	incr i
    }

    cd $wd

    while { [llength $pids] > 0 } {
        set pid [lindex $pids 0]
	while { [process_found \
	             [display_process_tree $pid]] } {
	    sleep 2
	}
	set pids [lrange $pids 1 end]
    }

    puts "===================== Test of $parallel_runs\
          Parallel Runs"
    exec date >@ stdout
    exec hostname -f >@ stdout
    puts -nonewline "testproblems -p $parallel_runs $k"
    set j 0
    foreach d $myargv {
        if { $j % 5 == 0 } {
	    puts -nonewline " \\\n   "
	}
	puts -nonewline " $d"
	incr j
    }
    puts ""
    puts ""
    set i 1
    while { $i <= $parallel_runs } {
	puts "========== run $i:"
    	exec cat $tmp/test$i.report >@ stdout
	incr i
    }
    file delete -force -- $tmp
    exit 0

} elseif { $SUB == 1 } {
    if { $keep } { set k -keep } else { set k "" }
    # time writes its output to the standard error file
    catch { eval exec time -p $argv0 \
                 -SUB 2 $SUB_filename $k $myargv } \
	  tout
    set fd [open $SUB_filename a]
    puts $fd "\n$tout"
    close $fd
    exit 0
} elseif { $SUB == 2 } {
    if { $keep } { set k -keep } else { set k "" }
    set eout [eval exec $argv0 > /dev/null \
                   -SUB 3 $SUB_filename $k $myargv]
    if { $eout != "" } {
	set fd [open $SUB_filename a]
	puts $fd "\nTESTPROBLEMS ERROR OUTPUT\n\n$eout"
	close $fd
    }
    exit 0
} elseif { $SUB == 0 } {
    file delete -force -- $tmp
    set fd [open $tmp w]
}

set diff_files {}

proc putsfd { string } {
    global fd
    if { [info exists fd] } {
        puts $fd $string
    }
}

proc diff { file1 file2 } {
    global problem diff_files SUB
    puts "diff $file1 $file2"
    catch {
	set diffs [exec diff $file1 $file2]
	  } diffs
    if { [string trim $diffs] != "" } {
	if {    $file1 != "$problem.out" } {
	    set diffs \
		"========== $file1:\n$diffs"
	}
	putsfd $diffs
	puts $diffs
	lappend diff_files \
	        [list $problem $file1 $file2]
    }
}

# Read .rc file to possibly set any problem_make_files,
# and problem_{optional_,}{link,copy}_files global
# variables.
#
proc read_rc_file { file problem } {
    global PROBLEM EXTENSION OPTIONS \
	   problem_make_files \
	   problem_link_files \
	   problem_optional_link_files \
	   problem_copy_files \
	   problem_optional_copy_files

    set PROBLEM $problem
    set EXTENSION UNDEFINED
    set OPTIONS UNDEFINED
    source_file $file
}

# Test that a $problem.rc global variable value is a
# TCL list and complain if it is not.
#
proc check_list { variable_name } {

    global problem
    upvar $variable_name variable

    if { [catch { llength $variable }] } {
	error "$problem.rc\
	       $variable_name value is\
	       not a TCL\
	       list:\n    $variable"
    }
}

foreach x $myargv {

    if { ! [file isdirectory $x] } {
        puts "====================\
	      $x is not a directory"
	continue
    }

    if { ! [file exists $x/Makefile] } {
	puts "====================\
	      $x/Makefile does not exist"
	continue
    }

    putsfd "==================== $x:"
    puts -nonewline "===================="
    puts -nonewline "===================="
    puts -nonewline "===================="
    puts " $x:"

    cd $x
    if { [catch {

	set problem [file tail [pwd]]

	# Do initial clean.
	#
	set type none
	catch { set type [file type $problem.in] }
	if { $type == "link" } {
	    file delete $problem.in
	}
	exec make clean >&@ stdout

	# List of files to be deleted at end if -keep
	# option is absent.
	#
	set delete_at_end {}

	# Compute make_files = problem_make_files value
	# in any $problem.rc file.  Similarly compute
	# link_files = problem_{link,copy}_files and
	# optional_link_files = problem_optional_{link,
	# copy}_files.
	#
	set make_files {}
	set link_files {}
	set optional_link_files {}
	if { [file exists $problem.rc] } {

	    catch { unset problem_make_files }
	    catch { unset problem_link_files }
	    catch { unset problem_optional_link_files }
	    catch { unset problem_copy_files }
	    catch { unset problem_optional_copy_files }
	    read_rc_file $problem.rc $problem

	    if { [info exists problem_make_files] } {
		check_list problem_make_files
	        set make_files $problem_make_files
	    }
	    if { [info exists problem_link_files] } {
		check_list problem_link_files
		set link_files $problem_link_files
	    }
	    if { [info exists \
		       problem_optional_link_files] } {
		check_list \
		    problem_optional_link_files
		set optional_link_files \
		    $problem_optional_link_files
	    }
	    if { [info exists problem_copy_files] } {
		check_list problem_copy_files
		eval lappend link_files \
		     $problem_copy_files
	    }
	    if { [info exists \
		       problem_optional_copy_files] } {
		check_list \
		    problem_optional_copy_files
		eval lappend optional_copy_files \
		    $problem_optional_link_files
	    }
	}

	# If there are make_files, (re)make them.
	#
	if { [llength $make_files] > 0 } {

	    set made {}

	    foreach instruction $make_files {
		if { [catch { llength $instruction }] \
		   } {
		    error "$problem.rc\
		           problem_make_files\
			   instruction is not a TCL\
			   list:\n    $instruction"
		}
		set file [lindex $instruction 0]
		if { $file == "" } {
		    error "$problem.rc\
		           problem_make_files\
			   instruction has empty file\
			   name:\n    $instruction"
		}
		if { ! $make } {
		    lappend delete_at_end $file
		}
		lappend made $file
	    }

	    puts "(re)making $made"
	    execute_makes $make_files . \
	                  "problem_make_files value in\
			   $problem.rc"
	}

	# If there are link files or optional link
	# files, link them if they do not exist.  If
	# -judge and they would be linked to another
	# existing file, insist that they are linked
	# to this file, removing any existing file or
	# link and relinking if necessary.  If there
	# is no file and no way to link it, complain
	# if the file is on link_files list (and
	# therefore is not optional).  If not -make
	# option, put all files that might be linked
	# on the delete list.
	#
	set non_optional [llength $link_files]
	    # If >= 0 file is not optional
	foreach instruction \
	        [concat $link_files \
			$optional_link_files] {
	    incr non_optional -1

	    if { [catch { llength $instruction }] \
	       } {
	      error
	        "$problem.rc\
		 problem_{,optional_}{link,copy}_files\
		 instruction is not a TCL\
		 list:\n    $instruction"
	    }

	    set file [lindex $instruction 0]

	    if { $file == "" } {
	      error
	        "$problem.rc\
		 problem_{,optional_}{link,copy}_files\
		 instruction has empty file\
		 name:\n    $instruction"
	    }
	    if { ! $make } {
		lappend delete_at_end $file
	    }

	    if { [file exists $file] && ! $judge } \
	        continue

	    # Compute desired target; File cannot be its
	    # own target.
	    #
	    set target ""
	    foreach t [lrange $instruction 1 end] {
	        if { [file exists $t] } {
		    set target $t
		    break
		}
	    }

	    if {    $target == "" \
	         && ! [file exists $file] \
		 && $non_optional >= 0 } {
	      error
	        "$problem.rc problem_{link,copy}_files\
		 instruction requires that $file be\
		 linked but this is not\
		 possible:\n    $instruction"
	    }

	    # If no target and file exists or is
	    # optional, skip it.
	    #
	    if { $target == "" } continue

	    set old_target ""
	    catch { set old_target \
			[file readlink $file] }
	    if { $old_target == $target } continue;

	    # If old_target targets an existing file
	    # we must have -judge at this point.
	    # Similarly if $file exists we must have
	    # -judge at this point.
	    #
	    if {    $old_target != "" \
	         && ! [file exists $old_target] } {
		puts "deleting link of $file to\
		      $old_target as $old_target does\
		      not exist"
		file delete -force -- $file
	    } elseif { $old_target != "" } {
		puts "deleting link of $file to\
		      $old_target as per -judge"
		file delete -force -- $file
	    } elseif { [file exists $file] } {
		puts "deleting $file as per -judge"
		file delete -force -- $file
	    }

	    # At this point $file does not exist
	    # and is not a link.
	    #
	    puts "linking $file to $target"
	    file link -symbolic $file $target
	}

	# If problem.in or problem.jin exist, only
	# consider them.  Otherwise consider all
	# *.in and *.jin.  Note that if problem.in
	# was a link it was deleted above.
	#
	set done ""
	set inputs ""
	if {    [file exists $problem.in] \
	     || [file exists $problem.jin] } {
	    set inputs [list $problem.in $problem.jin]
	} else {
	    set inputs [glob *.in *.jin]
	    lappend done $problem
	}
	foreach file [lsort $inputs] {

	    set f [file rootname $file]
	    if { [lcontain $done $f] } continue
	    lappend done $f

	    if { $f != $problem } {
	        puts "========== $file:"
	    }
	    file delete -force -- $f.in#
	    if { ! [file exists $f.in] } {
	        puts "jfilter -v $f.jin $f.in >& $f.in#"
	        exec jfilter -v $f.jin $f.in >& $f.in#
		lappend delete_at_end $f.in $f.in#
	    } elseif { [file exists $f.jin] } {
	        file delete -force -- $f.in+
	        puts "jfilter -v $f.jin $f.in+\
		      >& $f.in#"
	        exec jfilter -v $f.jin $f.in+ >& $f.in#
		lappend delete_at_end $f.in+ $f.in#
		diff $f.in $f.in+
	    }
	    if { $f != $problem } {
	        exec ln -s $f.in $problem.in
	    }

	    set make_error \
	        [catch { exec make >@ stdout } \
		       mout]
	    if { $make_error } {
	        if { $f != $problem } {
		    putsfd "========== making $f.out:"
		}
		putsfd $mout
		puts $mout
	    }

	    if { $f != $problem } {
	        file rename $problem.out $f.out
		lappend delete_at_end $f.out
		file delete $problem.in
	    }

	    if { $make_error } continue

	    diff $f.out $f.test

	    if { [file exists Scoring_Filter] } {
		puts "Scoring_Filter $f.in\
		      < $f.out > $f.fout"
		exec Scoring_Filter $f.in \
		     < $f.out > $f.fout
		lappend delete_at_end $f.fout
		if { [file exists $f.ftest] } {
		    diff $f.fout $f.ftest
		}
		if { [file exists $f.jin] } {
		    file delete -force -- $f.jfout#
		    puts "jfilter -v\
			  $f.jin $f.fout $f.jfout\
			  >& $f.jfout#"
		    exec jfilter -v \
			 $f.jin $f.fout $f.jfout \
			 >& $f.jfout#
		    lappend delete_at_end \
		            $f.jfout $f.jfout#
		    if { [file exists $f.jftest] } {
			diff $f.jfout $f.jftest
		    }
		    diff $f.in# $f.jfout#
		}
	    } elseif { [file exists $f.jin] } {
		file delete -force -- $f.jout#
		puts "jfilter -v $f.jin $f.out\
			      $f.jout >& $f.jout#"
		exec jfilter -v $f.jin $f.out \
		     $f.jout >& $f.jout#
		lappend delete_at_end $f.jout $f.jout#
		if { [file exists $f.jtest] } {
		    diff $f.jout $f.jtest
		}
		diff $f.in# $f.jout#
	    }

	    if { ! $keep } {
	        exec make clean >&@ stdout
	    }
	}
	if { ! $keep && [llength $delete_at_end] > 0 } {
	    puts "rm -f $delete_at_end"
	    eval file delete -force -- $delete_at_end
	}
    } out] } {
        puts $out
	putsfd $out
    }
    cd $wd
}

if { $SUB == 3 } {
    set report [open $SUB_filename a]
} else {
    puts ""
    puts "******************** SUMMARY:"
    set report stdout
}


if { $SUB == 0 } {
    close $fd
    exec cat $tmp >@ stdout
    file delete $tmp
}

if { [llength $diff_files] > 0 } {
    puts $report "******************** \
          FILES THAT ARE DIFFERENT:"
    set p ""
    foreach item $diff_files {
        set problem [lindex $item 0]
        set file1 [lindex $item 1]
        set file2 [lindex $item 2]
	if { $p != $problem } {
	    puts $report "  in $problem:"
	    set p $problem
	}
	puts $report \
	     [format {%38s != %-38s} $file1 $file2]
    }
}
if { $SUB == 3 } {
    close $report
}

exit 0

} caught_output
caught_error
