#! /bin/sh
#
# Test problem code.
#
# File:		testproblems
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Fri Aug 20 18:53:42 EDT 2010
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2010/08/20 23:21:10 $
#   $RCSfile: testproblems,v $
#   $Revision: 1.36 $
#
# The next lines run tclsh \
trap "echo testproblems: Terminated by Signal; exit 1" \
    HUP INT QUIT; \
trap "rm -rf /tmp/testproblems$$" EXIT; \
HPCM_SANDBOX_UNSECURE= \
    tclsh "$0" /tmp/testproblems$$ "$@"; exit $status

# Note we set HPCM_SANDBOX_UNSECURE above so we run
# hpcm_sandbox with the current uid and can access
# a local directory without a+x permissions on all its
# ancestors.

set tmp [lindex $argv 0]
set argv [lrange $argv 1 end]

set lib_directory "[file dirname $argv0]/../lib"
set judging_directory .
set log_disable yes
source $lib_directory/judging_common.tcl
catch {

set document "
testproblems \[-p N\] \[-keep|-|-make|-judge\] \\
             \[directory ...\]

    The command with no arguments is equivalent to

    	testproblems .

    The command with just the argument `-' is equivalent
    to
    	testproblems -keep .

    In general the default directory is `.' and the
    argument `-' is equivalent to `-keep'.

    The `-p N' arguments cause the run to be done N
    times in parallel, as a way of testing timing of on
    multiple CPU computers.  To do this copies of the
    directories are made inside /tmp, and testproblems
    is run on these copies.

    The output without the `-p' option is the output
    of the `make' executions followed by a summary in-
    cluding the diff listings of any files with unex-
    pected differences followed by a list containing the
    names of these files.  With the `-p' option the only
    output is for each run a list of the names of files
    with differences, if any, followed by timing infor-
    mation.

    This program runs:		make clean
				make
				diff *.out *.test
				make clean

    in each directory.  It saves the diff outputs in
    addition to outputting them, and then plays back
    all the saved output at the end of this program's
    execution.  Errors made during the above run are
    also played back.  The -keep option suppresses the
    final `make clean'.

    Before doing the above, this program uses any
    problem_make_files value in any problem .rc file in
    a directory to make or remake files in the direc-
    tory.  If these files exist when this program is
    run, they are deleted and remade if they are
    obsolete.

    After making problem_make_files, files listed in
    problem_link_files, and problem_optional_link_files,
    are linked if they do not exist.  Also problem_copy_
    files and problem_optional_copy_files are treated
    the same as problem_link_files and problem_optional_
    line_files.

    The -judge option forces the links to be set as they
    would be in a judging directory.  This means that
    if a file exists but would link to another file if
    it did not exist, the file is deleted and linked to
    that other file.

    If a file listed in problem_link_files (or problem_
    copy_files) does not exist and cannot be linked
    because all possible targets do not exists, and
    error is announced.

    Unless the -keep or -make options are given, after
    finishing a directory all files listed in problem_
    make_files, problem_link_files, problem_optional_
    link_files, problem_copy_files, and problem_
    optional_copy_files are deleted.  Both the -make
    and -keep options causes these files to be kept
    instead of being deleted.  -make is weaker than
    -keep in that it keeps only these files, and not
    other files.

    Next the .in and .jin files in the directory are
    processed.  If problem.in is a link it is deleted.
    Then a set of path roots is choosen such that if f
    is in the set then either f.in or f.jin exists.  If
    either problem.in or problem.jin exists (after any
    linked problem.in is deleted), only f == problem is
    used.  Otherwise all f for which either f.in or
    f.jin exist are used.

    Given f.jin the program runs

    		make clean

    once followed by

    		jfilter -v f.jin f.in >& f.in#
		ln -s f.in problem.in
		make
		mv problem.out f.out
		diff f.out f.test
		make clean
		rm f.in f.in# problem.in

    The -keep option suppresses the final `make clean'
    and `rm'.

    Given f.in but no f.jin, this program does the same
    thing as for f.jin, but jfilter is not run and f.in
    is not removed.

    If a directory contains both f.in and f.jin, then

    		jfilter -v f.jin f.in+ >& f.in#

    is executed and f.in and f.in+ are diff'ed, instead
    of making f.in from f.jin.

    If after the above, Scoring_Filter does not exist,

	jfilter -v f.jin f.out f.jout >& f.jout#
	rm f.jout f.jout#

    is execute if f.jin exists.  But if Scoring_Filter
    does exist then

	Scoring_Filter f.in < f.out > f.fout
	jfilter -v f.jin f.fout f.jfout >& f.jfout#
	rm f.fout f.jfout f.jfout#

    is executed, with the jfilter execution and f.jfout
    removal suppressed if f.jin does not exist.

    If f.jout (f.fout, f.jfout) is made and f.jtest
    (f.ftest, f.jftest) exists, these two files are
    diff'ed, and if different the differences are
    reported.  If f.jout# or f.jfout# are made, they
    are similarly diff'ed with f.jin#.

    If a non-directory is given the program, or if a
    directory with no Makefile is given, the program
    merely notes this in the output."

# Process options.
#
# The `-SUB 1 filename' option is used when testproblems
# is called recursively for the `-p' option, and
# causes a list of names of differing files, followed by
# a report of errors running testproblems, if any,
# followed by timing information, to be APPENDED to the
# named file.  There is no other output. `-SUB 2 file-
# name' is similar but does not include the timing in-
# formation.  `-SUB 3 filename' is similar but does not
# include the error report or timing information and
# does have the other output associated with test-
# problems.  When called with -SUB 1, testproblems calls
# `time testproblems -SUB 2 ...' and appends the timing
# info to the named file.  When called with -SUB 2 test-
# problems calls `testproblems > /dev/null -SUB 3 ...'
# and if there is any returned text, which will be
# stderr output, appends that as the error report to the
# named file.  None of these options may be used with
# the -p option, and there is no error checking of
# the -SUB option arguments.
#
set parallel_runs 0
set keep 0
set make 0
set judge 0
set SUB 0
set SUB_filename ""
set myargv $argv
while { 1 } {
    switch -glob -- [lindex $myargv 0] {
    -doc* {
	puts $document
	exit 1
    }
    -keep { set keep 1 }
    -     { set keep 1 }
    -make { set make 1 }
    -judge { set judge 1 }
    -p {
	    set myargv [lrange $myargv 1 end]
	    set parallel_runs [lindex $myargv 0]
	    if { [catch \
	            { expr { $parallel_runs + 1 }}] \
	         || \
		 $parallel_runs <= 0 } {
	        puts "-p $parallel_runs is not legal"
		exit 2
	    }
    }
    -SUB {
	    set myargv [lrange $myargv 1 end]
	    set SUB [lindex $myargv 0]
	    set myargv [lrange $myargv 1 end]
	    set SUB_filename [lindex $myargv 0]
    }
    default break
    }
    set myargv [lrange $myargv 1 end]
}
if { [llength $myargv] == 0 } {
    set myargv .
}

# -keep forces -make
#
if { $keep } { set make 1 }

set wd [pwd]

if { $parallel_runs > 0 } {

    file delete -force -- $tmp
    file mkdir $tmp
    grant_access $tmp x
    set i 1
    while { $i <= $parallel_runs } {
        file mkdir $tmp/test$i
	grant_access $tmp/test$i x
	foreach d $myargv {
	    exec cp -pr $d $tmp/test$i
	}
	incr i
    }
    if { $keep } { set k -keep } else { set k "" }
    set i 1
    set pids {}
    while { $i <= $parallel_runs } {
        cd $tmp/test$i
	eval lappend pids \
	     [eval exec $argv0 \
		   -SUB 1 $tmp/test$i.report \
		   $k $myargv &]
	incr i
    }

    cd $wd

    while { [llength $pids] > 0 } {
        set pid [lindex $pids 0]
	while { [process_found \
	             [display_process_tree $pid]] } {
	    sleep 2
	}
	set pids [lrange $pids 1 end]
    }

    puts "===================== Test of $parallel_runs\
          Parallel Runs"
    exec date >@ stdout
    exec hostname -f >@ stdout
    puts -nonewline "testproblems -p $parallel_runs $k"
    set j 0
    foreach d $myargv {
        if { $j % 5 == 0 } {
	    puts -nonewline " \\\n   "
	}
	puts -nonewline " $d"
	incr j
    }
    puts ""
    puts ""
    set i 1
    while { $i <= $parallel_runs } {
	puts "========== run $i:"
    	exec cat $tmp/test$i.report >@ stdout
	incr i
    }
    file delete -force -- $tmp
    exit 0

} elseif { $SUB == 1 } {
    if { $keep } { set k -keep } else { set k "" }
    # time writes its output to the standard error file
    catch { eval exec time -p $argv0 \
                 -SUB 2 $SUB_filename $k $myargv } \
	  tout
    set fd [open $SUB_filename a]
    puts $fd "\n$tout"
    close $fd
    exit 0
} elseif { $SUB == 2 } {
    if { $keep } { set k -keep } else { set k "" }
    set eout [eval exec $argv0 > /dev/null \
                   -SUB 3 $SUB_filename $k $myargv]
    if { $eout != "" } {
	set fd [open $SUB_filename a]
	puts $fd "\nTESTPROBLEMS ERROR OUTPUT\n\n$eout"
	close $fd
    }
    exit 0
} elseif { $SUB == 0 } {
    file delete -force -- $tmp
    set fd [open $tmp w]
}

set diff_files {}

proc putsfd { string } {
    global fd
    if { [info exists fd] } {
        puts $fd $string
    }
}

proc diff { file1 file2 } {
    global problem diff_files SUB
    puts "diff $file1 $file2"
    catch {
	set diffs [exec diff $file1 $file2]
	  } diffs
    if { [string trim $diffs] != "" } {
	if {    $file1 != "$problem.out" } {
	    set diffs \
		"========== $file1:\n$diffs"
	}
	putsfd $diffs
	puts $diffs
	lappend diff_files \
	        [list $problem $file1 $file2]
    }
}

# Read .rc file to possibly set any problem_make_files,
# and problem_{optional_,}{link,copy}_files global
# variables.
#
proc read_rc_file { file problem } {
    global PROBLEM EXTENSION OPTIONS \
	   problem_make_files \
	   problem_link_files \
	   problem_optional_link_files \
	   problem_copy_files \
	   problem_optional_copy_files

    set PROBLEM $problem
    set EXTENSION UNDEFINED
    set OPTIONS UNDEFINED
    source_file $file
}

# Test that a $problem.rc global variable value is a
# TCL list and complain if it is not.
#
proc check_list { variable_name } {

    global problem
    upvar $variable_name variable

    if { [catch { llength $variable }] } {
	error "$problem.rc\
	       $variable_name value is\
	       not a TCL\
	       list:\n    $variable"
    }
}

foreach x $myargv {

    if { ! [file isdirectory $x] } {
        puts "====================\
	      $x is not a directory"
	continue
    }

    if { ! [file exists $x/Makefile] } {
	puts "====================\
	      $x/Makefile does not exist"
	continue
    }

    putsfd "==================== $x:"
    puts -nonewline "===================="
    puts -nonewline "===================="
    puts -nonewline "===================="
    puts " $x:"

    cd $x
    if { [catch {

	set problem [file tail [pwd]]

	# Do initial clean.
	#
	set type none
	catch { set type [file type $problem.in] }
	if { $type == "link" } {
	    file delete $problem.in
	}
	exec make clean >&@ stdout

	# List of files to be deleted at end.
	#
	set delete_at_end {}

	# Compute make_files = problem_make_files value
	# in any $problem.rc file.  Similarly compute
	# link_files = problem_{link,copy}_files and
	# optional_link_files = problem_optional_{link,
	# copy}_files.
	#
	set make_files {}
	set link_files {}
	set optional_link_files {}
	if { [file exists $problem.rc] } {

	    catch { unset problem_make_files }
	    catch { unset problem_link_files }
	    catch { unset problem_optional_link_files }
	    catch { unset problem_copy_files }
	    catch { unset problem_optional_copy_files }
	    read_rc_file $problem.rc $problem

	    if { [info exists problem_make_files] } {
		check_list problem_make_files
	        set make_files $problem_make_files
	    }
	    if { [info exists problem_link_files] } {
		check_list problem_link_files
		set link_files $problem_link_files
	    }
	    if { [info exists \
		       problem_optional_link_files] } {
		check_list \
		    problem_optional_link_files
		set optional_link_files \
		    $problem_optional_link_files
	    }
	    if { [info exists problem_copy_files] } {
		check_list problem_copy_files
		eval lappend link_files \
		     $problem_copy_files
	    }
	    if { [info exists \
		       problem_optional_copy_files] } {
		check_list \
		    problem_optional_copy_files
		eval lappend optional_copy_files \
		    $problem_optional_link_files
	    }
	}

	# If there are make_files, (re)make them.
	#
	if { [llength $make_files] > 0 } {

	    set made {}

	    foreach instruction $make_files {
		if { [catch { llength $instruction }] \
		   } {
		    error "$problem.rc\
		           problem_make_files\
			   instruction is not a TCL\
			   list:\n    $instruction"
		}
		set file [lindex $instruction 0]
		if { $file == "" } {
		    error "$problem.rc\
		           problem_make_files\
			   instruction has empty file\
			   name:\n    $instruction"
		}
		if { ! $make } {
		    lappend delete_at_end $file
		}
		lappend made $file
	    }

	    puts "(re)making $made"
	    execute_makes $make_files . \
	                  "problem_make_files value in\
			   $problem.rc"
	}

	# If there are link files or optional link
	# files, link them if they do not exist.  If
	# -judge and they would be linked to another
	# existing file, insist that they are linked
	# to this file, removing any existing file or
	# link and relinking if necessary.  If there
	# is no file and no way to link it, complain
	# if the file is on link_files list (and
	# therefore is not optional).  If not -make
	# option, put all files that might be linked
	# on the delete list.
	#
	set non_optional [llength $link_files]
	    # If >= 0 file is not optional
	foreach instruction \
	        [concat $link_files \
			$optional_link_files] {
	    incr non_optional -1

	    if { [catch { llength $instruction }] \
	       } {
	      error
	        "$problem.rc\
		 problem_{,optional_}{link,copy}_files\
		 instruction is not a TCL\
		 list:\n    $instruction"
	    }

	    set file [lindex $instruction 0]

	    if { $file == "" } {
	      error
	        "$problem.rc\
		 problem_{,optional_}{link,copy}_files\
		 instruction has empty file\
		 name:\n    $instruction"
	    }
	    if { ! $make } {
		lappend delete_at_end $file
	    }

	    if { [file exists $file] && ! $judge } \
	        continue

	    # Compute desired target; File cannot be its
	    # own target.
	    #
	    set target ""
	    foreach t [lrange $instruction 1 end] {
	        if { [file exists $t] } {
		    set target $t
		    break
		}
	    }

	    if {    $target == "" \
	         && ! [file exists $file] \
		 && $non_optional >= 0 } {
	      error
	        "$problem.rc problem_{link,copy}_files\
		 instruction requires that $file be\
		 linked but this is not\
		 possible:\n    $instruction"
	    }

	    # If no target and file exists or is
	    # optional, skip it.
	    #
	    if { $target == "" } continue

	    set old_target ""
	    catch { set old_target \
			[file readlink $file] }
	    if { $old_target == $target } continue;

	    # If old_target targets an existing file
	    # we must have -judge at this point.
	    # Similarly if $file exists we must have
	    # -judge at this point.
	    #
	    if {    $old_target != "" \
	         && ! [file exists $old_target] } {
		puts "deleting link of $file to\
		      $old_target as $old_target does\
		      not exist"
		file delete -force -- $file
	    } elseif { $old_target != "" } {
		puts "deleting link of $file to\
		      $old_target as per -judge"
		file delete -force -- $file
	    } elseif { [file exists $file] } {
		puts "deleting $file as per -judge"
		file delete -force -- $file
	    }

	    # At this point $file does not exist.
	    #
	    puts "linking $file to $target"
	    file link -symbolic $file $target
	}

	# If problem.in or problem.jin exist, only
	# consider them.  Otherwise consider all
	# *.in and *.jin.
	#
	set done ""
	set inputs ""
	if {    [file exists $problem.in] \
	     || [file exists $problem.jin] } {
	    set inputs [list $problem.in $problem.jin]
	} else {
	    set inputs [glob *.in *.jin]
	    lappend done $problem
	}
	foreach file [lsort $inputs] {

	    set f [file rootname $file]
	    if { [lcontain $done $f] } continue
	    lappend done $f

	    if { $f != $problem } {
	        puts "========== $file:"
	    }
	    file delete -force -- $f.in#
	    if { ! [file exists $f.in] } {
	        puts "jfilter -v $f.jin $f.in >& $f.in#"
	        exec jfilter -v $f.jin $f.in >& $f.in#
		lappend delete_at_end $f.in $f.in#
	    } elseif { [file exists $f.jin] } {
	        file delete -force -- $f.in+
	        puts "jfilter -v $f.jin $f.in+\
		      >& $f.in#"
	        exec jfilter -v $f.jin $f.in+ >& $f.in#
		lappend delete_at_end $f.in+ $f.in#
		diff $f.in $f.in+
	    }
	    if { $f != $problem } {
	        exec ln -s $f.in $problem.in
	    }

	    set make_error \
	        [catch { exec make >@ stdout } \
		       mout]
	    if { $make_error } {
	        if { $f != $problem } {
		    putsfd "========== making $f.out:"
		    file delete $problem.in
		}
		putsfd $mout
		puts $mout
		continue
	    }

	    if { $f != $problem } {
	        file rename $problem.out $f.out
		lappend delete_at_end $f.out
		file delete $problem.in
	    }
	    diff $f.out $f.test

	    if { [file exists Scoring_Filter] } {
		puts "Scoring_Filter $f.in\
		      < $f.out > $f.fout"
		exec Scoring_Filter $f.in \
		     < $f.out > $f.fout
		lappend delete_at_end $f.fout
		if { [file exists $f.ftest] } {
		    diff $f.fout $f.ftest
		}
		if { [file exists $f.jin] } {
		    file delete -force -- $f.jfout#
		    puts "jfilter -v\
			  $f.jin $f.fout $f.jfout\
			  >& $f.jfout#"
		    exec jfilter -v \
			 $f.jin $f.fout $f.jfout \
			 >& $f.jfout#
		    lappend delete_at_end \
		            $f.jfout $f.jfout#
		    if { [file exists $f.jftest] } {
			diff $f.jfout $f.jftest
		    }
		    diff $f.in# $f.jfout#
		}
	    } elseif { [file exists $f.jin] } {
		file delete -force -- $f.jout#
		puts "jfilter -v $f.jin $f.out\
			      $f.jout >& $f.jout#"
		exec jfilter -v $f.jin $f.out \
		     $f.jout >& $f.jout#
		lappend delete_at_end $f.jout $f.jout#
		if { [file exists $f.jtest] } {
		    diff $f.jout $f.jtest
		}
		diff $f.in# $f.jout#
	    }

	    if { ! $keep } {
	        exec make clean >&@ stdout
	    }
	}
	if { ! $keep && [llength $delete_at_end] > 0 } {
	    puts "rm -f $delete_at_end"
	    eval file delete -force -- $delete_at_end
	}
    } out] } {
        puts $out
	putsfd $out
    }
    cd $wd
}

if { $SUB == 3 } {
    set report [open $SUB_filename a]
} else {
    puts ""
    puts "******************** SUMMARY:"
    set report stdout
}


if { $SUB == 0 } {
    close $fd
    exec cat $tmp >@ stdout
    file delete $tmp
}

if { [llength $diff_files] > 0 } {
    puts $report "******************** \
          FILES THAT ARE DIFFERENT:"
    set p ""
    foreach item $diff_files {
        set problem [lindex $item 0]
        set file1 [lindex $item 1]
        set file2 [lindex $item 2]
	if { $p != $problem } {
	    puts $report "  in $problem:"
	    set p $problem
	}
	puts $report \
	     [format {%38s != %-38s} $file1 $file2]
    }
}
if { $SUB == 3 } {
    close $report
}

exit 0

} caught_output
caught_error
