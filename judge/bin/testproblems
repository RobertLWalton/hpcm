#! /bin/sh
#
# Test problem code.
#
# File:		testproblems
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Wed Oct  5 07:07:53 EDT 2005
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2005/10/05 11:36:16 $
#   $RCSfile: testproblems,v $
#   $Revision: 1.15 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

set document "
testproblems \[-keep | -filter\] directory ...
testproblems

    The command with no arguments is equivalent to

    	testproblems -keep -filter .

    This program runs:

    		make clean
		make
		diff *.out *.test
		make clean

    in each directory.  It saves the diff outputs in
    addition to outputting them, and then plays back
    all the saved output at the end of this program's
    execution.  Errors made during the above run are
    also played back.

    The -keep option suppresses the final `make clean'.

    If a directory contains .jin files, then for every
    f.jin file the program runs

    		jfilter f.jin f.in
		ln -s f.in problem.in
		make clean
		make
		mv problem.out f.out
		diff f.out f.test
		make clean
		rm f.in problem.in

    The -keep option suppresses the the final `rm'.

    If a directory contains multiple .in files, the
    same thing is done as for .jin files, but jfilter
    is not run and f.in is not removed.  If a directory
    contains just problem.jin, the same thing is done
    without the linking of problem.in or the moving
    of problem.out (here f = problem).

    If the -filter option is present, then after making
    an f.out file and diff'ing it with f.test,

    		make Scoring_Filter

    is executed if Scoring_Filter does not exist.  If
    this has errors, they are ignored.  If after this
    Scoring_Filter does not exist,

    		jfilter f.jin f.out f.jout
		rm f.jout

    is execute if f.jin exists.  But if Scoring_Filter
    does exist then

    		Scoring_Filter f.in < f.out > f.fout
		jfilter f.jin f.fout f.jfout
		rm f.fout f.jfout

    is executed, with the jfilter execution and f.jfout
    removal suppressed if f.jin does not exist.

    If f.jout (f.fout, f.jfout) is made and f.jtest
    (f.ftest, f.jftest) exists, these two files are
    diff'ed, and if different the differences are
    reported.

    All `rm' commands are suppressed by -keep.
    
    If a non-directory is given the program, or if a
    directory with no Makefile is given, the program
    merely notes this in the output."

# Process options.
#
if { [llength $argv] == 0 } {
    set argv {-keep -filter .}
}
set keep 0
set filter 0
while { 1 } {
    switch -glob -- [lindex $argv 0] {
    -doc* {
	puts $document
	exit 1
    }
    -filter { set filter 1 }
    -keep { set keep 1 }
    default break
    }
    set argv [lrange $argv 1 end]
}

set tmp /tmp/testproblems[pid]
file delete -force -- $tmp

# Arrange to always delete $tmp at end.
#
signal error {HUP INT QUIT TERM}

catch {

set wd [pwd]
set fd [open $tmp w]

proc diff { file1 file2 } {
    global problem fd
    puts "diff $file1 $file2"
    catch {
	set diffs [exec diff $file1 $file2]
	  } diffs
    if { [string trim $diffs] != "" } {
	if {    $file1 != "$problem.out" } {
	    set diffs \
		"========== $file1:\n$diffs"
	}
	puts -nonewline $fd $diffs
	puts -nonewline $diffs
    }
}

foreach x $argv {

    if { ! [file isdirectory $x] } {
        puts "====================\
	      $x is not a directory"
	continue
    }

    if { ! [file exists $x/Makefile] } {
	puts "====================\
	      $x/Makefile does not exist"
	continue
    }

    puts $fd "==================== $x:"
    puts -nonewline "===================="
    puts -nonewline "===================="
    puts -nonewline "===================="
    puts " $x:"

    cd $x
    if { [catch {
	set problem [file tail [pwd]]
	set type none
	catch { set type [file type $problem.in] }
	if { $type == "link" } {
	    file delete $problem.in
	}
	# Make sure that "problem" is the first
	# value of f if it is a value of f.
	#
	set done ""
	set made ""
	foreach file [glob $problem.in $problem.jin \
			   *.in *.jin] {
	    set f [file rootname $file]
	    if { [lcontain $f $done] } continue
	    lappend done $f
	    if { $f != $problem } {
	        puts "========== $file:"
	    }
	    exec make clean >@ stdout 2>@ stderr
	    if { ! [file exists $f.in] } {
	        puts "jfilter $f.jin $f.in"
	        exec jfilter $f.jin $f.in \
		     >@ stdout
		lappend made $f.in
	    }
	    if { $f != $problem } {
	        exec ln -s $f.in $problem.in
	    }
	    set make_error \
	        [catch { exec make >@ stdout } \
		       mout]
	    if { $make_error } {
	        if { $f != $problem } {
		    puts $fd "========== making $f.out:"
		    file delete $problem.in
		}
		puts -nonewline $fd $mout
		puts -nonewline $mout
		continue
	    }
	    if { $f != $problem } {
	        file rename $problem.out $f.out
		lappend made $f.out
		file delete $problem.in
	    }
	    diff $f.out $f.test
	    if { $filter } {
	        if { ! [file exists Scoring_Filter] } {
		    catch { exec make Scoring_Filter \
		                 >@ stdout }
		    if { [file exists Scoring_Filter] \
		       } {
		        lappend made Scoring_Filter
		    }
		}
		if { [file exists Scoring_Filter] } {
		    puts "Scoring_Filter $f.in\
		          < $f.out > $f.fout"
		    exec Scoring_Filter $f.in \
		         < $f.out > $f.fout
		    lappend made $f.fout
		    if { [file exists $f.ftest] } {
		        diff $f.fout $f.ftest
		    }
		    if { [file exists $f.jin] } {
		        puts "jfilter\
			      $f.jin $f.fout $f.jfout"
		        exec jfilter \
			     $f.jin $f.fout $f.jfout \
			     >@ stdout
			lappend made $f.jfout
			if { [file exists $f.jftest] } {
			    diff $f.jfout $f.jftest
			}
		    }
		} elseif { [file exists $f.jin] } {
		    puts "jfilter $f.jin $f.out $f.jout"
		    exec jfilter $f.jin $f.out $f.jout \
			 >@ stdout
		    lappend made $f.jout
		    if { [file exists $f.jtest] } {
			diff $f.jout $f.jtest
		    }
		}
	    }
	    if { ! $keep } {
	        exec make clean >@ stdout 2>@ stderr
	    }
	}
	if { ! $keep && [llength $made] > 0 } {
	    puts "rm $made"
	    eval file delete -force -- $made
	}
    } out] } {
        puts $out
	puts $fd $out
    }
    cd $wd
}
close $fd

puts ""
puts "******************** SUMMARY:"
exec cat $tmp >@ stdout
file delete $tmp
exit 0

} out
file delete $tmp
puts $out
exit 1
