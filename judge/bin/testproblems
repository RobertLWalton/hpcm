#! /bin/sh
#
# Test problem code.
#
# File:		testproblems
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Thu May 30 01:03:50 EDT 2013
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2013/05/30 05:07:29 $
#   $RCSfile: testproblems,v $
#   $Revision: 1.50 $
#
# The next lines run tclsh \
trap "echo testproblems: Terminated by Signal; exit 1" \
    HUP INT QUIT; \
trap "rm -rf /tmp/testproblems$$" EXIT; \
HPCM_SANDBOX_UNSECURE=yes \
    tclsh "$0" /tmp/testproblems$$ "$@"; exit $status

# Note we set HPCM_SANDBOX_UNSECURE above so we run
# hpcm_sandbox with the current uid and can access
# a local directory without a+x permissions on all its
# ancestors.

set tmp [lindex $argv 0]
set argv [lrange $argv 1 end]

set lib_directory "[file dirname $argv0]/../lib"
set judging_directory .
set log_disable yes
source $lib_directory/judging_common.tcl
catch {

set document "
testproblems \[-p N] \[-keep|-|-contestant|-q] \\
             \[-ext \".EXT ...\"] \[directory ...]

    The command with no arguments is equivalent to

    	testproblems .

    The command with just the argument `-' is equivalent
    to
    	testproblems -keep .

    In general the default directory is `.' and the
    argument `-' is equivalent to `-keep'.

    The `-p N' arguments cause the run to be done N
    times in parallel, as a way of testing timing of on
    multiple CPU computers.  To do this copies of the
    directories are made inside /tmp, and testproblems
    is run on these copies.

    The output without the `-p' option is the output
    of the `make' executions followed by a summary in-
    cluding the diff listings of any files with unex-
    pected differences followed by a list containing the
    names of these files.  With the `-p' option the only
    output is for each run a list of the names of files
    with differences, if any, followed by timing infor-
    mation.

    To first approximation, this program tests a solu-
    tion in file PROBLEMXXX.EXT by making a subdirectory
    named test_PROBLEMXXX_EXT, linking appropriate files
    into it, and running:

		make
		diff *.out *.test

    in the subdirectory.  After a test_PROBLEMXXX_EXT
    subdirectory is completely processed, it is deleted,
    unless the -keep option is used.  The diff outputs
    are both saved and outputted, and all relevant saved
    output for each directory is played back at the end
    of this program's execution.  Errors made during the
    above run are also played back.

    More specifically, for each directory this program
    does the following.  First, it does a cd to the
    directory and extracts the name PROBLEM from the
    `P = PROBLEM' line of the directory's Makefile.
    Then it deletes any symbolic link named PROBLEM.in
    (but will NOT delete a regular file of that name)
    and runs

    		make clean

    Then the set of input names is formed.  Initially
    this is the set of names N such that N.in or N.jin
    exist.  Then if the variable problem_input_names is
    defined in PROBLEM.rc, names not listed in that
    variable's value are removed from the set.  Then if
    the set has a name other than PROBLEM, the name
    PROBLEM is removed from the set if it is in the
    set.

    Next this program uses any problem_make_files value
    in any PROBLEM.rc file in the directory to make or
    remake files in the directory.  If these files exist
    when this program is run, they are deleted and
    remade if they are obsolete.

    After making problem_make_files, this program
    identifies the solution files PROBLEM*.EXT that are
    to be tested.  Here .EXT is restricted to values
    in a list given by the -ext argument if that is
    given, or the problem_allowed_extensions variable
    in the PROBLEM.rc file, if that is given, or

        $allowed_extensions

    otherwise.  For each file PROBLEMSXXX.EXT that
    exists for some .EXT in the allowed extensions list,
    the subdirectory test_PROBLEMSXXX_EXT is made, files
    files are linked into it, and in that directory
    PROBLEMXXX.EXT is tested.

    Files are linked from the problem directory to its
    test_PROBLEMXXX_EXT subdirectory using link instruc-
    tions of the form:

    	{ F F1 F2 F3 ... }

    which mean that the file name F in the subdirectory
    is to be linked to F1 in the problem directory, if
    that exists, else F2 in the problem directory, etc.
    An instruction of the form `F' is equivalent to
    `{F F}'.  A link instruction may be required,
    meaning that if F cannot be linked to anything sub-
    directory processing terminates with an error, or
    optional, meaning the link instruction can fail
    without error.

    The link instructions executed are

        * { PROBLEM.EXT PROBLEMXXX.EXT }     \[required]

    	* Those listed in problem_{link,copy}_files
	  \[required] or problem_optional_{link,copy}_
	  files \[optional].  Note the ..._copy_files
	  are linked and not copied, because the only
	  reason for copying them is so the sandbox can
	  access them, but this is not an issue for this
	  program disables sandboxing.

	* { Makefile Makefile_EXT Makefile } \[required]
	  Scoring_Filter                     \[optional]

	* For each N in the set of input names (all
	  optional).  Note the *_EXT forms which allow
	  for language variants, particularly for .test
	  files for which numeric accuracy is language
	  dependent.

	      N.in
	      N.jin
	      N.test N.out N.test_EXT N.test
	      N.jtest N.jout N.jtest_EXT N.jtest
	      N.ftest N.fout N.ftest_EXT N.ftest
	      N.jftest N.jfout N.jftest_EXT N.jftest

    The -contestant option takes link_instructions

    		{ F F1 F2 ... }
    
    in the PROBLEM.rc file and modifies them to

    		{ F F F1 F2 ...}

    so if F exists in problem directory it will be
    linked to.  An example of using this is when the
    files F and judges_F are made and PROBLEM.rc con-
    tains the link instruction

    		{ F judges_F }

    so the contestant sees the made F and the judge
    sees the made judges_F renamed as F.  F is likely
    to be a monitor program that executes the contest-
    ant's submission as a subprocess and feeds it
    input while checking its output.

    After linking files into the test_PROBLEMXXX_EXT
    subdirectory, the following are run in the subdirec-
    tory for each input name N:
    
      * If N.jin exists but N.in does not:

	    jfilter -v N.jin N.in >& N.in#

      * If both N.jin and N.in exist:

	    jfilter -v N.jin N.in+ >& N.in#
	    diff N.in N.in+

      * Always:

	    rm PROBLEM.in              # if N != PROBLEM
	    ln -s N.in PROBLEM.in      # if N != PROBLEM
	    make
	    mv PROBLEM.out N.out       # if N != PROBLEM
	    diff N.out N.test

      * If N.jin exists but Scoring_Filter does not
        exist:

	    jfilter -v N.jin N.out N.jout >& N.jout#
	    diff N.jout N.jtest
	    diff N.jin# N.jout#

      * If Scoring_Filter exists:

	    Scoring_Filter N.in < N.out > N.fout
	    diff N.fout N.ftest

      * If N.jin and Scoring_Filter exist:

	    jfilter -v N.jin N.fout N.jfout >& N.jfout#
	    diff N.jfout N.jftest
	    diff N.jin# N.jfout#

    If errors occur while processing a directory, they
    are announced and processing of the directory is
    terminated.

    Unless the -keep option is given, after finishing a
    directory `make clean' is executed in the directory,
    all files made by problem_make_files are deleted,
    and all test_PROBLEMXXX.EXT subdirectories of the
    directory are deleted.

    If a non-directory is given the program, or if a
    directory with no Makefile is given, the program
    merely notes this in the output.
    
    The -q or quiet option suppresses just the non-
    error output from `make PROBLEM.out' commands."

# Process options.
#
# The `-SUB 1 filename' option is used when testproblems
# is called recursively for the `-p' option, and
# causes a list of names of differing files, followed by
# a report of errors running testproblems, if any,
# followed by timing information, to be APPENDED to the
# named file.  There is no other output. `-SUB 2 file-
# name' is similar but does not include the timing in-
# formation.  `-SUB 3 filename' is similar but does not
# include the error report or timing information and
# does have the other output associated with test-
# problems.  When called with -SUB 1, testproblems calls
# `time testproblems -SUB 2 ...' and appends the timing
# info to the named file.  When called with -SUB 2 test-
# problems calls `testproblems > /dev/null -SUB 3 ...'
# and if there is any returned text, which will be
# stderr output, appends that as the error report to the
# named file.  None of these options may be used with
# the -p option, and there is no error checking of
# the -SUB option arguments.
#
set parallel_runs 0
set keep 0
set contestant 0
set quiet 0
set stdoutq stdout
    # reset to file descriptor sending to /dev/null
    # if quiet
set SUB 0
set SUB_filename ""
set myargv $argv
while { 1 } {
    switch -glob -- [lindex $myargv 0] {
    -doc* {
	puts $document
	exit 1
    }
    -keep { set keep 1 }
    -     { set keep 1 }
    -contestant { set contestant 1 }
    -q {
           set quiet 1
	   set stdoutq [open /dev/null w]
    }
    -ext {
	    set myargv [lrange $myargv 1 end]
	    set allowed_extensions [lindex $myargv 0]
	    if { [catch { llength \
	                    $allowed_extensions }] } {
	        error "-ext $allowed_extensions\
		            is not legal"
	    }
    }
    -p {
	    set myargv [lrange $myargv 1 end]
	    set parallel_runs [lindex $myargv 0]
	    if { [catch \
	            { expr { $parallel_runs + 1 }}] \
	         || \
		 $parallel_runs <= 0 } {
	        puts "-p $parallel_runs is not legal"
		exit 2
	    }
    }
    -SUB {
	    set myargv [lrange $myargv 1 end]
	    set SUB [lindex $myargv 0]
	    set myargv [lrange $myargv 1 end]
	    set SUB_filename [lindex $myargv 0]
    }
    default break
    }
    set myargv [lrange $myargv 1 end]
}
if { [llength $myargv] == 0 } {
    set myargv .
}

set wd [pwd]

if { $parallel_runs > 0 } {

    file delete -force -- $tmp
    file mkdir $tmp
    grant_access $tmp x
    set i 1
    while { $i <= $parallel_runs } {
        file mkdir $tmp/test$i
	grant_access $tmp/test$i x
	foreach d $myargv {
	    exec cp -pr $d $tmp/test$i
	}
	incr i
    }
    if { $keep } { set k -keep } else { set k "" }
    set i 1
    set pids {}
    while { $i <= $parallel_runs } {
        cd $tmp/test$i
	lappend_lists pids \
	     [eval exec $argv0 \
		   -SUB 1 $tmp/test$i.report \
		   $k $myargv &]
	incr i
    }

    cd $wd

    while { [llength $pids] > 0 } {
        set pid [lindex $pids 0]
	while { [process_found \
	             [display_process_tree $pid]] } {
	    sleep 2
	}
	set pids [lrange $pids 1 end]
    }

    puts "===================== Test of $parallel_runs\
          Parallel Runs"
    exec date >@ stdout
    exec hostname >@ stdout
    puts -nonewline "testproblems -p $parallel_runs $k"
    set j 0
    foreach d $myargv {
        if { $j % 5 == 0 } {
	    puts -nonewline " \\\n   "
	}
	puts -nonewline " $d"
	incr j
    }
    puts ""
    puts ""
    set i 1
    while { $i <= $parallel_runs } {
	puts "========== run $i:"
    	exec cat $tmp/test$i.report >@ stdout
	incr i
    }
    file delete -force -- $tmp
    exit 0

} elseif { $SUB == 1 } {
    if { $keep } { set k -keep } else { set k "" }
    # time writes its output to the standard error file
    catch { eval exec time -p $argv0 \
                 -SUB 2 $SUB_filename $k $myargv } \
	  tout
    set fd [open $SUB_filename a]
    puts $fd "\n$tout"
    close $fd
    exit 0
} elseif { $SUB == 2 } {
    if { $keep } { set k -keep } else { set k "" }
    set eout [eval exec $argv0 > /dev/null \
                   -SUB 3 $SUB_filename $k $myargv]
    if { $eout != "" } {
	set fd [open $SUB_filename a]
	puts $fd "\nTESTPROBLEMS ERROR OUTPUT\n\n$eout"
	close $fd
    }
    exit 0
} elseif { $SUB == 0 } {
    # SUB == 0 means we can ignore -p option
    #
    file delete -force -- $tmp
    set fd [open $tmp w]
}

# Summary report is accumulated in $tmp.  fd is file
# descriptor of report, and exists only if report is
# being output.

# List of names of files that differ.  List item has the
# format:
#		{ location file1 file2 }
# if
#		diff file1 file2
#
# working in the `location' directory produced non-empty
# output.
#
set diff_files {}

# Put into report
#
proc putsfd { string } {
    global fd
    if { [info exists fd] } {
        puts $fd $string
    }
}

# Put to output if not quiet
#
proc putsq { args } {
    global quiet
    if { ! $quiet } {
        eval puts $args
    }
}

# Diff two files and update reports.
#
proc diff { subdir file1 file2 } {
    global directory problem diff_files
    putsq "diff $file1 $file2"
    catch {
	set diffs [exec diff $file1 $file2]
	  } diffs
    if { [string trim $diffs] != "" } {
	if {    $file1 != "$problem.out" } {
	    set diffs \
		"  ==== $subdir\
		 ==== diff $file1 $file2:\n$diffs"
	}
	putsfd $diffs
	puts $diffs
	lappend diff_files \
	        [list "$directory/$subdir" \
		      $file1 $file2]
    }
}

# Read .rc file to possibly set any problem_make_files,
# problem_{optional_,}{link,copy}_files, and problem_
# input_names global variables.  Unset these if they
# are not set in the .rc file.
#
proc read_rc_file { file problem } {
    global PROBLEM EXTENSION OPTIONS \
	   problem_make_files \
	   problem_link_files \
	   problem_optional_link_files \
	   problem_copy_files \
	   problem_optional_copy_files \
	   problem_input_names

    set PROBLEM $problem
    set EXTENSION UNDEFINED
    set OPTIONS UNDEFINED
    catch { unset problem_make_files }
    catch { unset problem_link_files }
    catch { unset problem_optional_link_files }
    catch { unset problem_copy_files }
    catch { unset problem_optional_copy_files }
    catch { unset problem_input_names }
    source_file $file
}

# Test that a $problem.rc global variable value is a
# TCL list and complain if it is not.
#
proc check_list { variable_name } {

    global problem
    upvar $variable_name variable

    if { [catch { llength $variable }] } {
	error "$problem.rc\
	       $variable_name value is\
	       not a TCL\
	       list:\n    $variable"
    }
}

# Process a link instruction.  Return 1 on success and
# 0 on failure.  Targets are in current directory and
# links are in given subdirectory.
#
proc execute_link { subdir instruction } {

    global problem

    if { [catch { llength $instruction }] \
       } {
      error \
	"$problem.rc\
	 problem_{,optional_}{link,copy}_files\
	 instruction is not a TCL\
	 list:\n    $instruction"
    }

    set file [lindex $instruction 0]

    if { $file == "" } {
      error \
	"$problem.rc\
	 problem_{,optional_}{link,copy}_files\
	 instruction has empty file\
	 name:\n    $instruction"
    }

    # Compute desired target; File cannot be its
    # own target unless instruction has only one
    # element.
    #
    if { [llength $instruction] == 1 } {
	if { ! [file exists $file] } {
	    return 0
	}
        set target $file
    } else {
	set target ""
	foreach t [lrange $instruction 1 end] {
	    if { [file exists $t] } {
		set target $t
		break
	    }
	}
	if { $target == "" } {
	    return 0
	}
    }

    putsq "linking $subdir/$file to ../$target"
    # file link -symbolic $subdir/$file ../$target
    # On some linux systems `file link' fails when
    # when ../$target does not exist relative to
    # current directory.
    link_file ../$target $subdir/$file

    return 1
}


set mregexp \
    "^\[ \t]*P\[ \t]*=\[ \t]*(\[^ \t]\[^ \t]*)\[ \t]*\$"
    # for regexp
set mgrepexp \
    "^\[ \t]*P\[ \t]*=\[ \t]*\[^ \t]\[^ \t]*\[ \t]*\$"
    # for grep

foreach directory $myargv {

    cd $wd

    if { ! [file isdirectory $directory] } {
        puts "====================\
	      $directory is not a directory"
	continue
    }

    if { ! [file exists $directory/Makefile] } {
	puts "====================\
	      $directory/Makefile does not exist"
	continue
    }

    putsfd "==================== $directory:"
    puts -nonewline "===================="
    puts -nonewline "===================="
    puts -nonewline "===================="
    puts " $directory:"

    cd $directory
    set dir [pwd]

    if { [catch {

	# Extract problem from `P = problem' line in
	# Makefile
	#
	set pline ""
	if { [catch { set pline \
	                  [exec grep $mgrepexp Makefile]
		    }]\
	    || \
	    ! [regexp $mregexp $pline \
	               forget problem] } {
	    error "CANNOT find P = ... line in Makefile"
	}

	# Make list of PROBLEM*.EXT values (solutions).
	#
	set solutions {}
	set allowed {}
	foreach pext $allowed_extensions {
	    if { ! [regexp "^\\.(.*)\$" $pext \
	                   forget EXT] } {
	        error "bad allowed_extension `$pext'"
	    }

	    lappend allowed $EXT
	    lappend_lists solutions \
	                  [glob -nocomplain \
			        "$problem*.$EXT"]
	}
	if { [llength $solutions] == 0 } {
	    set exts [join $allowed ,]
	    error "no $problem*.{$exts} solutions"
	}

	# Do initial clean.
	#
	set type none
	catch { set type [file type $problem.in] }
	if { $type == "link" } {
	    file delete $problem.in
	}
	putsq "make clean"
	if { [catch { exec make clean >@ $stdoutq } \
	            mout] } {
	    puts $mout
	    putsfd $mout
	    continue
	}

	# List of files and directories to be deleted
	# at end if -keep option is absent.
	#
	set delete_at_end {}

	# Compute list of names N for which either N.in
	# or N.jin exist.
	#
	set input_names {}
	foreach file [glob *.in *.jin] {
	    set N [file rootname $file]
	    if { [lcontain $input_names $N] } continue
	    lappend input_names $N
	}

	# Compute make_files = problem_make_files value
	# in any $problem.rc file.  Similarly compute
	# link_files = problem_{link,copy}_files and
	# optional_link_files = problem_optional_{link,
	# copy}_files.
	#
	# If problem_input_names has a $problem.rc list
	# value, remove from input_files names not in
	# this list value. 
	#
	set make_files {}
	set link_files {}
	set optional_link_files {}
	if { [file exists $problem.rc] } {

	    read_rc_file $problem.rc $problem

	    if { [info exists problem_make_files] } {
		check_list problem_make_files
	        set make_files $problem_make_files
	    }
	    if { [info exists problem_link_files] } {
		check_list problem_link_files
		set link_files $problem_link_files
	    }
	    if { [info exists \
		       problem_optional_link_files] } {
		check_list \
		    problem_optional_link_files
		set optional_link_files \
		    $problem_optional_link_files
	    }
	    if { [info exists problem_copy_files] } {
		check_list problem_copy_files
		lappend_lists link_files \
		     $problem_copy_files
	    }
	    if { [info exists \
		       problem_optional_copy_files] } {
		check_list \
		    problem_optional_copy_files
		lappend_lists optional_copy_files \
		    $problem_optional_link_files
	    }
	    if { [info exists problem_input_names] } {
		check_list problem_input_names
		set input_names {}
		foreach file $problem_input_names {
		    if {    [file exists $file.in] \
		         || [file exists $file.jin] } {
		        lappend input_names $file
		    }
		}
	    }
	}

	# If input_names contains $problem and something
	# else, remove $problem.
	#
	if {    [llength $input_names] > 1 \
	     && [lcontain $input_names $problem] } {
	   set i [lsearch -exact $input_names $problem]
	   set input_names [lreplace $input_names $i $i]
	}

	# If -contestant convert link instructions
	# in link_files and optional_link_files from
	# { F F1 ... } to { F F F1 ... }.
	#
	if { $contestant } {

	    set old_link_files $link_files
	    set link_files {}
	    foreach inst $old_link_files {
	        lappend link_files \
		        [lreplace $inst 0 -1 \
			          [lindex $inst 0 ]]
	    }
	    set old_optional_link_files \
	        $optional_link_files
	    set optional_link_files {}
	    foreach inst $old_optional_link_files {
	        lappend optional_link_files \
		        [lreplace $inst 0 -1 \
			          [lindex $inst 0 ]]
	    }
	}

	# Append stuff to optional_link_files.
	#
	# We CANNOT append *_EXT stuff here because
	# EXT is not yet determined.
	#
	lappend optional_link_files \
		[list Scoring_Filter]
	foreach N $input_names {
	    lappend optional_link_files [list $N.in]
	    lappend optional_link_files [list $N.jin]
	}

	# If there are make_files, (re)make them.
	#
	if { [llength $make_files] > 0 } {

	    set made {}

	    foreach instruction $make_files {
		if { [catch { llength $instruction }] \
		   } {
		    error "$problem.rc\
		           problem_make_files\
			   instruction is not a TCL\
			   list:\n    $instruction"
		}
		set file [lindex $instruction 0]
		if { $file == "" } {
		    error "$problem.rc\
		           problem_make_files\
			   instruction has empty file\
			   name:\n    $instruction"
		}
		lappend delete_at_end $file
		lappend made $file
	    }

	    putsq "(re)making $made"
	    execute_makes $make_files . \
	                  "problem_make_files value in\
			   $directory/$problem.rc"
	}

	# Process each value of PROBLEMXXX.EXT
	#
	if { [catch { foreach SOLUTION $solutions {

	    # Be sure we are in problem directory
	    #
	    cd $dir

	    regexp "^(.*)\\.(\[^.]*)\$" $SOLUTION \
	           forget PROBLEMXXX EXT
	    set testdir "test_${PROBLEMXXX}_$EXT"

	    putsq "==================== $testdir:"

	    putsq "rm -rf $testdir"
	    file delete -force -- $testdir
	    putsq "mkdir $testdir"
	    file mkdir $testdir
	    lappend delete_at_end $testdir

	    # Execute link instructions
	    #
	    set rlist $link_files
	    lappend rlist [list $problem.$EXT $SOLUTION]
	    lappend rlist \
	            "Makefile Makefile_$EXT Makefile"
	    foreach i $rlist {
	        if { ! [execute_link $testdir $i] } {
		    error "failed to execute link\
		           instruction $i"
		}
	    }
	    set olist $optional_link_files
	    foreach N $input_names {
		lappend olist \
			[list $N.test $N.out \
			      $N.test_$EXT $N.test]
		lappend olist \
			[list $N.jtest $N.jout \
			      $N.jtest_$EXT $N.jtest]
		lappend olist \
			[list $N.ftest $N.fout \
			      $N.ftest_$EXT $N.ftest]
		lappend olist \
			[list $N.jftest $N.jfout \
			      $N.jftest_$EXT $N.jftest]
	    }
	    foreach i $olist {
	        execute_link $testdir $i
	    }

	    # Change to subdirectory
	    #
	    cd $testdir

	    # If problem.in or problem.jin exist, only
	    # consider them.  Otherwise consider all
	    # *.in and *.jin.  Note that if problem.in
	    # was a link it was deleted above.
	    #
	    foreach N [lsort $input_names] {

		if { $N != $problem } {
		    putsq "========== $N:"
		}
		if { ! [file exists $N.in] } {
		    putsq "jfilter -v $N.jin $N.in\
		                  >& $N.in#"
		    exec jfilter -v $N.jin $N.in \
		                 >& $N.in#
		} elseif { [file exists $N.jin] } {
		    putsq "jfilter -v $N.jin $N.in+\
			  >& $N.in#"
		    exec jfilter -v $N.jin $N.in+ \
		         >& $N.in#
		    diff $testdir $N.in $N.in+
		}
		if { $N != $problem } {
		    putsq "rm -f $problem.in"
		    file delete -force -- $problem.in
		    putsq "ln -s $N.in $problem.in"
		    exec ln -s $N.in $problem.in
		}

		putsq "make"
		set make_error \
		    [catch { exec make >@ $stdoutq } \
			   mout]
		if { $make_error } {
		    if { $N != $problem } {
			set makes "  ==== $testdir\
			    ==== making $N.out:"
			putsfd $makes
			puts $makes
		    }
		    putsfd $mout
		    puts $mout
		}

		if { $N != $problem } {
		    if { [file exists $problem.out] } {
			putsq "mv $problem.out $N.out"
			file rename $problem.out $N.out
		    }
		}

		if { $make_error } continue

		diff $testdir $N.out $N.test

		if { [file exists Scoring_Filter] } {
		    putsq "Scoring_Filter $N.in\
			  < $N.out > $N.fout"
		    exec Scoring_Filter $N.in \
			 < $N.out > $N.fout
		    if { [file exists $N.ftest] } {
			diff $testdir $N.fout $N.ftest
		    }
		    if { [file exists $N.jin] } {
			putsq "jfilter -v\
			      $N.jin $N.fout $N.jfout\
			      >& $N.jfout#"
			exec jfilter -v \
			     $N.jin $N.fout $N.jfout \
			     >& $N.jfout#
			if { [file exists $N.jftest] } {
			    diff $testdir \
			         $N.jfout $N.jftest
			}
			diff $testdir $N.in# $N.jfout#
		    }
		} elseif { [file exists $N.jin] } {
		    putsq "jfilter -v $N.jin $N.out\
				  $N.jout >& $N.jout#"
		    exec jfilter -v $N.jin $N.out \
			 $N.jout >& $N.jout#
		    if { [file exists $N.jtest] } {
			diff $testdir $N.jout $N.jtest
		    }
		    diff $testdir $N.in# $N.jout#
		}
		}
	  } } out] } {
	    puts "  ==== $testdir:"
	    puts $out
	    putsfd "  ==== $testdir:"
	    putsfd $out
        }

	# Return to problem directory
	#
	cd $dir

	if { ! $keep } {
	    putsq "make clean"
	    exec make clean >&@ $stdoutq
	}

	if { ! $keep && [llength $delete_at_end] > 0 } {
	    putsq "rm -rf $delete_at_end"
	    eval file delete -force -- $delete_at_end
	}

    } out] } {
        puts $out
	putsfd $out
    }
}

if { $SUB == 3 } {
    set report [open $SUB_filename a]
} else {
    puts ""
    puts "******************** SUMMARY:"
    set report stdout
}


if { $SUB == 0 } {
    close $fd
    exec cat $tmp >@ stdout
    file delete $tmp
}

if { [llength $diff_files] > 0 } {
    puts $report "******************** \
          FILES THAT ARE DIFFERENT:"
    set previous ""
    foreach item $diff_files {
        set location [lindex $item 0]
        set file1 [lindex $item 1]
        set file2 [lindex $item 2]
	if { $previous != $location } {
	    puts $report "  in $location:"
	    set previous $location
	}
	puts $report \
	     [format {%38s != %-38s} $file1 $file2]
    }
}
if { $SUB == 3 } {
    close $report
}

exit 0

} caught_output
caught_error
