#! /bin/sh
#
# Test problem code.
#
# File:		testproblems
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Fri May 22 15:35:24 EDT 2009
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2009/05/22 19:41:10 $
#   $RCSfile: testproblems,v $
#   $Revision: 1.33 $
#
# The next lines run tclsh \
trap "echo testproblems: Terminated by Signal; exit 1" \
    HUP INT QUIT; \
trap "rm -rf /tmp/testproblems$$" EXIT; \
HPCM_SANDBOX_UNSECURE= \
    tclsh "$0" /tmp/testproblems$$ "$@"; exit $status

# Note we set HPCM_SANDBOX_UNSECURE above so we run
# hpcm_sandbox with the current uid and can access
# a local directory without a+x permissions on all its
# ancestors.

set tmp [lindex $argv 0]
set argv [lrange $argv 1 end]

set lib_directory "[file dirname $argv0]/../lib"
set judging_directory .
set log_disable yes
source $lib_directory/judging_common.tcl
catch {

set document "
testproblems \[-p N\] \[-keep|-\] \[directory ...\]

    The command with no arguments is equivalent to

    	testproblems .

    The command with just the argument `-' is equivalent
    to
    	testproblems -keep .

    In general the default directory is `.' and the
    argument `-' is equivalent to `-keep'.

    The `-p N' arguments cause the run to be done N
    times in parallel, as a way of testing timing of on
    multiple CPU computers.  To do this copies of the
    directories are made inside /tmp, and testproblems
    is run on these copies.

    The output without the `-p' option is the output
    of the `make' executions followed by a summary in-
    cluding the diff listings of any files with unex-
    pected differences followed by a list containing the
    names of these files.  With the `-p' option the only
    output is for each run a list of the names of files
    with differences, if any, followed by timing infor-
    mation.

    This program runs:		make clean
				make
				diff *.out *.test
				make clean

    in each directory.  It saves the diff outputs in
    addition to outputting them, and then plays back
    all the saved output at the end of this program's
    execution.  Errors made during the above run are
    also played back.

    Before doing the above, this program uses any
    problem_make_files value in any problem .rc file in
    a directory to make or remake files in the direc-
    tory, and after finishing all other operations in
    the directory, this program removes these files.  If
    these files exist when this program is run, they are
    deleted and remade.

    The -keep option suppresses the final `make clean'
    and the removal of files.

    If a directory contains .jin files, then the pro-
    gram runs

    		make clean

    once followed by

    		jfilter -v f.jin f.in >& f.in#
		ln -s f.in problem.in
		make
		mv problem.out f.out
		diff f.out f.test
		make clean
		rm f.in f.in# problem.in

    for each f.jin file.  The -keep option suppresses
    the final `make clean' and `rm'.

    If a directory contains multiple .in files, the
    same thing is done as for .jin files, but jfilter
    is not run and f.in is not removed.  If a directory
    contains just problem.jin, the same thing is done
    without the linking of problem.in or the moving
    of problem.out (here f = problem).

    If a directory contains both f.in and f.jin, then

    		jfilter -v f.jin f.in+ >& f.in#

    is executed and f.in and f.in+ are diff'ed, instead
    of making f.in from f.jin.

    If after the above, Scoring_Filter does not exist,

	jfilter -v f.jin f.out f.jout >& f.jout#
	rm f.jout f.jout#

    is execute if f.jin exists.  But if Scoring_Filter
    does exist then

	Scoring_Filter f.in < f.out > f.fout
	jfilter -v f.jin f.fout f.jfout >& f.jfout#
	rm f.fout f.jfout f.jfout#

    is executed, with the jfilter execution and f.jfout
    removal suppressed if f.jin does not exist.

    If f.jout (f.fout, f.jfout) is made and f.jtest
    (f.ftest, f.jftest) exists, these two files are
    diff'ed, and if different the differences are
    reported.  If f.jout# or f.jfout# are made, they
    are similarly diff'ed with f.jin#.

    All `rm' commands are suppressed by -keep.  All
    `make clean' commands except the initial one in
    each directory are suppressed by -keep.
    
    If a non-directory is given the program, or if a
    directory with no Makefile is given, the program
    merely notes this in the output."

# Process options.
#
# The `-SUB 1 filename' option is used when testproblems
# is called recursively for the `-p' option, and
# causes a list of names of differing files, followed by
# a report of errors running testproblems, if any,
# followed by timing information, to be APPENDED to the
# named file.  There is no other output. `-SUB 2 file-
# name' is similar but does not include the timing in-
# formation.  `-SUB 3 filename' is similar but does not
# include the error report or timing information and
# does have the other output associated with test-
# problems.  When called with -SUB 1, testproblems calls
# `time testproblems -SUB 2 ...' and appends the timing
# info to the named file.  When called with -SUB 2 test-
# problems calls `testproblems > /dev/null -SUB 3 ...'
# and if there is any returned text, which will be
# stderr output, appends that as the error report to the
# named file.  None of these options may be used with
# the -p option, and there is no error checking of
# the -SUB option arguments.
#
set parallel_runs 0
set keep 0
set SUB 0
set SUB_filename ""
set myargv $argv
while { 1 } {
    switch -glob -- [lindex $myargv 0] {
    -doc* {
	puts $document
	exit 1
    }
    -keep { set keep 1 }
    -     { set keep 1 }
    -p {
	    set myargv [lrange $myargv 1 end]
	    set parallel_runs [lindex $myargv 0]
	    if { [catch { expr { $parallel_runs + 1 }}] \
	         || \
		 $parallel_runs <= 0 } {
	        puts "-p $parallel_runs is not legal"
		exit 2
	    }
    }
    -SUB {
	    set myargv [lrange $myargv 1 end]
	    set SUB [lindex $myargv 0]
	    set myargv [lrange $myargv 1 end]
	    set SUB_filename [lindex $myargv 0]
    }
    default break
    }
    set myargv [lrange $myargv 1 end]
}
if { [llength $myargv] == 0 } {
    set myargv .
}

set wd [pwd]

if { $parallel_runs > 0 } {

    file delete -force -- $tmp
    file mkdir $tmp
    grant_access $tmp x
    set i 1
    while { $i <= $parallel_runs } {
        file mkdir $tmp/test$i
	grant_access $tmp/test$i x
	foreach d $myargv {
	    exec cp -pr $d $tmp/test$i
	}
	incr i
    }
    if { $keep } { set k -keep } else { set k "" }
    set i 1
    set pids {}
    while { $i <= $parallel_runs } {
        cd $tmp/test$i
	eval lappend pids \
	     [eval exec $argv0 \
		   -SUB 1 $tmp/test$i.report \
		   $k $myargv &]
	incr i
    }

    cd $wd

    while { [llength $pids] > 0 } {
        set pid [lindex $pids 0]
	while { [process_found \
	             [display_process_tree $pid]] } {
	    sleep 2
	}
	set pids [lrange $pids 1 end]
    }

    puts "===================== Test of $parallel_runs\
          Parallel Runs"
    exec date >@ stdout
    exec hostname -f >@ stdout
    puts -nonewline "testproblems -p $parallel_runs $k"
    set j 0
    foreach d $myargv {
        if { $j % 5 == 0 } {
	    puts -nonewline " \\\n   "
	}
	puts -nonewline " $d"
	incr j
    }
    puts ""
    puts ""
    set i 1
    while { $i <= $parallel_runs } {
	puts "========== run $i:"
    	exec cat $tmp/test$i.report >@ stdout
	incr i
    }
    file delete -force -- $tmp
    exit 0

} elseif { $SUB == 1 } {
    if { $keep } { set k -keep } else { set k "" }
    # time writes its output to the standard error file
    catch { eval exec time -p $argv0 \
                 -SUB 2 $SUB_filename $k $myargv } \
	  tout
    set fd [open $SUB_filename a]
    puts $fd "\n$tout"
    close $fd
    exit 0
} elseif { $SUB == 2 } {
    if { $keep } { set k -keep } else { set k "" }
    set eout [eval exec $argv0 > /dev/null \
                   -SUB 3 $SUB_filename $k $myargv]
    if { $eout != "" } {
	set fd [open $SUB_filename a]
	puts $fd "\nTESTPROBLEMS ERROR OUTPUT\n\n$eout"
	close $fd
    }
    exit 0
} elseif { $SUB == 0 } {
    file delete -force -- $tmp
    set fd [open $tmp w]
}

set diff_files {}

proc putsfd { string } {
    global fd
    if { [info exists fd] } {
        puts $fd $string
    }
}

proc diff { file1 file2 } {
    global problem diff_files SUB
    puts "diff $file1 $file2"
    catch {
	set diffs [exec diff $file1 $file2]
	  } diffs
    if { [string trim $diffs] != "" } {
	if {    $file1 != "$problem.out" } {
	    set diffs \
		"========== $file1:\n$diffs"
	}
	putsfd $diffs
	puts $diffs
	lappend diff_files \
	        [list $problem $file1 $file2]
    }
}

# Read .rc file to possibly set any problem_make_files
# global variable.
#
proc read_rc_file { file problem } {
    global PROBLEM EXTENSION OPTIONS \
	   problem_make_files
    set PROBLEM $problem
    set EXTENSION UNDEFINED
    set OPTIONS UNDEFINED
    source_file $file
}

foreach x $myargv {

    if { ! [file isdirectory $x] } {
        puts "====================\
	      $x is not a directory"
	continue
    }

    if { ! [file exists $x/Makefile] } {
	puts "====================\
	      $x/Makefile does not exist"
	continue
    }

    putsfd "==================== $x:"
    puts -nonewline "===================="
    puts -nonewline "===================="
    puts -nonewline "===================="
    puts " $x:"

    cd $x
    if { [catch {

	set problem [file tail [pwd]]

	# Do initial clean.
	#
	set type none
	catch { set type [file type $problem.in] }
	if { $type == "link" } {
	    file delete $problem.in
	}
	exec make clean >&@ stdout

	# List of files to be deleted at end.
	#
	set made ""

	# Compute make_files = problem_make_files value
	# in any $problem.rc file.
	#
	set make_files {}
	if { [file exists $problem.rc] } {

	    catch { unset problem_make_files }
	    read_rc_file $problem.rc $problem
	    if { [info exists problem_make_files] } {
	        set make_files $problem_make_files

		if { [catch { llength $make_files }] } {
		    error "$problem.rc\
		           problem_make_files value is\
			   not a TCL\
			   list:\n    $make_files"
		}
	    }
	}

	# If there are make_files, delete them and
	# (re)make them.
	#
	if { [llength $make_files] > 0 } {

	    foreach instruction $make_files {
		if { [catch { llength $instruction }] \
		   } {
		    error "$problem.rc\
		           problem_make_files\
			   instruction is not a TCL\
			   list:\n    $instruction"
		}
		set file [lindex $instruction 0]
		if { $file == "" } {
		    error "$problem.rc\
		           problem_make_files\
			   instruction has empty file\
			   name:\n    $instruction"
		}
		lappend made $file
	    }

	    puts "(re)making $made"
	    eval file delete -force -- $made
	    execute_makes $make_files . \
	                  "problem_make_files value in\
			   $problem.rc"
	}

	# Make sure that "problem" is the first
	# value of f if it is a value of f.
	#
	set done ""
	foreach file [lsort [glob $problem.in \
	                          $problem.jin \
			          *.in *.jin]] {
	    set f [file rootname $file]
	    if { [lcontain $done $f] } continue
	    lappend done $f
	    if { $f != $problem } {
	        puts "========== $file:"
	    }
	    file delete -force -- $f.in#
	    if { ! [file exists $f.in] } {
	        puts "jfilter -v $f.jin $f.in >& $f.in#"
	        exec jfilter -v $f.jin $f.in >& $f.in#
		lappend made $f.in $f.in#
	    } elseif { [file exists $f.jin] } {
	        file delete -force -- $f.in+
	        puts "jfilter -v $f.jin $f.in+\
		      >& $f.in#"
	        exec jfilter -v $f.jin $f.in+ >& $f.in#
		lappend made $f.in+ $f.in#
		diff $f.in $f.in+
	    }
	    if { $f != $problem } {
	        exec ln -s $f.in $problem.in
	    }
	    set make_error \
	        [catch { exec make >@ stdout } \
		       mout]
	    if { $make_error } {
	        if { $f != $problem } {
		    putsfd "========== making $f.out:"
		    file delete $problem.in
		}
		putsfd $mout
		puts $mout
		continue
	    }
	    if { $f != $problem } {
	        file rename $problem.out $f.out
		lappend made $f.out
		file delete $problem.in
	    }
	    diff $f.out $f.test

	    if { [file exists Scoring_Filter] } {
		puts "Scoring_Filter $f.in\
		      < $f.out > $f.fout"
		exec Scoring_Filter $f.in \
		     < $f.out > $f.fout
		lappend made $f.fout
		if { [file exists $f.ftest] } {
		    diff $f.fout $f.ftest
		}
		if { [file exists $f.jin] } {
		    file delete -force -- $f.jfout#
		    puts "jfilter -v\
			  $f.jin $f.fout $f.jfout\
			  >& $f.jfout#"
		    exec jfilter -v \
			 $f.jin $f.fout $f.jfout \
			 >& $f.jfout#
		    lappend made $f.jfout $f.jfout#
		    if { [file exists $f.jftest] } {
			diff $f.jfout $f.jftest
		    }
		    diff $f.in# $f.jfout#
		}
	    } elseif { [file exists $f.jin] } {
		file delete -force -- $f.jout#
		puts "jfilter -v $f.jin $f.out\
			      $f.jout >& $f.jout#"
		exec jfilter -v $f.jin $f.out \
		     $f.jout >& $f.jout#
		lappend made $f.jout $f.jout#
		if { [file exists $f.jtest] } {
		    diff $f.jout $f.jtest
		}
		diff $f.in# $f.jout#
	    }

	    if { ! $keep } {
	        exec make clean >&@ stdout
	    }
	}
	if { ! $keep && [llength $made] > 0 } {
	    puts "rm -f $made"
	    eval file delete -force -- $made
	}
    } out] } {
        puts $out
	putsfd $out
    }
    cd $wd
}

if { $SUB == 3 } {
    set report [open $SUB_filename a]
} else {
    puts ""
    puts "******************** SUMMARY:"
    set report stdout
}


if { $SUB == 0 } {
    close $fd
    exec cat $tmp >@ stdout
    file delete $tmp
}

if { [llength $diff_files] > 0 } {
    puts $report "******************** \
          FILES THAT ARE DIFFERENT:"
    set p ""
    foreach item $diff_files {
        set problem [lindex $item 0]
        set file1 [lindex $item 1]
        set file2 [lindex $item 2]
	if { $p != $problem } {
	    puts $report "  in $problem:"
	    set p $problem
	}
	puts $report \
	     [format {%38s != %-38s} $file1 $file2]
    }
}
if { $SUB == 3 } {
    close $report
}

exit 0

} caught_output
caught_error
