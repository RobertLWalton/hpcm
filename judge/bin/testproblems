#! /bin/sh
#
# Test problem code.
#
# File:		testproblems
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Sun Feb  3 10:31:12 EST 2013
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2013/02/04 03:55:59 $
#   $RCSfile: testproblems,v $
#   $Revision: 1.40 $
#
# The next lines run tclsh \
trap "echo testproblems: Terminated by Signal; exit 1" \
    HUP INT QUIT; \
trap "rm -rf /tmp/testproblems$$" EXIT; \
HPCM_SANDBOX_UNSECURE= \
    tclsh "$0" /tmp/testproblems$$ "$@"; exit $status

# Note we set HPCM_SANDBOX_UNSECURE above so we run
# hpcm_sandbox with the current uid and can access
# a local directory without a+x permissions on all its
# ancestors.

set allowed_extensions "c cc java lsp"
set tmp [lindex $argv 0]
set argv [lrange $argv 1 end]

set lib_directory "[file dirname $argv0]/../lib"
set judging_directory .
set log_disable yes
source $lib_directory/judging_common.tcl
catch {

set document "
testproblems \[-p N\] \[-keep|-|-make|-judge\] \\
             \[directory ...\]

    The command with no arguments is equivalent to

    	testproblems .

    The command with just the argument `-' is equivalent
    to
    	testproblems -keep .

    In general the default directory is `.' and the
    argument `-' is equivalent to `-keep'.

    The `-p N' arguments cause the run to be done N
    times in parallel, as a way of testing timing of on
    multiple CPU computers.  To do this copies of the
    directories are made inside /tmp, and testproblems
    is run on these copies.

    The output without the `-p' option is the output
    of the `make' executions followed by a summary in-
    cluding the diff listings of any files with unex-
    pected differences followed by a list containing the
    names of these files.  With the `-p' option the only
    output is for each run a list of the names of files
    with differences, if any, followed by timing infor-
    mation.

    To first approximation, this program tests a solu-
    tion in file PROBLEM.EXT by making a subdirectory
    named EXT, linking appropriate files into it, and
    running:

		make clean
		make
		diff *.out *.test
		make clean

    in the subdirectory.  The diff outputs are both
    saved and outputted, and all relevant saved output
    for each directory is played back at the end of this
    program's execution.  Errors made during the above
    run are also played back.  The -keep option suppres-
    ses the final `make clean'.

    More specifically, for each directory this program
    does the following.  First, it does a cd to the
    directory and extracts the name PROBLEM as the last
    component of the full name of the directory (obtain-
    ed by pwd).  Then it deletes any symbolic link named
    PROBLEM.in (but will NOT delete a regular file of
    that name), and runs

    		make clean

    Next this program uses any problem_make_files value
    in any PROBLEM.rc file in the directory to make or
    remake files in the directory.  If these files exist
    when this program is run, they are deleted and
    remade if they are obsolete.

    After making problem_make_files, this program
    identifies the solution files PROBLEM.EXT that are
    to be tested.  Here EXT is restricted to values
    in a list given by the -l argument if that is given,
    of the problem_allowed_extensions variable in the
    PROBLEM.rc file, if that is given, or

        $allowed_extensions

    otherwise.  For each EXT in the list such that the
    file PROBLEM.EXT exists, the subdirectory EXT is
    made, files are linked into it, and in that direc-
    tory PROBLEM.EXT is tested.

    The files linked into the EXT subdirectory is

    	* Those listed in problem_{link,copy}_files
	  and problem_optional_{link,copy}_files.
	  Note the ..._copy_files are linked and not
	  copied, because the only reason for copying
	  them is so the sandbox can access them, but
	  this is not an issue for this program which
	  disables sandboxing.  It is an error if
	  a file in problem_{link,copy}_files cannot
	  be linked to any file, but it is not an error
	  if a file in problem_optional_{link,copy}_
	  files cannot be linked to any file.

	* Makefile and Scoring_Filter.  Makefile is
	  treated as a problem_link_files file with
	  entry

	  	Makefile Makefile.EXT Makefile

	  and Scoring_Filter is treated as a problem_
	  options_link_files file with entry
	  
	  	Scoring_Filter

	* The \`input set' of names N such that N.in or
	  N.jin exist in the directory is considered.
	  If PROBLEM is in this set but is not the only
	  member, then PROBLEM is deleted from the set.
	  Then the following problem_{optional_,}link_
	  files entries are executed for N in the
	  set:

	  Required:

		N.test N.out N.test

	  Optional (but one must exist):

	  	N.in
	  	N.jin

	  Required if Scoring_Filter not linked but
	  N.jin linked:

	  	N.jtest N.jout N.jtest

	  Required if Scoring_Filter linked:

	  	N.ftest N.fout N.ftest

	  Required if Scoring_Filter linked AND N.jin
	  linked:

	  	N.jftest N.jfout N.jftest

    Unless the -keep option is given, after finishing a
    directory all files listed in problem_make_files and
    all EXT subdirectories are deleted.

    Then the input set of names N is processed as
    follows.  If N.jin exists but NOT N.in does not,
    the program runs

    	jfilter -v N.jin N.in >& N.in#
	ln -s N.in PROBLEM.in          # if N != PROBLEM
	make
	rm PROBLEM.in                  # if N != PROBLEM
	mv PROBLEM.out N.out           # if N != PROBLEM
	diff N.out N.test

    If N.in exists but N.jin does not, this program does
    the same thing as for N.jin, but jfilter is not run.

    If both N.in and N.jin exist, then

    		jfilter -v N.jin N.in+ >& N.in#

    is executed and N.in and N.in+ are diff'ed, instead
    of making N.in from N.jin.

    If after the above, Scoring_Filter does not exist,

	jfilter -v N.jin N.out N.jout >& N.jout#

    is executed if N.jin exists.  But if Scoring_Filter
    does exist then

	Scoring_Filter N.in < N.out > N.fout
	jfilter -v N.jin N.fout N.jfout >& N.jfout#

    is executed, with the jfilter execution suppressed
    if N.jin does not exist.

    If N.jout (N.fout, N.jfout) is made and N.jtest
    (N.ftest, N.jftest) exists, these two files are
    diff'ed, and if different the differences are
    reported.  If N.jout# or N.jfout# are made, they
    are similarly diff'ed with N.jin#.

    If errors occur while processing a directory, they
    are announced and processing of the directory is
    terminated.

    If a non-directory is given the program, or if a
    directory with no Makefile is given, the program
    merely notes this in the output."

# Process options.
#
# The `-SUB 1 filename' option is used when testproblems
# is called recursively for the `-p' option, and
# causes a list of names of differing files, followed by
# a report of errors running testproblems, if any,
# followed by timing information, to be APPENDED to the
# named file.  There is no other output. `-SUB 2 file-
# name' is similar but does not include the timing in-
# formation.  `-SUB 3 filename' is similar but does not
# include the error report or timing information and
# does have the other output associated with test-
# problems.  When called with -SUB 1, testproblems calls
# `time testproblems -SUB 2 ...' and appends the timing
# info to the named file.  When called with -SUB 2 test-
# problems calls `testproblems > /dev/null -SUB 3 ...'
# and if there is any returned text, which will be
# stderr output, appends that as the error report to the
# named file.  None of these options may be used with
# the -p option, and there is no error checking of
# the -SUB option arguments.
#
set parallel_runs 0
set keep 0
set make 0
set judge 0
set SUB 0
set SUB_filename ""
set myargv $argv
while { 1 } {
    switch -glob -- [lindex $myargv 0] {
    -doc* {
	puts $document
	exit 1
    }
    -keep { set keep 1 }
    -     { set keep 1 }
    -make { set make 1 }
    -judge { set judge 1 }
    -p {
	    set myargv [lrange $myargv 1 end]
	    set parallel_runs [lindex $myargv 0]
	    if { [catch \
	            { expr { $parallel_runs + 1 }}] \
	         || \
		 $parallel_runs <= 0 } {
	        puts "-p $parallel_runs is not legal"
		exit 2
	    }
    }
    -SUB {
	    set myargv [lrange $myargv 1 end]
	    set SUB [lindex $myargv 0]
	    set myargv [lrange $myargv 1 end]
	    set SUB_filename [lindex $myargv 0]
    }
    default break
    }
    set myargv [lrange $myargv 1 end]
}
if { [llength $myargv] == 0 } {
    set myargv .
}

set wd [pwd]

if { $parallel_runs > 0 } {

    file delete -force -- $tmp
    file mkdir $tmp
    grant_access $tmp x
    set i 1
    while { $i <= $parallel_runs } {
        file mkdir $tmp/test$i
	grant_access $tmp/test$i x
	foreach d $myargv {
	    exec cp -pr $d $tmp/test$i
	}
	incr i
    }
    if { $keep } { set k -keep } else { set k "" }
    set i 1
    set pids {}
    while { $i <= $parallel_runs } {
        cd $tmp/test$i
	lappend_lists pids \
	     [eval exec $argv0 \
		   -SUB 1 $tmp/test$i.report \
		   $k $myargv &]
	incr i
    }

    cd $wd

    while { [llength $pids] > 0 } {
        set pid [lindex $pids 0]
	while { [process_found \
	             [display_process_tree $pid]] } {
	    sleep 2
	}
	set pids [lrange $pids 1 end]
    }

    puts "===================== Test of $parallel_runs\
          Parallel Runs"
    exec date >@ stdout
    exec hostname -f >@ stdout
    puts -nonewline "testproblems -p $parallel_runs $k"
    set j 0
    foreach d $myargv {
        if { $j % 5 == 0 } {
	    puts -nonewline " \\\n   "
	}
	puts -nonewline " $d"
	incr j
    }
    puts ""
    puts ""
    set i 1
    while { $i <= $parallel_runs } {
	puts "========== run $i:"
    	exec cat $tmp/test$i.report >@ stdout
	incr i
    }
    file delete -force -- $tmp
    exit 0

} elseif { $SUB == 1 } {
    if { $keep } { set k -keep } else { set k "" }
    # time writes its output to the standard error file
    catch { eval exec time -p $argv0 \
                 -SUB 2 $SUB_filename $k $myargv } \
	  tout
    set fd [open $SUB_filename a]
    puts $fd "\n$tout"
    close $fd
    exit 0
} elseif { $SUB == 2 } {
    if { $keep } { set k -keep } else { set k "" }
    set eout [eval exec $argv0 > /dev/null \
                   -SUB 3 $SUB_filename $k $myargv]
    if { $eout != "" } {
	set fd [open $SUB_filename a]
	puts $fd "\nTESTPROBLEMS ERROR OUTPUT\n\n$eout"
	close $fd
    }
    exit 0
} elseif { $SUB == 0 } {
    file delete -force -- $tmp
    set fd [open $tmp w]
}

set diff_files {}

proc putsfd { string } {
    global fd
    if { [info exists fd] } {
        puts $fd $string
    }
}

proc diff { file1 file2 } {
    global problem diff_files SUB
    puts "diff $file1 $file2"
    catch {
	set diffs [exec diff $file1 $file2]
	  } diffs
    if { [string trim $diffs] != "" } {
	if {    $file1 != "$problem.out" } {
	    set diffs \
		"========== $file1:\n$diffs"
	}
	putsfd $diffs
	puts $diffs
	lappend diff_files \
	        [list $problem $file1 $file2]
    }
}

# Read .rc file to possibly set any problem_make_files,
# and problem_{optional_,}{link,copy}_files global
# variables.
#
proc read_rc_file { file problem } {
    global PROBLEM EXTENSION OPTIONS \
	   problem_make_files \
	   problem_link_files \
	   problem_optional_link_files \
	   problem_copy_files \
	   problem_optional_copy_files

    set PROBLEM $problem
    set EXTENSION UNDEFINED
    set OPTIONS UNDEFINED
    source_file $file
}

# Test that a $problem.rc global variable value is a
# TCL list and complain if it is not.
#
proc check_list { variable_name } {

    global problem
    upvar $variable_name variable

    if { [catch { llength $variable }] } {
	error "$problem.rc\
	       $variable_name value is\
	       not a TCL\
	       list:\n    $variable"
    }
}

foreach x $myargv {

    if { ! [file isdirectory $x] } {
        puts "====================\
	      $x is not a directory"
	continue
    }

    if { ! [file exists $x/Makefile] } {
	puts "====================\
	      $x/Makefile does not exist"
	continue
    }

    putsfd "==================== $x:"
    puts -nonewline "===================="
    puts -nonewline "===================="
    puts -nonewline "===================="
    puts " $x:"

    cd $x
    if { [catch {

	set problem [file tail [pwd]]

	# Do initial clean.
	#
	set type none
	catch { set type [file type $problem.in] }
	if { $type == "link" } {
	    file delete $problem.in
	}
	exec make clean >&@ stdout

	# List of files to be deleted at end if -keep
	# option is absent.
	#
	set delete_at_end {}

	# Compute make_files = problem_make_files value
	# in any $problem.rc file.  Similarly compute
	# link_files = problem_{link,copy}_files and
	# optional_link_files = problem_optional_{link,
	# copy}_files.
	#
	set make_files {}
	set link_files {}
	set optional_link_files {}
	if { [file exists $problem.rc] } {

	    catch { unset problem_make_files }
	    catch { unset problem_link_files }
	    catch { unset problem_optional_link_files }
	    catch { unset problem_copy_files }
	    catch { unset problem_optional_copy_files }
	    read_rc_file $problem.rc $problem

	    if { [info exists problem_make_files] } {
		check_list problem_make_files
	        set make_files $problem_make_files
	    }
	    if { [info exists problem_link_files] } {
		check_list problem_link_files
		set link_files $problem_link_files
	    }
	    if { [info exists \
		       problem_optional_link_files] } {
		check_list \
		    problem_optional_link_files
		set optional_link_files \
		    $problem_optional_link_files
	    }
	    if { [info exists problem_copy_files] } {
		check_list problem_copy_files
		lappend_lists link_files \
		     $problem_copy_files
	    }
	    if { [info exists \
		       problem_optional_copy_files] } {
		check_list \
		    problem_optional_copy_files
		lappend_lists optional_copy_files \
		    $problem_optional_link_files
	    }
	}

	# If there are make_files, (re)make them.
	#
	if { [llength $make_files] > 0 } {

	    set made {}

	    foreach instruction $make_files {
		if { [catch { llength $instruction }] \
		   } {
		    error "$problem.rc\
		           problem_make_files\
			   instruction is not a TCL\
			   list:\n    $instruction"
		}
		set file [lindex $instruction 0]
		if { $file == "" } {
		    error "$problem.rc\
		           problem_make_files\
			   instruction has empty file\
			   name:\n    $instruction"
		}
		if { ! $make } {
		    lappend delete_at_end $file
		}
		lappend made $file
	    }

	    puts "(re)making $made"
	    execute_makes $make_files . \
	                  "problem_make_files value in\
			   $problem.rc"
	}

	# If there are link files or optional link
	# files, link them if they do not exist.  If
	# -judge and they would be linked to another
	# existing file, insist that they are linked
	# to this file, removing any existing file or
	# link and relinking if necessary.  If there
	# is no file and no way to link it, complain
	# if the file is on link_files list (and
	# therefore is not optional).  If not -make
	# option, put all files that might be linked
	# on the delete list.
	#
	set non_optional [llength $link_files]
	    # If >= 0 file is not optional
	foreach instruction \
	        [concat $link_files \
			$optional_link_files] {
	    incr non_optional -1

	    if { [catch { llength $instruction }] \
	       } {
	      error \
	        "$problem.rc\
		 problem_{,optional_}{link,copy}_files\
		 instruction is not a TCL\
		 list:\n    $instruction"
	    }

	    set file [lindex $instruction 0]

	    if { $file == "" } {
	      error \
	        "$problem.rc\
		 problem_{,optional_}{link,copy}_files\
		 instruction has empty file\
		 name:\n    $instruction"
	    }

	    if { [file exists $file] && ! $judge } \
	        continue

	    # Compute desired target; File cannot be its
	    # own target.
	    #
	    set target ""
	    foreach t [lrange $instruction 1 end] {
	        if { [file exists $t] } {
		    set target $t
		    break
		}
	    }

	    if {    $target == "" \
	         && ! [file exists $file] \
		 && $non_optional >= 0 } {
	      error \
	        "$problem.rc problem_{link,copy}_files\
		 instruction requires that $file be\
		 linked but this is not\
		 possible:\n    $instruction"
	    }

	    # If no target and file exists or is
	    # optional, skip it.
	    #
	    if { $target == "" } continue

	    set old_target ""
	    catch { set old_target \
			[file readlink $file] }
	    if { $old_target == $target } continue;

	    # If old_target targets an existing file
	    # we must have -judge at this point.
	    # Similarly if $file exists we must have
	    # -judge at this point.
	    #
	    if {    $old_target != "" \
	         && ! [file exists $old_target] } {
		puts "deleting link of $file to\
		      $old_target as $old_target does\
		      not exist"
		file delete -force -- $file
	    } elseif { $old_target != "" } {
		puts "deleting link of $file to\
		      $old_target as per -judge"
		file delete -force -- $file
	    } elseif { [file exists $file] } {
		puts "deleting $file as per -judge"
		file delete -force -- $file
	    }

	    # At this point $file does not exist
	    # and is not a link.
	    #
	    puts "linking $file to $target"
	    file link -symbolic $file $target

	    if { ! $make } {
		lappend delete_at_end $file
	    }
	}

	# If problem.in or problem.jin exist, only
	# consider them.  Otherwise consider all
	# *.in and *.jin.  Note that if problem.in
	# was a link it was deleted above.
	#
	set inputs ""
	foreach file [glob *.in *.jin] {
	    set f [file rootname $file]
	    if { [lcontain $inputs $f] } continue
	    lappend inputs $f
	}
	if {    [lcontain $inputs $problem] \
	     && [llength $inputs] > 1 } {
	    error "ERROR: $problem.in or $problem.jin\
	           exists\n       along with other .in\
		   or .jin files"
	}
	foreach f [lsort $inputs] {

	    if { $f != $problem } {
	        puts "========== $f:"
	    }
	    file delete -force -- $f.in#
	    if { ! [file exists $f.in] } {
	        puts "jfilter -v $f.jin $f.in >& $f.in#"
	        exec jfilter -v $f.jin $f.in >& $f.in#
		lappend delete_at_end $f.in $f.in#
	    } elseif { [file exists $f.jin] } {
	        file delete -force -- $f.in+
	        puts "jfilter -v $f.jin $f.in+\
		      >& $f.in#"
	        exec jfilter -v $f.jin $f.in+ >& $f.in#
		lappend delete_at_end $f.in+ $f.in#
		diff $f.in $f.in+
	    }
	    if { $f != $problem } {
	        exec ln -s $f.in $problem.in
	    }

	    set make_error \
	        [catch { exec make >@ stdout } \
		       mout]
	    if { $make_error } {
	        if { $f != $problem } {
		    putsfd "========== making $f.out:"
		}
		putsfd $mout
		puts $mout
	    }

	    if { $f != $problem } {
	        file rename $problem.out $f.out
		lappend delete_at_end $f.out
		file delete $problem.in
	    }

	    if { $make_error } continue

	    diff $f.out $f.test

	    if { [file exists Scoring_Filter] } {
		puts "Scoring_Filter $f.in\
		      < $f.out > $f.fout"
		exec Scoring_Filter $f.in \
		     < $f.out > $f.fout
		lappend delete_at_end $f.fout
		if { [file exists $f.ftest] } {
		    diff $f.fout $f.ftest
		}
		if { [file exists $f.jin] } {
		    file delete -force -- $f.jfout#
		    puts "jfilter -v\
			  $f.jin $f.fout $f.jfout\
			  >& $f.jfout#"
		    exec jfilter -v \
			 $f.jin $f.fout $f.jfout \
			 >& $f.jfout#
		    lappend delete_at_end \
		            $f.jfout $f.jfout#
		    if { [file exists $f.jftest] } {
			diff $f.jfout $f.jftest
		    }
		    diff $f.in# $f.jfout#
		}
	    } elseif { [file exists $f.jin] } {
		file delete -force -- $f.jout#
		puts "jfilter -v $f.jin $f.out\
			      $f.jout >& $f.jout#"
		exec jfilter -v $f.jin $f.out \
		     $f.jout >& $f.jout#
		lappend delete_at_end $f.jout $f.jout#
		if { [file exists $f.jtest] } {
		    diff $f.jout $f.jtest
		}
		diff $f.in# $f.jout#
	    }

	    if { ! $keep } {
	        exec make clean >&@ stdout
	    }
	}
	if { ! $keep && [llength $delete_at_end] > 0 } {
	    puts "rm -f $delete_at_end"
	    eval file delete -force -- $delete_at_end
	}
    } out] } {
        puts $out
	putsfd $out
    }
    cd $wd
}

if { $SUB == 3 } {
    set report [open $SUB_filename a]
} else {
    puts ""
    puts "******************** SUMMARY:"
    set report stdout
}


if { $SUB == 0 } {
    close $fd
    exec cat $tmp >@ stdout
    file delete $tmp
}

if { [llength $diff_files] > 0 } {
    puts $report "******************** \
          FILES THAT ARE DIFFERENT:"
    set p ""
    foreach item $diff_files {
        set problem [lindex $item 0]
        set file1 [lindex $item 1]
        set file2 [lindex $item 2]
	if { $p != $problem } {
	    puts $report "  in $problem:"
	    set p $problem
	}
	puts $report \
	     [format {%38s != %-38s} $file1 $file2]
    }
}
if { $SUB == 3 } {
    close $report
}

exit 0

} caught_output
caught_error
