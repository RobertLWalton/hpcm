#!/bin/sh -f
#
# Given a submission directory, dispatch any automatic
# programs, such as `autojudge' and `autoinfo'.
#
# File:		autodispatch
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Tue Aug 29 08:43:32 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/29 12:39:50 $
#   $RCSfile: autodispatch,v $
#   $Revision: 1.6 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# If an subdirectory name is given, make it current, and
# consume the subdirectory name argument.  This must be
# done before looking for the parameters file.
#
# Don't change argc or argv so error output will work.
#
set my_argc $argc
set my_argv $argv
if { $argc >= 1 && ! [regexp {^-} [lindex $argv 0]] } {
    cd [lindex $my_argv 0]
    set my_argv [lreplace $my_argv 0 0]
    set my_argc [expr { $my_argc - 1 }]
}

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"
catch {

set document "
autodispatch \[directory\] \[-force\]

    If the directory argument is given, this program
    makes that directory current before searching for
    the `$judging_parameters_file' file or doing
    anything else.

    This program next creates the $dispatch_pid_file
    file containing the process ID of this program's
    process.  If this file aleady exists, this program
    exits without error or output.

    Otherwise this program makes its process into a
    process group leader, so the UNIX command

    	kill -INT -`cat $dispatch_pid_file`

    will kill this process and all its subprocesses.
    When this program exits, it deletes the
    $dispatch_pid_file file.

    This program then exits without error or output if
    any of the files:

    	$reply_file
	$auto_score_file
	${reply_file}+
	*-<<*>>-unchecked-error
	*-<<*>>-checked-error

    exist.  The `-force' option deletes the last entry
    in this list.

    Otherise, if the use_authentication global variable
    equals `yes', this program next authenticates the
    mail in $received_mail.  If the mail is NOT
    authentic, this program produces an error log file
    and exits without error code or output.

    Otherwise this program inspects the `Subject' line
    in the current directory's $received_file and based
    on this may call one of the following:
    
	autojudge
	autoinfo

    If the `Subject' is not suitable for one of these
    programs, this program does not call any other
    program.

    At this point this program exits without error
    or output (except for output produced by autojudge
    or other called program)."

# Check for and consume -force option.
#
set force_option no
if { $argc >= 1 && [lindex $argv 0] -- "-force" } {
    set force_option yes
    set my_argv [lreplace $my_argv 0 0]
    set my_argc [expr { $my_argc - 1 }]
}

# If there are leftover arguments, print document and
# exit with error.
#
if { $my_argc != 0 } {
    puts $document
    exit 1
}

# Create $dispatch_pid_file.  Exit if it already
# exits.
#
if { [catch { create_file $dispatch_pid_file }] } {
    exit 0
}

# Set exit_cleanup function (called before all exits
# in judging common code) to delete $dispatch_pid_
# file.
#
proc exit_cleanup {} {
    file delete -force $dispatch_pid_file
}

write_file $dispatch_pid_file [current_pid]

set_current_pgid

# If one of several files exists, exit without error.
#
set patterns [list $reply_file \
		   "${reply_file}+" \
		   $auto_score_file \
		   *-<<*>>-unchecked-error ]
if { $force_option == "no" } {
    lappend patterns *-<<*>>-checked-error
}
if { [llength [eval glob -nocomplain $patterns]] \
     != 0 } {
    exit_cleanup
    exit 0
}

# Read header.
#
set received_ch [open $received_file r]
read_header

# Check authentication if $use_authentication is `yes'.
# If not authorized, write log error and exit.
#
if { ! [header_is_authentic] } {
    log_error "Received message header is not authentic"
}

# Execute any program appropriate to the subject.
#
if { [length $message_subject] >= 1 } {
    switch -exact [lindex $message_subject 0] {
        get	{ exec autoinfo }
	submit	{ exec autojudge }
    }
}

# If we did nothing, another program will see there
# is no $dispatch_pid_file or $reply_file and schedule
# manual action.

exit_cleanup
exit 0

# Include common error catching code:
#
} caught_output
caught_error
