#!/bin/sh -f
#
# Given a submission directory, dispatch any automatic
# programs, such as `autojudge' and `autoinfo'.
#
# File:		dispatchmail
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Aug 20 21:06:50 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/24 00:06:04 $
#   $RCSfile: autodispatch,v $
#   $Revision: 1.3 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# If an argument is given, use it as a name of a
# directory to make current, and the argument is
# consumed.  This must be done before looking for the
# parameters file.
#
# Don't change argc or argv so error output will work.
#
set my_argc $argc
set my_argv $argv
if { $argc >= 1 && ! [regexp {^-} [lindex $argv 0]] } {
    cd [lindex $argv 0]
    set my_argv [lreplace $argv 0 0]
    set my_argc [expr { $argc - 1 }]
}

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"
catch {

set document "
dispatchmail \[directory\]

    Inspects the `Subject' line in the current
    directory's $received_file and based on this calls
    either autojudge or autoinfo to process the current
    directory.

    If the directory argument is given, this program
    makes that directory current before searching for
    the `$judging_parameters_file' file.

    Before calling either autoscore or autoinfo, this
    program stores its PID (process ID) in the file
    $dispatch_pid_file.  After the called program,
    autoscore or autoinfo, finishes, this program
    deletes the $dispatch_pid_file.  Also, during its
    execution, this program makes itself into a process
    group leader, so the UNIX command

    	kill -1 -`cat $dispatch_pid_file`

    will kill this process and all its subprocesses."

if { $my_argc != 0 } {
    puts $document
    exit 1
}

# Execute a program.  During execution the PID of
# the current process is stored in $dispatch_pid_file.
# Also the current process is made into a process
# group leader.
#
proc dispatch { program } {
    global dispatch_pid_file

    write_file $dispatch_pid_file [id process]

    id process group set

    catch { exec $program } out
    if { $out != "" } { puts $out }

    file delete -force $dispatch_pid_file
}


# Find the subject and dispatch on it.
#
set subject [find_subject]
if { [regexp {^submit } $subject] } {
    dispatch autojudge
} elseif { [regexp {^get } $subject] } {
    dispatch autoinfo
}

# If we did nothing, another program will see there
# is no $dispatch_pid_file or $reply_file and schedule
# manual action.

exit 0

# Include common error catching code:
#
} caught_output
caught_error
