#!/bin/sh
#
# Given a submission directory, dispatch any automatic
# programs, such as `autojudge' and `autoinfo'.
#
# File:		autodispatch
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Tue Oct 24 21:57:03 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/10/25 04:18:36 $
#   $RCSfile: autodispatch,v $
#   $Revision: 1.14 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# If an subdirectory name is given, make it current, and
# consume the subdirectory name argument.  This must be
# done before looking for the parameters file.
#
# Don't change argc or argv so error output will work.
#
set my_argc $argc
set my_argv $argv
if { $my_argc >= 1 \
     && ! [regexp {^-} [lindex $my_argv 0]] } {
    cd [lindex $my_argv 0]
    set my_argv [lreplace $my_argv 0 0]
    set my_argc [expr { $my_argc - 1 }]
}

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
autodispatch \[directory\] \[-force\]

    If the directory argument is given, this program
    makes that directory current before searching for
    the `$judging_parameters_file' file or doing\
    anything else.

    After this program reads the\
			$judging_parameters_file file,
    this program next creates the $dispatch_pid_file\
				    file
    containing the process ID of this program's process.
    If this file already exists, this program exits
    without error or output.

    When this program exits, it deletes the\
		    $dispatch_pid_file
    file.

    This program then exits without error or output if
    any of the files:

    	$reply_file
    	$no_reply_file
	*-<<*>>-unchecked-error
	*-<<*>>-checked-error

    exist.  The `-force' option deletes the last entry
    in this list.

    Otherwise, if the use_authentication global variable
    equals `yes', this program next authenticates the
    mail in $received_file file.  If the mail is NOT
    authentic, this program produces an error log file
    and exits without error code or output.

    Next this program inspects the `Subject' line in the
    current directory's $received_file file and based on
    this may call one of the following:
    
	autojudge
	autoinfo

    In general, it calls the program indicated by the
    `autodispatch_map' array element for the first word
    (list element) of the subject field, if the subject
    field is not empty, and the array element is de-
    fined.  If the array element is not defined, no pro-
    gram is called.

    If no program is called and if the reply mode is
    `auto', this program will compose a reply.  If the
    `reply_manager' variable is NOT \"\", the reply is
    CC'ed to the value of this variable, and the reply
    says the person at this email address may respond.
    Otherwise, if the `reply_manager' variable is \"\",
    the reply says that no-one will look at the mes-
    sage.

    If no program is called and if the reply mode is
    NOT `auto', this program will set the `needs reply'
    flag (the flag directory $needs_reply_flag_file\
			    file).

    Finally this program exits without error or output,
    except for output produced by autojudge or other
    called program."

# Check for and consume -force option.
#
set force_option no
if { $my_argc >= 1 \
     && [lindex $my_argv 0] == "-force" } {
    set force_option yes
    set my_argv [lreplace $my_argv 0 0]
    set my_argc [expr { $my_argc - 1 }]
}

# If there are leftover arguments, print document and
# exit with error.
#
if { $my_argc != 0 } {
    puts $document
    exit 1
}

# Lock current directory with $dispatch_pid_file.  Exit
# if directory already locked.
#
if { [dispatch_lock] == "no" } {
    exit 0
}

# Set exit_cleanup function (called before all exits
# in judging common code) to unlock current directory.
#
proc exit_cleanup {} {
    dispatch_unlock
}

# If one of several files exists, exit without error.
#
set patterns [list $reply_file \
		   $no_reply_file \
		   *-<<*>>-unchecked-error ]
if { $force_option == "no" } {
    lappend patterns *-<<*>>-checked-error
}
if { [llength [eval glob -nocomplain $patterns]] \
     != 0 } {
    exit_cleanup
    exit 0
}

# Read header.
#
set received_ch [open $received_file r]
read_header $received_ch
close $received_ch

# Check authentication if $use_authentication is `yes'.
# If not authenticated, write log error and exit.
#
if { [header_is_authentic] == "no" } {
    error "Received message header is not authentic"
}

# Execute any program appropriate to the subject.
#
set s [lindex $message_subject 0]
if { [llength $message_subject] >= 1 \
     && [info exists autodispatch_map($s)] } {
    exec $autodispatch_map($s) >@ stdout 2>@ stderr

# Else if special error test request call error.
#
} elseif { [regexp {error test 908374693717092149} \
		   $message_subject] } {
    error "Test of the error response system."

# Else if `auto' reply_mode, reply.
#
} elseif { $reply_mode == "auto" } {
    if { $reply_manager != "" } {
	reply -all -cc \
	     "This message cannot be properly answered\
	       automatically," \
	      "and there is no person to prompty answer\
	       this message." \
	      "" \
	      "Please fix the subject field or\
	        wait for" \
	      "a response from $reply_manager"
    } else {
	reply -all \
	     "This message cannot be properly answered\
	       automatically," \
	      "and there is no person to prompty answer\
	       this message." \
	      "" \
	      "Please fix the subject field or\
	       send the message elsewhere."
    }

# Else if `auto+manual' reply mode: this is manual case,
# and anther program will see there is no $reply_file,
# no $no_reply_file, no $dispatch_pid_file, etc., and
# that the subject is unsuitable for autodispatch, and
# then this other program will schedule manual action.
#
} else {
    set_flag $needs_reply_flag_file
}

exit_cleanup
exit 0

# Include common error catching code:
#
} caught_output
caught_error
