#! /bin/sh
#
# Make index and list of files
#
# File:		makehelp
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Tue Nov 27 23:46:41 EST 2012
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2012/11/28 06:21:29 $
#   $RCSfile: makehelp,v $
#   $Revision: 1.6 $
#
# The next lines start tclsh \
trap "echo makehelp: Terminated by Signal" \
    HUP INT QUIT; \
tclsh "$0" "$@"; exit $status

set document "
makehelp help_index title index web option ...

    Read the index and make the files:

        help_index	   Index
	help_index.html	   WWW index
	help_index.files   List of files to print.
	web/...		   Copies of files in web page
			   directory.
	                  
    Lines beginning with `#' in index are deleted,
    as they are comments.

    Otherwise the index is treated as a sequence of
    paragraphs composed of non-blank lines, with blank
    lines separating the paragraphs.  Paragraphs are
    classified as `indented' if their first character
    is a whitespace, and `non-indented' otherwise.

    Any paragraph consisting of a single line of the
    format

    	*** FILENAME option ...

    (which possible whitespace before the ***) is
    called an `item header'.  Item headers are
    `selected' if any of their options or their FILENAME
    is listed as a makehelp command option.  When an
    item header is selected, the following are output
    in order:

	All non-indented paragraphs since the previous
	item header that have not yet been output, if
	any.

	The item header if FILENAME does not name a
	directory.

	All indented paragraphs after the item header
	and before the next item header or non-indented
	paragraph.

    An indented paragraph is a `file list' if it is
    preceded by an item header and possible intervening
    indented paragraphs, if the FILENAME in the item
    header names a directory, and if each line of the
    indented paragraph begins a whitespace surrounded
    NAME that contains no whitespace and whose tail,
    when viewed as a filename, names a file in the
    directory specified by the item header filename.

    This program writes a file named help_index.files
    that is just a list of file names.  When an item
    header whose FILENAME does NOT name a directory is
    selected, this FILENAME is written to this file.
    When a `file list' is recognized, the names of the
    files listed are written to this file.  The
    name of the help_index files is written to the
    beginning of this file.

    Files that are listed in help_index.files are
    also copied to the web directory, if it is not
    \"\", except that help_index.html is copied
    instead of help_index.  These copies are made
    read-only to everyone.

    When an item header is output, the options are
    deleted and the `***'s are converted to 3 spaces.

    All non-item header paragraphs are output as is to
    the help_index.  Non-indented paragraphs are
    preceded by two blank lines, and indented paragraphs
    are preceded by one blank line.

    Output to help_index.html is as follows:

        If a non-indented paragraph ends in a line con-
	taining just `-'s, then all lines containing
	just `-'s are deleted from the paragraph, and
	the paragraph is surrounded by <H3>...</H3>.
	Otherwise the paragraph is surrounded by
	<P>...</P>.

	If an item description paragraph is a file list,
	it is output as an indented table with the file
	names as links.  Otherwise the paragraph is
	surrounded by <P>...</P>.

	<BLOCKQUOTE>...</BLOCKQUOTE> is used to indent
	text between non-indented paragraphs and to
	further indent indented paragraphs.

    Unlike most HPCM judging programs, this program does
    not read any hpcm_judging.rc file and errors made by
    this program are not written to log files."

set WS "\[\ \t\]"
set NWS "\[^\ \t\]"

# Given a directory name `dir' and a paragraph `p',
# check if each line of the paragraph has the form
#
#   ${WS}*${NAME}${WS}+${REST}${WS}*
#
# where NAME contains no whitespace and REST does not
# begin or end with whitespace (and may be empty), and
# where $dir/[file tail $NAME] names an existing
# ordinary file (or symbolic link to such).  If NO,
# return the empty list.  Otherwise return a list with
# one element per line consisting of
#
#	{ NAME REST }
#
proc is_file_list { p dir } {
    global WS NWS
    set result {}
    foreach line $p {
        if { ! [regexp "^$WS*($NWS+)(|$WS.*)\$" \
	               $line forget \
		       name rest] } {
	    return {}
	}
	if { ! [file isfile $dir/[file tail $name]] } {
	    return {}
	}
	lappend result \
	        [list $name [string trim $rest]]
    }
    return $result
}

# Copy a file's name to fch and the file itself to web
# if the latter is not "".  The file is located
# at src and is to be copied to web/dst.
#
proc print_and_copy_file { fch web src dst } {
    puts $fch $src
    if { $web != "" } {
	file mkdir [file dirname $web/$dst]
	file copy -force $src $web/$dst
	file attributes $web/$dst -permissions r--r--r--
    }
}

# Given the result r of is_file_list above, output
# to wch the html for the file list.  Here dirname is
# the item header FILENAME.
#
proc file_list_to_html { wch r dirname } {
    puts $wch "<TABLE>"
    foreach line $r {
        set name [lindex $line 0]
        set tail [file tail $name]
	set rest [lindex $line 1]
        puts $wch "<TR><TD WIDTH=\"20\"></TD>"
        puts $wch "    <TD><A HREF=\"$dirname/$tail\">"
        puts $wch "        $name</TD>"
        puts $wch "    <TD WIDTH=\"20\"></TD>"
        puts $wch "    <TD>$rest</TD>"
        puts $wch "</TR>"
    }
    puts $wch "</TABLE>"
}

# Output non-indented paragaph to html.  If there is
# any line containing just `-'s, delete all such
# lines and use <H3>...</H3>.  Otherwise delete no
# lines and output <P>...</P>.
#
proc p_to_html { wch p } {
    global WS
    set use_h2 0
    foreach line $p {
        if { [regexp "^$WS*\-\[ \t-\]*\$" $line] } {
	    set use_h2 1
	}
    }
    if { $use_h2 } {
        puts $wch "<H3>"
	foreach line $p {
	    if { ! [regexp "^$WS*\-\[ \t-\]*\$" \
	                   $line] } {
		puts $wch $line
	    }
	}
        puts $wch "</H3>"
    } else {
        puts $wch "<P>"
	foreach line $p { puts $wch $line }
        puts $wch "</P>"
    }
}

# If too few arguments or first argument begins with
# `-', print documentation and exit with error.
#
if { $argc < 5 || [regexp {^-} [lindex $argv 0]] } {
    puts $document
    exit 1
}

set help_index [lindex $argv 0]
set files "${help_index}.files"
set html "${help_index}.html"
set title [lindex $argv 1]
set index [lindex $argv 2]
set indexdir [file dirname $index]
set web [lindex $argv 3]
set options [lrange $argv 4 end]
set date [exec date]

if { [catch { set hich [open $help_index w] }] } {
    puts "ERROR: could not open $help_index for writing"
    exit 1
}
if { [catch { set wch [open $html w] }] } {
    puts "ERROR: could not open $html for writing"
    exit 1
}
if { [catch { set fch [open $files w] }] } {
    puts "ERROR: could not open $files for writing"
    exit 1
}
if { [catch { set ich [open $index r] }] } {
    puts "ERROR: could not open $index for reading"
    exit 1
}

set count [expr 56 - [string length $title] \
                   - [string length $date]]
set tline "$title[string repeat " " $count]$date"

puts $hich $tline
puts $hich ""

puts $fch $help_index

set p {}
set in_p 0
set non_indented_output 0
set item_name ""
set item_directory ""
    # [dirname $index]/$item_name
while { ! [eof $ich] } {
    set line [gets $ich]
    if { [eof $ich] || [regexp "^$WS*\$" $line] } {
        if { $in_p } {
	    set in_p 0
	    if { $item_name != "" \
		 && \
		 [llength $p] > 0 \
		 && \
		 [regexp "^$WS" [lindex $p 0]] } {

		# Output indented paragraph

		puts $hich ""
		foreach l $p { puts $hich $l }

		if { $item_directory == "" } {
		    set r {}
		} else {
		    set r [is_file_list \
		               $p $item_directory ]
		}
		if { $r == {} } {
		    puts $wch "<P>"
		    foreach l $p { puts $wch $l }
		    puts $wch "</P>"
		} else {
		    file_list_to_html \
		        $wch $r $item_name
		    foreach l $r {
			set f [file tail [lindex $l 0]]
			set src "$item_directory/$f"
			set dst "$item_name/$f"
		        print_and_copy_file \
			    $fch $web $src $dst
		    }
		}
		set p {}
	    }
	}

	if {    [eof $ich] \
	     && $item_name != "" \
	     && $item_directory == ""} {
	    puts $wch "</BLOCKQUOTE>"
	}
    } elseif { [regexp {^#} $line] } {
        continue
    } elseif { ! $in_p } {
	if {    ! [catch { set len [llength $line] }] \
	     && $len >= 2 \
	     && [lindex $line 0] == "***" } {

	    # item header line

	    if { $item_name != "" \
	         && $item_directory == ""} {
		puts $wch "</BLOCKQUOTE>"
	    }

	    set item_name ""
	    set item_directory ""

	    set option_list [lrange $line 1 end]
	    foreach option $options {
		if { [expr [lsearch -exact \
				     $option_list \
				     $option] >= 0] } {
		    if { $p != {} } {

		        # Output non-indented paragraph

		        puts $hich ""
		        puts $hich ""
			foreach l $p {
			    puts $hich $l
			}
			if { $non_indented_output } {
			    puts $wch "</BLOCKQUOTE>"
			}
			p_to_html $wch $p
			set non_indented_output 1
			puts $wch "<BLOCKQUOTE>"
			set p {}
		    }

		    set item_name [lindex $line 1]
		    set item_directory \
		      "[file dirname $index]/$item_name"
		    if { ! [file isdirectory \
		                 $item_directory] } {

			print_and_copy_file \
			    $fch $web $item_directory \
			              $item_name

			set item_directory ""

			# Output file name

			puts $hich ""
			regsub "\\*\\*\\*" $line "   " \
			       line
			regexp "^($WS*)$NWS" $line \
			       forget outline
			set outline \
			    "$outline[file tail \
			                   $item_name]"
			puts $hich $outline
			puts $wch "<P>"
			puts $wch \
			     "<A HREF=\"$item_name\">\
			      $item_name</A>"
			puts $wch "</P>"
			puts $wch "<BLOCKQUOTE>"
		    }
		}
	    }
	} elseif { [regexp "^$NWS" $line] \
	           || \
		   $item_name != "" } {
	    set p {}
	    lappend p $line
	    set in_p 1
	}
    } else {
        lappend p $line
    }
}

close $hich
close $fch
close $wch
close $ich

if { $web != "" } {
    file copy -force "${help_index}.html"  \
		     "${web}/${help_index}.html"
    file attributes "${web}/${help_index}.html" \
         -permissions r--r--r--
}

exit 0
