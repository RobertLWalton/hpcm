#! /bin/sh
#
# Make index and list of files
#
# File:		makehelp
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Fri Nov 30 03:21:04 EST 2012
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2012/11/30 08:37:44 $
#   $RCSfile: makehelp,v $
#   $Revision: 1.9 $
#
# The next lines start tclsh \
trap "echo makehelp: Terminated by Signal" \
    HUP INT QUIT; \
tclsh "$0" "$@"; exit $status

set document "
makehelp help_index title index web option ...

    Read the index and make the files:

        help_index	   Index
	help_index.html	   WWW index
	help_index.files   List of files to print.
	web/...		   Copies of files in web page
			   directory.
	                  
    Lines beginning with `#' in index are deleted,
    as they are comments.

    Otherwise the index is treated as a sequence of
    paragraphs composed of non-blank lines, with blank
    lines separating the paragraphs.  Paragraphs are
    classified as `indented' if their first character
    is a whitespace, `item header' (see below), and
    `non-indented' otherwise.

    Any paragraph consisting of a single line of the
    format

    	*** FILENAME option ...

    (with possible whitespace before the ***) is called
    an `item header'.  Item headers are `selected' if
    any of their options or their FILENAME is listed as
    a makehelp command option.  When an item header is
    selected, the following are output in order:

	All non-indented paragraphs since the previous
	item header, if any.

	The item header if FILENAME does not name a
	directory.

	All indented paragraphs after the item header
	and before the next item header or non-indented
	paragraph.

    An indented paragraph is a `file list' if it is
    preceded by an item header and possible intervening
    indented paragraphs, if the FILENAME in the item
    header names a directory, and if each line of the
    indented paragraph begins with a whitespace sur-
    rounded NAME that contains no whitespace and whose
    tail, when viewed as a filename, names a file in the
    directory specified by the item header FILENAME.

    This program writes a file named help_index.files
    that is just a list of file names.  The name of
    the help_index file is written first.  Then when an
    item header whose FILENAME does NOT name a directory
    is selected, FILENAME is written.  And when a
    `file list' is recognized, the names of the files
    listed are written.

    Files that are listed in help_index.files are also
    copied to the web directory, if it is not \"\",
    except that help_index.html is also copied (in
    addition to copying help_index).  These copies are
    made read-only to everyone.
    
    The directory names in the FILENAMEs given in item
    headers and the file names given in file lists
    are the names of the subdirectories in `web' in
    which the copied file will appear, and are not the
    names of the directories in which the original of
    the file appears.  In help_index.files these
    directories names are replaced by the names of the
    directories in which the original file appears.

    When an item header is output, the options are
    deleted and the `***'s are converted to 3 spaces.

    All non-item header paragraphs are output as is to
    the help_index.  Non-indented paragraphs ending in
    a line containing just `-'s are preceded by two
    blank lines, and other paragraphs are preceded by
    one blank line.

    Output to help_index.html is as follows:

        If a non-indented paragraph ends in a line con-
	taining just `-'s, then all lines containing
	just `-'s are deleted from the paragraph, and
	the paragraph is surrounded by <H3>...</H3>.
	Otherwise the paragraph is surrounded by
	<P>...</P>.

	If an indented paragraph is a file list, it is
	output as an indented table with the file names
	as links.  Otherwise the paragraph is surrounded
	by <P>...</P>.

	<BLOCKQUOTE>...</BLOCKQUOTE> is used to indent
	item headers and indented paragraphs appearing
	between non-indented paragraphs, and to indent
	indented paragraphs appearing between item
	headers.

    Unlike most HPCM judging programs, this program does
    not read any hpcm_judging.rc file and errors made by
    this program are not written to log files."

set WS "\[\ \t\]"
set NWS "\[^\ \t\]"

# Given a directory name `dir' and a paragraph `p',
# check if each line of the paragraph has the form
#
#   ${WS}*${NAME}${WS}+${REST}${WS}*
#
# where NAME contains no whitespace and REST does not
# begin or end with whitespace (and may be empty), and
# where $dir/[file tail $NAME] names an existing
# ordinary file (or symbolic link to such).  If NO,
# return the empty list.  Otherwise return a list with
# one element per line consisting of
#
#	{ NAME REST }
#
proc is_file_list { p dir } {
    global WS NWS
    set result {}
    foreach line $p {
        if { ! [regexp "^$WS*($NWS+)(|$WS.*)\$" \
	               $line forget \
		       name rest] } {
	    return {}
	}
	if { ! [file isfile $dir/[file tail $name]] } {
	    return {}
	}
	lappend result \
	        [list $name [string trim $rest]]
    }
    return $result
}

# Copy a file's name to fch and the file itself to web
# if the latter is not "".  The file is located
# at src and is to be copied to web/dst.
#
proc print_and_copy_file { fch web src dst } {
    puts $fch $src
    if { $web != "" } {
	file mkdir [file dirname $web/$dst]
	file copy -force $src $web/$dst
	file attributes $web/$dst -permissions r--r--r--
    }
}

# Given the result r of is_file_list above, output
# to wch the html for the file list.  Here dirname is
# the item header FILENAME.
#
proc file_list_to_html { wch r dirname } {
    puts $wch "<TABLE>"
    foreach line $r {
        set name [lindex $line 0]
        set tail [file tail $name]
	set rest [lindex $line 1]
        puts $wch "<TR><TD WIDTH=\"20\"></TD>"
        puts $wch "    <TD><A HREF=\"$dirname/$tail\">"
        puts $wch "        $name</TD>"
        puts $wch "    <TD WIDTH=\"20\"></TD>"
        puts $wch "    <TD>$rest</TD>"
        puts $wch "</TR>"
    }
    puts $wch "</TABLE>"
}

# Output non-indented paragaph to html.  If there is
# any line containing just `-'s and spaces, delete all
# such lines and use <H3>...</H3>.  Otherwise delete no
# lines and output <P>...</P>.
#
# Return 1 if some line contained just `-'s, and 0
# otherwise.
#
proc p_to_html { wch p } {
    global WS
    set use_h 0
    foreach line $p {
        if { [regexp "^$WS*\-\[ \t-\]*\$" $line] } {
	    set use_h 1
	}
    }
    if { $use_h } {
        puts $wch "<H3>"
	foreach line $p {
	    if { ! [regexp "^$WS*\-\[ \t-\]*\$" \
	                   $line] } {
		puts $wch $line
	    }
	}
        puts $wch "</H3>"
    } else {
        puts $wch "<P>"
	foreach line $p { puts $wch $line }
        puts $wch "</P>"
    }
    return $use_h
}

# If too few arguments or first argument begins with
# `-', print documentation and exit with error.
#
if { $argc < 5 || [regexp {^-} [lindex $argv 0]] } {
    puts $document
    exit 1
}

set help_index [lindex $argv 0]
set files "${help_index}.files"
set html "${help_index}.html"
set title [lindex $argv 1]
set index [lindex $argv 2]
set indexdir [file dirname $index]
set web [lindex $argv 3]
set options [lrange $argv 4 end]
set date [exec date]

if { [catch { set hich [open $help_index w] }] } {
    puts "ERROR: could not open $help_index for writing"
    exit 1
}
if { [catch { set wch [open $html w] }] } {
    puts "ERROR: could not open $html for writing"
    exit 1
}
if { [catch { set fch [open $files w] }] } {
    puts "ERROR: could not open $files for writing"
    exit 1
}
if { [catch { set ich [open $index r] }] } {
    puts "ERROR: could not open $index for reading"
    exit 1
}

set count [expr 56 - [string length $title] \
                   - [string length $date]]
set tline "$title[string repeat " " $count]$date"

puts $hich $tline
puts $hich ""

puts $fch $help_index

set p {}
    # current paragraph - a list of lines
set in_p 0
    # 1 if p holds partial paragraph, 0 otherwise
set blank_count 0
    # number of input blank lines preceding current
    # input paragraph, where item headers that are not
    # output are ignored as if they did not exist
set ps {}
    # list of previous non-indented paragraphs

set item_name ""
    # item_name if last item selected, "" otherwise
set item_directory ""
    # [dirname $index]/$item_name if last item is
    # selected and names a directory, "" otherwise
set istate ""
    # set to type of paragraph last input:
    #    "", item_header, indented, non_indented
set ostate ""
    # set to type of paragraph last output:
    #    "", item_header, indented, non_indented
set in_outer_blockquote 0
    # 1 if there is unclosed outer <BLOCKQUOTE>.
    # An outer blockquote is one that brackets
    # all outputted item headers and indented
    # paragraphs following an outputted non-indented
    # paragraph.
set in_inner_blockquote 1
    # 1 if there is unclosed inner <BLOCKQUOTE>.
    # An inner blockquote is one that brackets
    # all outputted indented paragraphs following
    # an outputted item header.

while { ! [eof $ich] } {
    set line [gets $ich]
    if { [eof $ich] || [regexp "^$WS*\$" $line] } {
        if { ! $in_p } {
	    incr blank_count
	} else {
	    
	    # Finish current paragraph.

	    if { [llength $p] == 0 } {

	        # Do nothing if zero length paragraph

	    } elseif { ! [regexp "^$WS" \
	                         [lindex $p 0]] } {

		# Save non-indented paragraph
		#
		lappend ps $p

	    } elseif { $item_name != "" } {

		# Output indented paragraph

		if { $ostate == "non_indented" } {

		    puts $wch "<BLOCKQUOTE>"
		    set in_outer_blockquote 1

		} elseif { $ostate == "item_header" } {

		    puts $wch "<BLOCKQUOTE>"
		    set in_inner_blockquote 1
		}
		set ostate indented

		if { $blank_count > 0 } {
		    puts $hich ""
		}
		foreach l $p { puts $hich $l }

		if { $item_directory == "" } {
		    set r {}
		} else {
		    set r [is_file_list \
		               $p $item_directory ]
		}
		if { $r == {} } {
		    puts $wch "<P>"
		    foreach l $p { puts $wch $l }
		    puts $wch "</P>"
		} else {
		    file_list_to_html \
		        $wch $r $item_name
		    foreach l $r {
			set f [file tail [lindex $l 0]]
			set src "$item_directory/$f"
			set dst "$item_name/$f"
		        print_and_copy_file \
			    $fch $web $src $dst
		    }
		}
	    }
	    set in_p 0
	    set p {}
	    set blank_count 1
	}
    } elseif { [regexp "^$WS*#" $line] } {
        continue
    } elseif { $in_p } {
        lappend p $line
    } else {

        # Start new paragraph

	if {    ! [catch { set len [llength $line] }] \
	     && $len >= 2 \
	     && [lindex $line 0] == "***" } {

	    # item header line

	    if { $in_inner_blockquote } {

		puts $wch "</BLOCKQUOTE>"
		set in_inner_blockquote 0
	    }

	    set item_name ""
	    set item_directory ""

	    set option_list [lrange $line 1 end]
	    foreach option $options {
		if { [expr [lsearch -exact \
				     $option_list \
				     $option] >= 0] } {

		    # item header is selected

		    set item_name [lindex $line 1]
		    break
		}
	    }

	    if { $item_name != "" } {

	        # Output selected item header

		if { $ps != {} } {

		    if { $in_outer_blockquote } {

			puts $wch "</BLOCKQUOTE>"
			set in_outer_blockquote 0
		    }

		    # Output non-indented paragraphs

		    foreach np $ps {
			if { [p_to_html $wch $np] } {
			    puts $hich ""
			}
			puts $hich ""
			foreach l $np {
			    puts $hich $l
			}
		    }
		    set ps {}
		    set ostate non_indented
		}

		set item_directory \
		  "[file dirname $index]/$item_name"
		if { ! [file isdirectory \
			     $item_directory] } {

		    print_and_copy_file \
			$fch $web $item_directory \
				  $item_name

		    set item_directory ""

		    # Output item header

		    if { $ostate == "non_indented" } {

			puts $wch "<BLOCKQUOTE>"
			set in_outer_blockquote 1
		    }

		    puts $hich ""
		    regsub "\\*\\*\\*" $line "   " \
			   line
		    regexp "^($WS*)$NWS" $line \
			   forget outline
		    set outline \
			"$outline[file tail \
				       $item_name]"
		    puts $hich $outline
		    puts $wch "<P>"
		    puts $wch \
			 "<A HREF=\"$item_name\">\
			  $item_name</A>"
		    puts $wch "</P>"

		    set ostate item_header
		    set blank_count 0
		}
	    }

	    set istate item_header

	} elseif { [regexp "^$NWS" $line] } {

	    # Input non-indented paragraph

	    if { $istate != "" \
	         &&
		 $istate != "non_indented" } {
	        set ps {}
	    }

	    set in_p 1
	    set p {}
	    lappend p $line

	    set istate non_indented

	} else {

	    # Input indented paragraph

	    if { $istate == "" } {
	        puts "ERROR: indented paragraph at\
		      beginning of $index"
		exit 1
	    } elseif { $istate == "non_indented" } {
	        puts "ERROR: indented paragraph\
		      immediately follows non-indented\
		      paragraph"
		puts "       in $index"
		exit 1
	    }

	    set in_p 1
	    set p {}
	    lappend p $line

	    set istate indented
	}
    }
}

if { $in_inner_blockquote } {
    puts $wch "</BLOCKQUOTE>"
}
if { $in_outer_blockquote } {
    puts $wch "</BLOCKQUOTE>"
}

close $hich
close $fch
close $wch
close $ich

if { $web != "" } {
    file copy -force "${help_index}"  \
		     "${web}/${help_index}"
    file attributes "${web}/${help_index}" \
         -permissions r--r--r--
    file copy -force "${help_index}.html"  \
		     "${web}/${help_index}.html"
    file attributes "${web}/${help_index}.html" \
         -permissions r--r--r--
}

exit 0
