#! /bin/sh
#
# Pipe a postscript file to all the printers.
#
# File:		printer_broadcast
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Fri Oct 13 08:04:51 EDT 2006
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2006/10/13 12:15:21 $
#   $RCSfile: printer_broadcast,v $
#   $Revision: 1.11 $

Pswitch=0

case "$1" in
   -P)
       Pswitch=1
       ;;
   -doc* )
   	echo "
printer_broadcast filename
printer_broadcast -P

    Print the standard input to all the printers in the
    
    	contest-directory/printer_map

    file if that is readable, or the printer named in
    the
    
    	contest-directory/printer
    
    file otherwise, or if neither file is readable, use
    the printer named in the PRINTER environment var-
    iable.  The printing to each printer is done just
    like hpcm/contestant/bin/printer_pipe, except the
    \`where' argument is replaced by \`JUDGE', and
    printer names beginning with \`!' are ignored (so
    contestant specified printers are ignored).
    
    The standard input to this program should be a
    file to be piped to the printers.  It is usually a
    postscript file, but can be ASCII with form feeds.

    If the -P option is given, the list of printer
    names is output, and no printing is done."

    	exit 1
	;;
esac

filename="$1"

# Locate judging and contest directories.
#
contest=""
for jd in . .. ../.. ../../.. ../../../..
do
    if test -r $jd/hpcm_judging.rc
    then
        contest=$jd/contest
	break
    fi
done

if test "$contest" = ""
then
    echo ERROR: Cannot find hpcm_judging.rc.
    exit 1
fi

if test ! -x $contest
then
    echo ERROR: Cannot access $contest
    exit 1
fi

# Make a list of all printers.
#
printers=""
if test -r "$contest/printer_map"
then

    # Open print map.
    #
    exec 3<"$contest/printer_map"

    # Read print map lines until match found.
    #
    while test x = x
    do
	read <&3 regexp printer
	if test $? -ne 0
	then
	    break
	fi
	case "$regexp" in
	"#*") continue ;;
	"#") continue ;;
	"")   continue ;;
	esac
	printers="$printers $printer"
    done

    # Close printer_map file.
    #
    exec 3<&-

elif test -r "$contest/printer"
then
    printers=`cat "$contest/printer"`
elif test "${PRINTER:-}" != ""
then
    printers=$PRINTER
else
    echo >&2 Could not find printers.
    exit 1
fi

# If not -P, copy standard input into tmpfile.
#
if test $Pswitch -eq 0
then
    tmpfile="/tmp/printer_broadcast$$"
    trap "rm -f $tmpfile" 0
    rm -f $tmpfile
    cat >$tmpfile
fi

# Print tmpfile to all printers, or just echo
# printer name if -P.
#
for printer in $printers
do
    # Ignore blank printer names or printer names
    # beginning with !.
    #
    if test ` expr "$printer" : "!" ` -ne 0
    then
    	continue
    fi

    if test "$printer" = ""
    then
    	continue
    fi

    if test $Pswitch -ne 0
    then
    	echo -n " $printer"
	continue
    fi

    # If printer_jobs exists, announce job therein.
    #
    if test -w $contest/printer_jobs; then
	shortpr=`expr "$printer" : "\\([^<]*\\)<"`
	if test "$shortpr" = ""
	then
	    shortpr="$printer"
	fi
	line=`date "+%a %r"`
	line="$line $shortpr $filename JUDGE"
	echo "$line" \
	     >> $contest/printer_jobs
    fi

    # Send the print job to the printer.

    case "$printer" in
	\|*)
	    c=` expr "$printer" : '|\(.*\)$' `
	    cat | eval "$c"
	    ;;
	@*)
	    a=` expr "$printer" : '@\(.*\)$' `
	    if ( head -1 $tmpfile | \
	         grep '^%!PS' >/dev/null 2>&1 )
	    then
		m=application/postscript
		D="$filename postscript"
	    else
		m=text/plain
		D="$filename"
	    fi
	    metasend -b -s "$filename JUDGE" -t "$a" \
		     -e base64 -m $m -D "$D" -f $tmpfile
	    ;;
	*@*)
	    ( echo "To: $printer"; \
	      echo "Subject: $filename JUDGE"; \
	      echo ""; cat $tmpfile ) \
	          | /usr/sbin/sendmail -t
	    ;;
	*)
	    lpr -P$printer < $tmpfile
	    ;;
    esac

done

if test $Pswitch -ne 0
then
    echo ""
fi

exit 0
