#!/bin/sh -f
#
# Manually examine the contents of a directory and
# possibly reply, maybe with a manual score.
#
# File:		manualreply
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Thu Sep 21 05:31:10 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/09/21 11:48:23 $
#   $RCSfile: manualreply,v $
#   $Revision: 1.7 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory; manualreply

    Given a submission directory as the current dir-
    ectory, permit a person to examine the contents of
    the directory and construct an email reply, or
    alternatively, create a $no_reply_file file that\
					indicates
    that there is to be no reply.  A $manual_score_file\
					    file
    may also be constructed and this score sent in the
    reply."

# If there are any arguments, print documentation and
# exit with error.
#
if { $argc != 0 } {
    puts $document
    exit 1
}

# Several of the following functions add text lines to
# the end of a variable, rather than writing to stdout.
# By accumulating text in a variable and writing it in
# a single puts statement, and by designing successive
# puts strings to have the same layout, we get the
# effect of having a single window.
#
# The window has the following parts:
#
#	window_blank	blank lines above window
#	window_display	file list or file
#	window_info	information specific to window
#	window_error	error line just above prompt
#	window_prompt	prompt and user response line
#
# The last two are 1 line.  The height of window_info
# is carefully controlled, the height of the window_
# display is suggested (its actually a maximum), and
# the height of the entire window is controlled unless
# it is too large.  The window_display should end with
# a bar.
#
set window_blank ""
set window_display ""
set window_info ""
set window_error ""
set window_prompt ""
set window_height 40
set window_display_height 12
set window_info_height 6

set window_newlines "\n\n\n\n\n\n\n\n\n\n"
set window_newlines "$window_newlines$window_newlines"
set window_newlines "$window_newlines$window_newlines"
set window_newlines "$window_newlines$window_newlines"
set window_newlines "$window_newlines$window_newlines"

proc display_window {} {

    global window_blank window_display window_info \
    	   window_error window_prompt

    set b $window_blank
    set d $window_display
    set i $window_info
    set e $window_error
    set p $window_prompt
    puts "$b\n$d\n$i\n$e\n$p"
    flush stdout
}

proc set_window_info { info } {

    global window_info window_info_height \
    	   window_newlines

    set height [llength [split $info "\n"]]
    if { $height > $window_info_height } {
    	error "window info too high:\n$info"
    }
    set offset [expr { $window_info_height \
    		       - $height - 1 }]
    set window_info \
        "[string range $window_newlines \
	         0 $offset]$info"
}

proc set_window_display { display } {

    global window_blank window_display \
    	   window_height window_info_height \
	   window_newlines

    set height [llength [split $display "\n"]]

    set offset \
        [expr { $window_height \
	        - $window_info_height - 2 \
		- $height - 1 }]
    set window_blank \
        [string range $window_newlines 0 $offset]
    set window_blank $display
}

set window_bar "===================="
set window_bar "$window_bar$window_bar"
set window_bar "$window_bar$window_bar"

proc bar_with_text { text } {
    global window_bar
    set l [expr 80 - 2 - [string length $text]]
    return "[string range $window_bar 0 $l] $text"
}

# Set the window display to display the first lines
# of the file.
#
proc set_file_display { filename }

    global window_display_height

    set height [expr { $window_display_height - 2 }]
    set display [bar_with_text "$filename:"]

    set file_ch [open $filename r]
    set n 0
    while { "yes" } {
    	set line [gets $file_ch]
	if { [eof $file_ch] } break

	incr n

	if { $n <= $height } {
	    set display "$display\n$line"
	}
    }
    close $file_ch

    if { $n > $height } {
	set more [expr { $n - $height }]
    	set bar [bar_with_text "......................\
		 there are $more lines in the file"]
    } else {
        set bar [bar_with_text " end-of-file"]
    }
    set_window_display "$display\n$bar"
}


# List of files in the current directory.  The N'th
# item on the list is itself a list of subitems
# with the format:
#
#	ctime mtime filename comment new
#
# The total list is sorted by ctime.  Ctime equals
# mtime, the file's modification time, with 0's
# prepended so all ctimes are the same length of
# items will be the same as numeric comparison of
# mtimes.
#
# The comment is to be printed after the filename if
# the file name is not too long.  Generally non-
# error log file names are short enough for the comment,
# and error log file names are too long.
#
# `New' is `*' if the file is new since the last time
# the file list was computed, and the previous file list
# was not empty.  Otherwise `new' is "".
#
# Below `file_list' is a simple list of file names that
# can be lsearch'ed.  `file_list_items' has the list of
# items described above.  The number of files is in
# `file_list_length'.  The mtime of the $received_file
# file is in `file_list_origin_mtime', unless there is
# no such file, in which case the mtime of the oldest
# file is there instead.
#
set file_list ""
set file_list_items ""
set file_list_length 0
set file_list_origin_mtime 0

# Recompute the file list.  New files are marked unless
# the file list was previously empty.
#
proc refresh_file_list { } {

    global file_list file_list_items file_list_length \
    	   file_list_origin_mtime received_file

    set new_file_list [glob -nocomplain *]
    set new_file_list_items ""
    set n 0
    set origin ""
    set oldest 0
    foreach file $new_file_list {
	set mtime [file mtime $file]
	if { $file == $received_file } {
	    set origin $mtime
	}
	if { $mtime > $oldest } {
	    set oldest $mtime
	}
    	set item [format {%040d} $mtime]
	lappend item $mtime
	lappend item $file
	set size [file size $file]
	if { $size == 0 } {
	    lappend item "(empty)"
	} elseif { ! [file readable $file] } {
	    lappend item "(unreadable file)"
	} else {
	    set file_ch [open $file r]
	    set line [gets $file_ch]
	    gets $file_ch
	    if { [eof $file_ch] \
	         && [string length $line] < 35 } {
	    	lappend item "{$line}"
	    } else {
		lappend item "(${size}b)"
	    }
	    close $file_ch
	}

	set new ""
	if { $file_list_length != 0 \
	     && [lsearch -exact $file_list $file] \
	        < 0 } {
	    set new "*"
	}
	lappend item $new

	lappend new_file_list_items $item
	incr n
    }

    set file_list $new_file_list
    set file_list_items [lsort $new_file_list_items]
    set file_list_length $n

    if { $origin != "" } {
    	set file_list_origin_mtime $origin
    } else {
    	set file_list_origin_mtime $oldest
    }
}

# Set the window display to the file list.
#
proc set_file_list_display {} {

    global file_list_items file_list_origin_mtime \
    	   window_bar

    set display "$window_bar"

    set n 0
    set previous ""

    # If `previous' is non-empty it is the previous
    # item and has no more than 39 characters.
    #
    foreach item $file_list_items {
	incr n
	set time [expr { [lindex $item 1] \
	                 - $file_list_origin_mtime }]
	if { $time < 0 } {
	    set sign "-"
	    set time [expr { - $time }]
	} else {
	    set sign ""
	}
	set mm [expr { $time / 60 }]
	set hh [expr { $mm / 60 }]
	set mm [expr { $mm - 60 * $hh }]
	set tttt "$sign[format {%d:%02d} $hh $mm]"
	if { [string length $tttt] > 6 } {
	    set tttt "${sign}inf"
	}
	set next [format {%3d. %6.6s%1.1s %s} \
			 $n \
			 $tttt [lindex $item 4] \
			 [lindex $item 2]]
	set commented "${next} [lindex $item 3]"

	if { [string length $commented] <= 80 } {
	    set next $commented
	}
	if { [string length $next] > 39 } {
	    if { $previous != "" } {
	    	set next "$previous\n$next"
	    }
	    set previous ""
	} elseif { $previous != "" } {
	    set next [format {%-40s%s} $previous $next]
	    set previous ""
	} else {
	    set previous $next
	    set next ""
	}

	if { $next != "" } {
	    set display "$display\n$next"
	}
    }

    if { $previous != "" } {
	set display "$display\n$previous"
    }

    set_window_display "$display\n$window_bar"
}

# Given a file number, set `last_file' to the name of
# the corresponding file, and return `OK'.  If there is
# an error, leave `last_file' alone, and return an error
# description (of less than 60 characters) instead.
#
proc get_file { number } {

    global file_list file_list_length last_file

    if { $number == "" } {
	if { $last_file == "" } {
	    return "No previous file!"
	} else {
	    return OK
	}
    } elseif { $number < 1 \
               || $number > $file_list_length } {
	return "Bad file number: $number"
    } else {
	set last_file \
            [lindex [lindex $file_list \
                            [expr { $number - 1 }]] 1]
	return OK
    }
}

proc yes? {} {

    global window_error

    while { "yes" } {
    	set answer [string trim [gets stdin]]
	if { [eof stdin] } {
	    puts "Exiting manualreply"
	    exit 0
	}
	switch $answer {
	    y	-
	    yes	-
	    Y	-
	    YES	{ return yes }
	    n	-
	    no	-
	    N	-
	    NO	{ return no }
	}
	if { $answer == "" } {
	    set window_error \
		    "ERROR: empty answer"
	} else {
	    set window_error \
		    "ERROR: could not understand `$answer'"
	}
	display_window
        set window_error ""
    }
}

# Initialize the file list and the last_file variable.
#
refresh_file_list
set last_file ""

set_file_list_display
set_window_info "
POO BAH
"
set window_prompt "y or n? "

set n 0
while { "yes" } {
    incr n
    set window_error "TRY $n"
    display_window
    yes?
}

exit 0
    


# Read the received mail header.
#
set received_ch [open $received_file r]
read_header $received_ch
close $received_ch

if { [llength $message_subject] == 2 \
     && [lindex $message_subject 0] == "submit"
     && [llength [glob -nocomplain \
                       $reply_file \
                       $no_reply_file \
                       $auto_score_file \
                       *-unchecked-error]] == 0 } {


    set_file_list_display
    set_window_info "
It appears that `autojudge' should be run."
    set window_prompt "Do you want to do so (y or n)? "

    if { [yes?] } {

    	puts "Running autojudge"
	exec autojudge >@ stdout 2>@ stderr

	if { ! [file exists $auto_score_file] } {
	    puts "autojudge FAILED to make\
	         $auto_score_file"
	}
	puts "Type any character to continue"
	gets stdin
	if { [eof stdin] } {
	    puts "Exiting manualreply"
	    exit 0
	}
}

while { "yes" } {

    puts "Directory [file tail [pwd]]"
    puts ""
    put_file_list
    puts -nonewline "
v# = view #           e# = edit #        c# = checkoff #
ir = initiate reply   er = edit reply    sr = send reply
sh = call shell       u# = uncheckoff #	 x  = exit
ad = call autodispatch      ms = call manualscore

> "
    set answer [gets stdin]
    if { [eof stdin] } {
    	exit 0
    }

    if { [llength $answer] == 0 } {
    	continue;
    } elseif { [llength $answer] > 1 } {
        puts "Unknown: $answer"
	continue;
    }

    set answer [lindex $answer 0]

    switch -regexp $answer \
        {^v[0-9]*$} {
	    regexp {^v([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		view_file $last_file
	    }
	} \
	{^e[0-9]*$} {
	    regexp {^e([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		edit_file $last_file
	    }
	} \
	{^c[0-9]*$} {
	    regexp {^c([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		catch { set last_file \
			    [make_checked \
			     $last_file] } out
		if { $out != "" } {
		    puts $out
		}
	    }
	} \
	{^u[0-9]*$} {
	    regexp {^u([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		catch { set last_file \
		            [make_unchecked \
			     $last_file] } out
		if { $out != "" } {
		    puts $out
		}
	    }
	} \
	{ir} {
	    compose_reply -all
	    set last_file $reply_file+
	    edit_file $last_file
	} \
	{er} {
	    set last_file $reply_file+
	    edit_file $last_file
	} \
	{sr} {
	    if { ! [file exists $reply_file+] } {
		puts "No reply composed!"
	    } else {
	        puts "Do you want to send:"
	        puts ""
	        put_file $reply_file+ stdout 12
		puts -nonewline "
(y or n)? "
	        set answer [gets stdin]
	        if { [eof stdin] } {
		    exit 0
		} elseif { [regexp {^[yY]} $answer] } {
		    puts "Sending..."
		    send_reply
		    set last_file $reply_file
		} else {
		    puts "Send ABORTED!"
		}
	    }
	} \
	{sh} {
	    call_shell
	} \
	{ad} {
	    exec autodispatch -force \
	         >@ stdout 2>@ stderr
	} \
	{ms} {
	    exec manualscore >@ stdout 2>@ stderr
	} \
	{x} {
	    exit 0
	}

    refresh_file_list
}


# Include common error catching code:
#
} caught_output
caught_error
