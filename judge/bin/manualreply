#!/bin/sh
#
# Manually examine the contents of a directory and
# possibly reply, maybe with a manual score.
#
# File:		manualreply
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Tue Jan 22 21:19:56 EST 2002
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2002/01/23 02:29:19 $
#   $RCSfile: manualreply,v $
#   $Revision: 1.47 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Table of Contents:
#
#	Startup
#	Display
#	Reading Files
#	File List
#	Response Functions
#	Locking Functions
#	Reply Functions
#	Menu Initialization
#	Menu Loop


# Startup
# -------

# If an subdirectory name is given, make it current, and
# consume the subdirectory name argument.  This must be
# done before looking for the parameters file.
#
# Don't change argc or argv so error output will work.
#
set my_argc $argc
set my_argv $argv
if { $my_argc >= 1 \
     && ! [regexp {^-} [lindex $my_argv 0]] } {
    cd [lindex $my_argv 0]
    set my_argv [lreplace $my_argv 0 0]
    set my_argc [expr { $my_argc - 1 }]
}

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
source $lib_directory/display_common.tcl
source $lib_directory/scoring_common.tcl
catch {

set document "
manualreply \[directory\]

    If the directory argument is given, this program
    makes that directory current before searching for
    the `$judging_parameters_file' file or doing\
    anything else.

    Given a submission directory as the current direc-
    tory, this program permits a person to examine the
    contents of this directory and construct an email
    reply, or alternatively, create a $no_reply_file\
    		file that
    indicates there is to be no reply.  A\
    		$manual_score_file
    file may also be written with a score that is sent
    in the reply.  Unchecked error log files may be
    inspected and checked off.

    As a complex interactive program, manualreply has
    extensive builtin help documentation."

# If there are any arguments, print documentation and
# exit with error.
#
if { $my_argc != 0 } {
    puts $document
    exit 1
}


# Menus.

set main_menu "
    ? = help        \
x = exit            \
sm = scoring menu   \
ss = send score
#  = look at #      \
v# = view #         \
e# = edit #         \
ls = list files
pr = lookat proofs  \
c# = checkoff #     \
u# = uncheckoff #   \
sh = shell
ir = initiate reply \
er = edit reply     \
sr = send reply     \
nr = no reply
sq = send query     \
xq = examine query  \
aj = autojudge      \
ai = autoinfo"

set scoring_menu "
                        ? = help                       \
x  = exit
io = Incorrect Output   cc = Completely Correct        \
 #  = look at #
fe = Formatting Error   ic = Incomplete Output         \
 mm = back to main menu
se = Syntax Error       te = Cpu Time Limit Exceeded   \
 ss = send score + mm
pc = Program Crashed    oe = Output Size Limit Exceeded\
 pr = lookat proofs"

# Help displays.
#
# These must begin and end with a blank line.  The
# blank lines are changed to window bars by code.

set help(?) "
? WHAT

Gives help for WHAT, where WHAT can be:

    Any command listed in the main or scoring menu. \
    	E.g. `? ls'.
    Note that any command in either menu can be\
    	executed even
    if the other menu is being displayed.

    Any standard filename, e.g. `? Received_Mail', or\
    	any standard file
    extension, e.g., `? .diff'.
    
Type `? topics' for list of help topics.
"

set help(#) "
#			# denotes a `file\
                        identifier'.   This is one of:

  - The decimal integer number of a file listed by the\
    	last `ls' command.
  - A file extension, beginning with a `.'.
  - The beginning of a file name, if the first\
        character of the name is
    a CAPITAL letter.
  - The full name of the file.

Typing a file identifier by itself is recoginzed as a\
    command to display
the file, if the file identifier is unambiguous.
"

set help(x) "
x

Exit from the current program.  You can also do this by\
    typing control-D.
"

set help(sq) "
sq

Send a query to the judge about the current submission.

You can do this if you are the judge or are an auxilary\
    `read only' judge.

A file to be emailed to the judge is created in the\
    /tmp directory and the
editor is called on that file.  The subject of the\
    email is set to indicate
the current submission directory, and this subject\
    SHOULD NOT be changed.
You should edit the body of the message, and upon\
    return from the editor,
you will be asked if you want to send the message to\
    the judge, or continue
editing the message, or abort the message.
"

set help(xq) "
xq

Examine a submission mentioned in the subject of a\
    query to the judge.

If the current submission is a query whose `Subject:'\
    is of the form
`About SUBMISSION-DIRECTORY', this command executes\
    `manualreply' on the
indicated submission directory.  This is useful in\
    examining the submission
directory mentioned in a query created by the sq\
    command.  When the
`manualreply' executed returns, this `manualreply'\
    continues.
"

set help(aj) "
aj

Call `autojudge' in the current directory.  The\
    autojudge program makes
any missing or out of date Auto_Score file and any\
    missing or out of date
files needed to make a new Auto_Score file.
"

set help(v) "
v
v #

View the file identified by the file identifier # (or\
    the last file displayed
if # is missing) using an editor in read only mode,\
    such as UNIX `view'.
"
set help(v#) $help(v)

set help(e) "
e
e #

Edit the file identified by the file identifier # (or\
    the last file displayed
if # is missing) using an editor such as UNIX `vi'.
"
set help(e#) $help(e)

set help(ls) "
ls

List the names of all the files in the current\
    directory.  This list is in
order of the file creation dates, and the time the file\
    is created is given
to the nearest minute, relative to the creation time of\
    the $received_file
file if that is present, or of the most recent file\
    otherwise.  Here `inf'
means a time too large to be displayed.

The files are numbered.  These numbers can be used as\
    file identifiers in
other commands.  The numbers will change when files are\
    deleted.

Type `? ls2' for more information.
"
set help(ls2) "
ls      (2 of 3)

After each listed file name one of the following may\
    appear if there is room:

    (DDDDDb)		DDDDD is size of the file in\
			    bytes.
    (empty)		The file is empty.
    (directory)		The file is a directory.
    (dangling link)	The file is a link with no\
			    resolution.
    {CCC}		CCC is the contents of a single\
			    line file.

Type `? ls3' for more information.
"
set help(ls3) "
ls      (3 of 3)

If a file is listed that is newly created, a * appears\
    after the file time.
This * disappears when the list of files is\
    regenerated, so its presence
is not that reliable.
"

set help(ai) "
ai

Run the `autoinfo' program in the current\
    directory.  If the $received_file
file has a subject of the form `get ...', the autoinfo\
    program will send
an email response containing the files named in the\
    subject.
"

set help(pr) "
pr

Look at proofs of the score assigned by the `autoscore'\
    program (which is called
by `autojudge').  Each proof consists of a pair of\
    tokens, one in the .out file
and one in the .test file, that should match but do\
    not.  The mismatch is given
a name, called a difference type name, such as\
    `integer' or `word'.  The tokens
and the lines surrounding them are displayed.  The\
    tokens are highlighted.  The
difference type name is displayed on the last ==== bar\
    line.  If the difference
type is `integer' or `float', after its name the\
    absolute and relative differ-
ence of the mismatched integer or floating point\
    number tokens are displayed.

Type `? pr2' for more information.
"

set help(pr2) "
pr      (2 of 4)

You can look at proofs in a particular proof group:\
    e.g, if the score is
`Incorrect Output' the proofs relevant to that score\
    are in the `io' group.
The `n' and `p' commands move to the next or previous\
    proof in the current proof
group.  Proofs are ordered according to position of the\
    tokens in the files.
The number of the current proof within its group is in\
    brackets on the last
==== bar line of the display.  For groups that support\
    scores, the name of the
group is also within these brackets.

Type `? pr3' for more information.
"

set help(pr3) "
pr      (3 of 4)

There is one group for each possible score for which\
    there are supporting
proofs.  These groups, their two letter group names,\
    and the difference types
of proofs supporting each score are listed just above\
    the prompt.  Also listed
for each difference type is the number of proofs of\
    that type in square brackets
(however, only the first so many proofs of each type\
    are available).

There is also one proof group for each difference type\
    listed in the lines
above the prompt that describe the score groups.

Type `? pr4' for more information.
"

set help(pr4) "
pr      (4 of 4)

To change the proof group type its name.   You can\
    contract this name by
omitting characters from its end or before any\
    `-' in the name, so long as
what you type begins with a letter and has two or\
    more characters.
"

set help(c) "
c
c #

Change the unchecked error file identified by # (or the\
    last file displayed
if # is omitted) to be a checked error file.  This is\
    done by renaming the
file so the `unchecked' part of the name becomes\
    `checked'.

Unchecked error files are searched for by programs such\
    as `tracker', and
brought to the attention of a person.  But checked\
    error files are ignored by
these programs, as they assume a checked error file\
    has been read by a person.
"
set help(c#) $help(c)

set help(u) "
u
u #

Change the checked error file identified by # (or the\
    last file displayed
if # is omitted) to be a unchecked error file.  This is\
    done by renaming the
file so the `checked' part of the name becomes\
    `unchecked'.

Unchecked error files are searched for by programs such\
    as `tracker', and
brought to the attention of a person.  But checked\
    error files are ignored by
these programs, as they assume a checked error file\
    has been read by a person.

It is unusual for a checked file to be made unchecked.
"
set help(u#) $help(u)

set help(sh) "
sh

Execute a shell (such as csh) in the current directory\
    as a subprogram.
When the shell is exited, this program resumes.
"

set help(ir) "
ir

Create a reply file (named $reply_file+) and invoke an\
    editor (e.g., vi)
for that file.  If a reply file already exists, it is\
    overwritten.
"

set help(er) "
er

Edit an existing reply file (the file named\
    $reply_file+), creating the
file first if it does not already exist.
"

set help(sr) "
sr

Send the reply file to the submitter, after first\
    displaying it and asking
the user to be sure it should be send.  The reply file\
    is the file named
$reply_file+ that is created by the `ir' or `er'\
    commands.
"

set help(nr) "
nr

Has the user type a line that is then written into a\
    newly created one line
$no_reply_file file.  The presence of this file\
    indicates to HPCM that no
reply needs to be generated for the current submission\
    directory.  For example,
the `tracker' program searches for submission\
    directories that do NOT contain
either a $reply_file file or a $no_reply_file file.

The `lookat' program can search for submission\
    directories whose $no_reply_file
files have contents matching a regular expression, so\
    what is written into the
$no_reply_file can be used to find the submission\
    directory later.
"

set help(sm) "
sm

Change the menu displayed to the scoring menu.  When\
    not in a subtask such
as displaying proofs, one of two menus is displayed:\
    the main menu, or the
scoring menu.  No matter which of these two menus is\
    displayed, all
commands listed on both menus can be entered.
"

set help(mm) "
mm

Change the menu displayed to the main menu.  When not\
    in a subtask such
as displaying proofs, one of two menus is displayed:\
    the main menu, or the
scoring menu.  No matter which of these two menus is\
    displayed, all
commands listed on both menus can be entered.
"

set help(ss) "
ss

Composes a reply message ($reply_file+ file) containing\
    the proposed score
and sends that message.  Sets the manual score (in the\
    $manual_score_file file)
to this proposed score.  If anything unusual exists,\
    such as the presence of a
previous manual score, the user is given a chance to\
    edit and abort the
message before it is sent.

After the message is sent this command restores the\
    main menu.
"

set help(io) "

io = Incorrect Output    cc = Completely Correct
fe = Formatting Error    ic = Incomplete Output
se = Syntax Error        te = Cpu Time Limit Exceeded
pc = Program Crashed     oe = Output Size Limit Exceeded

Set the proposed score to the indicated value.
"

set help(ps) "

ps XX		where XX is one of:

io = Incorrect Output    cc = Completely Correct
fe = Formatting Error    ic = Incomplete Output
se = Syntax Error        te = Cpu Time Limit Exceeded
pc = Program Crashed     oe = Output Size Limit Exceeded

Set the proposed score to the indicated value.  This\
	command is only valid
when displaying proofs with the `pr' command.  When\
	the main or scoring menus
are displayed, XX can be typed by itself as a command.
"

set help(cc) $help(io)
set help(fe) $help(io)
set help(ic) $help(io)
set help(se) $help(io)
set help(te) $help(io)
set help(pc) $help(io)
set help(oe) $help(io)


set help($reply_file) "
$reply_file		The last and final reply\
			   message.  If this is present,
			the judge has finished with\
			  this submission.

$no_reply_file		A file whose presence indicates\
    the judge has finished
			with this submission but is\
			  not going to reply.  By
			putting a comment in this file,\
			  the judge can locate
			the submission later by using\
			  the lookat program to
			search for submissions with a\
			  particular $no_reply_file
			comment.

See also: $received_file, $reply_file+, and\
    $reply_history_file.
"
set help($no_reply_file) $help($reply_file)


set help($received_file) "
$received_file		The submission mail message. \
			  The `Subject:' of this
			message determines whether the\
			  submission is a `get',
			a `submit', or a query.

$reply_file+		A reply from the judge to the\
			  submitter that is under
			construction, and not yet\
			  sent.  Can be editted by
			the `er' command and sent by\
			  the `sr' command.

$reply_history_file	A copy of all the replies sent\
			  to the submitter by
			the judge.

See also: $reply_file and $no_reply_file.
"
set help($reply_file+) $help($received_file)
set help($reply_history_file) $help($received_file)


set help($auto_score_file) "
$auto_score_file	The score produced\
		    automatically by the autojudge\
		    program
		(which calls autoscore to produce the\
		    score).

$manual_score_file	The score enterred manually\
		    by using the `manualreply' program.
		See the `sm' and `ss' commands.

.score		The file produced by the scorediff\
		    program that describes the
		differences between the .out and\
		    .test files.  The first line
		lists all the differences, and\
		    subsequent lines list proofs.
		A proof specifies the locations of\
		    mismatched tokens in the
		two files.
"
set help($manual_score_file) $help($auto_score_file)
set help(.score) $help($auto_score_file)



set help(.c) "
.c	Source file for a solution written in C.

.cc	Source file for a solution written in C++.

.java	Source file for a solution written in JAVA.

.p	Source file for a solution written in PASCAL.
"
set help(.cc) $help(.c)
set help(.java) $help(.c)
set help(.p) $help(.c)



set help($make_file) "
$make_file	Makefile to make solution binary and\
		    .out file.  Symbolic link
		to solution directory.

$scoring_instructions_file	Scoring instructions\
			    for autoscore program. \
			    Optional.
			Symbolic link to solution\
			    directory.
"
set help($scoring_instructions_file) $help($make_file)


set help(.p2c) "
.p2c	Intermediate file, the translation of a PASCAL\
	    .p file into the
        C language.

.class	JAVA relocatable binary (byte code) file.

.cerr	Solution compiler error output.  Does NOT\
	    affect score.

No extension; with same basename as solution source.
	Binary executable of the solution.  For JAVA\
	    this is a shell script
	invoking the .class file with the same basename\
	    as the source.
	If missing, score is `Syntax Error'.
"
set help(.class) $help(.p2c)
set help(.cerr) $help(.p2c)



set help(.in) "
.in	Judge's input.  Symbolic link to solution\
	    directory.

.test	Judge's output.  Symbolic link to solution\
	    directory.

.out	Solution output.  If empty, score is `Program\
	    Crashed'.

.err	Solution error output.  If non-empty, score is\
	    `Program Crashed' or
        something more specific, such as `Output Limit\
		    Exceeded'.

core	Core dump of the solution execution; usually\
	    only present if the
	solution crashed.  Does NOT affect score.
"
set help(.test) $help(.in)
set help(.out) $help(.in)
set help(.err) $help(.in)
set help(core) $help(.in)


set help(.diff) "
.diff	Result of `diff *.out *.test'.  This file is\
	    not created until it
	is viewed.

.bdiff	Result of `diff -b *.out *.test'.  This file\
	    is not created until it
	is viewed.
"
set help(.bdiff) $help(.diff)


set help(topics) "
List of help topics:

"
set c 0
foreach topic [lsort [array names help]] {
    set l [string length $topic]
    incr l 4
    incr c $l
    if { $c > 80 } {
        set help(topics) "$help(topics)\n"
	set c $l
    }
    set help(topics) "$help(topics)    $topic"
}
set help(topics) "$help(topics)\n"

# Menu Initialization
# ---- --------------

# Set if in readonly mode.
#
set readonly_mode yes

if { [file writable "."] } {
    set readonly_mode no
    get_lock
}

refresh_file_list

# If auto score file, reply file, no_reply file,
# and unchecked errors do not exists, consider running
# autojudge, if not in readonly mode.
#
if { $readonly_mode == "no" \
     && $submitted_program != "" \
     && [llength [glob -nocomplain \
                       $reply_file \
                       $no_reply_file \
                       $auto_score_file \
                       *-unchecked-error]] == 0 } {


    set_file_list_display
    set window_info_height 5
    set_window_info "
It appears that `autojudge' should be run."
    set window_prompt "Do you want to do so (y or n)? "
    set window_error ""

    display_window

    if { [yes?] } {

    	puts "Running autojudge"
	catch { exec autojudge >&@ stdout }

	if { ! [file exists $auto_score_file] } {
	    puts "autojudge FAILED to make\
	          $auto_score_file"
	}
	continue?
    }
}

set menu $main_menu

set directory [file tail [pwd]]
set proposed_score none
set last_file ""
set last_display ""

# Procedure to recompute window_display for menu loop.
#
proc refresh_display {} {

    global last_display last_file last_help

    if { $last_display == "file_list" } {
	set_file_list_display
    } elseif { $last_display == "file" } {
	set_file_display $last_file
    } elseif { $last_display == "help" } {
	set_window_display $last_help
    }
}

# Procedure to recompute window_info for menu loop.
#
proc refresh_info {} {

    global proposed_score manual_score auto_score \
    	   window_info_height directory menu \
	   scoring_instructions submitted_program

    set old_info_height $window_info_height

    if { $proposed_score == "none" } {
	if { $manual_score != "none" } {
	    set proposed_score $manual_score
	} else {
	    set proposed_score $auto_score
	}
    }
    if { $submitted_program == "" } {
    	set scoring_info ""
	set window_info_height 6
    } else {
	set scoring_info "
Scoring Instructions: $scoring_instructions"

	if { $manual_score == "none" } {
	    set scoring_info "$scoring_info
Scores:  Auto: $auto_score   Proposed: $proposed_score"
	    set window_info_height 8
	} elseif { $proposed_score == "none" } {
	    set scoring_info "$scoring_info
Scores:  Auto: $auto_score   Manual: $manual_score"
	    set window_info_height 8
	} else {
	    set scoring_info "$scoring_info
Scores:  Auto: $auto_score   Manual: $manual_score
           Proposed: $proposed_score"
	    set window_info_height 9
	}
    }

    set_window_info \
        "Dir: $directory$scoring_info$menu"

    # Refresh the display if window_info_height is
    # changed.
    #
    if { $window_info_height != $old_info_height } {
        refresh_display
    }
}

# Function to recompute info for proofs menu loop.
#
proc refresh_proofs_info { } {

    global window_info_height scoring_instructions \
	   auto_score proposed_score

    set info "[compute_proof_info]   \
        Scores:  Auto: $auto_score   Proposed:\
			        $proposed_score\n   \
	Scoring Instructions:\
	    $scoring_instructions\n   \
        n|p = goto next|previous proof  \
        ? = help   x = exit   ss = send score + mm\n   \
        mm|sm = return to main|scoring menu  \
        ps XX = set propose score to XX"

    set window_info_height [llength [split $info "\n"]]
    set_window_info $info
}

# Execute ss command for main or proof loop.
#
proc send_score { } {

    global proposed_score window_error last_file \
           reply_file window_prompt last_display

    if { [not_readonly] == "no" } {
	# do nothing
    } elseif { $proposed_score == "none" } {
	set window_error "ERROR: set the\
	    proposed score before sending it"
    } elseif { [compose_score_reply] } {
	send_score_reply
	set last_file $reply_file
	set last_display file
	set window_error "Score sent!"
    } else {
	set window_error "NOTICE: Old manual\
	    score exists or scoring mode is\
	    `auto'."
	set window_prompt "To continue you\
	    must edit reply.  Do you want to\
	    continue (y or n)? "
	set last_file $reply_file+
	set_file_display $reply_file+
	display_window
	if { [yes?] } {
	    edit_file $last_file
	    set window_error "Reply is ready\
		to send."
	    set window_prompt "Do you want to\
		send it (y or n)? "
	    display_window
	    if { [yes?] } {
		send_score_reply
		set last_file $reply_file
		set window_error "Score sent!"
	    } else {
		set window_error "Score sending\
		    ABORTED!"
		set last_display file_list
	    }
	} else {
	    set window_error "Score sending\
		ABORTED!"
	    set last_display file_list
	}
    }
}

# Execute ? command for main or proof loop.
#
proc display_help { } {

    global help window_error last_help window_bar \
           last_display answer

    regexp {^\? *([^ ]*)$} $answer forget what
    if { $what == "" } {
	set what "?"
    } elseif { ! [info exists help($what)] } {
	set window_error \
	    "ERROR: no help available for\
			  `$what'!"
	set what "?"
    }
    set last_help $help($what)
    set last_help \
	"$window_bar$last_help$window_bar"
    set_window_display $last_help
    set last_display help
}

# Function to run proof display loop.
#
proc display_proofs {} {

    global last_file window_error window_prompt \
	   proposed_score answer

    if { [catch {

		    compute_instruction_array
		    compute_score_and_proof_arrays
		    compute_score

		} out] } {
	set window_error $out
	return ""
    }

    refresh_proofs_info

    if { [get_proof] == "no" } return ""
    if { [set_proof_display] == "no" } return ""

    while { "yes" } {

	set window_prompt "> "
	display_window
	set window_error ""

	set answer [string trim [gets stdin]]
	switch -regexp -- $answer {
	    {^mm$} { return mm }
	    {^sm$} { return sm }
	    {^x$} {
		exit_cleanup
		exit 0
	    }
	    {^ss$} {
		send_score
		return mm
	    }
	    "^ps[ \t]" {
		set l [llength $answer]
		switch ${l}_[lindex $answer 1] {
		    2_io {
			set proposed_score \
			    "Incorrect Output"
			refresh_proofs_info
		    }
		    2_cc {
			set proposed_score \
			    "Completely Correct"
			refresh_proofs_info
		    }
		    2_fe {
			set proposed_score \
			    "Formatting Error"
			refresh_proofs_info
		    }
		    2_ic {
			set proposed_score \
			    "Incomplete Output"
			refresh_proofs_info
		    }
		    2_se {
			set proposed_score \
			    "Syntax Error"
			refresh_proofs_info
		    }
		    2_te {
			set proposed_score \
			    "Cpu Time Limit Exceeded"
			refresh_proofs_info
		    }
		    2_pc {
			set proposed_score \
			    "Program Crashed"
			refresh_proofs_info
		    }
		    2_oe {
			set proposed_score \
			    "Output Size Limit\
			                 Exceeded"
			refresh_proofs_info
		    }
		    default {
			set window_error \
			    "ERROR: cannot understand\
					  `$answer'!"
		    }
		}
	    }
	    {^\?} {
		display_help
	    }
	    {^pr$} {
		refresh_proofs_info
		set_proof_display
	    }
	    {^$} {
		if { [eof stdin] } {
		    exit_cleanup
		    exit 0
		}
		set window_error "ERROR: empty input"
	    }
	    default {
		if { [regexp {^\.} $answer] } {
		    if { [get_file $answer] } {
			set_file_display $last_file
		    }
	    	} elseif { [get_proof $answer] } {
		     set_proof_display
		}
	    }
	}
    }
}

# Menu Loop
# ---- ----

refresh_file_list
refresh_info
set_file_list_display


if { $readonly_mode } {
    set window_error "You are in read only mode."
} else {
    set window_error ""
}

# Helper function to verify we are not in readonly
# mode or to set window_error if we are.
#
proc not_readonly {} {
    global readonly_mode window_error answer
    if { $readonly_mode } {
        set window_error \
	    "ERROR: You are in readonly mode and\
	     cannot do `$answer'."
	return no
    } else {
    	return yes
    }
}

while { "yes" } {

    set window_prompt "> "
    display_window
    set window_error ""

    set answer [string trim [gets stdin]]
    switch -regexp -- $answer {
        {^[1-9][0-9]*$} {
	    if { [get_file $answer] } {
		set_file_display $last_file
	    }
	}
        {^v *[0-9]*$} {
	    regexp {^v *([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		view_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
        {^v } {
	    regexp {^v +([^ ]*)$} $answer forget id
	    if { [get_file $id] } {
		view_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^e *[0-9]*$} {
	    regexp {^e *([0-9]*)$} $answer forget n
	    if { [not_readonly] && [get_file $n] } {
		edit_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^e } {
	    regexp {^e +([^ ]*)$} $answer forget id
	    if { [not_readonly] && [get_file $id] } {
		edit_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^c *[0-9]*$} {
	    regexp {^c *([0-9]*)$} $answer forget n
	    if { [not_readonly] && [get_file $n] } {
	        set mail_file $last_file.mail
		if { [catch { set last_file \
			          [make_checked \
			              $last_file] } \
			    out] } {
		    out_check $out
		} elseif { [file exists $mail_file ] \
			   && [catch {
			          make_checked \
				      $mail_file
			       } out] } {
		    out_check $out
		} else {
		    set window_error \
		        "Checked $last_file"
		}
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^u *[0-9]*$} {
	    regexp {^u *([0-9]*)$} $answer forget n
	    if { [not_readonly] && [get_file $n] } {
	        set mail_file $last_file.mail
		if { [catch { set last_file \
			          [make_unchecked \
			              $last_file] } \
			    out] } {
		    out_check $out
		} elseif { [file exists $mail_file ] \
			   && [catch {
			          make_unchecked \
				      $mail_file
			       } out] } {
		    out_check $out
		} else {
		    set window_error \
		        "Unchecked $last_file"
		}
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^ls$} {
	    refresh_file_list
	    refresh_info
	    set_file_list_display
	}
	{^ir$} {
	    if { [not_readonly] } {
		compose_reply \
		    {LINE "EDIT YOUR REPONSE HERE"} \
		    BLANK \
		    { BAR "this message replies to:" } \
		    RECEIVED-HEADER \
		    BLANK \
		    RECEIVED-BODY
		set last_file $reply_file+
		edit_file $last_file
		refresh_file_list
		refresh_info
		set_file_display $last_file
	    }
	}
	{^er$} {
	    if { [not_readonly] } {
		if { ! [file exists $reply_file+] } {
		    compose_reply \
			{LINE "EDIT YOUR REPONSE\
			       HERE"} \
			BLANK \
			{ BAR "this message replies\
			       to:" } \
			RECEIVED-HEADER \
			BLANK \
			RECEIVED-BODY
		}
		set last_file $reply_file+
		edit_file $last_file
		refresh_file_list
		refresh_info
		set_file_display $last_file
	    }
	}
	{^sr$} {
	    if { ! [file exists $reply_file+] } {
		set window_error \
		    "ERROR: No reply composed!"
	    } elseif { [not_readonly] } {
		set_file_display $reply_file+
		set window_error ""
		set window_prompt \
		    "Do you want to send the above\
			(y or n)? "
		display_window

		if { [yes?] } {
		    set window_prompt \
		       "Sending..."
		    display_window
		    catch { send_reply } out
		    set last_file $reply_file
		    if { $out == "" } {
		    	set window_error "Reply sent!"
		    } else {
		        puts "\n$out"
			continue?
		    }
		} else {
		    set window_error "Send ABORTED!"
		}
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^nr$} {
	    if { [not_readonly] } {
		set window_error \
		    "Type line to write into\
		     $no_reply_file file (or type ^D\
		     to abort):"
		set window_prompt "> "
		display_window
		set no_reply_line \
		    [string trim [gets stdin]]
		if { [eof stdin] } {
		    set window_error \
			"$no_reply_file NOT WRITTEN"
		} else {
		    write_file $no_reply_file \
		               $no_reply_line
		    set window_error \
			"$no_reply_file written"
		}
		refresh_file_list
		refresh_info
		refresh_display
	    }
	}
	{^ss$} {
	    send_score
	    if { [not_readonly] } {
		set menu $main_menu
		refresh_file_list
		refresh_info
		refresh_display
	    }
	}
	{^aj$} {
	    if { [not_readonly] } {

		puts "Running autojudge"
		catch { exec autojudge >&@ stdout }

		if { ! [file exists $auto_score_file] \
			} {
		    puts "autojudge FAILED to make\
			 $auto_score_file"
		}
		continue?
		refresh_file_list
		refresh_info
		refresh_display
	    }
	}
	{^sh$} {
	    if { [catch { call_shell }] } continue?
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^ai$} {
	    if { [not_readonly] } {

		puts "Running autoinfo"
		catch { exec autoinfo >&@ stdout }
		continue?
		refresh_file_list
		refresh_info
		refresh_display
	    }
	}
	{^sq$} {
	    send_query "Subject: About\n  $directory"
	}
	{^xq$} {
	    if { ! [info exists message_subject] } {
	        set window_error \
		    "ERROR: No $received_file file."
	    } else {
	        set ws "\[\ \t\n\]"
	        set nws "\[^\ \t\n\]"
		set about ""
		regexp "^$ws*About$ws+($nws+)$ws*\$" \
		       $message_subject forget about
		set d $mail_directory/$about
		if { $about == "" } {
		    set window_error \
			"ERROR: $received_file subject\
				does not have the form\
				`About DIRECTORY'."
		} elseif { ! [file isdirectory $d] } {
		    set window_error \
			"ERROR: $d is not a directory."
		} else {
		    catch { exec manualreply \
				 $d >&@ stdout } 
		    puts ""
		    puts "Finished manualreply of"
		    puts "  $about"
		    continue?
		}
	    }
	}
	{^sm$} {
	    set menu $scoring_menu
	    refresh_info
	}
	{^mm$} {
	    set menu $main_menu
	    refresh_info
	}
	{^x$} {
	    exit_cleanup
	    exit 0
	}
	{^io$} {
	    set proposed_score "Incorrect Output"
	    refresh_info
	}
	{^cc$} {
	    set proposed_score "Completely Correct"
	    refresh_info
	}
	{^fe$} {
	    set proposed_score "Formatting Error"
	    refresh_info
	}
	{^ic$} {
	    set proposed_score "Incomplete Output"
	    refresh_info
	}
	{^se$} {
	    set proposed_score "Syntax Error"
	    refresh_info
	}
	{^te$} {
	    set proposed_score "Cpu Time Limit Exceeded"
	    refresh_info
	}
	{^pc$} {
	    set proposed_score "Program Crashed"
	    refresh_info
	}
	{^oe$} {
	    set proposed_score \
	    	"Output Size Limit Exceeded"
	    refresh_info
	}
	{^pr$} {
	    switch -exact [display_proofs] {
	        "" {}
		mm { set menu $main_menu }
		sm { set menu $scoring_menu }
	    }
	    refresh_info
	}
	{^\?} {
	    display_help
	}
	{^$} {
	    if { [eof stdin] } {
		exit_cleanup
		exit 0
	    }
	    set window_error "ERROR: empty input"
	}
	{default} {
	    if { [get_file $answer] } {
		set_file_display $last_file
	    } else {
		set window_error \
		    "ERROR: cannot understand\
				  `$answer'!"
	    }
        }

    }
}


# Include common error catching code:
#
} caught_output
caught_error
