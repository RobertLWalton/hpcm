#!/bin/sh
#
# Manually examine the contents of a directory and
# possibly reply, maybe with a manual score.
#
# File:		manualreply
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sat Sep  8 06:11:42 EDT 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/09/08 18:29:52 $
#   $RCSfile: manualreply,v $
#   $Revision: 1.27 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Table of Contents:
#
#	Startup
#	Display
#	Reading Files
#	File List
#	Response Functions
#	Locking Functions
#	Reply Functions
#	Menu Initialization
#	Menu Loop


# Startup
# -------

# If an subdirectory name is given, make it current, and
# consume the subdirectory name argument.  This must be
# done before looking for the parameters file.
#
# Don't change argc or argv so error output will work.
#
set my_argc $argc
set my_argv $argv
if { $my_argc >= 1 \
     && ! [regexp {^-} [lindex $my_argv 0]] } {
    cd [lindex $my_argv 0]
    set my_argv [lreplace $my_argv 0 0]
    set my_argc [expr { $my_argc - 1 }]
}

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
source $lib_directory/display_common.tcl
source $lib_directory/scoring_common.tcl
catch {

set document "
manualreply \[directory\]

    If the directory argument is given, this program
    makes that directory current before searching for
    the `$judging_parameters_file' file or doing\
    anything else.

    Given a submission directory as the current direc-
    tory, this program permits a person to examine the
    contents of this directory and construct an email
    reply, or alternatively, create a $no_reply_file\
    		file that
    indicates there is to be no reply.  A\
    		$manual_score_file
    file may also be written with a score that is sent
    in the reply.  Unchecked error log files may be
    inspected and checked off."

# If there are any arguments, print documentation and
# exit with error.
#
if { $my_argc != 0 } {
    puts $document
    exit 1
}


# Menus.

set main_menu "
                    \
? = help            \
x = exit            \

#  = look at #      \
v# = view #         \
e# = edit #         \
ls = list files
pr = lookat proofs  \
c# = checkoff #     \
u# = uncheckoff #   \
sh = shell
ir = initiate reply \
er = edit reply     \
sr = send reply     \
nr = no reply
sm = scoring menu   \
aj = autojudge      \
ai = autoinfo       \
ss = send score"

set scoring_menu "
                         ? = help                     \
x  = exit
io = Incorrect Output    cc = Completely Correct      \
#  = look at #
fe = Formatting Error    ic = Incomplete Output       \
mm = back to main menu
se = Syntax Error        te = Cpu Time Limit Exceeded \
ss = send score + mm
pc = Program Crashed     oe = Output Size Exceeded    \
pr = lookat proofs"

# Help displays.
#
# These must begin and end with a blank line.  The
# blank lines are changed to window bars by code.

set help(?) "
? WHAT		gives help for WHAT, where WHAT can be:

# = file identifier \
? = help            \
x = exit            \
aj = autojudge
v  = view #         \
e  = edit #         \
ls = list files     \
ai = autoinfo
pr = lookat proofs  \
c  = checkoff #     \
u  = uncheckoff #   \
sh = shell
ir = initiate reply \
er = edit reply     \
sr = send reply     \
nr = no reply

sm = goto scoring menu   mm = goto main menu           ss = send score + mm

io = Incorrect Output    cc = Completely Correct 
fe = Formatting Error    ic = Incomplete Output 
se = Syntax Error        te = Cpu Time Limit Exceeded
pc = Program Crashed     oe = Output Size Exceeded
"


# Menu Initialization
# ---- --------------

get_lock
refresh_file_list

# If auto score file, reply file, no replay file,
# and unchecked errors do not exists, consider running
# autojudge.
#
if { $submitted_program != "" \
     && [llength [glob -nocomplain \
                       $reply_file \
                       $no_reply_file \
                       $auto_score_file \
                       *-unchecked-error]] == 0 } {


    set_file_list_display
    set window_info_height 5
    set_window_info "
It appears that `autojudge' should be run."
    set window_prompt "Do you want to do so (y or n)? "
    set window_error ""

    display_window

    if { [yes?] } {

    	puts "Running autojudge"
	exec autojudge >@ stdout 2>@ stderr

	if { ! [file exists $auto_score_file] } {
	    puts "autojudge FAILED to make\
	          $auto_score_file"
	}
	continue?
    }
}

set menu $main_menu

set directory [file tail [pwd]]
set proposed_score none
set last_file ""
set last_display ""

# Procedure to recompute window_display for menu loop.
#
proc refresh_display {} {

    global last_display last_file last_help

    if { $last_display == "file_list" } {
	set_file_list_display
    } elseif { $last_display == "file" } {
	set_file_display $last_file
    } elseif { $last_display == "help" } {
	set_window_display $last_help
    }
}

# Procedure to recompute window_info for menu loop.
#
proc refresh_info {} {

    global proposed_score manual_score auto_score \
    	   window_info_height directory menu \
	   scoring_instructions submitted_program

    set old_info_height $window_info_height

    if { $proposed_score == "none" } {
	if { $manual_score != "none" } {
	    set proposed_score $manual_score
	} else {
	    set proposed_score $auto_score
	}
    }
    if { $submitted_program == "" } {
    	set scoring_info ""
	set window_info_height 6
    } else {
	set scoring_info "
Scoring Instructions: $scoring_instructions"

	if { $manual_score == "none" } {
	    set scoring_info "$scoring_info
Scores:    Auto: $auto_score    Proposed:\
			        $proposed_score"
	    set window_info_height 8
	} elseif { $proposed_score == "none" } {
	    set scoring_info "$scoring_info
Scores:    Auto: $auto_score    Manual: $manual_score"
	    set window_info_height 8
	} else {
	    set scoring_info "$scoring_info
Scores:    Auto:     $auto_score    Manual:\
				    $manual_score
           Proposed: $proposed_score"
	    set window_info_height 9
	}
    }

    set_window_info \
        "Dir: $directory$scoring_info$menu"

    # Refresh the display if window_info_height is
    # changed.
    #
    if { $window_info_height != $old_info_height } {
        refresh_display
    }
}

# Function to display proofs.
#
proc display_proofs {} {

    global last_file window_error window_prompt

    compute_instruction_array
    compute_score_and_proof_arrays
    compute_score

    if { [get_proof] == "no" } return ""
    set_proof_info ""
    if { [set_proof_display] == "no" } return ""

    while { "yes" } {

	set window_prompt "> "
	display_window
	set window_error ""

	set answer [string trim [gets stdin]]
	switch -regexp -- $answer {
	    {^mm$} { return mm }
	    {^sm$} { return sm }
	    {^$} {
		if { [eof stdin] } {
		    exit_cleanup
		    exit 0
		}
		set window_error "ERROR: empty input"
	    }
	    default {
		if { [regexp {^\.} $answer] } {
		    if { [get_file $answer] } {
			set_file_display $last_file
		    }
	    	} elseif { [get_proof $answer] } {
		     set_proof_info ""
		     set_proof_display
		}
	    }
	}
    }
}

# Menu Loop
# ---- ----

refresh_file_list
refresh_info
set_file_list_display

set window_error ""

while { "yes" } {

    set window_prompt "> "
    display_window
    set window_error ""

    set answer [string trim [gets stdin]]
    switch -regexp -- $answer {
        {^[1-9][0-9]*$} {
	    if { [get_file $answer] } {
		set_file_display $last_file
	    }
	}
        {^v *[0-9]*$} {
	    regexp {^v *([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		view_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
        {^v } {
	    regexp {^v +([^ ]*)$} $answer forget id
	    if { [get_file $id] } {
		view_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^e *[0-9]*$} {
	    regexp {^e *([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		edit_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^e } {
	    regexp {^e +([^ ]*)$} $answer forget id
	    if { [get_file $id] } {
		edit_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^c *[0-9]*$} {
	    regexp {^c *([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
	        set mail_file $last_file.mail
		if { [catch { set last_file \
			          [make_checked \
			              $last_file] } \
			    out] } {
		    out_check $out
		} elseif { [file exists $mail_file ] \
			   && [catch {
			          make_checked \
				      $mail_file
			       } out] } {
		    out_check $out
		} else {
		    set window_error \
		        "Checked $last_file"
		}
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^u *[0-9]*$} {
	    regexp {^u *([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
	        set mail_file $last_file.mail
		if { [catch { set last_file \
			          [make_unchecked \
			              $last_file] } \
			    out] } {
		    out_check $out
		} elseif { [file exists $mail_file ] \
			   && [catch {
			          make_unchecked \
				      $mail_file
			       } out] } {
		    out_check $out
		} else {
		    set window_error \
		        "Unchecked $last_file"
		}
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^ls$} {
	    refresh_file_list
	    refresh_info
	    set_file_list_display
	}
	{^ir$} {
	    compose_reply -all
	    set last_file $reply_file+
	    edit_file $last_file
	    refresh_file_list
	    refresh_info
	    set_file_display $last_file
	}
	{^er$} {
	    if { ! [file exists $reply_file+] } {
		compose_reply -all
	    }
	    set last_file $reply_file+
	    edit_file $last_file
	    refresh_file_list
	    refresh_info
	    set_file_display $last_file
	}
	{^sr$} {
	    if { ! [file exists $reply_file+] } {
		set window_error \
		    "ERROR: No reply composed!"
	    } else {
		set_file_display $reply_file+
		set window_error ""
		set window_prompt \
		    "Do you want to send the above\
			(y or n)? "
		display_window

		if { [yes?] } {
		    set window_prompt \
		       "Sending..."
		    display_window
		    catch { send_reply } out
		    set last_file $reply_file
		    if { $out == "" } {
		    	set window_error "Reply sent!"
		    } else {
		        puts "\n$out"
			continue?
		    }
		} else {
		    set window_error "Send ABORTED!"
		}
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^nr$} {
	    set window_error \
		"Type line to write into $no_reply_file\
                 file (or type ^D to abort):"
	    set window_prompt "> "
	    display_window
	    set no_reply_line [string trim [gets stdin]]
	    if { [eof stdin] } {
		set window_error \
		    "$no_reply_file NOT WRITTEN"
	    } else {
		write_file $no_reply_file $no_reply_line
		set window_error \
		    "$no_reply_file written"
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^ss$} {
	    if { $proposed_score == "none" } {
	        set window_error "ERROR: set the\
		    proposed score before sending it"
	    } elseif { [compose_score_reply] } {
		send_score_reply
		set last_file $reply_file
		set last_display file
	        set window_error "Score sent!"
	    } else {
	        set window_error "NOTICE: Old manual\
		    score exists or scoring mode is\
		    `auto'."
	        set window_prompt "To continue you\
		    must edit reply.  Do you want to\
		    continue (y or n)? "
		set last_file $reply_file+
		set_file_display $reply_file+
		display_window
		if { [yes?] } {
		    edit_file $last_file
		    set window_error "Reply is ready\
			to send."
		    set window_prompt "Do you want to\
			send it (y or n)? "
		    display_window
		    if { [yes?] } {
		    	send_score_reply
			set last_file $reply_file
			set window_error "Score sent!"
		    } else {
			set window_error "Score sending\
			    ABORTED!"
			set last_display file_list
		    }
		} else {
		    set window_error "Score sending\
			ABORTED!"
		    set last_display file_list
		}
	    }
	    set menu $main_menu
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^aj$} {
	    puts "Running autojudge"
	    exec autojudge >@ stdout 2>@ stderr

	    if { ! [file exists $auto_score_file] } {
		puts "autojudge FAILED to make\
		     $auto_score_file"
	    }
	    continue?
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^sh$} {
	    call_shell
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^ai$} {
	    exec autoinfo >@ stdout 2>@ stderr
	    continue?
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^sm$} {
	    set menu $scoring_menu
	    refresh_info
	}
	{^mm$} {
	    set menu $main_menu
	    refresh_info
	}
	{^x$} {
	    exit_cleanup
	    exit 0
	}
	{^io$} {
	    set proposed_score "Incorrect Output"
	    refresh_info
	}
	{^cc$} {
	    set proposed_score "Completely Correct"
	    refresh_info
	}
	{^fe$} {
	    set proposed_score "Formatting Error"
	    refresh_info
	}
	{^ic$} {
	    set proposed_score "Incomplete Output"
	    refresh_info
	}
	{^se$} {
	    set proposed_score "Syntax Error"
	    refresh_info
	}
	{^te$} {
	    set proposed_score "Cpu Time Limit Exceeded"
	    refresh_info
	}
	{^pc$} {
	    set proposed_score "Program Crashed"
	    refresh_info
	}
	{^oe$} {
	    set proposed_score "Output Size Exceeded"
	    refresh_info
	}
	{^pr$} {
	    switch -exact [display_proofs] {
	        "" {}
		mm { set menu $main_menu }
		sm { set menu $scoring_menu }
	    }
	    refresh_info
	}
	{^\?} {
	    regexp {^? *([^ ]*)$} $answer forget what
	    if { $what == "" } {
	        set what "?"
	    } elseif { ! [info exists help($what)] } {
		set window_error \
		    "ERROR: no help available for\
				  `$what'!"
		set what "?"
	    }
	    set last_help $help($what)
	    set last_help \
	        "$window_bar$last_help$window_bar"
	    set_window_display $last_help
	    set last_display help
	}
	{^$} {
	    if { [eof stdin] } {
		exit_cleanup
		exit 0
	    }
	    set window_error "ERROR: empty input"
	}
	{default} {
	    if { [get_file $answer] } {
		set_file_display $last_file
	    } else {
		set window_error \
		    "ERROR: cannot understand\
				  `$answer'!"
	    }
        }

    }
}


# Include common error catching code:
#
} caught_output
caught_error
