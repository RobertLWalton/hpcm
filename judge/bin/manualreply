#!/bin/sh
#
# Manually examine the contents of a directory and
# possibly reply, maybe with a manual score.
#
# File:		manualreply
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Aug 26 09:06:43 EDT 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/08/26 13:30:27 $
#   $RCSfile: manualreply,v $
#   $Revision: 1.24 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Table of Contents:
#
#	Startup
#	Display
#	Reading Files
#	File List
#	Response Functions
#	Locking Functions
#	Reply Functions
#	Menu Initialization
#	Menu Loop


# Startup
# -------

# If an subdirectory name is given, make it current, and
# consume the subdirectory name argument.  This must be
# done before looking for the parameters file.
#
# Don't change argc or argv so error output will work.
#
set my_argc $argc
set my_argv $argv
if { $my_argc >= 1 \
     && ! [regexp {^-} [lindex $my_argv 0]] } {
    cd [lindex $my_argv 0]
    set my_argv [lreplace $my_argv 0 0]
    set my_argc [expr { $my_argc - 1 }]
}

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
source $lib_directory/display_common.tcl
catch {

set document "
manualreply \[directory\]

    If the directory argument is given, this program
    makes that directory current before searching for
    the `$judging_parameters_file' file or doing\
    anything else.

    Given a submission directory as the current direc-
    tory, this program permits a person to examine the
    contents of this directory and construct an email
    reply, or alternatively, create a $no_reply_file\
    		file that
    indicates there is to be no reply.  A\
    		$manual_score_file
    file may also be written with a score that is sent
    in the reply.  Unchecked error log files may be
    inspected and checked off."

# If there are any arguments, print documentation and
# exit with error.
#
if { $my_argc != 0 } {
    puts $document
    exit 1
}


# Menu Initialization
# ---- --------------

get_lock
refresh_file_list

# If auto score file, reply file, no replay file,
# and unchecked errors do not exists, consider running
# autojudge.
#
if { $submitted_program != "" \
     && [llength [glob -nocomplain \
                       $reply_file \
                       $no_reply_file \
                       $auto_score_file \
                       *-unchecked-error]] == 0 } {


    set_file_list_display
    set window_info_height 5
    set_window_info "
It appears that `autojudge' should be run."
    set window_prompt "Do you want to do so (y or n)? "
    set window_error ""

    display_window

    if { [yes?] } {

    	puts "Running autojudge"
	exec autojudge >@ stdout 2>@ stderr

	if { ! [file exists $auto_score_file] } {
	    puts "autojudge FAILED to make\
	          $auto_score_file"
	}
	continue?
    }
}

set main_menu "
#  = look at #      \
v# = view #         \
e# = edit #         \
x  = exit
ls = list files     \
c# = checkoff #     \
u# = uncheckoff #   \
sh = shell
ir = initiate reply \
er = edit reply     \
sr = send reply     \
nr = no reply
sm = scoring menu   \
aj = autojudge      \
ai = autoinfo       \
ss = send score"

set scoring_menu "
io = Incorrect Output    cc = Completely Correct      \
#  = look at #
fe = Formatting Error    ic = Incomplete Output       \
mm = back to main menu
se = Syntax Error        te = Cpu Time Limit Exceeded \
ss = send score + mm
pc = Program Crashed     oe = Output Size Exceeded"

set menu $main_menu

set directory [file tail [pwd]]
set proposed_score none

set last_display file_list
set last_file ""
set window_error ""


# Menu Loop
# ---- ----

while { "yes" } {

    refresh_file_list

    if { $proposed_score == "none" } {
	if { $manual_score != "none" } {
	    set proposed_score $manual_score
	} else {
	    set proposed_score $auto_score
	}
    }
    if { $submitted_program == "" } {
    	set scoring_info ""
	set window_info_height 6
    } else {
	set scoring_info "
Scoring Instructions: $scoring_instructions"

	if { $manual_score == "none" } {
	    set scoring_info "$scoring_info
Scores:    Auto: $auto_score    Proposed:\
			        $proposed_score"
	    set window_info_height 8
	} elseif { $proposed_score == "none" } {
	    set scoring_info "$scoring_info
Scores:    Auto: $auto_score    Manual: $manual_score"
	    set window_info_height 8
	} else {
	    set scoring_info "$scoring_info
Scores:    Auto:     $auto_score    Manual:\
				    $manual_score
           Proposed: $proposed_score"
	    set window_info_height 9
	}
    }

    set_window_info "Directory: $directory$scoring_info
$menu"

    # Set the display after the window_info_height is
    # determined.
    #
    if { $last_display == "file_list" } {
	set_file_list_display
    } else {
	set_file_display $last_file
    }

    set window_prompt "> "
    display_window
    set window_error ""

    set answer [string trim [gets stdin]]
    switch -regexp -- $answer {
        {^[1-9][0-9]*$} {
	    if { [get_file $answer] } {
		set_file_display $last_file
	    }
	}
        {^v *[0-9]*$} {
	    regexp {^v *([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		view_file $last_file
		set_file_display $last_file
	    }
	}
        {^v } {
	    regexp {^v +([^ ]*)$} $answer forget id
	    if { [get_file $id] } {
		view_file $last_file
		set_file_display $last_file
	    }
	}
	{^e *[0-9]*$} {
	    regexp {^e *([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		edit_file $last_file
		set_file_display $last_file
	    }
	}
	{^e } {
	    regexp {^e +([^ ]*)$} $answer forget id
	    if { [get_file $id] } {
		edit_file $last_file
		set_file_display $last_file
	    }
	}
	{^c *[0-9]*$} {
	    regexp {^c *([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
	        set mail_file $last_file.mail
		if { [catch { set last_file \
			          [make_checked \
			              $last_file] } \
			    out] } {
		    out_check $out
		} elseif { [file exists $mail_file ] \
			   && [catch {
			          make_checked \
				      $mail_file
			       } out] } {
		    out_check $out
		} else {
		    set window_error \
		        "Checked $last_file"
		}
	    }
	}
	{^u *[0-9]*$} {
	    regexp {^u *([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
	        set mail_file $last_file.mail
		if { [catch { set last_file \
			          [make_unchecked \
			              $last_file] } \
			    out] } {
		    out_check $out
		} elseif { [file exists $mail_file ] \
			   && [catch {
			          make_unchecked \
				      $mail_file
			       } out] } {
		    out_check $out
		} else {
		    set window_error \
		        "Unchecked $last_file"
		}
	    }
	}
	{^ls$} { set last_display "file_list" }
	{^ir$} {
	    compose_reply -all
	    set last_file $reply_file+
	    edit_file $last_file
	}
	{^er$} {
	    if { ! [file exists $reply_file+] } {
		compose_reply -all
	    }
	    set last_file $reply_file+
	    edit_file $last_file
	}
	{^sr$} {
	    if { ! [file exists $reply_file+] } {
		set window_error \
		    "ERROR: No reply composed!"
	    } else {
		set_file_display $reply_file+
		set window_error ""
		set window_prompt \
		    "Do you want to send the above\
			(y or n)? "
		display_window

		if { [yes?] } {
		    set window_prompt \
		       "Sending..."
		    display_window
		    catch { send_reply } out
		    set last_file $reply_file
		    if { $out == "" } {
		    	set window_error "Reply sent!"
		    } else {
		        puts "\n$out"
			continue?
		    }
		} else {
		    set window_error "Send ABORTED!"
		}
	    }
	}
	{^nr$} {
	    set window_error \
		"Type line to write into $no_reply_file\
                 file (or type ^D to abort):"
	    set window_prompt "> "
	    display_window
	    set no_reply_line [string trim [gets stdin]]
	    if { [eof stdin] } {
		set window_error \
		    "$no_reply_file NOT WRITTEN"
	    } else {
		write_file $no_reply_file $no_reply_line
		set window_error "$no_reply_file written"
	    }
	}
	{^ss$} {
	    if { $proposed_score == "none" } {
	        set window_error "ERROR: set the\
		    proposed score before sending it"
	    } elseif { [compose_score_reply] } {
		send_score_reply
		set last_file $reply_file
		set last_display file
	        set window_error "Score sent!"
	    } else {
	        set window_error "NOTICE: Old manual\
		    score exists or scoring mode is\
		    `auto'."
	        set window_prompt "To continue you\
		    must edit reply.  Do you want to\
		    continue (y or n)? "
		set last_file $reply_file+
		set_file_display $reply_file+
		display_window
		if { [yes?] } {
		    edit_file $last_file
		    set window_error "Reply is ready\
			to send."
		    set window_prompt "Do you want to\
			send it (y or n)? "
		    display_window
		    if { [yes?] } {
		    	send_score_reply
			set last_file $reply_file
			set window_error "Score sent!"
		    } else {
			set window_error "Score sending\
			    ABORTED!"
			set last_display file_list
		    }
		} else {
		    set window_error "Score sending\
			ABORTED!"
		    set last_display file_list
		}
	    }
	    set menu $main_menu
	}
	{^aj$} {
	    puts "Running autojudge"
	    exec autojudge >@ stdout 2>@ stderr

	    if { ! [file exists $auto_score_file] } {
		puts "autojudge FAILED to make\
		     $auto_score_file"
	    }
	    continue?
	}
	{^sh$} { call_shell }
	{^ai$} {
	    exec autoinfo >@ stdout 2>@ stderr
	    continue?
	}
	{^sm$} { set menu $scoring_menu }
	{^mm$} { set menu $main_menu }
	{^x$} {
	    exit_cleanup
	    exit 0
	}
	{^io$} { set proposed_score \
		     "Incorrect Output" }
	{^cc$} { set proposed_score\
		     "Completely Correct" }
	{^fe$} { set proposed_score\
		     "Formatting Error" }
	{^ic$} { set proposed_score\
		     "Incomplete Output" }
	{^se$} { set proposed_score\
		     "Syntax Error" }
	{^te$} { set proposed_score\
		     "Cpu Time Limit Exceeded" }
	{^pc$} { set proposed_score\
		     "Program Crashed" }
	{^oe$} { set proposed_score\
		     "Output Size Exceeded" }
	{^$} {
	    if { [eof stdin] } {
		exit_cleanup
		exit 0
	    }
	    set window_error "ERROR: empty input"
	}
	{default} {
	    if { [get_file $answer] } {
		set_file_display $last_file
	    } else {
		set window_error \
		    "ERROR: cannot understand\
				  `$answer'!"
	    }
        }

    }
}


# Include common error catching code:
#
} caught_output
caught_error
