#!/bin/sh -f
#
# Manually examine the contents of a directory and
# possibly reply, maybe with a manual score.
#
# File:		manualreply
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Sep 20 22:06:13 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/09/21 03:26:00 $
#   $RCSfile: manualreply,v $
#   $Revision: 1.6 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory; manualreply

    Given a submission directory as the current dir-
    ectory, permit a person to examine the contents of
    the directory and construct an email reply or a
    $no_reply_file file indicating there is to be no
    reply.  A $manual_score_file file may also be\
    			constructed
    and this score sent in the reply."

# If there are any arguments, print documentation and
# exit with error.
#
if { $argc != 0 } {
    puts $document
    exit 1
}

proc add_file { variable
                filename 
		{ maxlength 999999999 } } {
    upvar 1 $variable out
    set file_ch [open $filename r]
    set n 0
    while { "yes" } {
    	set line [gets $file_ch]
	if { [eof $file_ch] } break

	incr n

	if { $n <= $maxlength } {
	    set out "$out\n$line"
	}
    }

    return n
}


# List of files in the current directory.  The N'th
# item on the list is itself a list of subitems
# with the format:
#
#	ctime mtime filename comment new
#
# The total list is sorted by ctime.  Ctime equals
# mtime, the file's modification time, with 0's
# prepended so all ctimes are the same length of
# items will be the same as numeric comparison of
# mtimes.
#
# The comment is to be printed after the filename if
# the file name is not too long.  Generally non-
# error log file names are short enough for the comment,
# and error log file names are too long.
#
# `New' is `*' if the file is new since the last time
# the file list was computed, and the previous file list
# was not empty.  Otherwise `new' is "".
#
set file_list ""
set file_list_length 0
set file_list_origin_mtime 0

proc refresh_file_list { } {

    global file_list file_list_length \
    	   file_list_origin_mtime received_file

    set new_file_list ""
    set n 0
    set origin ""
    set oldest 0
    foreach file [glob -nocomplain *] {
	set mtime [file mtime $file]
	if { $file == $received_file } {
	    set origin $mtime
	}
	if { $mtime > $oldest } {
	    set oldest $mtime
	}
    	set item [format {%040d} $mtime]
	lappend item $mtime
	lappend item $file
	set size [file size $file]
	if { $size == 0 } {
	    lappend item "(empty)"
	} elseif { ! [file readable $file] } {
	    lappend item "(unreadable file)"
	} else {
	    set file_ch [open $file r]
	    set line [gets $file_ch]
	    gets $file_ch
	    if { [eof $file_ch] \
	         && [string length $line] < 35 } {
	    	lappend item "{$line}"
	    } else {
		lappend item "(${size}b)"
	    }
	    close $file_ch
	}
	if { $file_list_length != 0 } {
	    set new "*"
	    foreach item2 $file_list {
		if { [lindex $item2 2] == $file } {
		    set new ""
		    break
		}
	    }
	} else {
	    set new ""
	}
	lappend item $new

	lappend new_file_list $item
	incr n
    }

    set file_list [lsort $new_file_list]
    set file_list_length $n

    if { $origin != "" } {
    	set file_list_origin_mtime $origin
    } else {
    	set file_list_origin_mtime $oldest
    }
}

proc add_file_list { variable } {

    global file_list file_list_origin_mtime

    upvar 1 $variable out

    set n 0
    set previous ""

    # If `previous' is non-empty it is the previous
    # item and has no more than 39 characters.
    #
    foreach item $file_list {
	incr n
	set time [expr { [lindex $item 1] \
	                 - $file_list_origin_mtime }]
	if { $time < 0 } {
	    set sign "-"
	    set time [expr { - $time }]
	} else {
	    set sign ""
	}
	set mm [expr { $time / 60 }]
	set hh [expr { $mm / 60 }]
	set mm [expr { $mm - 60 * $hh }]
	set tttt "$sign[format {%d:%02d} $hh $mm]"
	if { [string length $tttt] > 6 } {
	    set tttt "${sign}inf"
	}
	set next [format {%3d. %6.6s%1.1s %s} \
			 $n \
			 $tttt [lindex $item 4] \
			 [lindex $item 2]]
	set commented "${next} [lindex $item 3]"

	if { [string length $commented] <= 80 } {
	    set next $commented
	}
	if { [string length $next] > 39 } {
	    if { $previous != "" } {
	    	set next "$previous\n$next"
	    }
	    set previous ""
	} elseif { $previous != "" } {
	    set next [format {%-40s%s} $previous $next]
	    set previous ""
	} else {
	    set previous $next
	    set next ""
	}

	if { $next != "" } {
	    set out "$out\n$next"
	}
    }

    if { $previous != "" } {
	set out "$out\n$previous"
    }
}

refresh_file_list
set out "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
add_file_list out
puts $out
exit 0

proc get_file { number } {

    global file_list file_list_length last_file

    if { $number == "" } {
	if { $last_file == "" } {
	    puts "No previous file!"
	    return no
	} else {
	    return yes
	}
    } elseif { $number < 1 \
               || $number > $file_list_length } {
	puts "Bad file number: $number"
	return no
    } else {
	set last_file \
            [lindex [lindex $file_list \
                            [expr { $number - 1 }]] 1]
	return yes
    }
}

# Read the received mail header.
#
set received_ch [open $received_file r]
read_header $received_ch
close $received_ch


if { [llength $message_subject] == 2 \
     && [lindex $message_subject 0] == "submit"
     && [llength [glob -nocomplain \
                       $reply_file \
                       $no_reply_file \
                       $auto_score_file \
                       *-unchecked-error]] == 0 } {

    puts "Running autojudge"
    exec autojudge >@ stdout 2>@ stderr

    if { ! [file exists $auto_score_file] } {
	puts "autojudge FAILED to make $auto_score_file"
    }
}

refresh_file_list no
set last_file ""

while { "yes" } {

    puts "Directory [file tail [pwd]]"
    puts ""
    put_file_list
    puts -nonewline "
v# = view #           e# = edit #        c# = checkoff #
ir = initiate reply   er = edit reply    sr = send reply
sh = call shell       u# = uncheckoff #	 x  = exit
ad = call autodispatch      ms = call manualscore

> "
    set answer [gets stdin]
    if { [eof stdin] } {
    	exit 0
    }

    if { [llength $answer] == 0 } {
    	continue;
    } elseif { [llength $answer] > 1 } {
        puts "Unknown: $answer"
	continue;
    }

    set answer [lindex $answer 0]

    switch -regexp $answer \
        {^v[0-9]*$} {
	    regexp {^v([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		view_file $last_file
	    }
	} \
	{^e[0-9]*$} {
	    regexp {^e([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		edit_file $last_file
	    }
	} \
	{^c[0-9]*$} {
	    regexp {^c([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		catch { set last_file \
			    [make_checked \
			     $last_file] } out
		if { $out != "" } {
		    puts $out
		}
	    }
	} \
	{^u[0-9]*$} {
	    regexp {^u([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		catch { set last_file \
		            [make_unchecked \
			     $last_file] } out
		if { $out != "" } {
		    puts $out
		}
	    }
	} \
	{ir} {
	    compose_reply -all
	    set last_file $reply_file+
	    edit_file $last_file
	} \
	{er} {
	    set last_file $reply_file+
	    edit_file $last_file
	} \
	{sr} {
	    if { ! [file exists $reply_file+] } {
		puts "No reply composed!"
	    } else {
	        puts "Do you want to send:"
	        puts ""
	        put_file $reply_file+ stdout 12
		puts -nonewline "
(y or n)? "
	        set answer [gets stdin]
	        if { [eof stdin] } {
		    exit 0
		} elseif { [regexp {^[yY]} $answer] } {
		    puts "Sending..."
		    send_reply
		    set last_file $reply_file
		} else {
		    puts "Send ABORTED!"
		}
	    }
	} \
	{sh} {
	    call_shell
	} \
	{ad} {
	    exec autodispatch -force \
	         >@ stdout 2>@ stderr
	} \
	{ms} {
	    exec manualscore >@ stdout 2>@ stderr
	} \
	{x} {
	    exit 0
	}

    refresh_file_list
}


# Include common error catching code:
#
} caught_output
caught_error
