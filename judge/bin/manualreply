#!/bin/sh -f
#
# Manually examine the contents of a directory and
# possibly reply, maybe with a manual score.
#
# File:		manualreply
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Fri Sep 22 07:57:59 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/09/22 12:11:41 $
#   $RCSfile: manualreply,v $
#   $Revision: 1.9 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory; manualreply

    Given a submission directory as the current dir-
    ectory, permit a person to examine the contents of
    the directory and construct an email reply, or
    alternatively, create a $no_reply_file file that\
					indicates
    that there is to be no reply.  A $manual_score_file\
					    file
    may also be constructed and this score sent in the
    reply."

# If there are any arguments, print documentation and
# exit with error.
#
if { $argc != 0 } {
    puts $document
    exit 1
}

# Several of the following functions add text lines to
# the end of a variable, rather than writing to stdout.
# By accumulating text in a variable and writing it in
# a single puts statement, and by designing successive
# puts strings to have the same layout, we get the
# effect of having a single window.
#
# The window has the following parts:
#
#	window_blank	blank lines above window
#	window_display	file list or file
#	window_info	information specific to window
#	window_error	error line just above prompt
#	window_prompt	prompt and user response line
#
# The last two are 1 line.  The height of window_info
# is carefully controlled, the height of the window_
# display is suggested (its actually a maximum), and
# the height of the entire window is controlled unless
# it is too large.  The window_display should end with
# a bar.
#
set window_blank ""
set window_display ""
set window_info ""
set window_error ""
set window_prompt ""
set window_height 40
set window_display_height 12
set window_info_height 8

set window_newlines "\n\n\n\n\n\n\n\n\n\n"
set window_newlines "$window_newlines$window_newlines"
set window_newlines "$window_newlines$window_newlines"
set window_newlines "$window_newlines$window_newlines"
set window_newlines "$window_newlines$window_newlines"

proc display_window {} {

    global window_blank window_display window_info \
    	   window_error window_prompt

    set b $window_blank
    set d $window_display
    set i $window_info
    set e $window_error
    set p $window_prompt
    puts -nonewline "$b\n$d\n$i\n\n$e\n$p"
    flush stdout
}

proc set_window_info { info } {

    global window_info window_info_height \
    	   window_newlines

    set split [split $info "\n"]
    set height [llength $split]
    if { $height > $window_info_height } {
    	error "window info too high:\n$info"
    }
    set offset [expr { $window_info_height \
    		       - $height - 1 }]
    set window_info \
        "[string range $window_newlines \
	         0 $offset]$info"
}

proc set_window_display { display } {

    global window_blank window_display \
    	   window_height window_info_height \
	   window_newlines

    set height [llength [split $display "\n"]]

    set offset \
        [expr { $window_height \
	        - $window_info_height - 2 \
		- $height - 1 }]
    set window_blank \
        [string range $window_newlines 0 $offset]
    set window_display $display
}

set window_bar "===================="
set window_bar "$window_bar$window_bar"
set window_bar "$window_bar$window_bar"

proc bar_with_text { text } {
    global window_bar
    set l [expr 80 - 2 - [string length $text]]
    return "[string range $window_bar 0 $l] $text"
}

# Set the window display to display the first lines
# of the file.
#
proc set_file_display { filename } {

    global window_display_height last_display

    if { ! [file readable $filename] } {
	refresh_file_list
    	set_file_list_display
	return
    }

    set height [expr { $window_display_height - 2 }]
    set display [bar_with_text "$filename:"]

    set file_ch [open $filename r]
    set n 0
    while { "yes" } {
    	set line [gets $file_ch]
	if { [eof $file_ch] } break

	incr n

	if { $n <= $height } {
	    set display "$display\n$line"
	}
    }
    close $file_ch

    if { $n > $height } {
	set more [expr { $n - $height }]
    	set bar [bar_with_text "......................\
		 there are $more more lines in this\
		 file"]
    } else {
        set bar [bar_with_text " end-of-file"]
    }
    set_window_display "$display\n$bar"
    set last_display file
}


# List of files in the current directory.  The N'th
# item on the list is itself a list of subitems
# with the format:
#
#	ctime mtime filename comment new
#
# The total list is sorted by ctime.  Ctime equals
# mtime, the file's modification time, with 0's
# prepended so all ctimes are the same length of
# items will be the same as numeric comparison of
# mtimes.
#
# The comment is to be printed after the filename if
# the file name is not too long.  Generally non-
# error log file names are short enough for the comment,
# and error log file names are too long.
#
# `New' is `*' if the file is new since the last time
# the file list was computed, and the previous file list
# was not empty.  Otherwise `new' is "".
#
# Below `file_list' is a simple list of file names that
# can be lsearch'ed.  `file_list_items' has the list of
# items described above.  The number of files is in
# `file_list_length'.  The mtime of the $received_file
# file is in `file_list_origin_mtime', unless there is
# no such file, in which case the mtime of the oldest
# file is there instead.
#
set file_list ""
set file_list_items ""
set file_list_length 0
set file_list_origin_mtime 0

# Recompute the file list.  New files are marked unless
# the file list was previously empty.
#
proc refresh_file_list { } {

    global file_list file_list_items file_list_length \
    	   file_list_origin_mtime received_file

    set new_file_list [glob -nocomplain *]
    set new_file_list_items ""
    set n 0
    set origin ""
    set oldest 0
    foreach file $new_file_list {
	set mtime [file mtime $file]
	if { $file == $received_file } {
	    set origin $mtime
	}
	if { $mtime > $oldest } {
	    set oldest $mtime
	}
    	set item [format {%040d} $mtime]
	lappend item $mtime
	lappend item $file
	set size [file size $file]
	if { [file isdirectory $file] } {
	    lappend item "(directory)"
	} elseif { $size == 0 } {
	    lappend item "(empty)"
	} elseif { ! [file readable $file] } {
	    lappend item "(unreadable file)"
	} else {
	    set file_ch [open $file r]
	    set line [gets $file_ch]
	    gets $file_ch
	    if { [eof $file_ch] \
	         && [string length $line] < 35 } {
	    	lappend item "{$line}"
	    } else {
		lappend item "(${size}b)"
	    }
	    close $file_ch
	}

	set new ""
	if { $file_list_length != 0 \
	     && [lsearch -exact $file_list $file] \
	        < 0 } {
	    set new "*"
	}
	lappend item $new

	lappend new_file_list_items $item
	incr n
    }

    set file_list $new_file_list
    set file_list_items [lsort $new_file_list_items]
    set file_list_length $n

    if { $origin != "" } {
    	set file_list_origin_mtime $origin
    } else {
    	set file_list_origin_mtime $oldest
    }
}

# Set the window display to the file list.
#
proc set_file_list_display {} {

    global file_list_items file_list_origin_mtime \
    	   window_bar last_display

    set display "$window_bar"

    set n 0
    set previous ""

    # If `previous' is non-empty it is the previous
    # item and has no more than 39 characters.
    #
    foreach item $file_list_items {
	incr n
	set time [expr { [lindex $item 1] \
	                 - $file_list_origin_mtime }]
	if { $time < 0 } {
	    set sign "-"
	    set time [expr { - $time }]
	} else {
	    set sign ""
	}
	set mm [expr { $time / 60 }]
	set hh [expr { $mm / 60 }]
	set mm [expr { $mm - 60 * $hh }]
	set tttt "$sign[format {%d:%02d} $hh $mm]"
	if { [string length $tttt] > 6 } {
	    set tttt "${sign}inf"
	}
	set next [format {%3d. %6.6s%1.1s %s} \
			 $n \
			 $tttt [lindex $item 4] \
			 [lindex $item 2]]
	set commented "${next} [lindex $item 3]"

	if { [string length $commented] <= 80 } {
	    set next $commented
	}
	if { [string length $next] > 39 } {
	    if { $previous != "" } {
	    	set next "$previous\n$next"
	    }
	    set previous ""
	} elseif { $previous != "" } {
	    set next [format {%-40s%s} $previous $next]
	    set previous ""
	} else {
	    set previous $next
	    set next ""
	}

	if { $next != "" } {
	    set display "$display\n$next"
	}
    }

    if { $previous != "" } {
	set display "$display\n$previous"
    }

    set_window_display "$display\n$window_bar"
    set last_display file_list
}

# Given a file number, set `last_file' to the name of
# the corresponding file, set `window_error' to "", and
# return `yes'.  If there is an error, leave `last_file'
# alone, set `window_error' to the error description,
# and return `no'.
#
proc get_file { number } {

    global file_list_items file_list_length \
	   last_file window_error

    set window_error ""
    if { $number == "" } {
	if { $last_file == "" } {
	    set window_error "No previous file!"
	    return no
	} else {
	    return yes
	}
    } elseif { $number < 1 \
               || $number > $file_list_length } {
	set window_error "Bad file number: $number"
	return no
    } else {
	set last_file \
            [lindex [lindex $file_list_items \
                            [expr { $number - 1 }]] 2]
	return yes
    }
}

proc yes? {} {

    global window_error

    while { "yes" } {
    	set answer [string trim [gets stdin]]
	if { [eof stdin] } {
	    puts "Exiting manualreply"
	    exit_cleanup
	    exit 0
	}
	switch -- $answer {
	    y	-
	    yes	-
	    Y	-
	    YES	{ return yes }
	    n	-
	    no	-
	    N	-
	    NO	{ return no }
	}
	if { $answer == "" } {
	    set window_error \
		    "ERROR: empty input"
	} else {
	    set window_error \
		    "ERROR: could not understand `$answer'"
	}
	display_window
        set window_error ""
    }
}

proc continue? {} {

    puts -nonewline "\nType any character to continue "
    flush stdout
    gets stdin
    if { [eof stdin] } {
	puts "Exiting manualreply"
	exit_cleanup
	exit 0
    }
}
 
proc out_check { out } {
    if { $out == "" } return
    puts $out
    continue?
}

# Lock current directory with $dispatch_pid_file.  If
# $dispatch_pid_file already exists, let our user
# take corrective action.
#
proc get_lock {} {

    global dispatch_pid_file window_error window_bar \
    	   window_prompt


    while { "yes" } {

	if { [dispatch_lock] == "yes" } break

	set time [expr { [clock seconds] - \
			 [file mtime \
			       $dispatch_pid_file] }]

	if { ! [catch {
		   set pgid \
		       [read_file \
			   $dispatch_pid_file] }] } {
	    set group_display \
		[display_process_group $pgid]
	    set group_display \
		"Process Group Tree:\n\n$group_display"
	    set window_error ""
	    set b $window_bar
	    set_window_display "$b\n$group_display\n$b"
	} else {
	    refresh_file_list
	    set_file_list_display
	    set window_error \
		"ERROR: cannot read $dispatch_pid_file"
	}

	set_window_info "
$dispatch_pid_file file exists and is $time seconds old.
Maybe `autodispatch' or another `manualreply' is running.

u = update above info		d = delete\
				    $dispatch_pid_file
k = kill -INT process group	x = exit this program
m = kill -KILL process group"

	set window_prompt "> "

	while { "yes" } {
	
	    display_window

	    set answer [string trim [gets stdin]]
	    set window_error ""
	    switch -- $answer {
		u   {   break
		    }
		k   {   catch {
			    signal_process_group INT \
				[read_file \
				    $dispatch_pid_file]
			} out
			out_check $out
			break
		    }
		m   {   catch {
			    signal_process_group KILL \
				[read_file \
				    $dispatch_pid_file]
			} out
			out_check $out
			break
		    }
		d   {   file delete -force \
				    $dispatch_pid_file
			break
		    }
		x   {
			exit_cleanup
			exit 0
		    }
		""   {   if { [eof stdin] } {
			    exit_cleanup
			    exit 0
			} else {
			    set window_error \
				"ERROR: empty input"
			}
		    }
		default
		    {
			set window_error \
			    "ERROR: unknown\
			     answer `$answer'!"
		    }
	    }
	}
    }

    # Set exit_cleanup function (called before all exits
    # in judging common code) to unlock current directory.
    #
    proc exit_cleanup {} {
	dispatch_unlock
    }
}

# Unlock current directory.
#
proc clear_lock {} {

    dispatch_unlock
    proc exit_cleanup {} {}
}

# Read the received mail header.
#
proc read_received_mail {} {

    global received_file message_subject \
	   submitted_file submitted_program \
	   submitted_extension

    set received_ch [open $received_file r]
    read_header $received_ch
    close $received_ch

    # Compute submitted program.
    #
    if { [llength $message_subject] == 2 \
	 && [lindex $message_subject 0] == "submit" } {
	 set submitted_file \
	     [lindex $message_subject 1]
	 set submitted_program \
	     [file rootname $submitted_file]
	 set submitted_extension \
	     [file extension $submitted_file]
    } else {
	 set submitted_file      ""
	 set submitted_program   ""
	 set submitted_extension ""
    }
}

# Read a 1-line file and return its line.  Check for
# the file being non-existing, unreadable, and empty,
# and in these cases return `none', `UNREADABLE', and
# `EMPTY'.
#
proc read_score { score_file } {

    if { [file exists $score_file] } {
	if { ! [file readable $score_file] } {
	    return UNREADABLE
	} else {
	    set score [read_file $score_file]
	    if { $score == "" } {
		return EMPTY
	    } else {
	    	return $score
	    }
	}
    } else {
	return none
    }
}

# Initialize the file list and the last_file variable.
# Initialize last_display variable (equal to `file_list'
# or `file'.)
#
refresh_file_list
set last_file ""
set last_display "file_list"

get_lock
read_received_mail

# If auto score file, reply file, no replay file,
# and unchecked errors do not exists, consider running
# autojudge.
#
if { $submitted_program != "" \
     && [llength [glob -nocomplain \
                       $reply_file \
                       $no_reply_file \
                       $auto_score_file \
                       *-unchecked-error]] == 0 } {


    set_file_list_display
    set_window_info "
It appears that `autojudge' should be run."
    set window_prompt "Do you want to do so (y or n)? "
    set window_error ""

    display_window

    if { [yes?] } {

    	puts "Running autojudge"
	exec autojudge >@ stdout 2>@ stderr

	if { ! [file exists $auto_score_file] } {
	    puts "autojudge FAILED to make\
	         $auto_score_file"
	}
	continue?
    }
}

# Procedure to get a new manual_score by manual entry by
# the program user.
#
proc get_new_score { current_score } {

    switch $current_score {
        "Incorrect Output"		{ set code io }
        "Formatting Error"		{ set code fe }
        "Syntax Error"			{ set code se }
        "Program Crashed		{ set code pc }
        "Completely Correct"		{ set code cc }
        "Incomplete Output"		{ set code io }
        "Cpu Time Limit Exceeded"	{ set code te }
        "Output Size Exceeded"		{ set code oe }
    }

    while { "yes" } {

	puts -nonewline "
======================================================
Please select a new current score:
  io = Incorrect Output     cc = Completely Correct
  fe = Formatting Error     ic = Incomplete Output
  se = Syntax Error         te = Cpu Time Limit Exceeded
  pc = Program Crashed      oe = Output Size Exceeded

($code) > "

	flush stdout

	set answer [string string[gets stdin]
	switch [string trim [gets stdin]] {
	    "" { if { [eof stdin] } {
		     exit 0
		 } else {
		     return $current_score
		 }
	       }
	    io { return "Incorrect Output" }
	    fe { return "Formatting Error" }
	    se { return "Syntax Error" }
	    pc { return "Program Crashed" }
	    cc { return "Completely Correct" }
	    ic { return "Incomplete Output" }
	    te { return "Cpu Time Limit Exceeded" }
	    oe { return "Output Size Limit Exceeded" }
	}
    }
}

set directory [file tail [pwd]]
set proposed_score "none"

set auto_score   [read_score $auto_score_file]
set manual_score [read_score $manual_score_file]
    
set scoring_instructions [find_scoring_instructions]

set last_display "file_list"
set window_error ""

set main_menu "
#  = look at #      \
v# = view #         \
e# = edit #         \
x  = exit
ls = list files     \
c# = checkoff #     \
u# = uncheckoff #   \
sh = shell
ir = initiate reply \
er = edit reply     \
sr = send reply     \
ss = send score
sm = scoring menu   \
aj = autojudge      \
ai = autoinfo"

set scoring_menu "
io = Incorrect Output    cc = Completely Correct      \
#  = look at #
fe = Formatting Error    ic = Incomplete Output       \
mm = back to main menu
se = Syntax Error        te = Cpu Time Limit Exceeded \
ss = send score + mm
pc = Program Crashed     oe = Output Size Exceeded"

set menu $main_menu

while { "yes" } {

    if { $last_display == "file_list" } {
	refresh_file_list
	set_file_list_display
    } else {
	set_file_display $last_file
    }

    if { $submitted_program == "" } {
    	set scoring_info ""
	set window_info_height 5
    } else {
	set scoring_info "
Scoring Instructions: $scoring_instructions"

	if { $manual_score == "none" } {
	    set scoring_info "$scoring_info
Scores:    Auto: $auto_score    Proposed: $proposed_score"
	    set window_info_height 8
	} elseif { $proposed_score == "none" } {
	    set scoring_info "$scoring_info
Scores:    Auto: $auto_score    Manual: $manual_score"
	    set window_info_height 8
	} else {
	    set scoring_info "$scoring_info
Scores:    Auto:     $auto_score    Manual: $manual_score
           Proposed: $proposed_score"
	    set window_info_height 9
	}
    }

    set_window_info "Directory: $directory$scoring_info
$menu"
    set window_prompt "> "
    display_window
    set window_error ""

    set answer [string trim [gets stdin]]
    switch -regexp -- $answer {
        {^[1-9][0-9]*$} {
	    if { [get_file $answer] } {
		set_file_display $last_file
	    }
	}
        {^v[0-9]*$} {
	    regexp {^v([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		view_file $last_file
		set_file_display $last_file
	    }
	}
	{^e[0-9]*$} {
	    regexp {^e([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		edit_file $last_file
		set_file_display $last_file
	    }
	}
	{^c[0-9]*$} {
	    regexp {^c([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		catch { set last_file \
			    [make_checked \
			     $last_file] } out
		out_check $out
	    }
	}
	{^u[0-9]*$} {
	    regexp {^u([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		catch { set last_file \
		            [make_unchecked \
			     $last_file] } out
		out_check $out
	    }
	}
	{^ls$} { set last_display "file_list" }
	{^ir$} {
	    compose_reply -all
	    set last_file $reply_file+
	    edit_file $last_file
	}
	{^er$} {
	    if { ! [file exists $reply_file+] } {
		compose_reply -all
	    }
	    set last_file $reply_file+
	    edit_file $last_file
	}
	{^sr$} {
	    if { ! [file exists $reply_file+] } {
		puts "No reply composed!"
	    } else {
		set_file_display $reply_file+
		set window_error ""
		set window_prompt \
		    "Do you want to send the above\
			(y or n)? "
		display_window

		if { [yes?] } {
		    set window_prompt \
		       "Sending..."
		    display_window
		    send_reply
		    set last_file $reply_file
		    continue?
		} else {
		    set window_error "Send ABORTED!"
		}
	    }
	}
	{^aj$} {
	    puts "Running autojudge"
	    exec autojudge >@ stdout 2>@ stderr

	    if { ! [file exists $auto_score_file] } {
		puts "autojudge FAILED to make\
		     $auto_score_file"
	    }
	    continue?
	}
	{^sh$} { call_shell }
	{^ai$} {
	    exec autoinfo >@ stdout 2>@ stderr
	    continue?
	}
	{^sm$} { set menu $scoring_menu }
	{^mm$} { set menu $main_menu }
	{^x$} {
	    exit_cleanup
	    exit 0
	}
	{^io$} { set proposed_score \
		     "Incorrect Output" }
	{^cc$} { set proposed_score\
		     "Completely Correct" }
	{^fe$} { set proposed_score\
		     "Formatting Error" }
	{^ic$} { set proposed_score\
		     "Incomplete Output" }
	{^se$} { set proposed_score\
		     "Syntax Error" }
	{^te$} { set proposed_score\
		     "Cpu Time Limit Exceeded" }
	{^pc$} { set proposed_score\
		     "Program Crashed" }
	{^oe$} { set proposed_score\
		     "Output Size Exceeded" }
	{^$} {
	    if { [eof stdin] } {
		exit_cleanup
		exit 0
	    }
	    set window_error "ERROR: empty input"
	}
	{default} {
	    set window_error "ERROR: cannot understand\
				`$answer'!"
        }

    }
}


# Include common error catching code:
#
} caught_output
caught_error
