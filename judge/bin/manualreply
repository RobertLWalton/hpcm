#!/bin/sh -f
#
# Manually examine the contents of a directory and
# possibly reply.
#
# File:		manualreply
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Tue Sep 12 15:07:52 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/09/12 19:09:35 $
#   $RCSfile: manualreply,v $
#   $Revision: 1.4 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory; manualreply

    Given a submission directory as the current dir-
    ectory, permit a person to examine the contents of
    the directory and construct an email reply or a
    $no_reply_file file indicating there is to be no
    reply."

if { $argc != 0 } {
    puts $document
    exit 1
}

set received_ch [open $received_file r]
read_header $received_ch
close $received_ch

if { [llength $message_subject] == 2 \
     && [lindex $message_subject 0] == "submit"
     && [llength [glob -nocomplain \
                       $reply_file \
                       $no_reply_file \
                       $auto_score_file \
                       *-unchecked-error]] == 0 } {

    puts "Running autojudge"
    exec autojudge

    if { ! [file exists $auto_score_file] } {
	puts "autojudge FAILED to make $auto_score_file"
    }
}

# List of files in the current directory.  The N'th
# item on the list is itself a list of subitems
# with the format:
#
#	mtime filename post_comment pre_coment
#
# The total list is sorted by mtime.  The mtime has
# 0's prepended so all mtimes are the same length
# and ascii comparison will be the same as numeric
# comparison.
#
# The pre_comment is to be printed before the file
# name, and the post_command after the filename.
# However, error files usually do that have the post
# comment printed because their names are too long.
#
set file_list ""
set file_list_length 0

proc refresh_file_list { { indicate_new_files yes } } {

    global file_list file_list_length

    set new_file_list ""
    set n 0
    foreach file [glob -nocomplain *] {
    	set item [format {%040d} [file mtime $file]]
	lappend item $file
	set size [file size $file]
	if { $size == 0 } {
	    lappend item "0 bytes (empty)"
	} else {
	    lappend item "$size bytes"
	}
	set pre_comment ""
	if { $indicate_new_files } {
	    set pre_comment "new"
	    foreach item2 $file_list {
		if { [lindex $item2 1] == $file } {
		    set pre_comment ""
		    break
		}
	    }
	}
	lappend item $pre_comment

	lappend new_file_list $item
	incr n
    }

    set file_list [lsort $new_file_list]
    set file_list_length $n
}

proc put_file_list {} {

    global file_list

    set n 0
    set previous ""

    # If `previous' is non-empty it is the previous
    # item and has no more than 39 characters.
    #
    foreach item $file_list {
	incr n
	set next [format {%-4s%3d. %s} \
	                 [lindex $item 3] \
		         $n \
		         [lindex $item 1]]
	set commented "$next ([lindex $item 2])"

	if { [string length $commented] <= 80 } {
	    set next $commented
	}
	if { [string length $next] > 39 } {
	    if { $previous != "" } {
	    	puts $previous
	    }
	    puts $next
	    set previous ""
	} elseif { $previous != "" } {
	    puts [format {%-40s%s} $previous $next]
	    set previous ""
	} else {
	    set previous $next
	}
    }

    if { $previous != "" } {
	puts $previous
    }
}

proc get_file { number } {

    global file_list file_list_length last_file

    if { $number == "" } {
	if { $last_file == "" } {
	    puts "No previous file!"
	    return no
	} else {
	    return yes
	}
    } elseif { $number < 1 \
               || $number > $file_list_length } {
	puts "Bad file number: $number"
	return no
    } else {
	set last_file \
            [lindex [lindex $file_list \
                            [expr { $number - 1 }]] 1]
	return yes
    }
}

refresh_file_list no
set last_file ""

while { "yes" } {

    puts "Directory [file tail [pwd]]"
    puts ""
    put_file_list
    puts -nonewline "
v# = view #           e# = edit #        c# = checkoff #
ir = initiate reply   er = edit reply    sr = send reply
sh = call shell       u# = uncheckoff #	 x  = exit
ad = call autodispatch      ms = call manualscore

> "
    set answer [gets stdin]
    if { [eof stdin] } {
    	exit 0
    }

    if { [llength $answer] == 0 } {
    	continue;
    } elseif { [llength $answer] > 1 } {
        puts "Unknown: $answer"
	continue;
    }

    set answer [lindex $answer 0]

    switch -regexp $answer \
        {^v[0-9]*$} {
	    regexp {^v([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		view_file $last_file
	    }
	} \
	{^e[0-9]*$} {
	    regexp {^e([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		edit_file $last_file
	    }
	} \
	{^c[0-9]*$} {
	    regexp {^c([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		catch { set last_file \
			    [make_checked \
			     $last_file] } out
		if { $out != "" } {
		    puts $out
		}
	    }
	} \
	{^u[0-9]*$} {
	    regexp {^u([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		catch { set last_file \
		            [make_unchecked \
			     $last_file] } out
		if { $out != "" } {
		    puts $out
		}
	    }
	} \
	{ir} {
	    compose_reply -all
	    set last_file $reply_file+
	    edit_file $last_file
	} \
	{er} {
	    set last_file $reply_file+
	    edit_file $last_file
	} \
	{sr} {
	    if { ! [file exists $reply_file+] } {
		puts "No reply composed!"
	    } else {
	        puts "Do you want to send:"
	        puts ""
	        put_file $reply_file+ stdout 12
		puts -nonewline "
(y or n)? "
	        set answer [gets stdin]
	        if { [eof stdin] } {
		    exit 0
		} elseif { [regexp {^[yY]} $answer] } {
		    puts "Sending..."
		    send_reply
		    set last_file $reply_file
		} else {
		    puts "Send ABORTED!"
		}
	    }
	} \
	{sh} {
	    call_shell
	} \
	{ad} {
	    exec autodispatch -force
	} \
	{ms} {
	    exec manualscore
	} \
	{x} {
	    exit 0
	}

    refresh_file_list
}


# Include common error catching code:
#
} caught_output
caught_error
