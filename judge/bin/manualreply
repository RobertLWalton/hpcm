#!/bin/sh
#
# Manually examine the contents of a directory and
# possibly reply, maybe with a manual score.
#
# File:		manualreply
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Sep 10 01:26:24 EDT 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/09/10 05:36:41 $
#   $RCSfile: manualreply,v $
#   $Revision: 1.30 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Table of Contents:
#
#	Startup
#	Display
#	Reading Files
#	File List
#	Response Functions
#	Locking Functions
#	Reply Functions
#	Menu Initialization
#	Menu Loop


# Startup
# -------

# If an subdirectory name is given, make it current, and
# consume the subdirectory name argument.  This must be
# done before looking for the parameters file.
#
# Don't change argc or argv so error output will work.
#
set my_argc $argc
set my_argv $argv
if { $my_argc >= 1 \
     && ! [regexp {^-} [lindex $my_argv 0]] } {
    cd [lindex $my_argv 0]
    set my_argv [lreplace $my_argv 0 0]
    set my_argc [expr { $my_argc - 1 }]
}

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
source $lib_directory/display_common.tcl
source $lib_directory/scoring_common.tcl
catch {

set document "
manualreply \[directory\]

    If the directory argument is given, this program
    makes that directory current before searching for
    the `$judging_parameters_file' file or doing\
    anything else.

    Given a submission directory as the current direc-
    tory, this program permits a person to examine the
    contents of this directory and construct an email
    reply, or alternatively, create a $no_reply_file\
    		file that
    indicates there is to be no reply.  A\
    		$manual_score_file
    file may also be written with a score that is sent
    in the reply.  Unchecked error log files may be
    inspected and checked off."

# If there are any arguments, print documentation and
# exit with error.
#
if { $my_argc != 0 } {
    puts $document
    exit 1
}


# Menus.

set main_menu "
                    \
? = help            \
x = exit            \

#  = look at #      \
v# = view #         \
e# = edit #         \
ls = list files
pr = lookat proofs  \
c# = checkoff #     \
u# = uncheckoff #   \
sh = shell
ir = initiate reply \
er = edit reply     \
sr = send reply     \
nr = no reply
sm = scoring menu   \
aj = autojudge      \
ai = autoinfo       \
ss = send score"

set scoring_menu "
                         ? = help                     \
x  = exit
io = Incorrect Output    cc = Completely Correct      \
#  = look at #
fe = Formatting Error    ic = Incomplete Output       \
mm = back to main menu
se = Syntax Error        te = Cpu Time Limit Exceeded \
ss = send score + mm
pc = Program Crashed     oe = Output Size Exceeded    \
pr = lookat proofs"

# Help displays.
#
# These must begin and end with a blank line.  The
# blank lines are changed to window bars by code.

set help(?) "
? WHAT		E.g., `? ls'.  Gives help for WHAT,\
                where WHAT can be:

#  = file identifier\
?  = help           \
x  = exit           \
aj = autojudge
v  = view #         \
e  = edit #         \
ls = list files     \
ai = autoinfo
pr = lookat proofs  \
c  = checkoff #     \
u  = uncheckoff #   \
sh = shell
ir = initiate reply \
er = edit reply     \
sr = send reply     \
nr = no reply

sm = goto scoring menu   \
mm = goto main menu      \
ss = send score + mm

io = Incorrect Output    \
cc = Completely Correct 
fe = Formatting Error    \
ic = Incomplete Output 
se = Syntax Error        \
te = Cpu Time Limit Exceeded
pc = Program Crashed     \
oe = Output Size Exceeded
"

set help(#) "
#			# denotes a `file\
                        identifier'.   This is one of:

    A decimal integer, denoting the file with the given\
    	number listed
    by the last `ls' command.

    A file extension, beginning with a `.'.  This\
    	denotes the file with the
    given extension, if that is unambiguously defined.

    The beginning of a file name, if the first\
        character of the name is
    a CAPITAL letter.  This denotes the file with the\
    	given name, if that
    is unambiguously defined.

Typing a file identifier by itself as a command\
    displays the file.
"

set help(x) "
x

Exit from the current program.  You can also do this by\
    typing control-D.
"

set help(aj) "
aj

Call `autojudge' in the current directory.  The\
    autojudge program makes
any missing or out of date Auto_Score file and any\
    missing or out of date
files needed to make a new Auto_Score file.
"

set help(v) "
v
v #

View the file identified by the file identifier # (or\
    the last file displayed
if # is missing) using an editor in read only mode,\
    such as UNIX `view'.
"

set help(e) "
e
e #

Edit the file identified by the file identifier # (or\
    the last file displayed
if # is missing) using an editor such as UNIX `vi'.
"

set help(ls) "
ls

List the names of all the files in the current\
    directory.  This list is in
order of the file creation dates, and the time the file\
    is created is given
to the nearest minute, relative to the creation time of\
    the $received_file
file if that is present, or of the most recent file\
    otherwise.  Here `inf'
means a time too large to be displayed.

The files are numbered.  These numbers can be used as\
    file identifiers in
other commands.  The numbers will change when files are\
    deleted.

Type `? ls2' for more information.
"
set help(ls2) "
ls

After each file name listed a comment may appear if\
    there is room.  Some of
these are:

    (DDDDDb)		DDDDD is size of the file in\
			    bytes.
    (empty)		The file is empty.
    (directory)		The file is a directory.
    (dangling link)	The file is a link with no\
			    resolution.
    			If a link can be resolved,\
			    the file it resolves to is
			the file named.
    {CCC}		CCC is the contents of the\
			    file, if the file is a
    			single line file with contents\
			    CCC.

Type `? ls3' for more information.
"
set help(ls3) "
ls

If a file is listed that is newly created, a * appears\
    after the file time.
This * disappears when the list of files is\
    regenerated, so its presence
is not that reliable.
"

set help(ai) "
ai

Run the `autoinfo' program in the current\
    directory.  If the $received_file
file has a subject of the form `get ...', the autoinfo\
    program will send
an email response containing the files named in the\
    subject.
"

set help(pr) "
= lookat proofs
"

set help(c) "
c
c #

Change the unchecked error file identified by # (or the\
    last file displayed
if # is omitted) to be a checked error file.  This is\
    done by renaming the
file so the `unchecked' part of the name becomes\
    `checked'.

Unchecked error files are searched for by programs such\
    as `tracker', and
brought to the attention of a person.  But checked\
    error files are ignored by
these programs, as they assume a checked error file\
    has been read by a person.
"

set help(u) "
u
u #

Change the checked error file identified by # (or the\
    last file displayed
if # is omitted) to be a unchecked error file.  This is\
    done by renaming the
file so the `checked' part of the name becomes\
    `unchecked'.

Unchecked error files are searched for by programs such\
    as `tracker', and
brought to the attention of a person.  But checked\
    error files are ignored by
these programs, as they assume a checked error file\
    has been read by a person.

It is unusual for a checked file to be made unchecked.
"

set help(sh) "
sh

Execute a shell (such as csh) in the current directory\
    as a subprogram.
When the shell is exited, this program resumes.
"

set help(ir) "
ir

Create a reply file (named $reply_file+) and invoke an\
    editor (e.g., vi)
for that file.  If a reply file already exists, it is\
    overwritten.
"

set help(er) "
er

Edit an existing reply file (the file named\
    $reply_file+), creating the
file first if it does not already exist.
"

set help(sr) "
sr

Send the reply file to the submitter, after first\
    displaying it and asking
the user to be sure it should be send.  The reply file\
    is the file named
$reply_file+ that is created by the `ir' or `er'\
    commands.
"

set help(nr) "
nr

Has the user type a line that is then written into a\
    newly created one line
$no_reply_file file.  The presence of this file\
    indicates to HPCM that no
reply needs to be generated for the current submission\
    directory.  For example,
the `tracker' program searches for submission\
    directories that do NOT contain
either a $reply_file file or a $no_reply_file file.

The `lookat' program can search for submission\
    directories whose $no_reply_file
files have contents matching a regular expression, so\
    what is written into the
$no_reply_file can be used to find the submission\
    directory later.
"

set help(sm) "
sm

Change the menu displayed to the scoring menu.  When\
    not in a subtask such
as displaying proofs, one of two menus is displayed:\
    the main menu, or the
scoring menu.  No matter which of these two menus is\
    displayed, all
commands listed on both menus can be entered.
"

set help(mm) "
mm

Change the menu displayed to the main menu.  When not\
    in a subtask such
as displaying proofs, one of two menus is displayed:\
    the main menu, or the
scoring menu.  No matter which of these two menus is\
    displayed, all
commands listed on both menus can be entered.
"

set help(ss) "
ss

Composes a reply message ($reply_file+ file) containing\
    the proposed score
and sends that message.  Sets the manual score (in the\
    $manual_score_file file)
to this proposed score.  If anything unusual exists,\
    such as the presence of a
previous manual score, the user is given a chance to\
    edit and abort the
message before it is sent.

After the message is sent this command restores the\
    main menu.
"

set help(io) "

io = Incorrect Output    cc = Completely Correct
fe = Formatting Error    ic = Incomplete Output
se = Syntax Error        te = Cpu Time Limit Exceeded
pc = Program Crashed     oe = Output Size Exceeded

Set the proposed score to the indicated value.
"

set help(cc) $help(io)
set help(fe) $help(io)
set help(ic) $help(io)
set help(se) $help(io)
set help(te) $help(io)
set help(pc) $help(io)
set help(oe) $help(io)


# Menu Initialization
# ---- --------------

get_lock
refresh_file_list

# If auto score file, reply file, no replay file,
# and unchecked errors do not exists, consider running
# autojudge.
#
if { $submitted_program != "" \
     && [llength [glob -nocomplain \
                       $reply_file \
                       $no_reply_file \
                       $auto_score_file \
                       *-unchecked-error]] == 0 } {


    set_file_list_display
    set window_info_height 5
    set_window_info "
It appears that `autojudge' should be run."
    set window_prompt "Do you want to do so (y or n)? "
    set window_error ""

    display_window

    if { [yes?] } {

    	puts "Running autojudge"
	exec autojudge >@ stdout 2>@ stderr

	if { ! [file exists $auto_score_file] } {
	    puts "autojudge FAILED to make\
	          $auto_score_file"
	}
	continue?
    }
}

set menu $main_menu

set directory [file tail [pwd]]
set proposed_score none
set last_file ""
set last_display ""

# Procedure to recompute window_display for menu loop.
#
proc refresh_display {} {

    global last_display last_file last_help

    if { $last_display == "file_list" } {
	set_file_list_display
    } elseif { $last_display == "file" } {
	set_file_display $last_file
    } elseif { $last_display == "help" } {
	set_window_display $last_help
    }
}

# Procedure to recompute window_info for menu loop.
#
proc refresh_info {} {

    global proposed_score manual_score auto_score \
    	   window_info_height directory menu \
	   scoring_instructions submitted_program

    set old_info_height $window_info_height

    if { $proposed_score == "none" } {
	if { $manual_score != "none" } {
	    set proposed_score $manual_score
	} else {
	    set proposed_score $auto_score
	}
    }
    if { $submitted_program == "" } {
    	set scoring_info ""
	set window_info_height 6
    } else {
	set scoring_info "
Scoring Instructions: $scoring_instructions"

	if { $manual_score == "none" } {
	    set scoring_info "$scoring_info
Scores:    Auto: $auto_score    Proposed:\
			        $proposed_score"
	    set window_info_height 8
	} elseif { $proposed_score == "none" } {
	    set scoring_info "$scoring_info
Scores:    Auto: $auto_score    Manual: $manual_score"
	    set window_info_height 8
	} else {
	    set scoring_info "$scoring_info
Scores:    Auto:     $auto_score    Manual:\
				    $manual_score
           Proposed: $proposed_score"
	    set window_info_height 9
	}
    }

    set_window_info \
        "Dir: $directory$scoring_info$menu"

    # Refresh the display if window_info_height is
    # changed.
    #
    if { $window_info_height != $old_info_height } {
        refresh_display
    }
}

# Function to display proofs.
#
proc display_proofs {} {

    global last_file window_error window_prompt \
           window_info_height

    compute_instruction_array
    compute_score_and_proof_arrays
    compute_score
    set info "[compute_proof_info]   \
              n = goto next proof   \
	      p = goto previous proof\n   \
	      mm = return to main menu   \
	      sm = return to scoring menu"

    set window_info_height [llength [split $info "\n"]]
    set_window_info $info

    if { [get_proof] == "no" } return ""
    if { [set_proof_display] == "no" } return ""

    while { "yes" } {

	set window_prompt "> "
	display_window
	set window_error ""

	set answer [string trim [gets stdin]]
	switch -regexp -- $answer {
	    {^mm$} { return mm }
	    {^sm$} { return sm }
	    {^$} {
		if { [eof stdin] } {
		    exit_cleanup
		    exit 0
		}
		set window_error "ERROR: empty input"
	    }
	    default {
		if { [regexp {^\.} $answer] } {
		    if { [get_file $answer] } {
			set_file_display $last_file
		    }
	    	} elseif { [get_proof $answer] } {
		     set_proof_display
		}
	    }
	}
    }
}

# Menu Loop
# ---- ----

refresh_file_list
refresh_info
set_file_list_display

set window_error ""

while { "yes" } {

    set window_prompt "> "
    display_window
    set window_error ""

    set answer [string trim [gets stdin]]
    switch -regexp -- $answer {
        {^[1-9][0-9]*$} {
	    if { [get_file $answer] } {
		set_file_display $last_file
	    }
	}
        {^v *[0-9]*$} {
	    regexp {^v *([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		view_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
        {^v } {
	    regexp {^v +([^ ]*)$} $answer forget id
	    if { [get_file $id] } {
		view_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^e *[0-9]*$} {
	    regexp {^e *([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		edit_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^e } {
	    regexp {^e +([^ ]*)$} $answer forget id
	    if { [get_file $id] } {
		edit_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^c *[0-9]*$} {
	    regexp {^c *([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
	        set mail_file $last_file.mail
		if { [catch { set last_file \
			          [make_checked \
			              $last_file] } \
			    out] } {
		    out_check $out
		} elseif { [file exists $mail_file ] \
			   && [catch {
			          make_checked \
				      $mail_file
			       } out] } {
		    out_check $out
		} else {
		    set window_error \
		        "Checked $last_file"
		}
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^u *[0-9]*$} {
	    regexp {^u *([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
	        set mail_file $last_file.mail
		if { [catch { set last_file \
			          [make_unchecked \
			              $last_file] } \
			    out] } {
		    out_check $out
		} elseif { [file exists $mail_file ] \
			   && [catch {
			          make_unchecked \
				      $mail_file
			       } out] } {
		    out_check $out
		} else {
		    set window_error \
		        "Unchecked $last_file"
		}
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^ls$} {
	    refresh_file_list
	    refresh_info
	    set_file_list_display
	}
	{^ir$} {
	    compose_reply -all
	    set last_file $reply_file+
	    edit_file $last_file
	    refresh_file_list
	    refresh_info
	    set_file_display $last_file
	}
	{^er$} {
	    if { ! [file exists $reply_file+] } {
		compose_reply -all
	    }
	    set last_file $reply_file+
	    edit_file $last_file
	    refresh_file_list
	    refresh_info
	    set_file_display $last_file
	}
	{^sr$} {
	    if { ! [file exists $reply_file+] } {
		set window_error \
		    "ERROR: No reply composed!"
	    } else {
		set_file_display $reply_file+
		set window_error ""
		set window_prompt \
		    "Do you want to send the above\
			(y or n)? "
		display_window

		if { [yes?] } {
		    set window_prompt \
		       "Sending..."
		    display_window
		    catch { send_reply } out
		    set last_file $reply_file
		    if { $out == "" } {
		    	set window_error "Reply sent!"
		    } else {
		        puts "\n$out"
			continue?
		    }
		} else {
		    set window_error "Send ABORTED!"
		}
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^nr$} {
	    set window_error \
		"Type line to write into $no_reply_file\
                 file (or type ^D to abort):"
	    set window_prompt "> "
	    display_window
	    set no_reply_line [string trim [gets stdin]]
	    if { [eof stdin] } {
		set window_error \
		    "$no_reply_file NOT WRITTEN"
	    } else {
		write_file $no_reply_file $no_reply_line
		set window_error \
		    "$no_reply_file written"
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^ss$} {
	    if { $proposed_score == "none" } {
	        set window_error "ERROR: set the\
		    proposed score before sending it"
	    } elseif { [compose_score_reply] } {
		send_score_reply
		set last_file $reply_file
		set last_display file
	        set window_error "Score sent!"
	    } else {
	        set window_error "NOTICE: Old manual\
		    score exists or scoring mode is\
		    `auto'."
	        set window_prompt "To continue you\
		    must edit reply.  Do you want to\
		    continue (y or n)? "
		set last_file $reply_file+
		set_file_display $reply_file+
		display_window
		if { [yes?] } {
		    edit_file $last_file
		    set window_error "Reply is ready\
			to send."
		    set window_prompt "Do you want to\
			send it (y or n)? "
		    display_window
		    if { [yes?] } {
		    	send_score_reply
			set last_file $reply_file
			set window_error "Score sent!"
		    } else {
			set window_error "Score sending\
			    ABORTED!"
			set last_display file_list
		    }
		} else {
		    set window_error "Score sending\
			ABORTED!"
		    set last_display file_list
		}
	    }
	    set menu $main_menu
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^aj$} {
	    puts "Running autojudge"
	    exec autojudge >@ stdout 2>@ stderr

	    if { ! [file exists $auto_score_file] } {
		puts "autojudge FAILED to make\
		     $auto_score_file"
	    }
	    continue?
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^sh$} {
	    call_shell
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^ai$} {
	    exec autoinfo >@ stdout 2>@ stderr
	    continue?
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^sm$} {
	    set menu $scoring_menu
	    refresh_info
	}
	{^mm$} {
	    set menu $main_menu
	    refresh_info
	}
	{^x$} {
	    exit_cleanup
	    exit 0
	}
	{^io$} {
	    set proposed_score "Incorrect Output"
	    refresh_info
	}
	{^cc$} {
	    set proposed_score "Completely Correct"
	    refresh_info
	}
	{^fe$} {
	    set proposed_score "Formatting Error"
	    refresh_info
	}
	{^ic$} {
	    set proposed_score "Incomplete Output"
	    refresh_info
	}
	{^se$} {
	    set proposed_score "Syntax Error"
	    refresh_info
	}
	{^te$} {
	    set proposed_score "Cpu Time Limit Exceeded"
	    refresh_info
	}
	{^pc$} {
	    set proposed_score "Program Crashed"
	    refresh_info
	}
	{^oe$} {
	    set proposed_score "Output Size Exceeded"
	    refresh_info
	}
	{^pr$} {
	    switch -exact [display_proofs] {
	        "" {}
		mm { set menu $main_menu }
		sm { set menu $scoring_menu }
	    }
	    refresh_info
	}
	{^\?} {
	    regexp {^\? *([^ ]*)$} $answer forget what
	    if { $what == "" } {
	        set what "?"
	    } elseif { ! [info exists help($what)] } {
		set window_error \
		    "ERROR: no help available for\
				  `$what'!"
		set what "?"
	    }
	    set last_help $help($what)
	    set last_help \
	        "$window_bar$last_help$window_bar"
	    set_window_display $last_help
	    set last_display help
	}
	{^$} {
	    if { [eof stdin] } {
		exit_cleanup
		exit 0
	    }
	    set window_error "ERROR: empty input"
	}
	{default} {
	    if { [get_file $answer] } {
		set_file_display $last_file
	    } else {
		set window_error \
		    "ERROR: cannot understand\
				  `$answer'!"
	    }
        }

    }
}


# Include common error catching code:
#
} caught_output
caught_error
