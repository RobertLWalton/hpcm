#!/bin/sh
#
# Manually examine the contents of a directory and
# possibly reply, maybe with a manual score.
#
# File:		manualreply
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Feb 10 08:47:44 EST 2003
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2003/02/10 13:59:26 $
#   $RCSfile: manualreply,v $
#   $Revision: 1.60 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Table of Contents:
#
#	Startup
#	Menus
#	Help Displays
#	Reply Functions
#	Menu Initialization
#	Menu Loop


# Startup
# -------

# Compute absolute name of current directory as we
# may change the current directory.
#
set current_directory [file dirname $argv0]
if { ! [regexp {^/} $current_directory] } {
    set current_directory [pwd]/$current_directory
}

# If an subdirectory name is given, make it current, and
# consume the subdirectory name argument.  This must be
# done before looking for the parameters file.
#
# Don't change argc or argv so error output will work.
#
set my_argc $argc
set my_argv $argv
if { $my_argc >= 1 \
     && ! [regexp {^-} [lindex $my_argv 0]] } {
    cd [lindex $my_argv 0]
    set my_argv [lrange $my_argv 1 end]
    incr my_argc -1
}

# Include common code and parameters:
#
set lib_directory "$current_directory/../lib"
source $lib_directory/judging_common.tcl
source $lib_directory/display_common.tcl
source $lib_directory/scoring_common.tcl
catch {

set document "
manualreply \[directory\]

    If the directory argument is given, this program
    makes that directory current before searching for
    the `$judging_parameters_file' file or doing\
    anything else.

    Given a submission directory as the current direc-
    tory, this program permits a person to examine the
    contents of this directory and construct an email
    reply, or alternatively, create a $no_reply_file\
    		file that
    indicates there is to be no reply.  A\
    		$manual_score_file
    file may also be written with a score that is sent
    in the reply.  Unchecked error log files may be
    inspected and checked off.

    While running, this program locks the current direc-
    tory by creating a $dispatch_pid_file file.  If no
    $auto_score_file, $reply_file, $no_reply_file, or\
    	unchecked error
    files exist when this program is started, this
    program will suggest that `autojudge' should be run.

    This program sources any problem .rc file it finds
    after any suggested `autojudge' is run.

    As a complex interactive program, manualreply has
    extensive builtin help documentation."

# If there are any arguments, print documentation and
# exit with error.
#
if { $my_argc != 0 } {
    puts $document
    exit 1
}


# Menus
# -----

set main_menu "
    ? = help        \
x = exit            \
sm = scoring menu   \
ss = send score
#  = look at #      \
v# = view #         \
e# = edit #         \
ls = list files
pr = lookat proofs  \
c# = checkoff #     \
u# = uncheckoff #   \
sh = shell
ir = initiate reply \
er = edit reply     \
sr = send reply     \
nr = no reply
sq = send query     \
xq = examine query  \
aj = autojudge      \
ai = autoinfo"

set scoring_menu "
                        ? = help                       \
x  = exit
io = Incorrect Output   cc = Completely Correct        \
 #  = look at #
fe = Formatting Error   ic = Incomplete Output         \
 mm = back to main menu
se = Syntax Error       te = Cpu Time Limit Exceeded   \
 ss = send score + mm
pc = Program Crashed    oe = Output Size Limit Exceeded\
 pr = lookat proofs"

# Help Displays
# ---- --------

# These must begin and end with a blank line.  The
# blank lines are changed to window bars by code.

set help(?) "
? WHAT

Gives help for WHAT, where WHAT can be:

    Any command listed in the main or scoring menu. \
    	E.g. `? ls'.
    Note that any command in either menu can be\
    	executed even
    if the other menu is being displayed.

    Any standard filename, e.g. `? Received_Mail', or\
    	any standard file
    extension, e.g., `? .diff'.
    
Type `? topics' for list of help topics.
"

set help($dispatch_pid_file) "
$dispatch_pid_file	A file containing the process\
			    ID (pid) of a program
		that has locked the current directory. \
			    For example, the
		manualreply program locks the directory\
			    it is looking at.

$gotten_file	A list of files gotten from the current\
			    directory by a
	get request.  Means the current directory is\
			    NOT a solution
	submission.
"
set help($gotten_file) $help($dispatch_pid_file)

set help(#) "
#			# denotes a `file\
                        identifier'.   This is one of:

  - The decimal integer number of a file listed by the\
    	last `ls' command.
  - A file extension, beginning with a `.'.
  - The beginning of a file name, if the first\
        character of the name is
    a CAPITAL letter.
  - The full name of the file.

Typing a file identifier by itself is recoginzed as a\
    command to display
the file, if the file identifier is unambiguous.
"

set help(x) "
x

Exit from the current program.  You can also do this by\
    typing control-D.
"

set help(sq) "
sq

Send a query to the judge about the current submission.

You can do this if you are the judge or are an auxilary\
    `read only' judge.

A file to be emailed to the judge is created in the\
    /tmp directory and the
editor is called on that file.  The subject of the\
    email is set to indicate
the current submission directory, and this subject\
    SHOULD NOT be changed.
You should edit the body of the message, and upon\
    return from the editor,
you will be asked if you want to send the message to\
    the judge, or continue
editing the message, or abort the message.
"

set help(xq) "
xq

Examine a submission mentioned in the subject of a\
    query to the judge.

If the current submission is a query whose `Subject:'\
    is of the form
`About SUBMISSION-DIRECTORY', this command executes\
    `manualreply' on the
indicated submission directory.  This is useful in\
    examining the submission
directory mentioned in a query created by the sq\
    command.  When the
`manualreply' executed returns, this `manualreply'\
    continues.
"

set help(aj) "
aj


Call `autojudge -manual' in the current directory.  The\
    autojudge
program makes any missing or out of date\
    $auto_score_file file and any missing
or out of date files needed to make a new\
    $auto_score_file file.  The -manual
option suppresses sending email to the submitter.
"

set help(v) "
v
v #

View the file identified by the file identifier # (or\
    the last file displayed
if # is missing) using an editor in read only mode,\
    such as UNIX `view'.
"
set help(v#) $help(v)

set help(e) "
e
e #

Edit the file identified by the file identifier # (or\
    the last file displayed
if # is missing) using an editor such as UNIX `vi'.
"
set help(e#) $help(e)

set help(ls) "
ls

List the names of all the files in the current\
    directory.  This list is in
order of the file creation dates, and the time the file\
    is created is given
to the nearest minute, relative to the creation time of\
    the $received_file
file if that is present, or of the most recent file\
    otherwise.  Here `inf'
means a time too large to be displayed.

The files are numbered.  These numbers can be used as\
    file identifiers in
other commands.  The numbers will change when files are\
    deleted.

Type `? ls2' for more information.
"
set help(ls2) "
ls      (2 of 3)

After each listed file name one of the following may\
    appear if there is room:

    (DDDDDb)		DDDDD is size of the file in\
			    bytes.
    (empty)		The file is empty.
    (directory)		The file is a directory.
    (dangling link)	The file is a link with no\
			    resolution.
    {CCC}		CCC is the contents of a single\
			    line file.

Type `? ls3' for more information.
"
set help(ls3) "
ls      (3 of 3)

If a file is listed that is newly created, a * appears\
    after the file time.
This * disappears when the list of files is\
    regenerated, so its presence
is not that reliable.
"

set help(ai) "
ai

Run the `autoinfo' program in the current\
    directory.  If the $received_file
file has a subject of the form `get ...', the autoinfo\
    program will send
an email response containing the files named in the\
    subject.
"

set help(pr) "
pr

Look at proofs of the score assigned by the `autoscore'\
    program (which is called
by `autojudge').  Each proof consists of a pair of\
    tokens, one in the .out file
and one in the .test file, that should match but do\
    not.  The mismatch is given
a name, called a difference type name, such as\
    `integer' or `word'.  The
mismatched tokens and the lines surrounding them are\
    displayed.  The mismatched
tokens are highlighted.  The difference type name is\
    displayed on the last ====
bar line.

Type `? pr2' for more information.
"

set help(pr2) "
pr      (2 of 5)

If the difference type is `integer' or `float', after\
    its name in the ==== bar
line the absolute and relative difference of the\
    mismatched integer or floating
point number tokens are displayed.

Documentation for different difference types is\
    available by executing the
`scorediff -doc' command (outside manualreply).

Type `? pr3' for more information.
"

set help(pr3) "
pr      (3 of 5)

You can look at proofs in a particular proof group:\
    e.g, if the score is
`Incorrect Output' the proofs relevant to that score\
    are in the `io' group.
The `n' and `p' commands move to the next or previous\
    proof in the current proof
group.  Proofs are ordered according to position of the\
    tokens in the files.
The number of the current proof within its group is in\
    brackets on the last
==== bar line of the display.  If the name of the proof\
    group is different from
the name a difference type, the name of the group is\
    also within the brackets.

Type `? pr4' for more information.
"

set help(pr4) "
pr      (4 of 5)

There is one proof group for each possible score for\
    which there are supporting
proofs.  E.g., the `io' group consists of proofs\
    supporting the score
`Incorrect Output', and the `fe' group consists of\
    proofs supporting the
score `Formatting Error'.  These groups, their two\
    letter group names, and the
difference types of proofs supporting each score are\
    listed just above the
prompt.  Also listed for each difference type is the\
    number of proofs of that
type in square brackets (however, only the first so\
    many proofs of each type
are available).

Type `? pr5' for more information.
"

set help(pr5) "
pr      (5 of 5)

In addition to the proof group for each score, there is\
    also a proof group
for each difference type.  Thus `integer' is the proof\
    group for a difference
type, while `io' is the proof group a score (Incorrect\
    Output).

To change the proof group being displayed, type the\
    name of the group.   You
can contract this name by omitting characters from its\
    end or before any `-',
so long as what you type begins with a letter and has\
    two or more characters.
Thus if for a particular submission there are type\
    differences `word' and
`word-eof1', but not `word-eof2', then `word' can be\
    abbreviated by `wo' and
`word-eof1' can be abbreviated by `w-'.
"

set help(c) "
c
c #

Change the unchecked error file identified by # (or the\
    last file displayed
if # is omitted) to be a checked error file.  This is\
    done by renaming the
file so the `unchecked' part of the name becomes\
    `checked'.

Unchecked error files are searched for by programs such\
    as `tracker', and
brought to the attention of a person.  But checked\
    error files are ignored by
these programs, as they assume a checked error file\
    has been read by a person.

Type `? .mail' for information about `.mail' files\
    associated with error files.
"
set help(c#) $help(c)

set help(.mail) "
.mail

Associated with an error file there is sometimes a file\
    with the same name
but with the extension `.mail' added.  This file\
    contains an email message
sent to a submitter.  Except to look at this email\
    message, this file
should be ignored.  The absence of this file indicates\
    no submitter was
notified of the error.

Error files can be checked or unchecked, according to\
    whether or not they
have `-checked' or `-unchecked' in their names.  When\
    an error file name is
changed to alter its checked status, the name of its\
    associated `.mail' file
is also changed.
"

set help(u) "
u
u #

Change the checked error file identified by # (or the\
    last file displayed
if # is omitted) to be a unchecked error file.  This is\
    done by renaming the
file so the `checked' part of the name becomes\
    `unchecked'.

It is unusual for a checked file to be made unchecked.

Type `? c' for more information about error files.
"
set help(u#) $help(u)

set help(sh) "
sh

Execute a shell (such as csh) in the current directory\
    as a subprogram.
When the shell is exited, this `manualreply' program\
    resumes.
"

set help(ir) "
ir

Initialize (create) a reply file (named $reply_file+)\
    and invoke an editor
(e.g., vi) for that file.  If a reply file already\
    exists, it is overwritten.
"

set help(er) "
er

Edit an existing reply file (the file named\
    $reply_file+), creating the
file first if it does not already exist.
"

set help(sr) "
sr

Send the reply file to the submitter, after first\
    displaying it and asking
the user to be sure it should be send.  The reply file\
    is the file named
$reply_file+ that is created by the `ir' or `er'\
    commands.
"

set help(nr) "
nr

Lets the user type a line that is then written into a\
    newly created one line
$no_reply_file file.  The presence of this file\
    indicates to HPCM that no
reply needs to be generated for the current submission\
    directory.  For example,
the `tracker' program searches for submission\
    directories that do NOT contain
either a $reply_file file or a $no_reply_file file.

The `lookat \"${no_reply_file}::regexp\"' program\
    command searches for submission
directories whose $no_reply_file files have contents\
    matching the regular expression
`regexp', so what is written into the $no_reply_file\
    file can be used to find the
submission directory later.
"

set help(sm) "
sm

Change the menu displayed to the scoring menu.  When\
    not in a subtask such
as displaying proofs, one of two menus is displayed:\
    the main menu, or the
scoring menu.  No matter which of these two menus is\
    displayed, all
commands listed on both menus can be entered.
"

set help(mm) "
mm

Change the menu displayed to the main menu.  When not\
    in a subtask such
as displaying proofs, one of two menus is displayed:\
    the main menu, or the
scoring menu.  No matter which of these two menus is\
    displayed, all
commands listed on both menus can be entered.
"

set help(ss) "
ss

Composes a reply message ($reply_file+ file) containing\
    the proposed score
and sends that message.  Sets the manual score (in the\
    $manual_score_file file)
to this proposed score.  If anything unusual exists,\
    such as the presence of a
previous manual score, the user is given a chance to\
    edit and abort the
message before it is sent.

After the message is sent this command restores the\
    main menu.
"

set help(io) "

io = Incorrect Output    cc = Completely Correct
fe = Formatting Error    ic = Incomplete Output
se = Syntax Error        te = Cpu Time Limit Exceeded
pc = Program Crashed     oe = Output Size Limit Exceeded

These commands set the proposed score to the value\
    indicated by the command.
"
set help(cc) $help(io)
set help(fe) $help(io)
set help(ic) $help(io)
set help(se) $help(io)
set help(te) $help(io)
set help(pc) $help(io)
set help(oe) $help(io)

set help(ps) "

ps XX		where XX is one of:

io = Incorrect Output    cc = Completely Correct
fe = Formatting Error    ic = Incomplete Output
se = Syntax Error        te = Cpu Time Limit Exceeded
pc = Program Crashed     oe = Output Size Limit Exceeded

Set the proposed score to the indicated value.  This\
	command is only valid
when displaying proofs with the `pr' command.  When\
	the main or scoring menus
are displayed, XX can be typed by itself as a command.
"


set help($reply_file) "
$reply_file		The last and final reply\
			   message.  If this is present,
			the judge has finished with\
			  this submission.

$no_reply_file		A file whose presence indicates\
    the judge has finished
			with this submission but is\
			  not going to reply.  By
			putting a comment in this file,\
			  the judge can locate
			the submission later by using\
			  the lookat program to
			search for submissions with a\
			  particular $no_reply_file
			comment.

See also: $received_file, $reply_file+, and\
    $reply_history_file.
"
set help($no_reply_file) $help($reply_file)


set help($received_file) "
$received_file		The submission mail message. \
			  The `Subject:' of this
			message determines whether the\
			  submission is a `get',
			a `submit', or a query.

$reply_file+		A reply from the judge to the\
			  submitter that is under
			construction, and not yet\
			  sent.  Can be editted by
			the `er' command and sent by\
			  the `sr' command.

$reply_history_file	A copy of all the replies sent\
			  to the submitter by
			the judge.

See also: $reply_file and $no_reply_file.
"
set help($reply_file+) $help($received_file)
set help($reply_history_file) $help($received_file)


set help($auto_score_file) "
$auto_score_file	The score produced\
		    automatically by the autojudge\
		    program
		(which calls autoscore to produce the\
		    score).

$manual_score_file	The score entered manually\
		    by using the `manualreply' program.
		See the `sm' and `ss' commands.

.score		The file produced by the scorediff\
		    program that describes the
		differences between the .out and\
		    .test files.  The first line
		lists all the differences, and\
		    subsequent lines list proofs.
		A proof specifies the locations of\
		    mismatched tokens in the
		two files.
"
set help($manual_score_file) $help($auto_score_file)
set help(.score) $help($auto_score_file)



set help(.c) "
.c	Source file for a solution written in C.

.cc	Source file for a solution written in C++.

.java	Source file for a solution written in JAVA.

.p	Source file for a solution written in PASCAL.
"
set help(.cc) $help(.c)
set help(.java) $help(.c)
set help(.p) $help(.c)



set help($make_file) "
$make_file	Makefile to make solution binary and\
		    .out file.  Symbolic link
		to solution directory.
"

set help($files_file) "
$files_file	A list of files that are to be\
		    submitted and of files that are
	to be linked from the solution directory. \
		    Optional.  A symbolic link
	to the solution directory.  Used by autojudge,\
		    extractmail, and
	trackfinder.
"


set help($scoring_filter_file) "
$scoring_filter_file	A program that filters the .out\
			    file to produce the
		.fout file, and the .test file to\
			    produce the .ftest file.
		These latter files are diff'ed instead\
			    of the .out and .test
		files by the autojudge program to\
			    produce an auto score.
		Optional.  A symbolic link to the\
			    solution directory.

.fout	The result of filtering the .out file through\
			    the $scoring_filter_file
	program.

.ftest	The result of filtering the .test file through\
			    the $scoring_filter_file
	program.
"
set help(.fout) $help($scoring_filter_file)
set help(.ftest) $help($scoring_filter_file)


set help(.p2c) "
.p2c	Intermediate file, the translation of a PASCAL\
	    .p file into the
        C language.

.class	JAVA relocatable binary (byte code) file.

.cerr	Solution compilation error output.  Does NOT\
	    affect score.

No extension; with same basename as solution source.
	Binary executable of the solution.  For JAVA\
	    this is a shell script
	invoking the .class file with the same basename\
	    as the source.
	If missing, score is `Syntax Error'.
"
set help(.class) $help(.p2c)
set help(.cerr) $help(.p2c)
set help(no-extension) $help(.p2c)



set help(.in) "
.in	Judge's input.  Symbolic link to solution\
	    directory.

.test	Judge's output.  Symbolic link to solution\
	    directory.

.out	Solution output.  If empty, score is `Program\
	    Crashed'.

.err	Solution error output.  If non-empty, score is\
	    `Program Crashed' or
        something more specific, such as `Output Limit\
		    Exceeded'.

.rc	Problem specific parameters, sourced to modify\
	    hpcm_judging.rc
        parameters during autojudging and manualreply. \
	    Symbolic link to
	solution directory.
"
set help(.rc) $help(.in)
set help(.test) $help(.in)
set help(.out) $help(.in)
set help(.err) $help(.in)


set help(.diff) "
.diff	Result of `diff *.out *.test'.  This file is\
	    not created until it
	is viewed.

.bdiff	Result of `diff -b *.out *.test'.  This file\
	    is not created until it
	is viewed.

core	Core dump of the solution execution; usually\
	    only present if the
	solution crashed.  Does NOT affect score.
"
set help(.bdiff) $help(.diff)
set help(core) $help(.diff)


set help(topics) "
List of help topics:

"
set c 0
proc topic_compare { t1 t2 } {
    regsub {\.} $t1 "" t1
    regsub {\.} $t2 "" t2
    return [string compare -nocase $t1 $t2]
}
foreach topic [lsort -command topic_compare \
                     [array names help]] {
    set l [string length $topic]
    incr l 4
    incr c $l
    if { $c > 80 } {
        set help(topics) "$help(topics)\n"
	set c $l
    }
    set help(topics) "$help(topics)    $topic"
}
set help(topics) "$help(topics)\n"

# Reply Functions
# ----- ---------

# Compose a reply indicating the assignment of the
# proposed score as the final score, and indicating
# whether this overrides or confirms any previous
# automatically or manually assigned score.  Return
# `yes' if this is a normal transaction and the
# reply does not need human editing.  Return `no' if
# the reply needs to be edited.
#
proc compose_score_reply {} {

    set return_commands [compose_response]

    if { ! [lcontain $return_commands FINAL] } {
        error "`response_instructions' value\
	       did not execute FINAL command"
    }
    if { [lcontain $return_commands EDIT] } {
    	return no
    } else {
    	return yes
    }
}

# Send any previously composed reply and set the
# manual score equal to the proposed score and the
# proposed score to `None'.
#
proc send_score_reply {} {

    global manual_score_file proposed_score \
           manual_score score_flag_file

    send_reply

    write_file $manual_score_file $proposed_score
    set_flag $score_flag_file
    set manual_score $proposed_score
}


# Menu Initialization
# ---- --------------

# Set if in readonly mode.
#
set readonly_mode yes

if { [file writable "."] } {
    set readonly_mode no
    get_lock
}

# Initialize file list.

refresh_file_list


# If auto score file, reply file, no_reply file,
# and unchecked errors do not exists, consider running
# autojudge, if not in readonly mode.
#
if { $readonly_mode == "no" \
     && $submitted_problem != "" \
     && [llength [glob -nocomplain \
                       $reply_file \
                       $no_reply_file \
                       $auto_score_file \
                       *-unchecked-error]] == 0 } {


    set_file_list_display
    set window_info_height 5
    set_window_info "
It appears that `autojudge' should be run."
    set window_prompt "Do you want to do so (y or n)? "
    set window_error ""

    display_window

    if { [yes?] } {

    	puts "Running autojudge"
	catch { exec autojudge >&@ stdout }

	if { ! [file exists $auto_score_file] } {
	    puts "autojudge FAILED to make\
	          $auto_score_file"
	}
	continue?
	refresh_file_list
    }
}

# Source any problem .rc file.

if { $submitted_problem != "" } {
    source_file $submitted_problem.rc
}

set menu $main_menu

set directory [file tail [pwd]]
set proposed_score None
set last_file ""
set last_display ""
set last_help ""

# Procedure to recompute window_display for menu loop.
#
proc refresh_display {} {

    global last_display last_file last_help

    if { $last_display == "file_list" } {
	set_file_list_display
    } elseif { $last_display == "file" } {
	set_file_display $last_file
    } elseif { $last_display == "help" } {
	set_window_display $last_help
    }
}

# Procedure to recompute window_info for menu loop.
#
proc refresh_info {} {

    global proposed_score manual_score auto_score \
    	   window_info_height directory menu \
	   scoring_instructions submitted_problem

    set old_info_height $window_info_height

    if { $proposed_score == "None" } {
	if { $manual_score != "None" } {
	    set proposed_score $manual_score
	} else {
	    set proposed_score $auto_score
	}
    }
    if { $submitted_problem == "" } {
    	set scoring_info ""
	set window_info_height 6
    } else {
	set scoring_info "
Scoring Instructions: $scoring_instructions"

	if { $manual_score == "None" } {
	    set scoring_info "$scoring_info
Scores:  Auto: $auto_score   Proposed: $proposed_score"
	    set window_info_height 8
	} elseif { $proposed_score == "None" } {
	    set scoring_info "$scoring_info
Scores:  Auto: $auto_score   Manual: $manual_score"
	    set window_info_height 8
	} else {
	    set scoring_info "$scoring_info
Scores:  Auto: $auto_score   Manual: $manual_score
           Proposed: $proposed_score"
	    set window_info_height 9
	}
    }

    set_window_info \
        "Dir: $directory$scoring_info$menu"

    # Refresh the display if window_info_height is
    # changed.
    #
    if { $window_info_height != $old_info_height } {
        refresh_display
    }
}

# Function to recompute info for proofs menu loop.
#
proc refresh_proofs_info { } {

    global window_info_height scoring_instructions \
	   auto_score proposed_score manual_score


    if { $manual_score == "None" } {
	set scoring_info \
	    "Auto: $auto_score   \
	     Proposed: $proposed_score"
    } else {
	set scoring_info \
	    "Auto: $auto_score   \
	     Manual: $manual_score"
    }

    set info "[compute_proof_info]   \
        Scores:  $scoring_info\n   \
	Scoring Instructions:\
	    $scoring_instructions\n   \
        n|p = goto next|previous proof  \
        ? = help   x = exit   ss = send score + mm\n   \
        mm|sm = return to main|scoring menu  \
        ps XX = set propose score to XX"

    set window_info_height [llength [split $info "\n"]]
    set_window_info $info
}

# Execute ss command for main or proof loop.
#
proc send_score { } {

    global proposed_score window_error last_file \
           reply_file window_prompt last_display

    if { [not_readonly] == "no" } {
	# do nothing
    } elseif { $proposed_score == "None" } {
	set window_error "ERROR: set the\
	    proposed score before sending it"
    } elseif { [compose_score_reply] } {
	send_score_reply
	set last_file $reply_file
	set last_display file
	set window_error "Score sent!"
    } else {
	set window_error "NOTICE: An unexpected\
	    situation exists."
	set window_prompt "To continue you\
	    must edit reply.  Do you want to\
	    continue (y or n)? "
	set last_file $reply_file+
	set_file_display $reply_file+
	display_window
	if { [yes?] } {
	    edit_file $last_file
	    set window_error "Reply is ready\
		to send."
	    set window_prompt "Do you want to\
		send it (y or n)? "
	    display_window
	    if { [yes?] } {
		send_score_reply
		set last_file $reply_file
		set window_error "Score sent!"
	    } else {
		set window_error "Score sending\
		    ABORTED!"
		set last_display file_list
	    }
	} else {
	    set window_error "Score sending\
		ABORTED!"
	    set last_display file_list
	}
    }
}

# Execute ? command for main or proof loop.
#
proc display_help { } {

    global help window_error last_help window_bar \
           last_display answer

    set what [string trim [string range $answer 1 end]]
    regsub -all "\[\ \t\]" $what "" topic
    if { $topic == "" } {
	set topic "?"
    } elseif { ! [info exists help($topic)] } {
	set window_error \
	    "ERROR: no help available for\
			  `$what'!"
	set topic "topics"
    }
    set last_help $help($topic)
    set last_help \
	"$window_bar$last_help$window_bar"
    set_window_display $last_help
    set last_display help
}

# Function to run proof display loop.  Returns an action
# to be performed after the loop as follows:
#
#	"mm" = switch to main menu
#	"sm" = switch to scoring menu
#	""   = do nothing
#
proc display_proofs {} {

    global last_file window_error window_prompt \
	   proposed_score answer

    if { [catch {

		    compute_instruction_array
		    compute_score_and_proof_arrays
		    compute_score

		} out] } {
	out_check $out
	return ""
    }

    refresh_proofs_info

    if { [get_proof] == "no" } return ""
    if { [set_proof_display] == "no" } return ""

    while { "yes" } {

	set window_prompt "> "
	display_window
	set window_error ""

	set answer [string trim [gets stdin]]
	switch -regexp -- $answer {
	    {^mm$} { return mm }
	    {^sm$} { return sm }
	    {^x$} {
		exit_cleanup
		exit 0
	    }
	    {^ss$} {
		send_score
		return mm
	    }
	    "^ps[ \t]" {
		if { [catch { set l [llength $answer] \
		            }] } {
			set window_error \
			    "ERROR: cannot understand\
					  `$answer'!"
		} else {
		    switch ${l}_[lindex $answer 1] {
			2_io {
			    set proposed_score \
				"Incorrect Output"
			    refresh_proofs_info
			}
			2_cc {
			    set proposed_score \
				"Completely Correct"
			    refresh_proofs_info
			}
			2_fe {
			    set proposed_score \
				"Formatting Error"
			    refresh_proofs_info
			}
			2_ic {
			    set proposed_score \
				"Incomplete Output"
			    refresh_proofs_info
			}
			2_se {
			    set proposed_score \
				"Syntax Error"
			    refresh_proofs_info
			}
			2_te {
			    set proposed_score \
				"Cpu Time Limit\
				          Exceeded"
			    refresh_proofs_info
			}
			2_pc {
			    set proposed_score \
				"Program Crashed"
			    refresh_proofs_info
			}
			2_oe {
			    set proposed_score \
				"Output Size Limit\
					     Exceeded"
			    refresh_proofs_info
			}
			default {
			    set window_error \
				"ERROR: cannot\
				        understand\
				        `$answer'!"
			}
		    }
		}
	    }
	    {^\?} {
		display_help
	    }
	    {^pr$} {
		refresh_proofs_info
		set_proof_display
	    }
	    {^$} {
		if { [eof stdin] } {
		    exit_cleanup
		    exit 0
		}
		set window_error "ERROR: empty input"
	    }
	    default {
		if { [regexp {^\.} $answer] } {
		    if { [get_file $answer] } {
			set_file_display $last_file
		    }
	    	} elseif { [get_proof $answer] } {
		     set_proof_display
		}
	    }
	}
    }
}

# Menu Loop
# ---- ----

refresh_file_list
refresh_info
set_file_list_display


if { $readonly_mode } {
    set window_error "You are in read only mode."
} else {
    set window_error ""
}

# Helper function to verify we are not in readonly
# mode or to set window_error if we are.
#
proc not_readonly {} {
    global readonly_mode window_error answer
    if { $readonly_mode } {
        set window_error \
	    "ERROR: You are in readonly mode and\
	     cannot do `$answer'."
	return no
    } else {
    	return yes
    }
}

while { "yes" } {

    set window_prompt "> "
    display_window
    set window_error ""

    set answer [string trim [gets stdin]]
    switch -regexp -- $answer {
        {^[1-9][0-9]*$} {
	    if { [get_file $answer] } {
		set_file_display $last_file
	    }
	}
        {^v *[0-9]*$} {
	    regexp {^v *([0-9]*)$} $answer forget n
	    if { [get_file $n] } {
		view_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
        {^v } {
	    regexp {^v +([^ ]*)$} $answer forget id
	    if { [get_file $id] } {
		view_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^e *[0-9]*$} {
	    regexp {^e *([0-9]*)$} $answer forget n
	    if { [not_readonly] && [get_file $n] } {
		edit_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^e } {
	    regexp {^e +([^ ]*)$} $answer forget id
	    if { [not_readonly] && [get_file $id] } {
		edit_file $last_file
		set last_display file
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^c *[0-9]*$} {
	    regexp {^c *([0-9]*)$} $answer forget n
	    if { [not_readonly] && [get_file $n] } {
	        set mail_file $last_file.mail
		if { [catch { set last_file \
			          [make_checked \
			              $last_file] } \
			    out] } {
		    out_check $out
		} elseif { [file exists $mail_file ] \
			   && [catch {
			          make_checked \
				      $mail_file
			       } out] } {
		    out_check $out
		} else {
		    set window_error \
		        "Checked $last_file"
		}
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^u *[0-9]*$} {
	    regexp {^u *([0-9]*)$} $answer forget n
	    if { [not_readonly] && [get_file $n] } {
	        set mail_file $last_file.mail
		if { [catch { set last_file \
			          [make_unchecked \
			              $last_file] } \
			    out] } {
		    out_check $out
		} elseif { [file exists $mail_file ] \
			   && [catch {
			          make_unchecked \
				      $mail_file
			       } out] } {
		    out_check $out
		} else {
		    set window_error \
		        "Unchecked $last_file"
		}
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^ls$} {
	    refresh_file_list
	    refresh_info
	    set_file_list_display
	}
	{^ir$} {
	    if { [not_readonly] } {
		compose_reply \
		    { LINE "EDIT YOUR REPONSE HERE" } \
		    BLANK \
		    { BAR "this message replies to:" } \
		    RECEIVED-HEADER \
		    BLANK \
		    RECEIVED-BODY
		set last_file $reply_file+
		edit_file $last_file
		refresh_file_list
		refresh_info
		set_file_display $last_file
	    }
	}
	{^er$} {
	    if { [not_readonly] } {
		if { ! [file exists $reply_file+] } {
		    compose_reply \
			{ LINE "EDIT YOUR REPONSE\
			        HERE" } \
			BLANK \
			{ BAR "this message replies\
			       to:" } \
			RECEIVED-HEADER \
			BLANK \
			RECEIVED-BODY
		}
		set last_file $reply_file+
		edit_file $last_file
		refresh_file_list
		refresh_info
		set_file_display $last_file
	    }
	}
	{^sr$} {
	    if { ! [file exists $reply_file+] } {
		set window_error \
		    "ERROR: No reply composed!"
	    } elseif { [not_readonly] } {
		set_file_display $reply_file+
		set window_error ""
		set window_prompt \
		    "Do you want to send the above\
			(y or n)? "
		display_window

		if { [yes?] } {
		    set window_prompt \
		       "Sending..."
		    display_window
		    catch { send_reply } out
		    set last_file $reply_file
		    if { $out == "" } {
		    	set window_error "Reply sent!"
		    } else {
		        puts "\n$out"
			continue?
		    }
		} else {
		    set window_error "Send ABORTED!"
		}
	    }
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^nr$} {
	    if { [not_readonly] } {
		set window_error \
		    "Type line to write into\
		     $no_reply_file file (or type ^D\
		     to abort):"
		set window_prompt "> "
		display_window
		set no_reply_line \
		    [string trim [gets stdin]]
		if { [eof stdin] } {
		    set window_error \
			"$no_reply_file NOT WRITTEN"
		} else {
		    write_file $no_reply_file \
		               $no_reply_line
		    set window_error \
			"$no_reply_file written"
		}
		refresh_file_list
		refresh_info
		refresh_display
	    }
	}
	{^ss$} {
	    send_score
	    if { [not_readonly] } {
		set menu $main_menu
		refresh_file_list
		refresh_info
		refresh_display
	    }
	}
	{^aj$} {
	    if { [not_readonly] } {

		puts "Running autojudge -manual"
		catch { exec autojudge -manual \
		             >&@ stdout }

		if { ! [file exists $auto_score_file] \
			} {
		    puts "autojudge -manual FAILED to\
		          make $auto_score_file"
		}
		continue?
		refresh_file_list
		refresh_info
		refresh_display
	    }
	}
	{^sh$} {
	    if { [catch { call_shell }] } continue?
	    refresh_file_list
	    refresh_info
	    refresh_display
	}
	{^ai$} {
	    if { [not_readonly] } {

		puts "Running autoinfo"
		catch { exec autoinfo >&@ stdout }
		continue?
		refresh_file_list
		refresh_info
		refresh_display
	    }
	}
	{^sq$} {
	    send_query "Subject: About\n  $directory"
	}
	{^xq$} {
	    if { ! [info exists message_subject] } {
	        set window_error \
		    "ERROR: No $received_file file."
	    } else {
	        set ws "\[\ \t\n\]"
	        set nws "\[^\ \t\n\]"
		set about ""
		regexp "^$ws*About$ws+($nws+)$ws*\$" \
		       $message_subject forget about
		set d $mail_directory/$about
		if { $about == "" } {
		    set window_error \
			"ERROR: $received_file subject\
				does not have the form\
				`About DIRECTORY'."
		} elseif { ! [file isdirectory $d] } {
		    set window_error \
			"ERROR: $d is not a directory."
		} else {
		    catch { exec manualreply \
				 $d >&@ stdout } 
		    puts ""
		    puts "Finished manualreply of"
		    puts "  $about"
		    continue?
		}
	    }
	}
	{^sm$} {
	    set menu $scoring_menu
	    refresh_info
	}
	{^mm$} {
	    set menu $main_menu
	    refresh_info
	}
	{^x$} {
	    exit_cleanup
	    exit 0
	}
	{^io$} {
	    set proposed_score "Incorrect Output"
	    refresh_info
	}
	{^cc$} {
	    set proposed_score "Completely Correct"
	    refresh_info
	}
	{^fe$} {
	    set proposed_score "Formatting Error"
	    refresh_info
	}
	{^ic$} {
	    set proposed_score "Incomplete Output"
	    refresh_info
	}
	{^se$} {
	    set proposed_score "Syntax Error"
	    refresh_info
	}
	{^te$} {
	    set proposed_score "Cpu Time Limit Exceeded"
	    refresh_info
	}
	{^pc$} {
	    set proposed_score "Program Crashed"
	    refresh_info
	}
	{^oe$} {
	    set proposed_score \
	    	"Output Size Limit Exceeded"
	    refresh_info
	}
	{^pr$} {
	    switch -exact [display_proofs] {
	        "" {}
		mm { set menu $main_menu }
		sm { set menu $scoring_menu }
	    }
	    refresh_info
	}
	{^\?} {
	    display_help
	}
	{^$} {
	    if { [eof stdin] } {
		exit_cleanup
		exit 0
	    }
	    set window_error "ERROR: empty input"
	}
	{default} {
	    if { [get_file $answer] } {
		set_file_display $last_file
	    } else {
		set window_error \
		    "ERROR: cannot understand\
				  `$answer'!"
	    }
        }

    }
}


# Include common error catching code:
#
} caught_output
caught_error
