#!/bin/sh -f
#
# Manually examine and possibly modify the auto score
# in a submission directory
#
# File:		manualscore
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Sep  4 14:38:15 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/09/04 20:39:27 $
#   $RCSfile: manualscore,v $
#   $Revision: 1.12 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"
catch {

set document "
cd submission_directory; manualscore

    Given the submission directory as the current dir-
    ectory, and given that this directory contains an
    $auto_score_file file, this program lets a person\
    	examine
    the files in the directory and select a manual score
    that is written into the $manual_score_file file and
    sent as email to the submitter.  A $reply_file file
    containing this email is created."

if { $argc != 0 } {
    puts $document
    exit 1
}

set received_ch [open $received_file r]
read_header $received_ch
close $received_ch

if { [llength $message_subject] != 2 \
     || [lindex $message_subject 0] != "submit" } {
    puts "Bad subject for manual scoring:"
    puts "    $message_subject"
    puts "Exiting manualscore"
    exit 0
}

set submitted_file [lindex $message_subject 1]
set submitted_program \
    [file rootname $submitted_file]
set submitted_extension \
    [file extension $submitted_file]
set output_file 	"${submitted_program}.out"
set error_file  	"${submitted_program}.err"
set compiler_error_file	"${submitted_program}.cerr"
set test_file   	"${submitted_program}.test"
set diff_file   	"${submitted_program}.diff"
set bdiff_file   	"${submitted_program}.bdiff"

if { ! [file readable $auto_score_file] } {
    puts "No $auto_score_file; Executing autojudge"
    exec autojudge
    if { ! [file readable $auto_score_file] } {
        puts "autojudge failed to make\
	      $auto_score_file file"
	puts "Exiting manualscore"
	exit 0
    }
}

if { [file exists $reply_file] } {
    puts "$reply_file exists"
    puts "Exiting manualscore"
    exit 0
}

set auto_score [read_file $auto_score_file]


set scoring_instructions \
    [find_scoring_instructions]


proc make_diff {} {

    global output_file test_file diff_file

    if { [file exists $diff_file] } {
        if { ( [file exists $output_file] \
	       && [file mtime $diff_file] \
	          < [file mtime $output_file] ) \
	     || \
             ( [file exists $test_file] \
	       && [file mtime $diff_file] \
	          < [file mtime $test_file] ) } {
	    file delete -force $diff_file
	} else {
	    return $diff_file
	}
    }

    set l "==================================="
    write_file $diff_file \
	       "diff $output_file $test_file\n$l"
    catch { exec diff $output_file $test_file \
                      >>& $diff_file }
    return $diff_file
}

proc make_bdiff {} {

    global output_file test_file bdiff_file

    if { [file exists $bdiff_file] } {
        if { ( [file exists $output_file] \
	       && [file mtime $bdiff_file] \
	          < [file mtime $output_file] ) \
	     || \
             ( [file exists $test_file] \
	       && [file mtime $bdiff_file] \
	          < [file mtime $test_file] ) } {
	    file delete -force $bdiff_file
	} else {
	    return $bdiff_file
	}
    }

    set l "==================================="
    write_file $bdiff_file \
	     "diff -b $output_file $test_file\n$l"
    catch { exec diff -b $output_file $test_file \
                      >>& $bdiff_file }
    return $bdiff_file
}

proc get_new_score {} {

    global manual_score auto_score \
           scoring_instructions

    puts "Scoring Instructions:\
          $scoring_instructions"
    puts "Auto Score: $auto_score\
	 \    Current score: $manual_score"
    puts ""
    puts -nonewline "
======================================================
Please select a new current score:
  i = Incorrect Output      cc = Completely Correct
  f = Formatting Error      ic = Incomplete Output
  s = Syntax Error          te = Cpu Time Limit Exceeded
  c = Program Crashed       oe = Output Size Exceeded
  k = keep old current score

> "

    set answer [gets stdin]
    if { [eof stdin] } {
	exit 0
    } elseif { [llength $answer] > 1 } {
	puts "Unknown: $answer"
    } elseif { [llength $answer] == 1 } {
	switch [lindex $answer 0] \
	    i	{ set manual_score \
	              "Incorrect Output" } \
	    f	{ set manual_score \
		      "Formatting Error" } \
	    s	{ set manual_score \
		      "Syntax Error" } \
	    c	{ set manual_score \
		      "Program Crashed" } \
	    cc	{ set manual_score \
		      "Completely Correct" } \
	    ic	{ set manual_score \
		      "Incomplete Output" } \
	    te	{ set manual_score \
		      "Cpu Time Limit Exceeded" } \
	    oe	{ set manual_score \
		      "Output Size Limit Exceeded" } \
	    k   {} \
	    default	{ puts "Unknown: $answer" }
    }
}

if { [file exists $compiler_error_file] } {
    set last_file $compiler_error_file
} elseif { [file exists $error_file] } {
    set last_file $error_file
} else {
    set last_file [make_bdiff]
}

set manual_score $auto_score

while { "yes" } {

    puts "Scoring [file tail [pwd]]"
    puts "Scoring Instructions: $scoring_instructions"
    puts "Auto Score: $auto_score    Current score:\
                                     $manual_score"

    puts "=========================== $last_file:"
    put_file $last_file stdout 10

    puts -nonewline "
======================================================
d = view .diff      b = view .bdiff     o = view .out
t = view .test      e = view .err       p = view\
				$submitted_extension
a = exit accepting current score        c = view .cerr
r = reject current score, and enter new current score
x = exit without doing anthing

> "
    set answer [gets stdin]
    if { [eof stdin] } {
    	exit 0
    }

    if { [llength $answer] == 0 } {
    	continue;
    } elseif { [llength $answer] > 1 } {
        puts "Unknown: $answer"
	continue;
    }

    set action "view"

    switch [lindex $answer 0] \
    	d	{ set last_file [make_diff] } \
    	b	{ set last_file [make_bdiff] } \
    	o	{ set last_file $output_file } \
    	t	{ set last_file $test_file } \
    	e	{ set last_file $error_file } \
    	c	{ set last_file $compiler_error_file } \
    	p	{ set last_file $submitted_file } \
	a	{ set action "accept" } \
	r	{ set action "reject" } \
	x	{ set action "exit" } \
	default	{ set action "unknown" }

    switch $action \
    	view	{
		    catch { view_file $last_file }
		} \
        accept	{
		    write_file $manual_score_file \
		               $manual_score
		    if { $manual_score \
		         == $auto_score } {
			reply "For $submitted_file your\
			       automatic score of:" \
			      "" \
			      "    $auto_score" \
			      "" \
			      "has been accepted by the\
			       human judge!"
		    } elseif { $scoring_mode \
			       == "manual" } {
			reply "For $submitted_file your\
			       final score is:" \
			      "" \
			      "    $manual_score"
		    } else {
			reply "For $submitted_file your\
			       automatic score of:" \
			      "" \
			      "    $auto_score" \
			      "" \
			      "has been OVERRIDDEN by\
			       the human judge!" \
			      "" \
			      "The human judge has\
			       assigned the FINAL\
			       SCORE:" \
			      "" \
			      "    $manual_score"
		    }

		    puts "Accepted Manual Score:\
		          \    $manual_score"
		    exit 0
		} \
	reject	{ get_new_score } \
	exit	{ exit 0 } \
	unknown	{ puts "Unknown: $answer" }
}


# Include common error catching code:
#
} caught_output
caught_error
