#!/bin/sh -f
#
# Manually examine and possibly modify the auto score
# in a submission directory
#
# File:		manualscore
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Sep 20 20:21:35 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2000/09/21 03:26:00 $
#   $RCSfile: manualscore,v $
#   $Revision: 1.17 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory; manualscore \[-force\]

    Given the submission directory as the current dir-
    ectory, and given that this directory contains an
    $auto_score_file file, this program lets a person\
    	examine
    the files in the directory and select a manual score
    that is written into the $manual_score_file file and
    sent as email to the submitter.  A $reply_file file
    containing this email is created.

    Normally this program will not run if a $reply_file
    file exists.  The -force option cause this program
    to run even if a $reply_file file exists."

# Consume any -force option.
#
set my_argc $argc
set my_argv $argv
if { $argc >= 1 && [lindex $argv 0] == "-force" } {
    set force_option yes
    set my_argc [expr { $my_argc - 1 }]
    set my_argv [lreplace $my_argv 0 0]
} else {
    set force_option no
}

# If any arguments left, print document and exit.
#
if { $my_argc != 0 } {
    puts $document
    exit 1
}

proc continue? {} {
    while { "yes" } {
	puts -nonewline "continue (y or n)? "
	flush stdout
	switch [string trim [gets stdin]] {
	y	-
	yes	-
	Y	-
	YES	{ break }
	n	-
	no	-
	N	-
	NO	{
		    puts "Exiting manualscore"
		    exit 0
		}
	}
    }
}



# Read received mail header.
#
set received_ch [open $received_file r]
read_header $received_ch
close $received_ch

# If subject inappropriate for manual scoring, announce
# error.
#
if { [llength $message_subject] != 2 \
     || [lindex $message_subject 0] != "submit" } {
    puts "Bad subject for manual scoring:"
    puts "    $message_subject"
    puts "Exiting manualscore"
    exit 0
}

# Compute file names from message subject.
#
set submitted_file [lindex $message_subject 1]
set submitted_program \
    [file rootname $submitted_file]
set submitted_extension \
    [file extension $submitted_file]
set output_file 	$submitted_program.out
set error_file  	$submitted_program.err
set compiler_error_file	$submitted_program.cerr
set test_file   	$submitted_program.test
set diff_file   	$submitted_program.diff
set bdiff_file   	$submitted_program.bdiff

# Make $auto_score_file if necessary.
#
if { ! [file readable $auto_score_file] } {
    puts "No $auto_score_file; Executing autojudge"
    exec autojudge >@ stdout 2>@ stderr
    if { ! [file readable $auto_score_file] } {
        puts "autojudge failed to make\
	      $auto_score_file file"
	puts "Exiting manualscore"
	exit 0
    }
}

# Exit if $reply_file exists.
#
if { [file exists $reply_file] } {
    puts "$reply_file exists"
    continue?
}

# Get some info.
#
set auto_score [read_file $auto_score_file]
set scoring_instructions [find_scoring_instructions]

while { "yes" } {
    set o "\n\n\n\n\n\n\n\n\n\n\n\n\n"
    set o "$o\n========================="
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\n========================"
    set o "$o\n$auto_score"
    puts $o
    continue?
    set o "\n\n\n\n\n\n\n\n\n\n\n\n\n"
    set o "$o\n========================="
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\nThis is the time of trial"
    set o "$o\n========================"
    set o "$o\n$scoring_instructions"
    puts $o
    continue?
}


# Procedure to make $diff_file if necessary, and
# return its name in any case.
#
proc make_diff {} {

    global output_file test_file diff_file

    if { [file exists $diff_file] } {
        if { ( [file exists $output_file] \
	       && [file mtime $diff_file] \
	          < [file mtime $output_file] ) \
	     || \
             ( [file exists $test_file] \
	       && [file mtime $diff_file] \
	          < [file mtime $test_file] ) } {
	    file delete -force $diff_file
	} else {
	    return $diff_file
	}
    }

    write_file $diff_file \
	       "diff $output_file $test_file"
    catch { exec diff $output_file $test_file \
                      >>& $diff_file }
    return $diff_file
}

# Procedure to make $bdiff_file if necessary, and
# return its name in any case.
#
proc make_bdiff {} {

    global output_file test_file bdiff_file

    if { [file exists $bdiff_file] } {
        if { ( [file exists $output_file] \
	       && [file mtime $bdiff_file] \
	          < [file mtime $output_file] ) \
	     || \
             ( [file exists $test_file] \
	       && [file mtime $bdiff_file] \
	          < [file mtime $test_file] ) } {
	    file delete -force $bdiff_file
	} else {
	    return $bdiff_file
	}
    }

    write_file $bdiff_file \
	     "diff -b $output_file $test_file"
    catch { exec diff -b $output_file $test_file \
                      >>& $bdiff_file }
    return $bdiff_file
}

# Procedure to get a new manual_score by manual entry by
# the program user.
#
proc get_new_score { current_score } {

    switch $current_score {
        "Incorrect Output"		{ set code io }
        "Formatting Error"		{ set code fe }
        "Syntax Error"			{ set code se }
        "Program Crashed		{ set code pc }
        "Completely Correct"		{ set code cc }
        "Incomplete Output"		{ set code io }
        "Cpu Time Limit Exceeded"	{ set code te }
        "Output Size Exceeded"		{ set code oe }
    }

    while { "yes" } {

	puts -nonewline "
======================================================
Please select a new current score:
  io = Incorrect Output     cc = Completely Correct
  fe = Formatting Error     ic = Incomplete Output
  se = Syntax Error         te = Cpu Time Limit Exceeded
  pc = Program Crashed      oe = Output Size Exceeded

($code) > "

	flush stdout

	set answer [string string[gets stdin]
	switch [string trim [gets stdin]] {
	    "" { if { [eof stdin] } {
		     exit 0
		 } else {
		     return $current_score
		 }
	       }
	    io { return "Incorrect Output" }
	    fe { return "Formatting Error" }
	    se { return "Syntax Error" }
	    pc { return "Program Crashed" }
	    cc { return "Completely Correct" }
	    ic { return "Incomplete Output" }
	    te { return "Cpu Time Limit Exceeded" }
	    oe { return "Output Size Limit Exceeded" }
	}
    }
}

# Set up name of first file to display in $last_file.
#
if { [file exists $compiler_error_file] \
     && [file size $compiler_error_file] > 0 } {
    set last_file $compiler_error_file
} elseif { [file exists $error_file] \
     && [file size $error_file] > 0 } {
    set last_file $error_file
} else {
    set last_file [make_bdiff]
}

# Set initial manual_score equal to auto_score.
#
set manual_score $auto_score

# Main program loop.  Print info, read command, execute
# command, repeat.
#
while { "yes" } {

    # Print out name of directory, scoring instructions,
    # current scores, part of last file of interest,
    # and command menu.
    #
    puts "Scoring [file tail [pwd]]"
    puts "Scoring Instructions: $scoring_instructions"
    puts "Auto Score: $auto_score    Current score:\
                                     $manual_score"

    puts "==========================================\
          $last_file:"
    put_file $last_file stdout 10

    puts -nonewline \
"======================================================
d = view .diff      b = view .bdiff     o = view .out
t = view .test      e = view .err       p = view\
				$submitted_extension
a = exit accepting current score        c = view .cerr
r = reject current score, and enter new current score
x = exit without doing anthing

> "

    # Input and check answer.
    #
    set answer [gets stdin]
    if { [eof stdin] } {
    	exit 0
    }
    if { [llength $answer] == 0 } {
    	continue;
    } elseif { [llength $answer] > 1 } {
        puts "Unknown: $answer"
	continue;
    }

    # Compute action and file of interest.
    #
    set action view
    switch [lindex $answer 0] \
    	d	{ set last_file [make_diff] } \
    	b	{ set last_file [make_bdiff] } \
    	o	{ set last_file $output_file } \
    	t	{ set last_file $test_file } \
    	e	{ set last_file $error_file } \
    	c	{ set last_file $compiler_error_file } \
    	p	{ set last_file $submitted_file } \
	a	{ set action accept } \
	r	{ set action reject } \
	x	{ set action exit } \
	default	{ set action unknown }

    # Perform action.
    #
    switch $action \
    	view	{
		    catch { view_file $last_file }
		} \
        accept	{
		    puts -nonewline "
Confirm final score `$manual_score' (y or n): "
		    set answer [gets stdin]

		    if { [llength $answer] == 1 \
		         && [regexp {y|Y} \
			        [lindex $answer 0]] } {

			write_file $manual_score_file \
				   $manual_score
			if { $manual_score \
			     == $auto_score } {
			    reply "For $submitted_file\
			           your automatic score\
				   of:" \
				  "" \
				  "    $auto_score" \
				  "" \
				  "has been accepted by\
				   the human judge!"
			} elseif { $scoring_mode \
				   == "manual" } {
			    reply "For $submitted_file\
			           your final score\
				   is:" \
				  "" \
				  "    $manual_score"
			} else {
			    reply "For $submitted_file\
			           your automatic score\
				   of:" \
				  "" \
				  "    $auto_score" \
				  "" \
				  "has been OVERRIDDEN\
				   by the human\
				   judge!" \
				  "" \
				  "The human judge has\
				   assigned the FINAL\
				   SCORE:" \
				  "" \
				  "    $manual_score"
			}

			puts "Accepted Manual Score:\
			      \    $manual_score"
			exit 0
		    } else {
		        puts "NOT confirmed!"
		    }
		} \
	reject	{ get_new_score } \
	exit	{ exit 0 } \
	unknown	{ puts "Unknown: $answer" }
}


# Include common error catching code:
#
} caught_output
caught_error
