#!/bin/sh -f
#
# Manually examine and possibly modify the auto score
# in a submission directory
#
# File:		manualscore
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Aug 16 07:06:59 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/24 11:09:05 $
#   $RCSfile: manualscore,v $
#   $Revision: 1.10 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"
catch {

set document "
cd submission_directory; manualscore

    Given the submission directory as the current dir-
    ectory, and given that this directory contains an
    $auto_score_file, this program lets a person examine
    the files in the directory and select a manual score
    that is written into the $manual_score_file and
    sent as email to the submitter.  A $reply_file
    containing this email is created."

if { $argc != 0 } {
    puts $document
    exit 1
}

set subject [find_subject]

if { ! [regexp {^submit (.*)$} all submitted_file] } {
    error "Bad subject: $subject"
}

set submitted_program \
    [file rootname $submitted_program]
set submitted_extension \
    [file extension $submitted_program]
set output_file 	"${program_name}.out"
set error_file  	"${program_name}.err"
set compiler_error_file	"${program_name}.cerr"
set test_file   	"${program_name}.test"
set diff_file   	"${program_name}.diff"
set bdiff_file   	"${program_name}.bdiff"

if { ! [file readable $auto_score_file] } {
    puts "No $auto_score_file; Executing autojudge"
    exec autojudge
}

if { [file exists $reply_file] } }
    puts "$reply_file exists; Terminating manual\
          scoring"
    exit 0
}

set auto_score [read_file $auto_score_file]


set scoring_instructions \
    [find_scoring_instructions]


if { [file exists $compiler_error_file] } {
    set last_file $compiler_error_file
} elseif { [file exists $error_file } {
    set last_file $error_file
} else {
    set last_file [make_bdiff]
}

set manual_score $auto_score

while { "yes" } {

    puts "Scoring [file tail [pwd]"
    puts "Scoring Instructions: $scoring_instructions"
    puts "Auto Score: $auto_score    Current score:\
                                     $manual_score"

    put_file $last_file stdout 10

    puts -nonewline "
------------------------------------------------------
d = view .diff      b = view .bdiff     o = view .out
t = view .test      e = view .err       p = view\
				$submitted_extension
a = exit accepting current score        c = view .cerr
r = reject current score, and enter new current score
x = exit without doing anthing

> "
    set answer [gets stdin]
    if { [eof stdin] } {
    	exit 0
    }

    regexp "^\[\ \t\]*(\[^\ \t\].*)\$" $answer all \
					       answer
    regexp "^(.*\[^\ \t\])\[\ \t\]*\$" $answer all \
					       answer

    set action "view"

    switch $answer \
    	d	{ set last_file [make_diff] } \
    	b	{ set last_file [make_bdiff] } \
    	o	{ set last_file $output_file } \
    	t	{ set last_file $test_file } \
    	e	{ set last_file $error_file } \
    	c	{ set last_file $cerror_file } \
    	p	{ set last_file $submitted_file } \
	a	{ set action "accept" } \
	r	{ set action "reject" } \
	x	{ set action "exit" } \
	default	{ set action "unknown" }

    switch $action \
    	view	{
		    catch { view_file $last_file }
		}
        accept	{
		    write_file $manual_score_file \
		               $manual_score
		    if { $manual_score \
		         == $auto_score } {
			reply "For $submitted_file your\
			       automatic score of:\
			       \    $auto_score" \
			      "has been accepted by the\
			       human judge!"
		    } elseif { $scoring_mode \
			       == "manual" } {
			reply "For $submitted_file your\
			       final score is:\
			       \    $manual_score"
		    } else {
			reply "For $submitted_file your\
			       automatic score of:\
			       \    $auto_score" \
			      "has been OVERRIDDEN by\
			       the human judge!" \
			      "" \
			      "The human judge has\
			       assigned the FINAL\
			       SCORE:     $manual_score"
		    }
		    make_checked

		    exit 0
		}
	reject	{
		    puts "Scoring Instructions:\
			  $scoring_instructions"
		    puts "Auto Score: $auto_score\
		         \    Current score:\
			      $manual_score"
		    puts ""
		    puts -nonewline "
Please select a new current score:
  i = Incorrect Output      cc = Completely Correct
  f = Formatting Error      ic = Incomplete Output
  s = Syntax Error          te = Cpu Time Limit Exceeded
  c = Program Crashed       oe = Output Size Exceeded
  k = keep old current score

> "
  
		    set answer [gets stdin]
		    if { ! [eof stdin] } {

			regexp \
			   "^\[\ \t\]*(\[^\ \t\].*)\$" \
			   $answer all answer
			regexp \
			   "^(.*\[^\ \t\])\[\ \t\]*\$" \
			   $answer all answer

			switch $answer \
			    i	{ set manual_score
			    	      "Incorrect\
				       Output" } \
			    f	{ set manual_score
			    	      "Formatting\
				       Error" } \
			    s	{ set manual_score
			    	      "Syntax\
				       Error" } \
			    c	{ set manual_score
			    	      "Program\
				       Crashed" } \
			    cc	{ set manual_score
			    	      "Completely\
				       Correct" } \
			    ic	{ set manual_score
			    	      "Incomplete\
				       Output" } \
			    te	{ set manual_score
			    	      "Cpu Time Limit\
				       Exceeded" } \
			    oe	{ set manual_score
			    	      "Output Size\
				       Limit\
				       Exceeded" } \
			    k   {} \
			    default	\
			    	{ puts "Unknown:\
				        $answer" }
		    }
		} \
	exit	{ exit 0 } \
	unknown	{ puts "Unknown: $answer }
}


# Include common error catching code:
#
} caught_output
caught_error
