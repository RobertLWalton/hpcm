#! /bin/sh
#
# Get and print files from remote queue.
#
# File:		printer_client
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Wed Oct 12 20:49:55 EDT 2016
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.

# NOTE: This file is not to be executed by the judge,
#       but is to be sent to whoever needs to print
#       files in printer queues set up by the judge.

document="
printer_client PRIVATE-KEY REMOTE-ACCOUNT [PRINTER]

    Get files queued for printing in a remote queue and
    print them on a local printer.  The PRIVATE-KEY is
    a file containing an ssh private key.  The REMOTE-
    ACCOUNT is an ssh login account name and names the
    remote queue.  The PRINTER is the local printer,
    or the local default printer if PRINTER is not
    given.

    The authorized_keys file of the REMOTE-ACCOUNT must
    contain the line

        command=\"printer_server QUEUE-DIRECTORY\" ...

    which invokes the printer_server program that works
    with printer_client to move files to be printed
    from the remote QUEUE-DIRECTORY to the current
    directory and from there to the printer.

    Printer_client reads and executes commands from its
    standard input.  If no input is received within a
    set time (default 30 seconds), printer_client exe-
    cutes the \`get' command which gets and prints any
    unprinted queue files, and then resumes waiting for
    another command (or another timeout).  Files to be
    printed are put in the local (printer_client's)
    current directory with extension .ps, and when the
    file is printed, its extension there is changed to
    .done.

    The common commands are:

        get	Get any unprinted files and print them.
		Files in the queue with extension .ps
		are copied to the current directory
		(of the printer_client program).  Then
		they are printed and their extension
		is changed to .done in both the server
		queue and in the current printer_
		client directory.

	list	List recent files.  Ready (.ps) files
		and recently printed (recent .done)
		files are listed.

	time [SECONDS]
		Reset the time interval between when
		printer_client is ready to read the
		next command and when it executes an
		automatic \`get' command.  The interval
		time is in seconds, with default of 30
		seconds.  The value 0 means infinity.

		If [SECONDS] is not given, the current
		time is printed.

	?	Print list of commands.
	help

	quit	Exit
	exit
	control-D
	control-C

    Other occassionally useful commands are the follow-
    ing.  In all these commands, FILE must have exten-
    sion .ps or .done.


	listfiles
	        List all the files in the server queue.
		File names have date and time and are
		in cronological order.  File extensions
		are changed to indicate status:

		    .out    Still being written.
		    .ps	    Ready to print.
		    .done   Printed.

	get FILE
		Copy FILE from server into current
		directory.

	sum FILE
		Check that the server and the local
		directory both have a copy of FILE and
		both copies have the same MD5 sum.
		The extension may be .ps or .done and
		need not match the extension of either
		copy of the file if that extension is
		either .ps or .done.

	print FILE
		Ditto but then print file and if its
		extension is .ps, change its extension
		to .done in current and server
		directories.

	done FILE
		If FILE has the .ps extension, just
		change the extension to .done in the
		current and server directories.

	ready FILE
		If FILE has the .done extension, just
		change the extension to .ps in the
		current and server directories.

	remove FILE
		Remove the file from local directory and
		and server.

	debug [on|off]
		If the debug switch is on, a trace of
		communications between printer_client
		and the remote server is printed.  With
		no option, the switch is toggled.  The
		\`on' and \`off' options set the switch.

		Lines sent to the server are prefaced
		with \`---> ', and lines received from
		the server are prefaced with \`<--- '.
		See \`printer_server -doc' for documen-
		tation describing the traced lines.

	doc	Print this document.
"

case "$1" in
   "" | -* )
   	echo "$document" | less -F -K
    	exit 1
	;;
esac


key="$1"
account="$2"
printer="$3"

DEBUGOUT=nop
DEBUGIN=nop
READ_TIMEOUT=30

COPROC_TIMEOUT=30
COPROC_DIED=0

WS='[\ 	]'
NWS='[^\ 	]'

function nop() {
    return 0
}

# Call when %%-HPCM_ERROR-%% has been read.  Reads from
# server until %%-HPCM_DONE-%% read and and prints error
# message.
#
function get_error() {
    echo "ERROR:"
    while read -r <&$out -t $COPROC_TIMEOUT
    do
        if [[ "$REPLY" == "%%-HPCM_DONE-%%" ]]
	then
	    $DEBUGIN "$REPLY"
	    COPROC_DIED=0
	    return
	fi
	echo "    $REPLY"
    done
    COPROC_DIED=1
}

# Call to finish server command that has no output.
# Reads until %%-HPCM_DONE-%% read, looking for
# %%-HPCM_ERROR-%%, and complaining if any other
# lines encountered.
#
function finish() {

    echo="$1"
    COPROC_DIED=1
    superfluous_found=0
    while read -r <&$out -t $COPROC_TIMEOUT
    do
        if [[ "$REPLY" == "%%-HPCM_DONE-%%" ]]
	then
	    $DEBUGIN "$REPLY"
	    COPROC_DIED=0
	    break
        elif [[ "$REPLY" == "%%-HPCM_ERROR-%%" ]]
	then
	    $DEBUGIN "$REPLY"
	    get_error
	    return 1
	fi
	if [[ "$echo" == "" && \
	      $superfluous_found == 0 ]]
	then
	    echo "ERROR:"
	    echo "    Superfluous output from server:"
	    superfluous_found=1
	fi
	echo "    $REPLY"
    done
    return $superfluous_found
}

# This function puts the listed files in the `files'
# array and does not print them.
#
declare -a files
declare -i nfiles
function listfiles() {
    echo >&$in listfiles
    $DEBUGOUT listfiles

    files=()
    nfiles=0
    COPROC_DIED=1
    while read -r <&$out -t $COPROC_TIMEOUT
    do
        if [[ "$REPLY" == "%%-HPCM_DONE-%%" ]]
	then
	    $DEBUGIN "$REPLY"
	    COPROC_DIED=0
	    break
        elif [[ "$REPLY" == "%%-HPCM_ERROR-%%" ]]
	then
	    $DEBUGIN "$REPLY"
	    get_error
	    return 1
	fi
	files[$nfiles]="$REPLY"
	(( nfiles += 1 ))
    done
    return 0
}

function get_file() {
    local base="$1"
    local ext="$2"
    local fileout
    rm -f $base.out
    trap "rm -f $base.out" EXIT
    exec {fileout}>$base.out
    echo >&$in get "$base$ext"
    $DEBUGOUT get "$base$ext"

    COPROC_DIED=1
    while read -r <&$out -t $COPROC_TIMEOUT
    do
        if [[ "$REPLY" == "%%-HPCM_DONE-%%" ]]
	then
	    $DEBUGIN "$REPLY"
	    COPROC_DIED=0
	    break
        elif [[ "$REPLY" == "%%-HPCM_ERROR-%%" ]]
	then
	    $DEBUGIN "$REPLY"
	    get_error
	    rm -f "$base.out"
	    trap EXIT
	    return 1
	fi
	echo "$REPLY" >&$fileout
    done
    exec {fileout}>&-
    trap EXIT
    if [[ $COPROC_DIED == 0 ]]
    then
	mv -f "$base.out" "$base$ext" >& /dev/null
	return 0
    else
	rm -f "$base.out"
	return 1
    fi
}

function print_file {
    local base="$1"
    local ext="$2"
    if [ ! -r "$base$ext" ]
    then
	get_file "$base" "$ext"
	if [[ $? != 0 ]]
	then
	    return 1
	fi
    fi
    if [[ "$printer" == "" ]]
    then
	echo "    lpr" "$base$ext"
	lpr "$base$ext"
    else
	echo "    lpr" -P"$printer" "$base$ext"
	lpr -P"$printer" "$base$ext"
    fi
    echo >&$in done "$base$ext"
    $DEBUGOUT done "$base$ext"
    finish
    if [[ $? == 0 ]]
    then
	mv -f "$base.ps" "$base.done" >& /dev/null
    fi
    return 0
}

function get_all() {
    listfiles
    if [[ $? != 0 ]]
    then
        return 1
    fi

    for file in "${files[@]}"
    do
	if [[ "$file" =~ ^(.*)(\.${NWS}*)$ ]]
	then
	    base="${BASH_REMATCH[1]}"
	    ext="${BASH_REMATCH[2]}"
	    if [[ "$ext" != ".ps" ]]
	    then
	        continue
	    fi
	else
	    echo "ERROR: badly formed file name" \
		     "returned by server: $file"
	    continue
	fi

        print_file $base .ps
	if [[ $COPROC_DIED == 1 ]]
	then
	    return
	fi
    done
}

function list() {
    listfiles
    if [[ $? != 0 ]]
    then
        return 1
    fi

    local -a goodfiles=()
    local -i ngoodfiles=0
    local -i first=-1
    for file in "${files[@]}"
    do
	if [[ "$file" =~ ^(.*)(\.${NWS}*)$ ]]
	then
	    base="${BASH_REMATCH[1]}"
	    ext="${BASH_REMATCH[2]}"
	    if [[ "$ext" == ".ps" ]]
	    then
	        if [[ $first == -1 ]]
		then
		    (( first = $ngoodfiles - 1 ))
		fi
	    elif [[ "$ext" != ".done" ]]
	    then
	        continue
	    fi
	else
	    continue
	fi
	goodfiles[$ngoodfiles]="$file"
	(( ngoodfiles += 1 ))
    done

    if (( $first <= 10 ))
    then
    	first=0
    else
    	(( first -= 10 ))
    fi

    while (( $first < $ngoodfiles ))
    do
        echo "    ${goodfiles[$first]}"
	(( first += 1 ))
    done
}

function get_sum() {
    local base="$1"
    local ext="$2"
    local sum="MISSING MD5 SUM"
    echo >&$in sum "$base$ext"
    $DEBUGOUT sum "$base$ext"
    COPROC_DIED=1
    while read -r <&$out -t $COPROC_TIMEOUT
    do
	$DEBUGIN "$REPLY"
        if [[ "$REPLY" == "%%-HPCM_DONE-%%" ]]
	then
	    COPROC_DIED=0
	    break
        elif [[ "$REPLY" == "%%-HPCM_ERROR-%%" ]]
	then
	    get_error
	    return 1
        elif [[ "$sum" != "MISSING MD5 SUM" ]]
	then
	    sum="MALFORMED MD5 SUM"
	else
	    sum="$REPLY"
	fi
    done
    SUM="$sum"
    return 0
}

while [ x = x ]
do
    if [[ "$COPROC_PID" != "" ]]
    then
	kill -9 $COPROC_PID >&/dev/null
	wait $COPROC_PID >&/dev/null
	echo ERROR: coprocess died: restarting
    fi
    coproc printer_server q
    out=${COPROC[0]}
    in=${COPROC[1]}
    COPROC_DIED=0

    while [ x = x ]
    do
	if [[ $READ_TIMEOUT != 0 ]]
	then
	    read -r -t $READ_TIMEOUT
	else
	    read -r
	fi
	STATUS=$?
	if [[ $STATUS > 128 ]]
	then
	    echo get "[at `date +%T`]"
	    get_all
	    continue
	elif [[ $STATUS != 0 ]]
	then
	    exit 0
	fi
	case "$REPLY" in
	doc)
	    echo "$document" | less -F -K
	    ;;
	\? | help )
	    echo "get             Get and print ready" \
	                          files
	    echo "list            List ready and" \
	                          recently printed files
	    echo "time [TIMEOUT]  Print or reset" \
	                          timeout
	    echo ""
	    echo "quit            Exit"
	    echo "exit            Exit"
	    echo "control-D       Exit"
	    echo "control-C       Exit"
	    echo ""
	    echo "get FILE        Get file"
	    echo "sum FILE        Check file MD5 sums"
	    echo "done FILE       Mark file done" \
	    		          '(printed)'
	    echo "ready FILE      Mark file ready to" \
	    		          print
	    echo "print FILE      Print file"
	    echo "remove FILE     Remove file"
	    echo "debug [on|off]  Set or toggle debug" \
	    			  output
	    ;;
	quit | exit )
	    exit 0
	    ;;
	listfiles)
	    listfiles
	    for file in "${files[@]}"
	    do
	        echo "    $file"
	    done
	    ;;
	time* )
	    if [[ "$REPLY" =~ ^time${WS}*$ ]]
	    then
	        echo "time interval is $READ_TIMEOUT" \
		     "seconds"
	    elif [[ "$REPLY" =~ \
	            ^time${WS}+([0-9]+)${WS}*$ ]]
	    then
	        READ_TIMEOUT=${BASH_REMATCH[1]}
	    else
	        echo "ERROR: badly formed time" \
		     "interval in $REPLY"
	    fi
	    ;;
	get)
	    get_all
	    ;;
	list)
	    list
	    ;;
	listdir)
	    echo >&$in listdir
	    $DEBUGOUT listdir
	    finish echo
	    ;;
	get* | sum* | print* | done* | ready* \
	     | remove* )
	    
	    if [[ "$REPLY" =~ \
		  ^(${NWS}+)${WS}+(.*${NWS})${WS}*$ ]]
	    then
		op="${BASH_REMATCH[1]}"
		file="${BASH_REMATCH[2]}"
		if [[ "$file" =~ ^(.*)(\.${NWS}*)$ ]]
		then
		    base="${BASH_REMATCH[1]}"
		    ext="${BASH_REMATCH[2]}"
		    if [[ $op == "remove" ]]
		    then
		        if [[ "$ext" =~ \
			      ^(.out|.ps|.done)$ ]]
			then
			    echo >&$in remove \
			               "$base$ext"
			    $DEBUGOUT remove \
			              "$base$ext"
			    finish
			    if [[ $? == 0 ]]
			    then
				rm -f "$base.ext"
			    fi
			else
			    echo "ERROR: $file" \
			         "extension is not" \
				 ".out, .ps, or .done"
			fi
			continue
		    elif [[ "$ext" != ".done" \
		              && "$ext" != ".ps" ]]
		    then
		        echo "ERROR: $file extension" \
			     "is not .ps or .done"
			continue
		    fi
		    case $op in
		    get)
			get_file "$base" "$ext"
			if [[ $? == 0 ]]
			then
			    ls -l "$base$ext"
			fi
			;;
		    sum)
			if [ -r "$base$ext" ]
			then
			    get_sum "$base" "$ext"
			    if [[ $? != 0 ]]
			    then
			        continue
			    fi
			    locsum=`md5sum \
			        "$base$ext"`
			    [[ "$locsum" =~ \
			       ^(${NWS}*)${WS} ]]
			    locsum="${BASH_REMATCH[1]}"
			    if [[ "$locsum" == \
			          "$SUM" ]]
			    then
			        echo Local and Server \
				     "$file" MD5 Sums \
				     Are Equal
			    else
			        echo Local "$file" MD5 \
				     Sum == "$locsum"
				echo !=
			        echo Server "$file" \
				     MD5 Sum == "$SUM"
			    fi
			else
			    echo Local "$file" Not \
			         Found "(Unreadable)"
			fi
			;;
		    print )
		        print_file "$base" "$ext"
			;;
		    done )
			echo >&$in done "$base$ext"
			$DEBUGOUT done "$base$ext"
			finish
			if [[ $? == 0 ]]
			then
			    mv -f "$base.ps" \
			           "$base.done" \
				   >& /dev/null
			fi
			;;
		    ready )
			echo >&$in ready "$base$ext"
			$DEBUGOUT ready "$base$ext"
			finish
			if [[ $? == 0 ]]
			then
			    mv -f "$base.done" \
			           "$base.ps" \
				   >& /dev/null
			fi
			;;
		    * )
		        echo "ERROR: unknown command" \
			     "in $REPLY"
			;;
		    esac
		else
		    echo "ERROR: $file has no extension"
		fi
	    else
	        echo "ERROR: badly formed command or" \
		     "file name in $REPLY"
	    fi
	    ;;
	debug*)
	    if [[ "$REPLY" =~ \
		     ^debug${WS}+(.*${NWS})${WS}*$ ]]
	    then
		toggle="${BASH_REMATCH[1]}"
	    elif [[ "$DEBUGOUT" == "nop" ]]
	    then
	        toggle=on
	    else
	        toggle=off
	    fi
	    case "$toggle" in
	    on)
		DEBUGOUT="echo --->"
		DEBUGIN="echo <---"
		;;
	    off)
		DEBUGOUT=nop
		DEBUGIN=nop
		;;
	    *)
	        echo ERROR: cannot understand $toggle
	    ;;
	    esac
	    ;;
	*)
	    echo "ERROR: Could not understand: $REPLY"
	    echo "       The \`help' command prints" \
	                 command list.
	    ;;
	esac
	if [[ $COPROC_DIED == 1 ]]
	then
	    break
	fi
    done
done

exit 0
