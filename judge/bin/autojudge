#!/bin/sh
#
# Compute all the files needed in a program submission
# directory in order to score a submission.
#
# File:		autojudge
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sat Nov 24 11:08:31 EST 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/11/24 17:37:10 $
#   $RCSfile: autojudge,v $
#   $Revision: 1.40 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory
autojudge \[problem\[.extension\]\]

    Given the submission directory as the current dir-
    ectory, and given that the submission directory
    contains the file `$received_file', this program
    makes everything needed to compute the score file,
    `$auto_score_file', and automatically computes that
    file.  Then this program may report the score to the
    submitter by creating and sending `$reply_file' as
    specified by the scoring mode.

    If the the problem name and optional extension is
    not given as an argument, it is extracted from the

    	Subject: problemname\[.extension\]

    field of the message in the $received_file file. \
    	The
    `problem' names the problem and the solution binary,
    and is the basename of the .in, .out, .test, .cerr,
    .err, and .score files.  The extension, if given,
    tells the language being used, and must be a member
    of the `allowed_extensions' global variable value,
    which by default is:
    
    	$allowed_extensions
 
    Specifically, this program makes the following in
    order:

	* $files_file file, if it exists
	. submitted files made by calling extractmail
	* $make_file file
	* any -LINK- files in any $files_file file
	* $scoring_instructions_file file, if it exists
	* $scoring_filter_file file, if it exists
	* .in solution input file
	* .test solution output file
	* .ftest solution output file, if it exists
	. the program binary (and .cerr file)
	. the .out file (and .err file)
	. the .fout file, sometimes
	. the .score file made by calling autoscore
	. the $auto_score_file file made by ditto
	. the $reply_file file, sometimes

    Here the files marked with * are linked into the
    current submission directory from the problem's so-
    lution directory.  For any other file, if it already
    exists, this program checks to be sure it is not
    older than the previous files (starting with sub-
    mitted files not being older than the $received_file
    file), and remakes any of the above files that are
    out-of-date.  Errors in making the program binary
    can cause $auto_score_file and maybe $reply_file to
    be generated early.

    First, this program verifies the existence of a so-
    lution directory for the problem and symbolically
    links the $files_file file from this directory into
    the current directory, if that file exists.  Then
    this program calls `extractmail' to extract the
    submitted files from the program.  If there is a
    non-system error in this extraction, this program
    generates and sends `$reply_file' automatically to
    the submitter.
 
    If the extraction had no errors, this program sym-
    bolically links the following solution directory
    files into the current directory:

	$make_file file
	any -LINK- files in any $files_file file
	$scoring_instructions_file file, if it exists
	$scoring_filter_file file, if it exists
	.in solution input file
	.test solution output file
	.ftest solution output file, if it exists

    In the solution directory, the `$files_file' file
    may be present in several forms under names of the
    form `$files_file.extension'.  If one of these forms
    has an extension matching that given with the pro-
    blem name, it is linked into the current directory
    under the name `$files_file'.  Otherwise there is an
    error.  The `$make_file' file is treated similarly.

    If a `$files_file' file is linked into the current\
    			direc-
    tory, it is read to find other files to link into
    the current directory.  This file is interpreted as
    a TCL list (with list elements separated by spaces,
    tabs, or new lines) whose elements are file names
    and the special symbols:
 
    	-REQUIRED-	Indicates that the following
			file names name files that MUST
			be submitted.
    
    	-OPTIONAL-	Indicates that the following
			file names name files that may
			optionally be submitted.
    
    	-LINK-		Indicates that the following
			file names name files that MUST
			be linked from the problem
			solution directory.

    File names before any special symbol are treated as
    `-REQUIRED-'.  Special symbols can appear any number
    of times in the list and apply to all file names
    following them but before the next special symbol in
    the list.  The `autojudge' program ignores non-
    `-LINK-' file names.

    The .test file is linked to the solution .out file
    if that exists, or the solution .test file other-
    wise.  If the solution .out file exists and the
    the current directory .test file is linked to the
    solution directory .test file, the current directory
    .test file is relinked to the solution .out file.
    Thus the solution .out file always has preference
    over the solution .test file.  The .ftest file is
    similarly linked to the solution .fout file in
    preference to the solution .ftest file.

    Next this program makes the program binary by using
    the $make_file.  Any compiler error messages are
    captured in a .cerr file.  If no executable binary
    is made, this program writes `Syntax Error' into the
    $auto_score_file file, and skips to the end of this
    program where a $reply_file file containing the auto
    score may be created and sent to the user.
 
    If an executable binary file was made, this program
    makes a .out output file by using the $make_file,
    and captures any error output in a .err file.  If
    the .out file exists and is non-empty, and if the
    $scoring_filter_file file exists, this program then
    runs

    	$scoring_filter_file <PPP.out >PPP.fout

    to make the .fout file.  It is a system error if
    the $scoring_filter_file program exits with a non-0
    UNIX exit code or writes the standard error output,
    of it no .ftest file exists in this situation.

    Then this program runs `autoscore' to produce a
    .score file and an automatic score in the\
        $auto_score_file
    file.  Any .score file will be not produced (and
    even deleted if it exists) if the score can be
    determined without it, i.e., if the score is deter-
    mined by the .err file or if the .out file does not
    exist or is empty.

    Lastly, this program may create a `$reply_file'
    and send it as email to the submitter.  It does this
    if the score is `Completely Correct' or the scoring_
    mode is `auto' or `auto+manual'.  If the mode is
    `auto+manual' and the score is not `Completely Cor-
    rect', the email informs its receiver that the score
    is preliminary and will be manually reviewed and
    possibly changed.
 
    If the score is to be manually reviewed, this prog-
    ram does not create a $reply_file file, even when it
    sends a reply (the reply is recorded in any case in
    the $reply_history_file file).  The absence of a
    $reply_file file signals that the final reply has
    not been given to the submitter, and further action
    using the `manualreply' program is necessary to gen-
    erate a final reply.

    This program prints information about its progress.
 
    Unless this program creates a $reply_file file that
    is intended to be the final reply to the submitter
    (because the score is `Completely Correct' or the
    scoring mode is `auto'), this program sets the
    `needs reply' flag (the $needs_reply_flag_file\
    			file in
    the flag directory).  This signals other programs
    (e.g. tracker) that they should search for submis-
    sion directories for which the manualreply program
    should be called.

    If this program (because of a `Syntax Error') or the
    `autoscore' program writes the $auto_score_file\
    	file,
    the program will set the score flag (the flag direc-
    tory $score_flag_file file), to signal that any\
	score-
    boards need to be recomputed.

    If something goes very wrong, such as finding that
    the `$received_file' file is not readable, or having
    `extractmail' return a system error, this program
    creates an error log file in the current directory,
    prints information about the error to the standard
    error output, and exits with exit code 0."

# If too many arguments or -doc argument, print docu-
# mentation and exit.
#
if { $argc > 1 || [regexp {^-doc} [lindex $argv 0]] } {
    puts $document
    exit 1
}

# Compute problem name.
#
if { $argc == 1 } {
    set argument [lindex $argv 0]
} else {

    # Read message header.
    #
    set received_ch [open $received_file r]
    read_header $received_ch
    close $received_ch

    # Get problem.
    #
    if {    [llength $message_subject] != 2 \
	 || [lindex $message_subject 0] != "submit" } {
	error "Illegal message subject:\
	      $message_subject"
    }
    set argument [lindex $message_subject 1]
}
set problem [file rootname $argument]
set extension [file extension $argument]

# Signal error if bad problem name or extension.
#
proc argument_error {} {
    global argument
    reply \
          "ERROR: problem name or extension is illegal:\
	          $argument" \
	  ""  \
	  "THIS SUBMISSION (see below) IGNORED"  \
	  "YOU MUST RESUBMIT WITH A LEGAL PROBLEM NAME"
    puts "SUBMISSION ERROR: problem name or extension\
          is illegal: $argument"
    exit 0
}

# Check legality of problem name and optional extension.
#
if {    $problem == "" \
     || [regexp {\.} $problem] \
     || [regexp {/}  $problem] \
     || [regexp {^-} $problem]  } {
    argument_error
}
if { $extension != "" \
     && [lsearch -exact $allowed_extensions \
     			$extension] < 0 } {
    argument_error
}


# Check for existence of problem solution directory.
#
set problem_solution $solutions_directory/$problem
if { ! [file isdirectory $problem_solution] } {
    argument_error
}

# Link $files_file or $make_file if possible.
#
proc link_optional_file { name } {

    global extension problem_solution

    if { [file exists $name] } return

    if { [file exists $problem_solution/$name] } {
	puts "Linking $name"
	link_file $problem_solution/$name
	return
    } 
    if { [file exists \
               $problem_solution/$name.$extension] } {
	puts "Linking $name.$extension to $name"
	link_file $problem_solution/$name.$extension \
		  $name
	return
    }

    if { [llength [glob -nocomplain $name.*]] > 0 } {
        argument_error
    }
}

# Link in any $files_file.
#
link_optional_file $files_file

# Get submitted files.  If error, on SYSTEM ERROR pass
# to `error' function and otherwise reply to submitter.
#
if { [catch { exec extractmail } extractout] } {
    if { [regexp {SYSTEM ERROR} $extractout] } {
        error "System error during\
	       extractmail:\n\n$extractout"
    } else {

	# Create a reply file complaining of an extrac-
	# tion error, and email this reply to the
	# submitter.  Include the submission email in
	# the reply.
	#
	reply -all \
            "ERROR during file extraction:" \
	    "" \
	    $extractout \
	    "" \
	    "THIS SUBMISSION (see below) IGNORED" \
	    "YOU MUST RESUBMIT"

	puts $extractout
	puts "Reply indicating error emailed to\
	     submitter."

	exit 0
    }
} else {
    puts $extractout
}

# Link $make_file, etc.
#
link_optional_file $make_file

# Link any $files_file -LINK- files.
#
if { [file exists $files_file] {
    set link_mode no
    foreach name [read_entire_file $files_file] {
        switch $name {
	    -LINK-	{ set link_mode yes }
	    -REQUIRED-	--
	    -OPTIONAL-	{ set link_mode no }
	    default	{
	        if { $link_mode \
		     && ! [file exists $name] } {
		    set sname \
		        $problem_solution/$name
     		    if { ! [file exists $sname] } {
		        error "-LINK- file $sname does\
			       not exist"
		    }
		    puts "Linking $name"
		    link_file $sname
		}
	    }
	}
    }
}

# Link $scoring_instructions_file and $scoring_filter_
# file.
#
set sif $scoring_instructions_file
if { ! [file exists $sif] \
     && [file exists $problem_solution/$sif] } {
    puts "Linking $sif"
    link_file $problem_solution/$sif
}
set sff $scoring_filter_file
if { ! [file exists $sff] \
     && [file exists $problem_solution/$sff] } {
    puts "Linking $sff"
    link_file $problem_solution/$sff
}

# Link .in, .test, and .ftest files.
#
if { ! [file exists $problem.in] } {
    puts "Linking $problem.in"
    link_file $problem_solution/$problem.in
}
set solout  $problem_solution/$problem.out
set soltest $problem_solution/$problem.test
if { ! [file exists $problem.test] \
     || ( [file exists $solout] \
          && [file extension \
	           [file readlink $problem.test]] \
	     == ".test" ) } {
    if { ! [catch { file type $problem.test }] } {
	puts "Deleting obsolete\
	      $problem.test"
	file delete -force $problem.test
    }
    if { [file exists $solout] } {
	puts "Linking $problem.test to solution\
	      $problem.out"
	link_file $solout $problem.test
    } else {
	puts "Linking $problem.test"
	link_file $soltest
    }
}
set solfout  $problem_solution/$problem.fout
set solftest $problem_solution/$problem.ftest
if {    (    [file exists $solftest] \
          && ! [file exists $problem.ftest] ) \
     || (    [file exists $solfout] \
          && ! [file exists $problem.ftest] ) \
     || (    [file exists $solfout] \
          && [file extension \
	           [file readlink $problem.ftest]] \
	     == ".ftest" ) } {
    if { ! [catch { file type $problem.ftest }] } {
	puts "Deleting obsolete\
	      $problem.ftest"
	file delete -force $problem.ftest
    }
    if { [file exists $solfout] } {
	puts "Linking $problem.ftest to solution\
	      $problem.fout"
	link_file $solfout $problem.ftest
    } else {
	puts "Linking $problem.ftest"
	link_file $solftest
    }
}

# Send reply to user containing new auto score.
#
proc auto_score_reply { auto_score } {

    global scoring_mode reply_file submitted_file \
           needs_reply_flag_file

    if { $auto_score == "Completely Correct" \
         || $scoring_mode == "auto" } {
	reply "For $submitted_file the automatically\
	       determined final score is:" \
	      "" \
	      "    $auto_score"
	puts "Emailed final auto-score:\
	      \    $auto_score"
    } elseif { [regexp {auto} $scoring_mode] } {
	compose_reply \
              "For $submitted_file the automatically\
	       determined score is:" \
	      "" \
	      "    $auto_score" \
	      "" \
	      "However, this score WILL BE REVIEWED by\
	       the human judge (soon)."
	send_reply -notfinal
	set_flag $needs_reply_flag_file
	puts "Emailed auto-score (review later):\
	      \    $auto_score"
    } else {
	set_flag $needs_reply_flag_file
	puts "Auto-score (NOT emailed):\
	      \    $auto_score"
    }
}

# should_be_made file_list1 file_list2 
#
# If any file_list1 file is older than any file_list2
# file, and all file_list2 files exist, delete any
# file_list1 files that exist and return `yes'.  If no
# file_list1 files exist and all file_list2 files
# exist, return `yes'.  Else return `no'.
#
#
proc should_be_made { file_list1 file_list2 } {

    # Set mtime1 to the oldest of the file_list1
    # mtimes, or 0 if no file_list1 file exists.
    #
    set mtime1 0
    foreach file1 $file_list1 {
	if { [file exists $file1] } {
	    set mt [file mtime $file1]
	    if { $mtime1 == 0 || $mtime1 > $mt } {
	    	set mtime1 $mt
	    }
	}
    }
    # Set mtime2 to the newest of the file_list2
    # mtimes, or 0 if any file_list2 file does not
    # exist.
    #
    set mtime2 0
    foreach file2 $file_list2 {
	if { [file exists $file2] } {
	    set mt [file mtime $file2]
	    if { $mtime2 < $mt } {
	    	set mtime2 $mt
	    }
	} else {
	    set mtime2 0
	    break
	}
    }

    # If mtime1 < mtime2 we need to make file_list1
    # from file_list2
    #
    if { $mtime1 < $mtime2 } {
    	foreach file1 $file_list1 {
	    if { [file exists $file1] } {
	        puts "Deleting out-of-date $file1"
		file delete -force $file1
	    }
	}
	return yes
    } else {
        return no
    }
}

# If necessary compile submitted file to produce
# binary.  If this fails, announce `Syntax Error'
# as the score.
#
if { [should_be_made \
         [list $problem $problem.cerr] \
	 [list $make_file $submitted_file]] } {

    puts "Making $problem"
    catch { make_file $problem $problem.cerr }

    # Print any non-empty .cerr file.
    #
    if { [file exists $problem.cerr] \
	 && [file size $problem.cerr] > 0 } {
	puts ""
	if { [file executable $problem] } {
	    puts "========== COMPILER WARNINGS\
	          ($problem.cerr) =========="
	} else {
	    puts "========== COMPILER ERRORS\
	          ($problem.cerr) =========="
	}
	put_file $problem.cerr stdout 10
	puts "============================="
	puts ""
    }

    # If no executable binary produced, record and
    # send `Syntax Error' reply.
    #
    if { ! [file executable $problem] } {

	puts "No executable `$problem' file produced"

	if { [file exists $auto_score_file] } {
	    file delete -force $auto_score_file
	}
	write_file $auto_score_file "Syntax Error"
	set_flag $score_flag_file
	auto_score_reply "Syntax Error"
	exit 0
    }
}

# Make .out file if necessary.
#
if { [should_be_made \
         [list $problem.out $problem.err] \
	 [list $problem $make_file $problem.in]] \
     && [file executable $problem] } {

    puts "Making $problem.out"
    catch { make_file $problem.out $problem.err }

    # Remove any a+x on the current directory as a
    # `best effort' security measure in the face of
    # the JAVA bug that requires .. to be a+x.
    #
    deny_access "."

    # Print any non-empty .err file.
    #
    if { [file exists $problem.err] \
	 && [file size $problem.err] > 0 } {
	puts ""
	puts "========== ERRORS ($problem.err)\
	      =========="
	put_file $problem.err stdout 10
	puts "============================="
	puts ""
    } elseif { ! [file exists $problem.out] } {
	puts "No `$problem.out' file produced"
    }
}

# Make .fout file if appropriate.
#
if { [should_be_made \
         [list $problem.fout] \
	 [list $problem.out $scoring_filter_file]] \
     && [file size $problem.out] > 0 } {

    puts "Making $problem.fout"
    exec $scoring_filter_file < $problem.out \
    			      > $problem.fout
}

# Make $auto_score_file if necessary.
#
if { [file exists $scoring_filter_file] } {

    set file_list [list $problem.ftest]

    if { [file exists $problem.fout] } {
	lappend file_list $problem.fout
    }
} else {
    set file_list [list $problem.test]

    if { [file exists $problem.out] } {
	lappend file_list $problem.out
    }
}
if { [file exists $problem.err] } {
    lappend file_list $problem.err
}

if { [llength $file_list] >= 2 \
     && [should_be_made \
            [list $auto_score_file] \
	    $file_list] } {

    exec autoscore $problem 2>@ stderr
}

# Make $reply_file if necessary.
#
if { [should_be_made \
         [list $reply_file] \
	 [list $auto_score_file]] } {

    auto_score_reply [read_file $auto_score_file]
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
