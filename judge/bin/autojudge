#!/bin/sh
#
# Compute all the files needed in a program submission
# directory in order to score a submission.
#
# File:		autojudge
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Thu Sep 29 09:56:02 EDT 2005
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2005/09/29 13:50:28 $
#   $RCSfile: autojudge,v $
#   $Revision: 1.97 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# In this program:
#
#	PROBLEM is the problem name.
#	EXTENSION is the extension from received file
#	    Subject: submit $PROBLEM$EXTENSION ...
#	s_d is the problem solution directory.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
source $lib_directory/scoring_common.tcl
catch {

set document "
cd submission_directory
autojudge \[-manual\] \[problem\[.extension\]\]

    Given the submission directory as the current dir-
    ectory, and given that the submission directory
    contains the file `$received_file', this program
    makes everything needed to compute the score file,
    `$auto_score_file', and then automatically computes\
    	that
    file.  This program may report the score to the sub-
    mitter by creating and sending `$reply_file' as
    specified by the `scoring_mode' global variable.

    If the -manual program option is given, it sets the
    scoring_mode to `manual' while this program is run-
    ning.  This suppresses sending email to the submit-
    ter.

    If the problem name and optional extension are not
    given as an argument, they are extracted from the

    	Subject: submit problem\[.extension\] ...

    field of the message in the $received_file file.
    Here `problem' names the problem and the solution
    binary, and is the basename of the .in, .out, .test,
    .fout, .ftest, .cerr, .err, and .score files.  If
    `extension' is given, it tells the language being
    used, and must be a member of the `allowed_exten-
    sions' global variable value, which by default is:
    
    	$allowed_extensions

    In this document and in the `$files_file' file\
    	mentioned
    below, the words `PROBLEM' and `EXTENSION' are used
    to denote the problem name and extension as given in
    an argument or `Subject:' field.  Also, the solution
    directory below is the problem directory within the
    solutions directory, i.e., the directory with name:

    	\$solutions_directory/PROBLEM

    More specifically, this program makes the following
    in order:

      * `PROBLEM.rc' file, if it exists.  If it exists
        (in the problem's solution directory), it is
        sourced, and may set some of the global varibles
	mentioned below.  See the `Problem .rc Files'
	section of hpcm_judging.rc for detailed specifi-
	cation of the values of these global variables.

      . Submitted files which are extracted from the
        submitted message in the $received_file file
        by the extractmail program.  These files must
	all be listed in the problem_required_files or
	problem_optional_files global variables.
	The default is for PROBLEM.EXTENSION to be
	the only required file if EXTENSION is not
	empty.

      . Files listed in the problem_make_files global
        variable, which gives instructions on when and
	how to make files in the problem's solution
	directory.  E.g., the Scoring_Filter program
	may be compiled there if necessary.  The
	default is to make PROBLEM.ftest if Scoring_
	Filter and PROBLEM.test exist, and to make
	PROBLEM.fout in the problem's solution direc-
	tory if Scoring_Filter and PROBLEM.out exist
	in that directory.

      * Files listed in the problem_link_files and
        problem_optional_link_files global variables.
	The default link files are $make_file,
	PROBLEM.in and PROBLEM.test.  The default
	optional link files are $scoring_filter_file
	and PROBLEM.ftest.

      . The program binary file `PROBLEM' and the
	compiler error file PROBLEM.cerr are made by
	executing `make PROBLEM', using the $make_file.

      . The program standard output file PROBLEM.out
	and the program standard error file PROBLEM.err
        are made by executing `make PROBLEM.out', using
	the $make_file.

      . The filtered output file PROBLEM.fout, if the
	$scoring_filter_file file exists.

      . The PROBLEM.score and $auto_score_file files
        are made by executing autoscore.

      . The $reply_file file is made and a reply sent
        to the submitter, unless the scoring_mode is
	`manual'.

    Here files marked with * are linked into the current
    submission directory from the problem's solution
    directory.
    
    In general, this program does not make a file that
    already exists, unless one of the files input to
    make the file is more recent that the file to be
    made.  So, for example, if the $received_file file
    is more recent than an extracted file, the files
    will be re-extracted, whereas if extracted files
    exist and are all as recent as the $received_file
    file, file extraction will be skipped.

    Inability to make a program binary or a .out file,
    or an empty .out file, can cause $auto_score_file\
        and
    maybe $reply_file to be generated early.

    In general, this program may detect two kinds of
    errors: system errors and submitter errors.  A
    system error means the judging files are incorrectly
    set up, and a submitter error means the submitter
    sent the wrong information.  On a system error, this
    program logs the error in an error log file in the
    current directory and prints information about the
    error to the standard error output.  On a submitter
    error, this program creates a $reply_file file that
    contains a description of the error and sends this
    to the submitter as the final word on the submis-
    sion.  In either case this program terminates after
    reporting the error.

    At its beginning, this program verifies the exis-
    tence of a solution directory for the problem and
    symbolically links the `PROBLEM.rc' file from this
    directory into the current directory, if this file
    exists.  If the `PROBLEM.rc' file exists, it is
    sourced, but before being sourced the

    	problem_make_files
	problem_required_files
	problem_optional_files
	problem_link_files
	problem_optional_link_files

    global variables are given default values as descri-
    bed in the `Problem .rc Files' section of hpcm_
    judging.rc.

    TBD

    In the above, a dangling link does not count as an
    existing file.  Thus if the solution directory con-
    tains a dangling link F2, i.e., a link to an non-
    existent file, then F2 does not exist.  Also note
    that by `link' we mean `symbolic link'.

    If no extension is given to this program with the
    problem name, any file name whose extension is
    .`EXTENSION' is treated as naming a file that does
    not exist and cannot be created.  It is an error to
    try to create such a file, but it is not an error to
    try to use such a file if it is not an error for the
    file not to exist.

    Thus in the default value of the `$files_file' file
    given above, the file named $make_file in the cur-
    rent directory is linked to the file named
    `$make_file.EXTENSION' if an extension was given
    with the problem name to this program and if the
    indicated file exists in the solution directory.
    Otherwise the file is linked to $make_file in the
    solution directory, if that file exists.  Otherwise
    there is an error, as $make_file is -LINK- and not
    -OPTIONAL-LINK-.

    In linking any `PROBLEM.rc' or `$files_file' file
    from the solution directory, this program behaves as
    if there were an initial `$files_file'\
    		file value of:

    	-OPTIONAL-LINK-
	    { PROBLEM.rc rc.EXTENSION PROBLEM.rc }
	    { $files_file $files_file.EXTENSION\
	      $files_file }

    Thus in the solution directory, rc.EXTENSION and
    $files_file.EXTENSION are preferred over\
    	PROBLEM.rc
    and `$files_file'.

    It is an error if the solution directory has no
    `PROBLEM.rc' file but does have `rc.*' files none of
    which match the extension given by the submitter;
    or if the solution directory has no `$files_file'\
    		file
    but does have `$files_file.*' files, none of which
    match the extension given by the submitter.

    All errors involving linking are submitter errors if
    there might be some extension that the submitter
    could specify which would make the submission cor-
    rect.  Otherwise the errors are system errors.

    Next this program calls `extractmail' to extract the
    submitted files from the program.  Errors in this
    extraction are classified as system errors if ex-
    tractmail outputs the phrase `SYSTEM ERROR' and
    submitter errors otherwise.

Moved to after extract.
    After linking any `PROBLEM.rc' and `$files_file'\
    		files
    from the solution directory, this program makes any
    files governed by -SOLUTION-MAKE- in the\
    	`$files_file'
    file.  If there is such a file F listed, and it does
    not already exist in the solution directory, this
    program executes `make F' in the solution directory.
    During this process this program locks the solution
    directory with a $dispatch_pid_file file.  Note that
    `PROBLEM' or `EXTENSION' are not substituted for in
    -SOLUTION-MAKE- file names; but the same effect can
    be had by having different `$files_file.EXTENSION'\
    	files
    for different extensions.
 
    If the extraction has no errors, this program sym-
    bolically links solution directory files into the
    current directory, according to instructions encoded
    by the -LINK- and -OPTIONAL-LINK- special symbols in
    the `$files_file' file or the default value given\
    	above
    for this file.  Note that a file may be listed as
    both -OPTIONAL- (for extractmail) and -LINK-: if
    submitted the submitted version will be used, and if
    not submitted, the solution directory version will
    be used.  Also note that a file listed as -LINK- or
    -OPTIONAL-LINK- may be made as a consequence of a
    -SOLUTION-MAKE- item (which may or may not directly
    name the file to be linked).

    Next this program makes the program binary by using
    the $make_file.  Any compiler error messages are
    captured in a .cerr file.  If no executable binary
    is made, this program writes `Syntax Error' into the
    $auto_score_file file, and skips to the end of this
    program where a $reply_file file containing the auto
    score may be created and sent to the user.
 
    If an executable binary file was made, this program
    makes a .out output file by using the $make_file,
    and captures any error output in a .err file.  If
    the .out file exists and is non-empty, and if the
    $scoring_filter_file file exists, this program then
    runs

    	$scoring_filter_file <PROBLEM.out >PROBLEM.fout

    to make the .fout file.  It is a system error if the
    $scoring_filter_file program exits with a non-zero\
    	UNIX
    exit code or writes the standard error output, or if
    no .ftest file exists in this situation.

    For purposes of computing file dependencies, the
    files PROBLEM, PROBLEM.out, and PROBLEM.fout are all
    assumed to depend upon all the extracted and linked
    files.

    Then this program runs `autoscore' to produce a
    .score file and an automatic score in the\
        $auto_score_file
    file.  Any .score file will be not produced (and
    even deleted if it exists) if the score can be
    determined without it, i.e., if the score is deter-
    mined by the .err file or if the .out file does not
    exist or is empty.

    Lastly, this program may create a `$reply_file' file
    and send it as email to the submitter.  It does this
    using instructions in the `response_instructions'
    global variable.  This variable contains instruc-
    tions that format the reply for a given\
    	$auto_score_file
    value and a given value of the scoring_mode global
    variable.  The format of the response instructions
    is described in hpcm_judging.rc, where a default
    value is also given for the `response_instructions'
    variable.
    
    With default response instructions, this program
    sends a reply if the score is `Completely Correct'
    or the scoring_mode is `auto' or `auto+manual'.  If
    the mode is `auto' or the score is `Completely Cor-
    rect', the reply is final, and is stored in the
    $reply_file file.  Otherwise the reply is not final,
    and informs its receiver that the score is prelim-
    inary and will be manually reviewed and possibly
    changed.  When the reply is not final, this program
    does not create a $reply_file file, even when it
    sends a reply (the reply is recorded in any case in
    the $reply_history_file file).  The absence of a
    $reply_file file signals that the final reply has
    not been given to the submitter, and further action
    using the `manualreply' program is necessary to gen-
    erate a final reply.

    This program prints information about its progress.
 
    Unless this program creates a $reply_file file that
    is intended to be the final reply to the submitter
    (e.g., because the score is `Completely Correct' or
    the scoring mode is `auto'), this program sets the
    `needs reply' flag (the $needs_reply_flag_file\
    			file in
    the flag directory).  This signals other programs
    (e.g. tracker) that they should search for submis-
    sion directories for which the manualreply program
    should be called.

    If this program (because of a `Syntax Error') or the
    `autoscore' program writes the $auto_score_file\
    	file,
    the program will set the score flag (the flag direc-
    tory $score_flag_file file), to signal that any\
	score-
    boards need to be recomputed.

    Problem names that contain `/' or `.' or begin with
    `-' or have no solution directory are illegal, and
    are submitter errors.  Similarly extension names
    not listed in the `allowed_extensions' global vari-
    able are unallowed and are submitter errors, as are
    misformatted $received_file file `Subject:' fields.
    It is a system error if the `$received_file' file is
    not readable, if a `$files_file' file is\
    	misformatted, or
    if `extractmail' returns a system error.  It is a
    system error if an existing `response_instructions'
    global variable value is misformatted."

# Do not change argc or argv so error printouts will be
# correct.
#
set my_argc $argc
set my_argv $argv

# Process any -manual argument.
#
set manual 0
if { [lindex $my_argv 0] == "-manual" } {
    set manual 1
    set my_argv [lrange $my_argv 1 end]
    incr my_argc -1
}

# If too many arguments or -doc argument, print docu-
# mentation and exit.
#
if {    $my_argc > 1 \
     || [regexp {^-doc} [lindex $my_argv 0]] } {
    puts $document
    exit 1
}

# Handle submitter error in subject.
#
proc subject_error { what } {
    global message_subject
    reply "LINE {ERROR: $what\
	  	 `Subject:$message_subject'}" \
	  BLANK \
	  { LINE "THIS SUBMISSION (see below)\
	          IGNORED" } \
	  { LINE "You must resubmit with a legal\
	         message subject." } \
	  BLANK \
	  { BAR "this message replies to:" } \
	  RECEIVED-HEADER
    puts "SUBMISSION ERROR: $what in\
          `Subject:$message_subject'"
    exit 0
}

# Compute problem name and extension.
#
if { $my_argc == 1 } {
    set argument [lindex $my_argv 0]
} else {

    # Read message header.
    #
    set received_ch [open $received_file r]
    read_header $received_ch
    close $received_ch

    # Get problem.
    #
    if {    [catch { llength $message_subject }] \
         || [llength $message_subject] != 2 \
	 || [lindex $message_subject 0] != "submit" } {
	subject_error "badly formatted"
    }
    set argument [lindex $message_subject 1]
}
set PROBLEM [file rootname $argument]
set EXTENSION [file extension $argument]

# Check legality of problem name and optional extension.
#
if {    $PROBLEM == "" \
     || [regexp {\.} $PROBLEM] \
     || [regexp {/}  $PROBLEM] \
     || [regexp {^-} $PROBLEM]  } {
    subject_error "illegal problem name `$PROBLEM' in"
}
if { $EXTENSION != "" \
     && ! [lcontain $allowed_extensions $EXTENSION] } {
    subject_error "unallowed extension `$EXTENSION'\
      (should be one of $allowed_extensions) in"
} elseif { [regexp {/} $EXTENSION] } {
    # should never happen
    error "/ in extension `$EXTENSION'"
}

# Check for existence of problem solution directory.
#
set s_d $solutions_directory/$PROBLEM
if { ! [file isdirectory $s_d] } {
    subject_error "unallowed problem name `$PROBLEM' in"
}

# Global variable that is list of all files linked
# into the submission directory by autojudge.  Various
# output files depend on all these (must not be older
# than any of these).
#
set linked_files ""

# Function that links files according to the data that
# has the format of a problem_link_files global variable
# value: see hpcm_judging.rc.  Name describes the data
# for error message purposes.  Optional is 1 if links
# are options, 0 if they are required.  Exists is 1 if
# linking is suppressed when the target exists (it CAN
# be a dangling link), and 0 otherwise.  Appends files
# linked to linked_files above.
#
# The global s_d names the problem solution directory.
#
proc execute_links \
	{ data name { optional 0 } { exists 0 } } {

    global s_d linked_files

    if { [catch { llength $data }] } {
	error "bad $name, not a TCL list: $data"
    }

    foreach item $data {
	if { [catch { set length [llength $item] }] } {
	    error "bad $name element, not a TCL list:\
	           $item"
	}
	if { $length == 0 } {
	    error "bad $name element, empty TCL list"
	} elseif { $length == 1 } {
	    set source_list $item
	    set target $item
	} else {
	    set source_list [lrange $item 1 end]
	    set target [lindex $item 0]
	}
	set source ""
	foreach file $source_list {
	    if { [file exists $s_d/$file] } {
		set source $s_d/$file
		break
	    }
	}
	if { $target == "" || [regexp {/} $target ] } {
	    error "Bad $name target in $item"
	}

	if { [catch { set type [file type $target] }] \
	            } {
	    set type none
	} elseif { $type == "link" \
		   && \
		   $source != "" \
		   && \
		   [file readlink $target] \
			 == $source } {
	    set type done
	}

	if { $type == "link" && ! $exists } {
	    puts "Deleting $target"
	    file delete -force $target
	    set type none
	}

	if { $type != "none" } {
	    if { ! [lcontain $linked_files $target] } {
		lappend linked_files $target
	    }
	} elseif { $source == "" } {
	    if { ! $optional } {
	        error "no source files exist for\
		       $item in $name"
	    }
	} else {
	    set tail [file tail $source]
	    if { $tail == $target } {
		puts "Linking $target"
	    } else {
		puts "Linking $tail to\
		      $target"
	    }
	    link_file $source $target
	    lappend linked_files $target
	}
    }
}

# Switch that is use by execute_makes to indicate that
# the s_d is locked.  If set at the end of the sequence
# of execute_makes calls, the directory must be
# unlocked.
#
set s_d_is_locked 0

# Function that makes files according to the data that
# has the format of a problem_make_files global variable
# value: see hpcm_judging.rc.  Name describes the data
# for error message purposes.
#
# The global s_d names the problem solution directory.
#
proc execute_makes { data name } {

    global s_d s_d_is_locked

    if { [catch {llength $data}] } {
	error "$name is not a TCL list: $data"
    }

    # If we need to lock the solution directory, we
    # first check to see if we can prove there is
    # nothing to do, as we do not want to lock the
    # solution directory unnecessarily.  First_target is
    # the first file that will be made if any are to be
    # made.
    #
    if { ! $s_d_is_locked } {

	# Loop through all instructions.
	#
	set first_target ""
	foreach instruction $data {
	    if { [catch {llength $instruction}] } {
		error "$name instruction is not a TCL\
		       list: $instruction"
	    }

	    # If a source file in the instruction does
	    # not exist, ignore instruction.
	    #
	    set sources [lrange $instruction 2 end]
	    set non_existant_input_found 0
	    foreach source $sources {
		if { ! [file exists $s_d/$source] } {
		    set non_existant_input_found 1
		    break
		}
	    }
	    if { $non_existant_input_found } continue

	    # If target file of the instruction does
	    # not exist, it must be made: end loop.
	    #
	    set target [lindex $instruction 0]
	    if { ! [file exists $s_d/$target] } {
		set first_target $target
		break
	    }

	    # If any source file is more recent than the
	    # target, the target must be made: end loop.
	    #
	    set mtime [file mtime $s_d/$target]
	    foreach source $sources {
		if {   [file mtime $s_d/$source] \
		     > $mtime } {
		    set first_target $target
		    break
		}
	    }
	    if { $first_target != "" } break
	}

	# If there is nothing to do, exit procedure.
	#
	if { $first_target == "" } return

	# Try repeatedly to lock the solution directory,
	# but if this fails after a while, just give up
	# and call error.
	#
	set seconds 0
	set limit 120
	set sleep 2
	set step 5
	# puts's are at step * sleep second intervals
	#
	while { "yes" } {
	    if { [dispatch_lock $s_d] } {
	    	break
	    } elseif { $seconds >= $limit } {
		error "CANNOT LOCK $s_d:\
		       giving up on making\
		       $first_target"
	    } elseif { $seconds == 0 } {
	    	# do nothing
	    } elseif { $seconds == $step * $sleep } {
	        puts "Waiting for $s_d lock"
	    } elseif { $seconds \
		       % ( $step * $sleep ) == 0 } {
	        puts "....will wait\
		      [expr $limit - $seconds]\
		      more seconds"
	    }
	    sleep $sleep
	    incr seconds $sleep
	}
	puts "Locked $s_d"
	set s_d_is_locked 1
    }

    # Execute each instruction if neccssary.
    #
    foreach instruction $data {

    	# Note: we may not have done this check above.
	#
	if { [catch {llength $instruction}] } {
	    error "$name instruction is not a TCL list:\
	           $instruction"
	}

	# If a source file in the instruction does
	# not exist, ignore instruction.
	#
	set sources [lrange $instruction 2 end]
	set non_existant_input_found 0
	foreach source $sources {
	    if { ! [file exists $s_d/$source] } {
		set non_existant_input_found 1
		break
	    }
	}
	if { $non_existant_input_found } continue

	set target [lindex $instruction 0]
	if { [file exists $s_d/$target] } {

	    # If target file exists and no source file
	    # is more recent, skip instruction.
	    #
	    set mtime [file mtime $s_d/$target]
	    set skip 1
	    foreach source $sources {
		if {   [file mtime $s_d/$source] \
		     > $mtime } {
		    set skip 0
		    break
		}
	    }
	    if { $skip } continue
	}

	if { [llength $instruction] == 1 } {
	    set command "make $target"
	} else {
	    set command [lindex $instruction 1]
	}
	puts "Making $target by executing $command"
	exec_in_directory $s_d $command >&@ stdout
    }
}

# Source any PROBLEM.rc file.
#
execute_links $PROBLEM.rc \
              "initial problem .rc file linking" 1
if { [file exists $PROBLEM.rc] } {
    source_file $PROBLEM.rc
}

# Force scoring mode if there was a -manual option.
#
if { $manual } {
    set scoring_mode manual
}

# List of all files extracted by extractmail.
#
set extracted_files ""

# Extract submitted files.  If error, if SYSTEM ERROR
# call `error' function and otherwise reply to submit-
# ter.  Compute list of extracted files in `extracted_
# files'.
#
if { [catch { exec extractmail } extractout] } {
    if { [regexp {SYSTEM ERROR} $extractout] } {
        error "System error during\
	       extractmail:\n\n$extractout"
    } else {

	# Create a reply file complaining of an extrac-
	# tion error, and email this reply to the
	# submitter.  Include the submission email in
	# the reply.
	#
	reply {LINE "ERROR during file extraction:" } \
	      BLANK \
	      [list LINES $extractout] \
	      BLANK \
	      { LINE "THIS SUBMISSION (see below)\
	              IGNORED" } \
	      { LINE "YOU MUST RESUBMIT" } \
	      BLANK \
	      { BAR "this message replies to:" } \
	      RECEIVED-FULL-HEADER \
	      BLANK \
	      RECEIVED-BODY

	puts $extractout
	puts "Reply indicating error has been emailed\
	      to submitter."

	exit 0
    }
} else {
    puts $extractout
    foreach line [split $extractout "\n"] {
        if { [regexp {^Extracted } $line] } {
	    lappend extracted_files [lindex $line 1]
	}
    }
}

# Execute problem_make_files instructions if any.
#
if { [info exists problem_make_files] } {
    execute_makes $problem_make_files \
    		  "problem_make_files value"
}

# Make list of names F such that F.in or F.jin exist.
# Do not list duplicate names.
# Do not list $PROBLEM.in if any other names found,
# as it should be just a link to another .in name.
#
set input_names ""
set problem_in_found 0
foreach name [glob -nocomplain "$s_d/*"] {
    set tail [file tail $name]
    if { $tail == "$PROBLEM.in" } {
        set problem_in_found 1
	continue
    }

    set ext [file extension $tail]
    set root [file rootname $tail]
    if { ! [lcontain  {.in .jin} $ext] } continue
    if { [lcontain $input_names $root] } continue
    lappend input_names $root
}
if {    $problem_in_found \
     && [llength $input_names] == 0 } {
    lappend input_names $PROBLEM
}

# Make .in files from .jin files.
#
# If Scoring_Filter exists, make .fout files from .out
# files, .ftest files from .test files, .jfout files
# from .fout files, .jftest files from .ftest files.
#
# If Scoring Filter does not exist, make .jout files
# from .out files and .jtest files from .test files>
#
set scoring_filter_exists \
    [file exists $s_d/Scoring_Filter]
set instructions ""
foreach name $input_names {
    lappend instructions \
            "$name.in {jfilter $name.jin $name.in}\
	              $name.jin"
    if { $scoring_filter_exists } {
	lappend instructions \
		"$name.fout\
		 {Scoring_Filter <$name.out\
		                 >$name.fout}\
	         Scoring_Filter $name.out" \
		"$name.ftest\
		 {Scoring_Filter <$name.test\
		                 >$name.ftest}\
	         Scoring_Filter $name.test" \
		"$name.jfout\
		 {jfilter $name.jin $name.fout\
		          $name.jfout}\
		 $name.jin $name.fout" \
		"$name.jftest\
		 {jfilter $name.jin $name.ftest\
		          $name.jftest}\
		 $name.jin $name.ftest"
    } else {
	lappend instructions \
		"$name.jout\
		 {jfilter $name.jin $name.out\
		          $name.jout}\
		 $name.jin $name.out" \
		"$name.jtest\
		 {jfilter $name.jin $name.test\
		          $name.jtest}\
		 $name.jin $name.test"
    }
}
execute_makes $instructions \
	      "autojudge generated instructions"

if { $s_d_is_locked } {
    dispatch_unlock $s_d
    puts "Unlocked $s_d"
}

# Execute problem_link_files instructions if any.
# Otherwise execute default.
#
if { [info exists problem_link_files] } {
    execute_links $problem_link_files \
    		  "problem_link_files value"
}
# Execute problem_optional_link_files instructions if
# any.
#
if { [info exists problem_optional_link_files] } {
    execute_links $problem_optional_link_files \
    		  "problem_optional_link_files value" 1
}

# Link everything that does not exist that we need.
# These links are not optional, but should not be done
# if target exists.
#
set instructions ""
lappend instructions \
	" Makefile Makefile$EXTENSION Makefile "
foreach name $input_names {
    set jin_exists [file exists $s_d/$name.jin]
    lappend instructions \
            $name.in \
	    " $name.test $name.out $name.test "
    if { $jin_exists } {
	lappend instructions $name.jin
    }
    if { $scoring_filter_exists } {
	lappend instructions \
	    Scoring_Filter \
	    " $name.ftest $name.fout $name.ftest "
	if { $jin_exists } {
	    lappend instructions \
		" $name.jftest $name.jfout\
		                $name.jftest "
	}
    } elseif { $jin_exists } {
	lappend instructions \
	    " $name.jtest $name.jout $name.jtest "
    }
}
execute_links $instructions \
              "autojudge generated required link\
	       instructions" \
	      0 1

# Function to send reply to user containing new auto
# score.
#
proc auto_score_reply { score } {

    global needs_reply_flag_file \
	   auto_score manual_score proposed_score \
	   submitted_problem submitted_extension \
	   PROBLEM EXTENSION

    set auto_score $score
    set manual_score None
    set proposed_score None
    set submitted_problem $PROBLEM
    set submitted_extension $EXTENSION
    set return_commands [compose_response]

    if { [lcontain $return_commands EDIT] } {
	error "EDIT response instruction executed"
    }

    send_response $return_commands

    if { [lcontain $return_commands FINAL] } {
	puts "Emailed final auto-score:\
	      \    $auto_score"
    } elseif { [lcontain $return_commands NOT-FINAL] } {
	set_flag $needs_reply_flag_file
	puts "Emailed auto-score (review later):\
	      \    $auto_score"
    } elseif { [lcontain $return_commands NO-REPLY] } {
	set_flag $needs_reply_flag_file
	puts "Auto-score (NOT emailed):\
	      \    $auto_score"
    } else {
        error "bad compose_response return value"
    }
}

# should_be_made [-nodelete] file_list1 file_list2 
#
# If any file_list1 file is older than any file_list2
# file, and all file_list2 files exist, delete any
# file_list1 files that exist and return `yes'.  If some
# file_list1 file does not exist, and all file_list2
# files exist, delete any file_list1 files that do exist
# and return `yes'.  Else return `no'.  If -nodelete
# option given, suppress deleting of files.
#
#
proc should_be_made { args } {

    set nodelete \
        [expr { [lindex $args 0] == "-nodelete" }]
    set file_list1 [lindex $args end-1]
    set file_list2 [lindex $args end]

    # Set mtime1 to the oldest of the file_list1
    # mtimes, or 0 if some file_list1 file does not
    # exist.
    #
    set mtime1 0
    foreach file1 $file_list1 {
	if { [file exists $file1] } {
	    set mt [file mtime $file1]
	    if { $mt < 0 } { error "negative mtime" }
	    if { $mtime1 == 0 || $mtime1 > $mt } {
	    	set mtime1 $mt
	    }
	} else {
	    set mtime1 0
	    break
	}
    }
    # Set mtime2 to the newest of the file_list2
    # mtimes, or 0 if any file_list2 file does not
    # exist.
    #
    set mtime2 0
    foreach file2 $file_list2 {
	if { [file exists $file2] } {
	    set mt [file mtime $file2]
	    if { $mt < 0 } { error "negative mtime" }
	    if { $mtime2 < $mt } {
	    	set mtime2 $mt
	    }
	} else {
	    set mtime2 0
	    break
	}
    }

    # If mtime1 < mtime2 we need to make file_list1
    # from file_list2
    #
    if { $mtime1 < $mtime2 } {
        if { ! $nodelete } {
	    foreach file1 $file_list1 {
		if { [file exists $file1] } {
		    puts "Deleting out-of-date $file1"
		    file delete -force $file1
		}
	    }
	}
	return yes
    } else {
        return no
    }
}

# If necessary compile submitted file to produce
# binary.  If this fails, announce `Syntax Error'
# as the score.
#
if { [should_be_made \
         [list $PROBLEM $PROBLEM.cerr] \
	 [concat $linked_files \
	 	 $extracted_files]] } {

    puts "Making $PROBLEM"
    catch { make_file $PROBLEM $PROBLEM.cerr }

    # Print any non-empty .cerr file.
    #
    if { [file exists $PROBLEM.cerr] \
	 && [file size $PROBLEM.cerr] > 0 } {
	puts ""
	if { [file executable $PROBLEM] } {
	    puts "========== COMPILER WARNINGS\
	          ($PROBLEM.cerr) =========="
	} else {
	    puts "========== COMPILER ERRORS\
	          ($PROBLEM.cerr) =========="
	}
	put_file $PROBLEM.cerr stdout 10
	puts "============================="
	puts ""
    }

    # If no executable binary produced, record and
    # send `Syntax Error' reply.
    #
    if { ! [file executable $PROBLEM] } {

	puts "No executable `$PROBLEM' file produced"

	if { [file exists $auto_score_file] } {
	    file delete -force $auto_score_file
	}
	write_file $auto_score_file "Syntax Error"
	set_flag $score_flag_file
	auto_score_reply "Syntax Error"
	exit 0
    }
}

# Make .out and .fout files as necessary.
#
foreach name $input_names {
    if { [should_be_made \
	     [list $name.out $name.err] \
	     [concat [list $name] \
		     $linked_files \
		     $extracted_files]] \
	 && [file executable $PROBLEM] } {

	if { $name != $PROBLEM } {
	    puts "Linking $name.in to $PROBLEM.in"
	    file delete -force $name.in
	    link_file $name.in $PROBLEM.in
	}
	file delete -force \
	     $PROBLEM.out $PROBLEM.err $PROBLEM.fout
	puts "Making $PROBLEM.out and $PROBLEM.err"
	catch { make_file $PROBLEM.out $PROBLEM.err }

	# Remove any a+x on the current directory as a
	# `best effort' security measure in the face of
	# the JAVA bug that requires .. to be a+x.
	#
	deny_access "."

	if { [should_be_made \
		 [list $PROBLEM.fout] \
		 [concat \
		    [list $PROBLEM.out $PROBLEM.in \
			  $scoring_filter_file] \
		    $linked_files \
		    $extracted_files]] \
	     && [file size $PROBLEM.out] > 0 } {

	    puts "Making $PROBLEM.fout"
	    exec $scoring_filter_file \
		 < $PROBLEM.out > $PROBLEM.fout
	}

	if { $name != $PROBLEM } {
	    foreach ext {out err fout} {
		if { [file exists $PROBLEM.$ext] } {
		    puts "Renaming $PROBLEM.$ext to\
			  $name.$ext"
		    file delete -force -- $name.$ext
		    file rename $PROBLEM.$ext $name.$ext
		}
	    }
	}

	# Print any non-empty .err file.
	#
	if {    [file exists $name.err] \
	     && [file size $name.err] > 0 } {
	    puts ""
	    puts "========== ERRORS ($name.err)\
		  =========="
	    put_file $name.err stdout 10
	    puts "============================="
	    puts ""
	} elseif { ! [file exists $name.out] } {
	    puts "No `$name.out' file produced"
	}
    }
}

# Make .jout or .jfout files as appropriate.
#
foreach name $input_names {
    if { [file exists $scoring_filter_file] } {
	if { [should_be_made \
		 [list $name.jfout] \
		 [list $name.jin $name.fout]] } {

	    puts "Making $name.jfout"
	    exec jfilter $name.in $name.fout $name.jfout
	}
    } else {
	if { [should_be_made \
		 [list $name.jout] \
		 [list $name.out $name.jin]] } {

	    puts "Making $name.jout"
	    exec jfilter $name.jin $name.out $name.jout
	}
    }
}

# Make $auto_score_file if necessary.
#
set file_list {}
set err_exists 0
foreach name $input_names {
    foreach ext {err out test fout ftest \
                 jout jtest jfout jftest} {
	if { [file exists $name.$ext] } {
	    lappend file_list $name.$ext
	}
    }
    if { [file exists $name.err]} {
        set err_exists 1
    }
}
if {    $err_exists \
     && [should_be_made \
            [list $auto_score_file] \
	    $file_list] } {

    exec autoscore $input_names 2>@ stderr
}

# Make $reply_file if necessary.
#
if { [should_be_made -nodelete \
         [list $reply_file] \
	 [concat [list $auto_score_file] \
	 	 $linked_files]] } {

    auto_score_reply [read_file $auto_score_file]
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
