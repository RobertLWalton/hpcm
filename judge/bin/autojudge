#!/bin/sh
#
# Compute all the files needed in a program submission
# directory in order to score a submission.
#
# File:		autojudge
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Fri Feb  7 11:49:42 EST 2003
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2003/02/07 18:27:30 $
#   $RCSfile: autojudge,v $
#   $Revision: 1.82 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
source $lib_directory/scoring_common.tcl
catch {

set document "
cd submission_directory
autojudge \[-manual\] \[problem\[.extension\]\]

    Given the submission directory as the current dir-
    ectory, and given that the submission directory
    contains the file `$received_file', this program
    makes everything needed to compute the score file,
    `$auto_score_file', and then automatically computes\
    	that
    file.  This program may report the score to the sub-
    mitter by creating and sending `$reply_file' as
    specified by the `scoring_mode' global variable.

    If the -manual program option is given, it sets the
    scoring_mode to `manual' while this program is run-
    ning.  This suppresses sending email to the submit-
    ter.

    If the problem name and optional extension are not
    given as an argument, they are extracted from the

    	Subject: problem\[.extension\]

    field of the message in the $received_file file.
    Here `problem' names the problem and the solution
    binary, and is the basename of the .in, .out, .test,
    .fout, .ftest, .cerr, .err, and .score files.  If
    `extension' is given, it tells the language being
    used, and must be a member of the `allowed_exten-
    sions' global variable value, which by default is:
    
    	$allowed_extensions

    In this document and in the `$files_file' file\
    	mentioned
    below, the words `PROBLEM' and `EXTENSION' are used
    to denote the problem name and extension as given in
    an argument or `Subject:' field.  Also, the solution
    directory below is the problem directory within the
    solutions directory, i.e., the directory with name:

    	\$solutions_directory/PROBLEM

    More specifically, this program makes the following
    in order:

      * `PROBLEM.rc' file, if it exists, and if it
        exists, it is sourced
      * `$files_file' file, if it exists
      . any -SOLUTION-MAKE- files listed in any
	`$files_file' file; note these files are in
	the solution directory
      . submitted files made by calling extractmail
      * any -LINK- or -OPTIONAL-LINK- files listed in
	any `$files_file' file; if there is no\
	  	`$files_file' file,
	the -LINK- files are by default:
	     $make_file, PROBLEM.in, PROBLEM.test
	and the -OPTIONAL-LINK- files are by default:
	     PROBLEM.ftest, $scoring_filter_file
      . the program binary file `PROBLEM' and the
	compiler error file PROBLEM.cerr
      . the program standard output file PROBLEM.out
	and the program standard error file PROBLEM.err
      . the filtered output file PROBLEM.fout, if the
	$scoring_filter_file file exists
      . the PROBLEM.score file made by calling autoscore
      . the $auto_score_file file made by ditto
      . the $reply_file file, sometimes

    Here files marked with * are linked into the current
    submission directory from the problem's solution
    directory.  This program checks any other file that
    already exists to see if it is younger than the pre-
    vious files upon which it depends (starting with
    submitted files being younger than the\
    	$received_file
    file), and if a file is younger and hence up to
    date, this program skips remaking the file.  Inabil-
    ity to make a program binary or a .out file, or an
    empty .out file, can cause $auto_score_file and\
    	maybe
    $reply_file to be generated early.

    In general, this program may detect two kinds of
    errors: system errors and submitter errors.  A
    system error means the judging files are incorrectly
    set up, and a submitter error means the submitter
    sent the wrong information.  On a system error, this
    program logs the error in an error log file in the
    current directory and prints information about the
    error to the standard error output.  On a submitter
    error, this program creates a $reply_file file that
    contains a description of the error and sends this
    to the submitter as the final word on the submis-
    sion.  In either case this program terminates after
    reporting the error.

    At its beginning, this program verifies the exis-
    tence of a solution directory for the problem and
    symbolically links the `PROBLEM.rc' and\
    		`$files_file'
    files from this directory into the current\
    		directory,
    if those files exist.  If the `PROBLEM.rc' file\
    exists, it is sourced.  If the `$files_file' file\
    		does
    not exist, it is given the default value:

        -LINK-
	    { $make_file $make_file.EXTENSION\
	    	$make_file }
	    PROBLEM.in
	    { PROBLEM.test PROBLEM.out PROBLEM.test }
	-OPTIONAL-LINK-
	    $scoring_filter_file
	    { PROBLEM.ftest PROBLEM.fout PROBLEM.ftest }

    The `$files_file' file is interpreted as a TCL list
    (with list elements separated by spaces, tabs, or
    new lines) whose elements are special symbols, file
    names, and { } bracketed sublists.  The special
    symbols consist of upper case letters and the `-'
    character, and begin and end with `-'.  All list
    items following a special symbol S but before the
    next special symbol are governed by S.  This program
    understands the following three special symbols:

    	-SOLUTION-MAKE-	The list items governed by
			-SOLUTION-MAKE- are the names of
			files that are to be `made' in
			the solution directory if they
			do not exist.
    
    	-LINK-		The list items governed by
			-LINK- name files that are to be
			linked from the solution direc-
			tory to the current directory.

    	-OPTIONAL-LINK-	The list items governed by
			-OPTIONAL-LINK- name files that
			are to be linked from the solu-
			tion directory to the current
			directory if they exist in the
			solution directory.

    List items governed by other special symbols are
    ignored by this program.  There is an implied
    `-REQUIRED-' before the beginning of the list, that
    governs list items appearing before any special
    symbol in the list.  The same special symbol can
    appear multiple times in the list.  The same file
    name can appear several times in the list: e.g.,
    a file name can appear governed by -SOLUTION-MAKE-
    and then again governed by -LINK-.

    Each item governed by one of the three special
    symbols listed above is either a file name or a list
    of file names.  In any file name, the basename
    `PROBLEM' is replaced by the problem name and the
    extension `.EXTENSION' is replaced by the submission
    extension.

    -LINK- and -OPTIONAL-LINK- items may be a { } brac-
    ketted list of file names.  In this case, the first
    file name F is the file name in the current direc-
    tory which is to be created by the link, and the
    rest of the file names name files in the solution
    directory that may be linked to F.  The first of
    these solution directory files that exists is
    chosen.  If F is an already existing link in the
    current directory, it is relinked to the chosen
    solution directory file, or F is deleted if there
    is no chosen file because all solution directory
    files in the list of files that can be linked to F
    do not exist.  If F does not exist, it is linked to
    the chosen file if there is one.  Otherwise nothing
    is done, so that if F is a file proper, and not a
    link, it will be left alone.

    A -LINK- or -OPTIONAL-LINK- item that is a single
    file name F is equivalent to the item `{ F F }'.

    The only difference between -LINK- and -OPTIONAL-
    LINK- is that for -LINK- it is an error if
    after taking the above actions the file F being
    created in the local directory does not exist;
    whereas for -OPTIONAL-LINK- it is no error at all
    in this case.

    In the above, a dangling link does not count as an
    existing file.  Thus if the solution directory con-
    tains a dangling link F2, i.e., a link to an non-
    existent file, then F2 does not exist.  Also note
    that by `link' we mean `symbolic link'.

    If no extension is given to this program with the
    problem name, any file name whose extension is
    .`EXTENSION' is treated as naming a file that does
    not exist and cannot be created.  It is an error to
    try to create such a file, but it is not an error to
    try to use such a file if it is not an error for the
    file not to exist.

    Thus in the default value of the `$files_file' file
    given above, the file named $make_file in the cur-
    rent directory is linked to the file named
    `$make_file.EXTENSION' if an extension was given
    with the problem name to this program and if the
    indicated file exists in the solution directory.
    Otherwise the file is linked to $make_file in the
    solution directory, if that file exists.  Otherwise
    there is an error, as $make_file is -LINK- and not
    -OPTIONAL-LINK-.

    In linking any `$files_file' file from the solution
    directory, this program behaves as if there were
    an initial `$files_file' file value of:

    	-OPTIONAL-LINK-
	    { $files_file $files_file.EXTENSION\
	      $files_file }

    Thus in the solution directory,\
    	$files_file.EXTENSION
    is preferred over `$files_file'.

    It is an error if the solution directory has no
    `$files_file' file but does have `$files_file.*'\
    	files,
    none of which match the extension given by the sub-
    mitter.

    All errors involving linking are submitter errors if
    there might be some extension that the submitter
    could specify which would make the submission cor-
    rect.  Otherwise the errors are system errors.

    After linking any `$files_file' file from the\
    	solution
    directory, this program makes any files governed
    by -SOLUTION-MAKE- in the `$files_file' file.  If
    there is such a file F listed, and it does not al-
    ready exist in the solution directory, this program
    executes `make F' in the solution directory.  During
    this process this program locks the solution direc-
    tory with a $dispatch_pid_file file.  Note that
    `PROBLEM' or `EXTENSION' are not substituted for in
    -SOLUTION-MAKE- file names; but the same effect can
    be had by having different `$files_file.EXTENSION'\
    	files
    for different extensions.

    Next this program calls `extractmail' to extract the
    submitted files from the program.  Errors in this
    extraction are classified as system errors if ex-
    tractmail outputs the phrase `SYSTEM ERROR' and
    submitter errors otherwise.
 
    If the extraction has no errors, this program sym-
    bolically links solution directory files into the
    current directory, according to instructions encoded
    by the -LINK- and -OPTIONAL-LINK- special symbols in
    the `$files_file' file or the default value given\
    	above
    for this file.  Note that a file may be listed as
    both -OPTIONAL- (for extractmail) and -LINK-: if
    submitted the submitted version will be used, and if
    not submitted, the solution directory version will
    be used.  Also note that a file listed as -LINK- or
    -OPTIONAL-LINK- may be made as a consequence of a
    -SOLUTION-MAKE- item (which may or may not directly
    name the file to be linked).

    Next this program makes the program binary by using
    the $make_file.  Any compiler error messages are
    captured in a .cerr file.  If no executable binary
    is made, this program writes `Syntax Error' into the
    $auto_score_file file, and skips to the end of this
    program where a $reply_file file containing the auto
    score may be created and sent to the user.
 
    If an executable binary file was made, this program
    makes a .out output file by using the $make_file,
    and captures any error output in a .err file.  If
    the .out file exists and is non-empty, and if the
    $scoring_filter_file file exists, this program then
    runs

    	$scoring_filter_file <PROBLEM.out >PROBLEM.fout

    to make the .fout file.  It is a system error if the
    $scoring_filter_file program exits with a non-zero\
    	UNIX
    exit code or writes the standard error output, or if
    no .ftest file exists in this situation.

    For purposes of computing file dependencies, the
    files PROBLEM, PROBLEM.out, and PROBLEM.fout are all
    assumed to depend upon all the extracted and linked
    files.

    Then this program runs `autoscore' to produce a
    .score file and an automatic score in the\
        $auto_score_file
    file.  Any .score file will be not produced (and
    even deleted if it exists) if the score can be
    determined without it, i.e., if the score is deter-
    mined by the .err file or if the .out file does not
    exist or is empty.

    Lastly, this program may create a `$reply_file' file
    and send it as email to the submitter.  It does this
    using instructions in the\
    	$response_instructions_file file
    if that exists (has been linked into the current
    directory), or uses a default value for this file
    otherwise.  This file (or its default value) con-
    tains instructions that format the reply for a given
    $auto_score_file value and a given value of the\
    	scoring_
    mode global variable.  The format of the response
    instructions is described in hpcm_judging.rc, where
    the default value for the\
        $response_instructions_file file
    is given.
    
    With default response instructions, this program
    sends a reply if the score is `Completely Correct'
    or the scoring_mode is `auto' or `auto+manual'.  If
    the mode is `auto' or the score is `Completely Cor-
    rect', the reply is final, and is stored in the
    $reply_file file.  Otherwise the reply is not final,
    and informs its receiver that the score is prelim-
    inary and will be manually reviewed and possibly
    changed.  When the reply is not final, this program
    does not create a $reply_file file, even when it
    sends a reply (the reply is recorded in any case in
    the $reply_history_file file).  The absence of a
    $reply_file file signals that the final reply has
    not been given to the submitter, and further action
    using the `manualreply' program is necessary to gen-
    erate a final reply.

    This program prints information about its progress.
 
    Unless this program creates a $reply_file file that
    is intended to be the final reply to the submitter
    (e.g., because the score is `Completely Correct' or
    the scoring mode is `auto'), this program sets the
    `needs reply' flag (the $needs_reply_flag_file\
    			file in
    the flag directory).  This signals other programs
    (e.g. tracker) that they should search for submis-
    sion directories for which the manualreply program
    should be called.

    If this program (because of a `Syntax Error') or the
    `autoscore' program writes the $auto_score_file\
    	file,
    the program will set the score flag (the flag direc-
    tory $score_flag_file file), to signal that any\
	score-
    boards need to be recomputed.

    Problem names that contain `/' or `.' or begin with
    `-' or have no solution directory are illegal, and
    are submitter errors.  Similarly extension names
    not listed in the `allowed_extensions' global vari-
    able are unallowed and are submitter errors, as are
    misformatted $received_file file `Subject:' fields.
    It is a system error if the `$received_file' file is
    not readable, if a `$files_file' file is\
    	misformatted, or
    if `extractmail' returns a system error.  It is a
    system error if an existing\
    	$response_instructions_file
    file is misformatted."

# Do not change argc or argv so error printouts will be
# correct.
#
set my_argc $argc
set my_argv $argv

# Process any -manual argument.
#
if { [lindex $my_argv 0] == "-manual" } {
    set scoring_mode manual
    set my_argv [lrange $my_argv 1 end]
    incr my_argc -1
}

# If too many arguments or -doc argument, print docu-
# mentation and exit.
#
if {    $my_argc > 1 \
     || [regexp {^-doc} [lindex $my_argv 0]] } {
    puts $document
    exit 1
}

# Handle submitter error in subject.
#
proc subject_error { what } {
    global message_subject
    reply "LINE {ERROR: $what\
	  	 `Subject:$message_subject'}" \
	  BLANK \
	  { LINE "THIS SUBMISSION (see below)\
	          IGNORED" } \
	  { LINE "You must resubmit with a legal\
	         message subject." } \
	  BLANK \
	  { BAR "this message replies to:" } \
	  RECEIVED-HEADER
    puts "SUBMISSION ERROR: $what in\
          `Subject:$message_subject'"
    exit 0
}

# Compute problem name and extension.
#
if { $my_argc == 1 } {
    set argument [lindex $my_argv 0]
} else {

    # Read message header.
    #
    set received_ch [open $received_file r]
    read_header $received_ch
    close $received_ch

    # Get problem.
    #
    if {    [catch { llength $message_subject }] \
         || [llength $message_subject] != 2 \
	 || [lindex $message_subject 0] != "submit" } {
	subject_error "badly formatted"
    }
    set argument [lindex $message_subject 1]
}
set problem [file rootname $argument]
set extension [file extension $argument]

# Check legality of problem name and optional extension.
#
if {    $problem == "" \
     || [regexp {\.} $problem] \
     || [regexp {/}  $problem] \
     || [regexp {^-} $problem]  } {
    subject_error "illegal problem name `$problem' in"
}
if { $extension != "" \
     && ! [lcontain $allowed_extensions $extension] } {
    subject_error "unallowed extension `$extension'\
      (should be one of $allowed_extensions) in"
} elseif { [regexp {/} $extension] } {
    # should never happen
    error "/ in extension `$extension'"
}

# Check for existence of problem solution directory.
#
set solution_directory $solutions_directory/$problem
if { ! [file isdirectory $solution_directory] } {
    subject_error "unallowed problem name `$problem' in"
}

# Function to return a list of extensions that make
# a file name exist.
#
proc find_exts { name } {
    set exts ""
    foreach f [glob -nocomplain $name.*] {
	if { [regexp "^$name\(\\.\[^/.\])\$" $f \
	             forget ext] \
	     && [file exists $name$ext] } {
	    lappend exts $ext
	}
    }
    return $exts
}

# Global variable that is list of all -LINK- or
# -OPTIONAL-LINK- files that actually exist.
#
set linked_files ""

# Function that links files according to the instruc-
# tions in the `files' argument, which is a list format-
# ted like a `$files_file' file value.
#
proc execute_links { files } {

    global problem extension solution_directory \
           linked_files

    if { [catch { llength $files }] } {
        error "$files_file file value is not formatted\
	       as a TCL list:\n    $files"
    }

    # Failure occurs if there is no source for a -LINK-
    # target, or if a target has a .EXTENSION but no
    # extension is given by the submitter.  If there is
    # no source for a -LINK- target, there may or may
    # not be a list of .EXTENSION values that would
    # cause there to be sources for all -LINK- targets.

    # True if a target has a .EXTENSION but no extension
    # is given by the submitter.
    #
    set needs_extension no
    
    # List of -LINK- targets that will fail regardless
    # of .EXTENSION value.
    #
    set hard_link_failures ""

    # List of -LINK- targets that fail because
    # .EXTENSION is wrong, and list of .EXTENSION values
    # that would permit ALL these targets to succeed.
    #
    set soft_link_failures ""
    set legal_exts not-set-yet

    set mode none
    foreach item $files {
        switch -- $item {
	    -LINK-		{
	        set mode link
	    }
	    -OPTIONAL-LINK-	{
	        set mode optional-link
	    }
	    default		{
		if { [regexp {^-[-A-Z]*-$} $item] } {
		    set mode none
		} elseif { $mode != "none" } {
		    if { [catch { llength $item }] } {
		        error "Bad $files_file -LINK-\
			       or -OPTIONAL-LINK- item:\
			       $item"
		    }
		    if { [llength $item] == 1 } {
		        set source_list $item
			set target $item
		    } else {
		        set source_list \
			    [lrange $item 1 end]
			set target [lindex $item 0]
		    }

		    set source ""
		    set exts ""
		    set sd $solution_directory
		    foreach name $source_list {
		    	set root \
			    [file rootname $name]
			set ext \
			    [file extension $name]
			if { $root == "PROBLEM" } {
			    set root $problem
			}
			if { $ext == ".EXTENSION" } {

			    set r $sd/$root
			    set n $r$extension
			    if { $extension == "" \
			         || ! [file exists $n] \
				 	} {
				set exts \
				    [concat \
				       $exts \
				       [find_exts \
					  $sd/$root]]
			    }

			    if { $extension == "" } {
			        continue
			    }
			    set ext $extension
			}
			if { [file exists \
			           $sd/$root$ext] } {
			    set source $sd/$root$ext
			    break
			}
		    }

		    set root \
			[file rootname $target]
		    set ext \
			[file extension $target]
		    if { $root == "PROBLEM" } {
			set root $problem
		    }
		    if { $ext == ".EXTENSION" } {
		        if { $extension == "" } {
			    set needs_extension yes
			    continue
			}
			set ext $extension
		    }
		    set target $root$ext
		    if { $target == "" \
		         || [regexp {/} $target ] } {
		        error "Bad $files_file -LINK-\
			       or -OPTIONAL-LINK-\
			       target in: $item"
		    }

		    if { [catch { \
			   set type \
			       [file type $target] \
				}] } {
			set type none
		    } elseif { $type == "link" \
			       && \
			       $source != "" \
			       && \
			       [file readlink $target] \
				     == $source } {
			set type done
		    }

		    if {    $type != "link" \
		         && $type != "none" } {
		        lappend linked_files $target
		    } elseif { $source == "" } {

		    	# No source found.

			if { $type == "link" } {
			    puts "Deleting $target"
			    file delete -force $target
			}

		        if { $mode == "link" } {

			    if { [llength $exts] > 0 } {
			        if { $legal_exts \
				     == "not-set-yet" \
				     	} {
				    set legal_exts $exts
				} else {
				    set legal_exts \
					[intersect \
					   $legal_exts \
					   $exts]
				}
				lappend \
				    soft_link_failures \
				    $target
			    } else {
				lappend \
				    hard_link_failures \
				    $target
			    }
			}
		    } else {

			if { $type == "link" } {
			    puts "Deleting $target"
			    file delete -force $target
			}

			set tail [file tail $source]
			if { $tail == $target } {
			    puts "Linking $target"
			} else {
			    puts "Linking $tail to\
				  $target"
			}
			link_file $source $target
		        lappend linked_files $target
		    }
		}
	    }
	}
    }

    if { [llength $hard_link_failures] > 0 } {
	error "No source files found for -LINK-\
	       targets: $hard_link_failures"
    } elseif { [llength $soft_link_failures] > 0 } {
        if { [llength $legal_exts] == 0 } {
	    error "No source files findable for all\
	    	   -LINK- targets: $soft_link_failures"
	} else {
	    subject_error \
		"unallowed extension (which should be
		one of $legal_exts) in"
	}
    } elseif { $needs_extension } {
	subject_error \
	    "missing extension where one is required in"
    }
}

# Link in any PROBLEM.rc or $files_file.
#
execute_links "
    -OPTIONAL-LINK-
	{ PROBLEM.rc rc.EXTENSION PROBLEM.rc }
	{ $files_file $files_file.EXTENSION
		      $files_file }
    "

# Source any PROBLEM.rc file.
#
source_file $problem.rc

# Read $files_file.
#
if { [file exists $files_file] } {
    set files [read_entire_file $files_file]
} else {
    set possibilities \
        [find_exts $solution_directory/$files_file]
    
    if { [llength $possibilities] > 0 } {
	subject_error \
	    "unallowed extension (should be one of\
	     $possibilities) in"
    }

    set files "
        -LINK-
	    { $make_file $make_file.EXTENSION\
	    	$make_file }
	    PROBLEM.in
	    { PROBLEM.test PROBLEM.out PROBLEM.test }
	-OPTIONAL-LINK-
	    $scoring_filter_file
	    { PROBLEM.ftest PROBLEM.fout PROBLEM.ftest }
	"
}

# Function to compute list of solution directory files
# to be made.
#
proc find_solution_make_files { files } {

    global solution_directory

    set solution_make_files ""
    set solution_make no
    foreach item $files {
	switch -- $item {
	    -SOLUTION-MAKE- {
		set solution_make yes
	    }
	    default {
		if { [regexp {^-[-A-Z]*-$} $item] } {
		    set solution_make no
		} elseif { $solution_make } {
		    set target $solution_directory/$item
		    if { ! [file exists $target] } {
			lappend solution_make_files \
				$item
		    }
		}
	    }
	}
    }

    return $solution_make_files
}

# Make -SOLUTION-MAKE- files.  Try repeatedly to lock
# the solution directory, but if this fails after a
# short while, just give up and print a comment.
#
set count 0
while { "yes" } {
    set solution_make_files \
        [find_solution_make_files $files]
    if { [llength $solution_make_files] == 0 } break

    if { [dispatch_lock $solution_directory] } {
	puts "Executing make $solution_make_files"
	exec_in_directory $solution_directory \
		          "make $solution_make_files" \
	     		  >&@ stdout
	dispatch_unlock $solution_directory
	break
    }

    incr count

    if { $count >= 10 } {
    	puts "CANNOT LOCK $solution_directory: giving\
	      up on make $solution_make_files"
	break
    }

    sleep 2
}

# List of all files extracted by extractmail.
#
set extracted_files ""

# Get submitted files.  If error, if SYSTEM ERROR call
# `error' function and otherwise reply to submitter.
# Compute list of extracted files in `extracted_files'.
#
if { [catch { exec extractmail } extractout] } {
    if { [regexp {SYSTEM ERROR} $extractout] } {
        error "System error during\
	       extractmail:\n\n$extractout"
    } else {

	# Create a reply file complaining of an extrac-
	# tion error, and email this reply to the
	# submitter.  Include the submission email in
	# the reply.
	#
	reply {LINE "ERROR during file extraction:" } \
	      BLANK \
	      [list LINES $extractout] \
	      BLANK \
	      { LINE "THIS SUBMISSION (see below)\
	              IGNORED" } \
	      { LINE "YOU MUST RESUBMIT" } \
	      BLANK \
	      { BAR "this message replies to:" } \
	      RECEIVED-HEADER \
	      BLANK \
	      RECEIVED-BODY

	puts $extractout
	puts "Reply indicating error emailed to\
	      submitter."

	exit 0
    }
} else {
    puts $extractout
    foreach line [split $extractout "\n"] {
        if { [regexp {^Extracted } $line] } {
	    lappend extracted_files [lindex $line 1]
	}
    }
}

# Process -LINK- and -OPTIONAL-LINK- instructions in
# $files_file (or its default value).
#
execute_links $files

# Function to send reply to user containing new auto
# score.
#
proc auto_score_reply { score } {

    global needs_reply_flag_file \
	   auto_score manual_score proposed_score \
	   submitted_problem submitted_extension \
	   problem extension

    set auto_score $score
    set manual_score None
    set proposed_score None
    set submitted_problem $problem
    set submitted_extension $extension
    set return_commands [compose_response]

    if { [lcontain $return_commands EDIT] } {
	error "EDIT response instruction executed"
    }

    send_response $return_commands

    if { [lcontain $return_commands FINAL] } {
	puts "Emailed final auto-score:\
	      \    $auto_score"
    } elseif { [lcontain $return_commands NOT-FINAL] } {
	set_flag $needs_reply_flag_file
	puts "Emailed auto-score (review later):\
	      \    $auto_score"
    } elseif { [lcontain $return_commands NO-REPLY] } {
	set_flag $needs_reply_flag_file
	puts "Auto-score (NOT emailed):\
	      \    $auto_score"
    } else {
        error "bad compose_response return value"
    }
}

# should_be_made file_list1 file_list2 
#
# If any file_list1 file is older than any file_list2
# file, and all file_list2 files exist, delete any
# file_list1 files that exist and return `yes'.  If no
# file_list1 files exist and all file_list2 files
# exist, return `yes'.  Else return `no'.
#
#
proc should_be_made { file_list1 file_list2 } {

    # Set mtime1 to the oldest of the file_list1
    # mtimes, or 0 if no file_list1 file exists.
    #
    set mtime1 0
    foreach file1 $file_list1 {
	if { [file exists $file1] } {
	    set mt [file mtime $file1]
	    if { $mt < 0 } { error "negative mtime" }
	    if { $mtime1 == 0 || $mtime1 > $mt } {
	    	set mtime1 $mt
	    }
	}
    }
    # Set mtime2 to the newest of the file_list2
    # mtimes, or 0 if any file_list2 file does not
    # exist.
    #
    set mtime2 0
    foreach file2 $file_list2 {
	if { [file exists $file2] } {
	    set mt [file mtime $file2]
	    if { $mt < 0 } { error "negative mtime" }
	    if { $mtime2 < $mt } {
	    	set mtime2 $mt
	    }
	} else {
	    set mtime2 0
	    break
	}
    }

    # If mtime1 < mtime2 we need to make file_list1
    # from file_list2
    #
    if { $mtime1 < $mtime2 } {
    	foreach file1 $file_list1 {
	    if { [file exists $file1] } {
	        puts "Deleting out-of-date $file1"
		file delete -force $file1
	    }
	}
	return yes
    } else {
        return no
    }
}

# If necessary compile submitted file to produce
# binary.  If this fails, announce `Syntax Error'
# as the score.
#
if { [should_be_made \
         [list $problem $problem.cerr] \
	 [concat $linked_files \
	 	 $extracted_files]] } {

    puts "Making $problem"
    catch { make_file $problem $problem.cerr }

    # Print any non-empty .cerr file.
    #
    if { [file exists $problem.cerr] \
	 && [file size $problem.cerr] > 0 } {
	puts ""
	if { [file executable $problem] } {
	    puts "========== COMPILER WARNINGS\
	          ($problem.cerr) =========="
	} else {
	    puts "========== COMPILER ERRORS\
	          ($problem.cerr) =========="
	}
	put_file $problem.cerr stdout 10
	puts "============================="
	puts ""
    }

    # If no executable binary produced, record and
    # send `Syntax Error' reply.
    #
    if { ! [file executable $problem] } {

	puts "No executable `$problem' file produced"

	if { [file exists $auto_score_file] } {
	    file delete -force $auto_score_file
	}
	write_file $auto_score_file "Syntax Error"
	set_flag $score_flag_file
	auto_score_reply "Syntax Error"
	exit 0
    }
}

# Make .out file if necessary.
#
if { [should_be_made \
         [list $problem.out $problem.err] \
	 [concat [list $problem] \
	 	 $linked_files \
	 	 $extracted_files]] \
     && [file executable $problem] } {

    puts "Making $problem.out"
    catch { make_file $problem.out $problem.err }

    # Remove any a+x on the current directory as a
    # `best effort' security measure in the face of
    # the JAVA bug that requires .. to be a+x.
    #
    deny_access "."

    # Print any non-empty .err file.
    #
    if { [file exists $problem.err] \
	 && [file size $problem.err] > 0 } {
	puts ""
	puts "========== ERRORS ($problem.err)\
	      =========="
	put_file $problem.err stdout 10
	puts "============================="
	puts ""
    } elseif { ! [file exists $problem.out] } {
	puts "No `$problem.out' file produced"
    }
}

# Make .fout file if appropriate.
#
if { [should_be_made \
         [list $problem.fout] \
	 [concat [list $problem.out \
	               $scoring_filter_file] \
	 	 $linked_files \
	 	 $extracted_files]] \
     && [file size $problem.out] > 0 } {

    puts "Making $problem.fout"
    exec $scoring_filter_file < $problem.out \
    			      > $problem.fout
}

# Make $auto_score_file if necessary.
#
if { [file exists $scoring_filter_file] } {

    set file_list [list $problem.ftest]

    if { [file exists $problem.fout] } {
	lappend file_list $problem.fout
    }
} else {
    set file_list [list $problem.test]

    if { [file exists $problem.out] } {
	lappend file_list $problem.out
    }
}
if { [file exists $problem.err] } {
    lappend file_list $problem.err
}

# If an attempt was made to make .out, then .err must
# exist for file_list must have at least 2 elements.
#
if { [llength $file_list] >= 2 \
     && [should_be_made \
            [list $auto_score_file] \
	    $file_list] } {

    exec autoscore $problem 2>@ stderr
}

# Make $reply_file if necessary.
#
if { [should_be_made \
         [list $reply_file] \
	 [concat [list $auto_score_file] \
	 	 $linked_files]] } {

    auto_score_reply [read_file $auto_score_file]
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
