#! /bin/sh -f
#
# Compute the judge.score file in a submission directory
#
# File:		judge
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Aug 16 06:43:27 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/16 11:24:46 $
#   $RCSfile: autojudge,v $
#   $Revision: 1.7 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

if { [info command signal] == "signal" } {
    signal error SIGINT
}

# Set program parameters that could be changed.
#
set allowed_extensions_default \
    ".c .cc .java"
set allowed_extensions_filename \
    "allowed_submission_extensions"
set score_file \
    "judge.score"

set document "
cd submission_directory; judge [-auto]

    Given the submission directory as the current dir-
    ectory, and given that the submission directory
    contains the submission file pppp.ee, where .ee is
    a legal extension such as .c, .cc, .java, etc.,
    this `judge' program computes the `judge.scores'
    file, first computing all intermediate files
    required, such as `pppp' and `pppp.out'.

    TBW"

if { $argc == 0 } {
    set autoscore no
} elseif { $argc == 1 && [lindex $argv 0] == "-auto" } {
    set autoscore yes
} else {
    puts $document
    exit 1
}

proc fatal_error { args } {
    puts "ERROR: [lindex $args 0]"
    set args [lreplace $args 0 0]
    foreach m $args {
    	puts "       $m"
    }
    exit 1
}

proc error_for_score_file { args } {
    global score_file
    set score_fd [open $score_file w]
    puts $score_fd [lindex $args 0]
    puts "ERROR: [lindex $args 0]"
    set args [lreplace $args 0 0]
    foreach m $args {
	puts $score_fd $m
    	puts "       $m"
    }
    close $score_fd
    exit 1
}

proc submission_error { args } {
    eval "error_for_score_file {Submission Error} $args"
}

set program_directory [file dirname $argv0]
set lib_directory "$program_directory/../lib"

set allowed_extensions_file \
    "$lib_directory/$allowed_extensions_filename"

if { [file readable $allowed_extensions_file] } {
    set allowed_extensions_fd \
        [open $allowed_extensions_file r]
    set allowed_extensions \
        [gets $allowed_extensions_fd]
    close $allowed_extensions_fd
    puts "Allowed extensions from ${allowed_extensions_file}:"
    puts "    $allowed extensions"
} else {
    set allowed_extensions $allowed_extensions_default
    puts "Default allowed extensions: $allowed extensions"
}

set score_file [glob -nocomplain "*.score"]

if { [llength $score_file] == 1 } {
    if ( ! [file readable $score_file] } {
        fatal_error "cannot read $score_file"
    }
    set score_fd [open $score_file r]
    set score [gets $score_fd]
    close $score_fd
    if { $score != "Defer Scoring" } {
        puts "Score file exists"
	exit 0
    }
    file delete -force $score_file
}
else if { [llength $score_file] > 1 } {
    fatal_error "too many score files: $score_file"
}

set submitted_file ""

foreach e $allowed_extensions {
    foreach f [glob -nocomplain "*.$e"] {
    	lappend submitted_file $f
    }
}

set submitted_program [file rootname $submitted_file]
set submitted_extension [file extension $submitted_file]

set solution_dir = "../$submitted_program"

if { ! [file isdirectory $solution_dir] } {
    [submission_error "unknown program name: $submitted_program]
}

if { ! [file readable Makefile] } {
    puts "Linking Makefile"
    exec ln -s $solution_dir/Makefile .
}

if { ! [file readable ${submitted_program}.in] } {
    puts "Linking ${submitted_program}.in"
    exec ln -s $solution_dir/${submitted_program}.in .
}

if { ! [file readable ${submitted_program}.test] } {
    puts "Linking ${submitted_program}.test to ${submitted_program}.out"
    exec ln -s $solution_dir/${submitted_program}.out \
               $solution_dir/${submitted_program}.test
}

if { ! [file readable $submitted_program] \
     || [file mtime $submitted_program \
           < [file mtime Makefile] \
     || [file mtime $submitted_program \
           < [file mtime $submitted_file] } {

    if { [file exists $submitted_program] } {
	puts "Deleting out-of-date $submitted_program"
    	file delete -force $submitted_program
    }
    puts "Making ${submitted_program}"
    if { [catch { exec make $submitted_program } \
                out] } {
        puts $out
        error_for_score_file "Syntax Error"
    }
    puts $out
    exec chmod a+x $submitted_program
}

if { ! [file readable "${submitted_program}.out" \
     || [file mtime "${submitted_program}.out"] \
           < [file mtime Makefile] \
     || [file mtime "${submitted_program}.out"] \
           < [file mtime $submitted_program] \
     || [file mtime "${submitted_program}.in"] \
           < [file mtime "${submitted_program}.in"] } {

    if { [file exists "${submitted_program}.out"] } {
	puts "Deleting out-of-date ${submitted_program}.out"
    	file delete -force "${submitted_program}.out"
    }

    if { [file exists "${submitted_program}.err"] } {
	puts "Deleting out-of-date ${submitted_program}.err"
    	file delete -force "${submitted_program}.err"
    }

    puts "Making ${submitted_program}.out"
    exec make "$submitted_program.out"
}

set score [exec autoscore $submitted_program]

if { $auto == "no" && $score != "Completely Correct" } {
    exec manualscore $submitted_program
}

exit 0
