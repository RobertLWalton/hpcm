#!/bin/sh -f
#
# Compute all the files needed in a program submission
# directory in order to score a submission.
#
# File:		autojudge
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Thu Sep  7 05:00:12 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/09/07 10:15:53 $
#   $RCSfile: autojudge,v $
#   $Revision: 1.21 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"
catch {

set document "
cd submission_directory; judge

    Given the submission directory as the current dir-
    ectory, and given that the submission directory
    contains the file `$received_file', this program
    makes everything needed to compute the score file,
    `$auto_score_file', and automatically computes that
    file.  Then this program may report the score to the
    submitter by creating and sending `$reply_file' as
    specified by the scoring mode.

    Specifically, this program makes the following in
    order:

	the submitted file by calling extractmail
	$make_file file
	$scoring_instructions_file file, if it exists
	.in solutin input file
	.test solutin output file
	the program binary (and .cerr file)
	the .out file (and .err file)
	the $auto_score_file file
	the $reply_file file, sometimes

    If any of these files exists, it checks to be sure
    they are not older than the previous files (starting
    with the submitted file not being older than the
    $received_file file), and remakes any of the above
    files that are out of date.  Errors in this process
    can cause $reply_file to be generated early.

    First, this program calls `extractmail' to extract
    the submitted file from the program.  This program
    then checks the legality of the submitted file name,
    and generates and sends `$reply_file' automatically
    if the name is illegal.
    
    If the file name is legal, this program symbolical-
    ly links the following solution directory files into
    the current directory:

    		$make_file
		$scoring_instructions_file if it exists
		.in solution input file
		.test solution output file

    The .test file is linked to the solution .out file
    if that exists, or the solution .test file
    otherwise.  If the solution .out file exists and
    is more recent than what the current directory .test
    file is linked to, the current directory .test file
    is relinked to the solution .out file.

    Next this program makes the program binary by using
    the $make_file.  If there is a compliler error, the
    error messages are captured in a .cerr file.  If
    no executable binary is made, this program writes
    `Syntax Error' into the $auto_score_file file, and
    skips to the end of this program where a $reply_file
    file containing the auto score may be created and
    sent to the user.

    If the binary file was made without error, this
    program makes a .out output file and a .err error
    file by using the $make_file.  Then this program
    runs `autoscore' to produce an automatic score in
    the $auto_score_file file.

    Lastly, this program may create a `$reply_file'
    and send it as email to the submitter.  It does this
    if the score is `Completely Correct' or the scoring_
    mode is `auto' or `auto+manual'.  If the mode is
    `auto+manual' and the score is not `Completely Cor-
    rect', the email informs its receiver that the score
    is preliminary and will be manually reviewed and
    possibly changed.
    
    If the score is to be manually reviewed, this prog-
    ram deletes any $reply_file containing a score taken
    from the $auto_score_file file, to signal that the
    final reply has not been given to the submitter,
    and further manual action is necessary to generate
    this reply.

    This program prints information about its progress.

    If something goes very wrong, such as finding that
    the `$received_file' file is not readable, this
    program creates an error log file in the current
    directory, prints information about the error to the
    standard error output, and exits with exit code 0."

if { $argc != 0 } {
    puts $document
    exit 1
}

set submitted_file [exec extractmail]

if { $submitted_file == "" } {
    exit 0
}

set submitted_program [file rootname $submitted_file]
set submitted_extension [file extension $submitted_file]

set program_solution \
    "$solutions_directory/$submitted_program"

proc illegal_filename_error { filename } {
    reply \
          "ERROR: submitted file has illegal name:\
	  $filename" \
	  ""  \
	  "THIS SUBMISSION (see below) IGNORED"  \
	  "YOU MUST RESUBMIT WITH A LEGAL FILENAME"
    puts "SUBMISSION ERROR: submitted file has illegal\
          name: $filename"
    exit 0
}

if { ! [file isdirectory $program_solution] } {
    illegal_filename_error $submitted_file
}

if { [lsearch -exact $allowed_extensions \
                     $submitted_extension] < 0 } {
    illegal_filename_error $submitted_file
}

if { ! [file readable $make_file] } {
    puts "Linking $make_file"
    link_file "$program_solution/$make_file"
}

set sif $scoring_instructions_file
if { ! [file readable $sif] \
     && [file exists "$program_solution/$sif"] } {
    puts "Linking $sif"
    link_file "$program_solution/$sif"
}

if { ! [file readable ${submitted_program}.in] } {
    puts "Linking ${submitted_program}.in"
    link_file \
         "$program_solution/${submitted_program}.in"
}

set solout ${program_solution}/${submitted_program}.out
set soltest ${program_solution}/${submitted_program}.test
if { ! [file readable ${submitted_program}.test] \
     || ( [file readable $solout] \
          && [file mtime ${submitted_program}.test] \
	     < [file mtime $solout] ) } {
    if { ! [catch { file type \
                         ${submitted_program}.test \
			 }] } {
	puts "Deleting out-of-date\
	      ${submitted_program}.test"
	file delete -force ${submitted_program}.test
    }
    if { [file readable $solout] } {
	puts "Linking ${submitted_program}.test to\
	      solution ${submitted_program}.out"
	link_file $solout ${submitted_program}.test
    } else {
	puts "Linking ${submitted_program}.test"
	link_file $soltest
    }
}

proc auto_score_reply { auto_score } {

    global scoring_mode reply_file submitted_file

    if { $auto_score == "Completely Correct" \
         || $scoring_mode == "auto" } {
	reply "For ${submitted_file} the automatically\
	       determined final score is:" \
	      "" \
	      "    $auto_score"
	puts "Emailed final auto-score:\
	      \    $auto_score"
    } elseif { [regexp {auto} $scoring_mode] } {
	reply "For ${submitted_file} the automatically\
	       determined score is:" \
	      "" \
	      "    $auto_score" \
	      "" \
	      "However, this score WILL BE REVIEWED by\
	       the human judge (soon)."
	file delete -force $reply_file
	puts "Emailed auto-score (review later):\
	      \    $auto_score"
    } else {
	puts "Auto-score (NOT emailed):\
	      \    $auto_score"
    }
}

# should_be_made file_list1 file_list2 
#
# If any file_list1 file is older than any file_list2
# file, and all file_list2 files exist, delete any
# file_list1 files that exist and return `yes'.  If no
# file_list1 files exists and all file_list2 files
# exist, return `yes'.  Else return `no'.
#
#
proc should_be_made { file_list1 file_list2 } {

    # Set mtime1 to the oldest of the file_list1
    # mtimes, or 0 if no file_list1 file exists.
    #
    set mtime1 0
    foreach file1 $file_list1 {
	if { [file exists $file1] } {
	    set mt [file mtime $file1]
	    if { $mtime1 == 0 || $mtime1 > $mt } {
	    	set mtime1 $mt
	    }
	}
    }
    # Set mtime2 to the newest of the file_list2
    # mtimes, or 0 if any file_list2 file does not
    # exist.
    #
    set mtime2 0
    foreach file2 $file_list2 {
	if { [file exists $file2] } {
	    set mt [file mtime $file2]
	    if { $mtime2 < $mt } {
	    	set mtime2 $mt
	    }
	} else {
	    set mtime2 0
	    break
	}
    }

    # If mtime1 < mtime2 we need to make file_list1
    # from file_list2
    #
    if { $mtime1 < $mtime2 } {
    	foreach file1 $file_list1 {
	    if { [file exists $file1] } {
	        puts "Deleting out-of-date $file1"
		file delete -force $file1
	    }
	}
	return yes
    } else {
        return no
    }
}

if { [should_be_made \
         [list $submitted_program \
	       "$submitted_program.cerr"] \
	 [list $make_file \
	       $submitted_file]] } {

    puts "Making ${submitted_program}"
    catch { exec make $submitted_program \
    		 2> "${submitted_program}.cerr" } out
    puts $out

    if { [file exists "${submitted_program}.cerr"] \
	 && [file size "${submitted_program}.cerr"] \
	    > 0 } {
	puts ""
	if { [file executable $submitted_program] } {
	    puts "========== COMPILER WARNINGS\
	          (${submitted_program}.cerr)\
		  =========="
	} else {
	    puts "========== COMPILER ERRORS\
	          (${submitted_program}.cerr)\
		  =========="
	}
	put_file "${submitted_program}.cerr" stdout 10
	puts "============================="
	puts ""
    }

    if { ! [file executable $submitted_program] } {

	puts "No executable `$submitted_program' file\
	      produced"

	if { [file exists $auto_score_file] } {
	    file delete -force $auto_score_file
	}
	write_file $auto_score_file "Syntax Error"
	auto_score_reply "Syntax Error"
	exit 0
    }
}

if { [should_be_made \
         [list "${submitted_program}.out" \
	       "${submitted_program}.err"] \
	 [list $submitted_program \
	       $make_file \
	       "${submitted_program}.in"]] \
     && [file executable $submitted_program] } {

    puts "Making ${submitted_program}.out"
    catch { exec make "${submitted_program}.out" \
		 2> "${submitted_program}.err" } out
    puts $out

    if { [file exists \
	       "${submitted_program}.err"] \
	 && [file size \
		  "${submitted_program}.err"] \
	      > 0 } {
	puts ""
	puts "========== ERRORS\
	      (${submitted_program}.err) =========="
	put_file "${submitted_program}.err" stdout 10
	puts "============================="
	puts ""
    } elseif { ! [file exists \
                       "${submitted_program}.out"] } {
	puts "No `${submitted_program}.out' file\
	      produced"
    }
}

set file_list [list "${submitted_program}.test"]

if { [file exists "${submitted_program}.out"] } {
    lappend file_list "${submitted_program}.out"
} else {
    lappend file_list "${submitted_program}.err"
}

if { [should_be_made \
         [list $auto_score_file] \
	 $file_list] } {

    exec autoscore $submitted_program
}

if { [should_be_made \
         [list $reply_file] \
	 [list $auto_score_file]] } {

    auto_score_reply [read_file $auto_score_file]
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
