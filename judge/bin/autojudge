#! /bin/sh -f
#
# Compute all the files needed in a program submission
# directory in order to score a submission.
#
# File:		judge
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Aug 16 06:43:27 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/20 01:07:16 $
#   $RCSfile: autojudge,v $
#   $Revision: 1.11 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"

set document "
cd submission_directory; judge

    Given the submission directory as the current dir-
    ectory, and given that the submission directory
    contains the file `$received_file', this program
    makes everything needed to compute the score file,
    `$auto_score_file', and automatically computes that
    file.  Then this program reports the score to the
    submitter by creating and sending `$reply_file'.

    Specifically, this program calls `extractmail' to
    extract the submitted file from the program.  This
    program then checks the legality of the submitted
    file name, and generates and sends `$reply_file'
    automatically if the name is illegal.
    
    If the file name is legal, this program symbolical-
    ly links the following solution files into the
    current directory:

    		$make_file
		$instructions_file
		.in solution input file
		.test solution output file
    
    Then this program makes the program binary and runs
    it to make its .out solution file, and possibly a
    .err error file.

    Next this program runs `autoscore' to produce a
    `$auto_score_file'.

    Lastly, this program may create a `$reply_file'
    and send it as email to the submitter.  It does this
    if the score is `Completely Correct' or the scoring_
    mode is `auto' or `auto+manual'.  If the mode is
    `auto+manual' and the score is not `Completely Cor-
    rect', the email informs its receiver that the score
    is preliminary and will be manually reviewed and
    possibly changed.
    
    If the score is mailed to the submitter and is NOT
    to be manually reviewed, this program also creates
    a `done_file' in current directory to indicate that
    directory processing is done."

if { $argc != 0 } {
    puts $document
    exit 1
}

proc submission_file_error { filename } {
    reply -all \
          "ERROR: submitted file has illegal name:\
	  $filename" \
	  ""  \
	  "THIS SUBMISSION (see below) IGNORED"  \
	  "YOU MUST RESUBMIT WITH A LEGAL FILENAME"
    puts "SUBMISSION ERROR: submitted file has illegal\
          name: $filename"
    exit 0
}

set submitted_file [exec extractmail]

if { $submitted_file == "" } {
    if { [file readable $reply_file] } {
        exit 0
    } elseif { [file exits $reply_file] } {
	fatal_error "Unreadable $reply_file exits"
    } else {
	fatal_error \
	    "Extract failed but no $reply_file exits"
    }
}

set submitted_program [file rootname $submitted_file]
set submitted_extension [file extension $submitted_file]

set program_solution \
    "$solutions_directory/$submitted_program"

if { ! [file isdirectory $program_solution] } {
    submission_file_error $submitted_file
}

if { [lsearch -exact $allowed_extensions \
                     $submitted_extension] < 0 } {
    submission_file_error $submitted_file
}

if { ! [file readable $make_file] } {
    puts "Linking $make_file"
    exec ln -s "$program_solution/$make_file" .
}

if { ! [file readable $instructions_file] \
     && [file exists \
	  "$program_solution/$instructions_file"] } {
    puts "Linking $instructions_file"
    exec ln -s "$program_solution/$instructions_file" .
}

if { ! [file readable ${submitted_program}.in] } {
    puts "Linking ${submitted_program}.in"
    exec ln -s \
         "$program_solution/${submitted_program}.in" .
}

if { ! [file readable ${submitted_program}.test] } {
    puts "Linking ${submitted_program}.test to\
          ${submitted_program}.out"
    exec ln -s \
         "$program_solution/${submitted_program}.out" \
         "$program_solution/${submitted_program}.test"
}

if { ! [file readable $submitted_program] \
     || [file mtime $submitted_program] \
           < [file mtime Makefile] \
     || [file mtime $submitted_program] \
           < [file mtime $submitted_file] } {

    if { [file exists $submitted_program] } {
	puts "Deleting out-of-date $submitted_program"
    	file delete -force $submitted_program
    }
    puts "Making ${submitted_program}"
    if { [catch { exec make $submitted_program } \
                out] } {
        puts $out

	if { [file exists $auto_score_file] } {
	    file delete -force $auto_score_file
	}
	set auto_score_ch [open $auto_score_file w]
	puts $auto_score_ch "Syntax Error"
	close $auto_score_ch
	auto_score_reply "Syntax Error"
	exit 0
    }
    puts $out

    if { ! [file exists $submitted_program" ] } {
        fatal_error \
	    "Make of $submitted_program failed\
	     without error indication."
    }

    exec chmod a+x $submitted_program
}

if { ! [file readable "${submitted_program}.out"] \
     || [file mtime "${submitted_program}.out"] \
           < [file mtime $submitted_program] \
     || [file mtime "${submitted_program}.in"] \
           < [file mtime "${submitted_program}.in"] } {

    if { [file exists "${submitted_program}.out"] } {
	puts "Deleting out-of-date\
	               ${submitted_program}.out"
    	file delete -force "${submitted_program}.out"
    }

    if { [file exists "${submitted_program}.err"] } {
	puts "Deleting out-of-date\
	               ${submitted_program}.err"
    	file delete -force "${submitted_program}.err"
    }

    puts "Making ${submitted_program}.out"
    catch { exec make "${submitted_program}.out" } out
    puts $out

    if { ! [file exists "${submitted_program}.out" ] } {
        fatal_error \
	    "Make of ${submitted_program}.out failed"
    }
}

if { ! [file readable $auto_score_file] \
     || [file mtime $auto_score_file] \
           < [file mtime ${submitted_program}.out] } {

    if { [file exists $auto_score_file] } {
	puts "Deleting out-of-date $auto_score_file"
    	file delete -force $auto_score_file
    }

    set auto_score [exec autoscore $submitted_program]

    if { ! [file exists $auto_score_file] } {
        fatal_error \
	    "Autoscore did not make $score_file"
    }

    set From_line [file tail [pwd]]

    if { $score == "Completely Correct" \
         || $scoring_mode == "auto" } {
	reply "${submitted_file} automatically\
	       determined score is:     $score"
    } elseif { [regexp {auto} $scoring_mode] } {
	reply "${submitted_file} automatically\
	       determined score is:     $score" \
	      "" \
	      "Score will be REVIEWED BY THE JUDGE\
	       soon"
	file delete -force $reply_file
    }
    puts "Automatic Score:    $score"
}

exit 0
