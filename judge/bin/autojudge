#!/bin/sh
#
# Compute all the files needed in a program submission
# directory in order to score a submission.
#
# File:		autojudge
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Thu Oct 18 03:02:16 EDT 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/10/18 07:02:01 $
#   $RCSfile: autojudge,v $
#   $Revision: 1.32 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory; autojudge

    Given the submission directory as the current dir-
    ectory, and given that the submission directory
    contains the file `$received_file', this program
    makes everything needed to compute the score file,
    `$auto_score_file', and automatically computes that
    file.  Then this program may report the score to the
    submitter by creating and sending `$reply_file' as
    specified by the scoring mode.

    Specifically, this program makes the following in
    order:

	the submitted file by calling extractmail
	$make_file file
	$scoring_instructions_file file, if it exists
	.in solution input file
	.test solution output file
	the program binary (and .cerr file)
	the .out file (and .err file)
	the .score file
	the $auto_score_file file
	the $reply_file file, sometimes

    If any of these files exists, this program checks to
    be sure it is not older than the previous files
    (starting with the submitted file not being older
    than the $received_file file), and remakes any of
    the above files that are out-of-date.  Errors in
    making the program binary can cause $auto_score_file
    and maybe $reply_file to be generated early.

    First, this program calls `extractmail' to extract
    the submitted file from the program.  This program
    then checks the legality of the submitted file name,
    and generates and sends `$reply_file' automatically
    if the name is illegal.  A file name is illegal if
    it does not have an extension listed in the value of
    the `allowed_extensions' variable, or if there is
    no subdirectory of the solutions directory that has
    the same name as the basename of the file.
    
    If the file name is legal, this program symbolical-
    ly links the following solution directory files into
    the current directory:

    		$make_file
		$scoring_instructions_file if it exists
		.in solution input file
		.test solution output file

    The .test file is linked to the solution .out file
    if that exists, or the solution .test file other-
    wise.  If the solution .out file exists and and the
    the current directory .test file is linked to the
    solution directory .test file, the current directory
    .test file is relinked to the solution .out file.
    Thus the solution .out file always has preference
    over the solution .test file.

    Next this program makes the program binary by using
    the $make_file.  Any compiler error messages are
    captured in a .cerr file.  If no executable binary
    is made, this program writes `Syntax Error' into the
    $auto_score_file file, and skips to the end of this
    program where a $reply_file file containing the auto
    score may be created and sent to the user.

    If an executable binary file was made, this program
    makes a .out output file by using the $make_file,
    and captures any error output in a .err file.  Then
    this program runs `autoscore' to produce a .score
    file and an automatic score in the $auto_score_file
    file.  Any .score file will be not produced (and
    even deleted if it exists) if the score can be
    determined without it, i.e., if the score is deter-
    mined by the .err file or if the .out file does not
    exist or is empty.

    Lastly, this program may create a `$reply_file'
    and send it as email to the submitter.  It does this
    if the score is `Completely Correct' or the scoring_
    mode is `auto' or `auto+manual'.  If the mode is
    `auto+manual' and the score is not `Completely Cor-
    rect', the email informs its receiver that the score
    is preliminary and will be manually reviewed and
    possibly changed.
    
    If the score is to be manually reviewed, this prog-
    ram does not create a $reply_file file, even when it
    sends a reply (the reply is recorded in any case in
    the $reply_history_file file).  The absence of a
    $reply_file file signals that the final reply has
    not been given to the submitter, and further manual
    action is necessary to generate this reply.

    This program prints information about its progress.

    Unless this program creates a $reply_file file that
    is intended to be the final reply to the submitter
    (because the score is `Completely Correct' or the
    scoring mode is `auto'), this program sets the
    `needs reply' flag (the $needs_reply_flag_file\
    			file in
    the flag directory).  This signals other programs
    (e.g. tracker) that they should search for submis-
    sion directories for which the manualreply program
    should be called.

    If this program (because of a `Syntax Error') or the
    `autoscore' program writes the $auto_score_file\
    	file,
    the program will set the score flag (the flag direc-
    tory $score_flag_file file), to signal that any\
	score-
    boards need to be recomputed.

    If something goes very wrong, such as finding that
    the `$received_file' file is not readable, this
    program creates an error log file in the current
    directory, prints information about the error to the
    standard error output, and exits with exit code 0."

# If any arguments, print documentation and exit.
#
if { $argc != 0 } {
    puts $document
    exit 1
}

# Get submitted file.  If none available, exit.
#
set submitted_file [exec extractmail 2>@ stderr]
if { $submitted_file == "" } {
    exit 0
}

# Compute names.
#
set submitted_program [file rootname $submitted_file]
set submitted_extension [file extension $submitted_file]
set program_solution \
    $solutions_directory/$submitted_program

# On illegal filename error, send error reply to sub-
# mitter, print error message on standard output, and
# exit.
#
proc illegal_filename_error { filename } {
    reply \
          "ERROR: submitted file has illegal name:\
	  $filename" \
	  ""  \
	  "THIS SUBMISSION (see below) IGNORED"  \
	  "YOU MUST RESUBMIT WITH A LEGAL FILENAME"
    puts "SUBMISSION ERROR: submitted file has illegal\
          name: $filename"
    exit 0
}

# Detect illegal file names and found reply to user
# and exit.
#
if { ! [file isdirectory $program_solution] } {
    illegal_filename_error $submitted_file
}
if { [lsearch -exact $allowed_extensions \
                     $submitted_extension] < 0 } {
    illegal_filename_error $submitted_file
}

# Link $make_file, etc.
#
if { ! [file readable $make_file] } {
    puts "Linking $make_file"
    link_file $program_solution/$make_file
}

set sif $scoring_instructions_file
if { ! [file readable $sif] \
     && [file exists $program_solution/$sif] } {
    puts "Linking $sif"
    link_file $program_solution/$sif
}

if { ! [file readable $submitted_program.in] } {
    puts "Linking $submitted_program.in"
    link_file \
         $program_solution/$submitted_program.in
}

set solout \
    $program_solution/$submitted_program.out
set soltest \
    $program_solution/$submitted_program.test
if { ! [file readable $submitted_program.test] \
     || ( [file readable $solout] \
          && [file extension \
	           [file readlink \
		         $submitted_program.test]] \
	     == ".test" ) } {
    if { ! [catch { file type \
                         $submitted_program.test \
			 }] } {
	puts "Deleting obsolete\
	      $submitted_program.test"
	file delete -force $submitted_program.test
    }
    if { [file readable $solout] } {
	puts "Linking $submitted_program.test to\
	      solution $submitted_program.out"
	link_file $solout $submitted_program.test
    } else {
	puts "Linking $submitted_program.test"
	link_file $soltest
    }
}

# Send reply to user containing new auto score.
#
proc auto_score_reply { auto_score } {

    global scoring_mode reply_file submitted_file \
           needs_reply_flag_file

    if { $auto_score == "Completely Correct" \
         || $scoring_mode == "auto" } {
	reply "For $submitted_file the automatically\
	       determined final score is:" \
	      "" \
	      "    $auto_score"
	puts "Emailed final auto-score:\
	      \    $auto_score"
    } elseif { [regexp {auto} $scoring_mode] } {
	compose_reply \
              "For $submitted_file the automatically\
	       determined score is:" \
	      "" \
	      "    $auto_score" \
	      "" \
	      "However, this score WILL BE REVIEWED by\
	       the human judge (soon)."
	send_reply -notfinal
	set_flag $needs_reply_flag_file
	puts "Emailed auto-score (review later):\
	      \    $auto_score"
    } else {
	set_flag $needs_reply_flag_file
	puts "Auto-score (NOT emailed):\
	      \    $auto_score"
    }
}

# should_be_made file_list1 file_list2 
#
# If any file_list1 file is older than any file_list2
# file, and all file_list2 files exist, delete any
# file_list1 files that exist and return `yes'.  If no
# file_list1 files exists and all file_list2 files
# exist, return `yes'.  Else return `no'.
#
#
proc should_be_made { file_list1 file_list2 } {

    # Set mtime1 to the oldest of the file_list1
    # mtimes, or 0 if no file_list1 file exists.
    #
    set mtime1 0
    foreach file1 $file_list1 {
	if { [file exists $file1] } {
	    set mt [file mtime $file1]
	    if { $mtime1 == 0 || $mtime1 > $mt } {
	    	set mtime1 $mt
	    }
	}
    }
    # Set mtime2 to the newest of the file_list2
    # mtimes, or 0 if any file_list2 file does not
    # exist.
    #
    set mtime2 0
    foreach file2 $file_list2 {
	if { [file exists $file2] } {
	    set mt [file mtime $file2]
	    if { $mtime2 < $mt } {
	    	set mtime2 $mt
	    }
	} else {
	    set mtime2 0
	    break
	}
    }

    # If mtime1 < mtime2 we need to make file_list1
    # from file_list2
    #
    if { $mtime1 < $mtime2 } {
    	foreach file1 $file_list1 {
	    if { [file exists $file1] } {
	        puts "Deleting out-of-date $file1"
		file delete -force $file1
	    }
	}
	return yes
    } else {
        return no
    }
}

# If necessary compile submitted file to produce
# binary.  If this fails, announce `Syntax Error'
# as the score.
#
if { [should_be_made \
         [list $submitted_program \
	       $submitted_program.cerr] \
	 [list $make_file \
	       $submitted_file]] } {

    puts "Making $submitted_program"
    catch { make_file $submitted_program \
    		      $submitted_program.cerr }

    # Print any non-empty .cerr file.
    #
    if { [file exists $submitted_program.cerr] \
	 && [file size $submitted_program.cerr] \
	    > 0 } {
	puts ""
	if { [file executable $submitted_program] } {
	    puts "========== COMPILER WARNINGS\
	          ($submitted_program.cerr)\
		  =========="
	} else {
	    puts "========== COMPILER ERRORS\
	          ($submitted_program.cerr)\
		  =========="
	}
	put_file $submitted_program.cerr stdout 10
	puts "============================="
	puts ""
    }

    # If no executable binary produced, record and
    # send `Syntax Error' reply.
    #
    if { ! [file executable $submitted_program] } {

	puts "No executable `$submitted_program' file\
	      produced"

	if { [file exists $auto_score_file] } {
	    file delete -force $auto_score_file
	}
	write_file $auto_score_file "Syntax Error"
	set_flag $score_flag_file
	auto_score_reply "Syntax Error"
	exit 0
    }
}

# Make .out file if necessary.
#
if { [should_be_made \
         [list $submitted_program.out \
	       $submitted_program.err] \
	 [list $submitted_program \
	       $make_file \
	       $submitted_program.in]] \
     && [file executable $submitted_program] } {

    puts "Making $submitted_program.out"
    catch { make_file $submitted_program.out \
		      $submitted_program.err }

    # Remove any a+x on the current directory as a
    # `best effort' security measure in the face of
    # the JAVA bug that requires .. to be a+x.
    #
    deny_access "."

    # Print any non-empty .err file.
    #
    if { [file exists $submitted_program.err] \
	 && [file size $submitted_program.err] \
	      > 0 } {
	puts ""
	puts "========== ERRORS\
	      ($submitted_program.err) =========="
	put_file $submitted_program.err stdout 10
	puts "============================="
	puts ""
    } elseif { ! [file exists \
                       $submitted_program.out] } {
	puts "No `$submitted_program.out' file\
	      produced"
    }
}

# Make $auto_score_file if necessary.
#
set file_list [list $submitted_program.test]

if { [file exists $submitted_program.out] } {
    lappend file_list $submitted_program.out
}
if { [file exists $submitted_program.err] } {
    lappend file_list $submitted_program.err
}

if { [llength $file_list] >= 2 \
     && [should_be_made \
            [list $auto_score_file] \
	    $file_list] } {

    exec autoscore $submitted_program 2>@ stderr
}

# Make $reply_file if necessary.
#
if { [should_be_made \
         [list $reply_file] \
	 [list $auto_score_file]] } {

    auto_score_reply [read_file $auto_score_file]
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
