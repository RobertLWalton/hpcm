#!/bin/sh
#
# Compute all the files needed in a program submission
# directory in order to score a submission.
#
# File:		autojudge
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Sun Sep 25 07:40:15 EDT 2005
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2005/09/25 15:26:31 $
#   $RCSfile: autojudge,v $
#   $Revision: 1.90 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
source $lib_directory/scoring_common.tcl
catch {

set document "
cd submission_directory
autojudge \[-manual\] \[problem\[.extension\]\]

    Given the submission directory as the current dir-
    ectory, and given that the submission directory
    contains the file `$received_file', this program
    makes everything needed to compute the score file,
    `$auto_score_file', and then automatically computes\
    	that
    file.  This program may report the score to the sub-
    mitter by creating and sending `$reply_file' as
    specified by the `scoring_mode' global variable.

    If the -manual program option is given, it sets the
    scoring_mode to `manual' while this program is run-
    ning.  This suppresses sending email to the submit-
    ter.

    If the problem name and optional extension are not
    given as an argument, they are extracted from the

    	Subject: problem\[.extension\]

    field of the message in the $received_file file.
    Here `problem' names the problem and the solution
    binary, and is the basename of the .in, .out, .test,
    .fout, .ftest, .cerr, .err, and .score files.  If
    `extension' is given, it tells the language being
    used, and must be a member of the `allowed_exten-
    sions' global variable value, which by default is:
    
    	$allowed_extensions

    In this document and in the `$files_file' file\
    	mentioned
    below, the words `PROBLEM' and `EXTENSION' are used
    to denote the problem name and extension as given in
    an argument or `Subject:' field.  Also, the solution
    directory below is the problem directory within the
    solutions directory, i.e., the directory with name:

    	\$solutions_directory/PROBLEM

    More specifically, this program makes the following
    in order:

      * `PROBLEM.rc' file, if it exists, and if it
        exists, it is sourced
      * `$files_file' file, if it exists
      . any -SOLUTION-MAKE- files listed in any
	`$files_file' file; note these files are in
	the solution directory
      . submitted files made by calling extractmail
      * any -LINK- or -OPTIONAL-LINK- files listed in
	any `$files_file' file; if there is no\
	  	`$files_file' file,
	the -LINK- files are by default:
	     $make_file, PROBLEM.in, PROBLEM.test
	and the -OPTIONAL-LINK- files are by default:
	     PROBLEM.ftest, $scoring_filter_file
      . the program binary file `PROBLEM' and the
	compiler error file PROBLEM.cerr
      . the program standard output file PROBLEM.out
	and the program standard error file PROBLEM.err
      . the filtered output file PROBLEM.fout, if the
	$scoring_filter_file file exists
      . the PROBLEM.score file made by calling autoscore
      . the $auto_score_file file made by ditto
      . the $reply_file file, sometimes

    Here files marked with * are linked into the current
    submission directory from the problem's solution
    directory.  This program checks any other file that
    already exists to see if it is younger than the pre-
    vious files upon which it depends (starting with
    submitted files being younger than the\
    	$received_file
    file), and if a file is younger and hence up to
    date, this program skips remaking the file.  Inabil-
    ity to make a program binary or a .out file, or an
    empty .out file, can cause $auto_score_file and\
    	maybe
    $reply_file to be generated early.

    In general, this program may detect two kinds of
    errors: system errors and submitter errors.  A
    system error means the judging files are incorrectly
    set up, and a submitter error means the submitter
    sent the wrong information.  On a system error, this
    program logs the error in an error log file in the
    current directory and prints information about the
    error to the standard error output.  On a submitter
    error, this program creates a $reply_file file that
    contains a description of the error and sends this
    to the submitter as the final word on the submis-
    sion.  In either case this program terminates after
    reporting the error.

    At its beginning, this program verifies the exis-
    tence of a solution directory for the problem and
    symbolically links the `PROBLEM.rc' and\
    		`$files_file'
    files from this directory into the current direc-
    tory, if these files exist.  If the `PROBLEM.rc'
    file exists, it is sourced.  If the\
    		`$files_file' file
    does not exist, it is given the default value:

        -LINK-
	    { $make_file $make_file.EXTENSION\
	    	$make_file }
	    PROBLEM.in
	    { PROBLEM.test PROBLEM.out PROBLEM.test }
	-OPTIONAL-LINK-
	    $scoring_filter_file
	    { PROBLEM.ftest PROBLEM.fout PROBLEM.ftest }

    The `$files_file' file is interpreted as a TCL list
    (with list elements separated by spaces, tabs, or
    new lines) whose elements are special symbols, file
    names, and { } bracketed sublists.  The special
    symbols consist of upper case letters and the `-'
    character, and begin and end with `-'.  All list
    items following a special symbol S but before the
    next special symbol are governed by S.  This program
    understands the following three special symbols:

    	-SOLUTION-MAKE-	The list items governed by
			-SOLUTION-MAKE- are the names of
			files that are to be `made' in
			the solution directory if they
			do not exist.
    
    	-LINK-		The list items governed by
			-LINK- name files that are to be
			linked from the solution direc-
			tory to the current directory.

    	-OPTIONAL-LINK-	The list items governed by
			-OPTIONAL-LINK- name files that
			are to be linked from the solu-
			tion directory to the current
			directory if they exist in the
			solution directory.

    List items governed by other special symbols are
    ignored by this program.  There is an implied
    `-REQUIRED-' before the beginning of the list, that
    governs list items appearing before any special
    symbol in the list.  The same special symbol can
    appear multiple times in the list.  The same file
    name can appear several times in the list: e.g.,
    a file name can appear governed by -SOLUTION-MAKE-
    and then again governed by -LINK-.

    Each item governed by one of the three special
    symbols listed above is either a file name or a list
    of file names.  In any file name, the basename
    `PROBLEM' is replaced by the problem name and the
    extension `.EXTENSION' is replaced by the submission
    extension.

    -LINK- and -OPTIONAL-LINK- items may be a { } brac-
    ketted list of file names.  In this case, the first
    file name F is the file name in the current direc-
    tory which is to be created by the link, and the
    rest of the file names name files in the solution
    directory that may be linked to F.  The first of
    these solution directory files that exists is
    chosen.  If F is an already existing link in the
    current directory, it is relinked to the chosen
    solution directory file, or F is deleted if there
    is no chosen file because all solution directory
    files in the list of files that can be linked to F
    do not exist.  If F does not exist, it is linked to
    the chosen file if there is one.  Otherwise nothing
    is done, so that if F is a file proper, and not a
    link, it will be left alone.

    A -LINK- or -OPTIONAL-LINK- item that is a single
    file name F is equivalent to the item `{ F F }'.

    The only difference between -LINK- and -OPTIONAL-
    LINK- is that for -LINK- it is an error if
    after taking the above actions the file F being
    created in the local directory does not exist;
    whereas for -OPTIONAL-LINK- it is no error at all
    in this case.

    In the above, a dangling link does not count as an
    existing file.  Thus if the solution directory con-
    tains a dangling link F2, i.e., a link to an non-
    existent file, then F2 does not exist.  Also note
    that by `link' we mean `symbolic link'.

    If no extension is given to this program with the
    problem name, any file name whose extension is
    .`EXTENSION' is treated as naming a file that does
    not exist and cannot be created.  It is an error to
    try to create such a file, but it is not an error to
    try to use such a file if it is not an error for the
    file not to exist.

    Thus in the default value of the `$files_file' file
    given above, the file named $make_file in the cur-
    rent directory is linked to the file named
    `$make_file.EXTENSION' if an extension was given
    with the problem name to this program and if the
    indicated file exists in the solution directory.
    Otherwise the file is linked to $make_file in the
    solution directory, if that file exists.  Otherwise
    there is an error, as $make_file is -LINK- and not
    -OPTIONAL-LINK-.

    In linking any `PROBLEM.rc' or `$files_file' file
    from the solution directory, this program behaves as
    if there were an initial `$files_file'\
    		file value of:

    	-OPTIONAL-LINK-
	    { PROBLEM.rc rc.EXTENSION PROBLEM.rc }
	    { $files_file $files_file.EXTENSION\
	      $files_file }

    Thus in the solution directory, rc.EXTENSION and
    $files_file.EXTENSION are preferred over\
    	PROBLEM.rc
    and `$files_file'.

    It is an error if the solution directory has no
    `PROBLEM.rc' file but does have `rc.*' files none of
    which match the extension given by the submitter;
    or if the solution directory has no `$files_file'\
    		file
    but does have `$files_file.*' files, none of which
    match the extension given by the submitter.

    All errors involving linking are submitter errors if
    there might be some extension that the submitter
    could specify which would make the submission cor-
    rect.  Otherwise the errors are system errors.

    After linking any `PROBLEM.rc' and `$files_file'\
    		files
    from the solution directory, this program makes any
    files governed by -SOLUTION-MAKE- in the\
    	`$files_file'
    file.  If there is such a file F listed, and it does
    not already exist in the solution directory, this
    program executes `make F' in the solution directory.
    During this process this program locks the solution
    directory with a $dispatch_pid_file file.  Note that
    `PROBLEM' or `EXTENSION' are not substituted for in
    -SOLUTION-MAKE- file names; but the same effect can
    be had by having different `$files_file.EXTENSION'\
    	files
    for different extensions.

    Next this program calls `extractmail' to extract the
    submitted files from the program.  Errors in this
    extraction are classified as system errors if ex-
    tractmail outputs the phrase `SYSTEM ERROR' and
    submitter errors otherwise.
 
    If the extraction has no errors, this program sym-
    bolically links solution directory files into the
    current directory, according to instructions encoded
    by the -LINK- and -OPTIONAL-LINK- special symbols in
    the `$files_file' file or the default value given\
    	above
    for this file.  Note that a file may be listed as
    both -OPTIONAL- (for extractmail) and -LINK-: if
    submitted the submitted version will be used, and if
    not submitted, the solution directory version will
    be used.  Also note that a file listed as -LINK- or
    -OPTIONAL-LINK- may be made as a consequence of a
    -SOLUTION-MAKE- item (which may or may not directly
    name the file to be linked).

    Next this program makes the program binary by using
    the $make_file.  Any compiler error messages are
    captured in a .cerr file.  If no executable binary
    is made, this program writes `Syntax Error' into the
    $auto_score_file file, and skips to the end of this
    program where a $reply_file file containing the auto
    score may be created and sent to the user.
 
    If an executable binary file was made, this program
    makes a .out output file by using the $make_file,
    and captures any error output in a .err file.  If
    the .out file exists and is non-empty, and if the
    $scoring_filter_file file exists, this program then
    runs

    	$scoring_filter_file <PROBLEM.out >PROBLEM.fout

    to make the .fout file.  It is a system error if the
    $scoring_filter_file program exits with a non-zero\
    	UNIX
    exit code or writes the standard error output, or if
    no .ftest file exists in this situation.

    For purposes of computing file dependencies, the
    files PROBLEM, PROBLEM.out, and PROBLEM.fout are all
    assumed to depend upon all the extracted and linked
    files.

    Then this program runs `autoscore' to produce a
    .score file and an automatic score in the\
        $auto_score_file
    file.  Any .score file will be not produced (and
    even deleted if it exists) if the score can be
    determined without it, i.e., if the score is deter-
    mined by the .err file or if the .out file does not
    exist or is empty.

    Lastly, this program may create a `$reply_file' file
    and send it as email to the submitter.  It does this
    using instructions in the `response_instructions'
    global variable.  This variable contains instruc-
    tions that format the reply for a given\
    	$auto_score_file
    value and a given value of the scoring_mode global
    variable.  The format of the response instructions
    is described in hpcm_judging.rc, where a default
    value is also given for the `response_instructions'
    variable.
    
    With default response instructions, this program
    sends a reply if the score is `Completely Correct'
    or the scoring_mode is `auto' or `auto+manual'.  If
    the mode is `auto' or the score is `Completely Cor-
    rect', the reply is final, and is stored in the
    $reply_file file.  Otherwise the reply is not final,
    and informs its receiver that the score is prelim-
    inary and will be manually reviewed and possibly
    changed.  When the reply is not final, this program
    does not create a $reply_file file, even when it
    sends a reply (the reply is recorded in any case in
    the $reply_history_file file).  The absence of a
    $reply_file file signals that the final reply has
    not been given to the submitter, and further action
    using the `manualreply' program is necessary to gen-
    erate a final reply.

    This program prints information about its progress.
 
    Unless this program creates a $reply_file file that
    is intended to be the final reply to the submitter
    (e.g., because the score is `Completely Correct' or
    the scoring mode is `auto'), this program sets the
    `needs reply' flag (the $needs_reply_flag_file\
    			file in
    the flag directory).  This signals other programs
    (e.g. tracker) that they should search for submis-
    sion directories for which the manualreply program
    should be called.

    If this program (because of a `Syntax Error') or the
    `autoscore' program writes the $auto_score_file\
    	file,
    the program will set the score flag (the flag direc-
    tory $score_flag_file file), to signal that any\
	score-
    boards need to be recomputed.

    Problem names that contain `/' or `.' or begin with
    `-' or have no solution directory are illegal, and
    are submitter errors.  Similarly extension names
    not listed in the `allowed_extensions' global vari-
    able are unallowed and are submitter errors, as are
    misformatted $received_file file `Subject:' fields.
    It is a system error if the `$received_file' file is
    not readable, if a `$files_file' file is\
    	misformatted, or
    if `extractmail' returns a system error.  It is a
    system error if an existing `response_instructions'
    global variable value is misformatted."

# Do not change argc or argv so error printouts will be
# correct.
#
set my_argc $argc
set my_argv $argv

# Process any -manual argument.
#
set manual 0
if { [lindex $my_argv 0] == "-manual" } {
    set manual 1
    set my_argv [lrange $my_argv 1 end]
    incr my_argc -1
}

# If too many arguments or -doc argument, print docu-
# mentation and exit.
#
if {    $my_argc > 1 \
     || [regexp {^-doc} [lindex $my_argv 0]] } {
    puts $document
    exit 1
}

# Handle submitter error in subject.
#
proc subject_error { what } {
    global message_subject
    reply "LINE {ERROR: $what\
	  	 `Subject:$message_subject'}" \
	  BLANK \
	  { LINE "THIS SUBMISSION (see below)\
	          IGNORED" } \
	  { LINE "You must resubmit with a legal\
	         message subject." } \
	  BLANK \
	  { BAR "this message replies to:" } \
	  RECEIVED-HEADER
    puts "SUBMISSION ERROR: $what in\
          `Subject:$message_subject'"
    exit 0
}

# Compute problem name and extension.
#
if { $my_argc == 1 } {
    set argument [lindex $my_argv 0]
} else {

    # Read message header.
    #
    set received_ch [open $received_file r]
    read_header $received_ch
    close $received_ch

    # Get problem.
    #
    if {    [catch { llength $message_subject }] \
         || [llength $message_subject] != 2 \
	 || [lindex $message_subject 0] != "submit" } {
	subject_error "badly formatted"
    }
    set argument [lindex $message_subject 1]
}
set problem [file rootname $argument]
set extension [file extension $argument]

# Check legality of problem name and optional extension.
#
if {    $problem == "" \
     || [regexp {\.} $problem] \
     || [regexp {/}  $problem] \
     || [regexp {^-} $problem]  } {
    subject_error "illegal problem name `$problem' in"
}
if { $extension != "" \
     && ! [lcontain $allowed_extensions $extension] } {
    subject_error "unallowed extension `$extension'\
      (should be one of $allowed_extensions) in"
} elseif { [regexp {/} $extension] } {
    # should never happen
    error "/ in extension `$extension'"
}

# Check for existence of problem solution directory.
#
set solution_directory $solutions_directory/$problem
if { ! [file isdirectory $solution_directory] } {
    subject_error "unallowed problem name `$problem' in"
}

# Global variable that is list of all files linked
# into the submission directory by autojudge.  Various
# output files depend on all these (must not be older
# than any of these).
#
set linked_files ""

# Function that links files according to the data that
# has the format of a problem_link_files global variable
# value: see hpcm_judging.rc.  Name describes the data
# for error message purposes.  Optional is 1 if links
# are options, 0 if they are required.  Appends files
# linked to linked_files above.
#
# The global solution_directory names the problem solu-
# tion directory.
#
proc execute_links { data name { optional 0 } } {

    global solution_directory linked_files

    if { [catch { llength $data }] } {
	error "bad $name, not a TCL list: $data"
    }

    foreach item $data {
	if { [catch { set length [llength $item] }] } {
	    error "bad $name element, not a TCL list:\
	           $item"
	}
	if { $length == 0 } {
	    error "bad $name element, empty TCL list"
	} elseif { $length == 1 } {
	    set source_list $item
	    set target $item
	} else {
	    set source_list [lrange $item 1 end]
	    set target [lindex $item 0]
	}
	set source ""
	set sd $solution_directory
	foreach file $source_list {
	    if { [file exists $sd/$file] } {
		set source $sd/$file
		break
	    }
	}
	if { $target == "" || [regexp {/} $target ] } {
	    error "Bad $name target in $item"
	}

	if { [catch { set type [file type $target] }] \
	            } {
	    set type none
	} elseif { $type == "link" \
		   && \
		   $source != "" \
		   && \
		   [file readlink $target] \
			 == $source } {
	    set type done
	}

	if { $type == "link" } {
	    puts "Deleting $target"
	    file delete -force $target
	    set type none
	}

	if { $type != "none" } {
	    lappend linked_files $target
	} elseif { $source == "" } {
	    if { ! $optional } {
	        error "no source files exist for\
		       $item in $name"
	    }
	} else {
	    set tail [file tail $source]
	    if { $tail == $target } {
		puts "Linking $target"
	    } else {
		puts "Linking $tail to\
		      $target"
	    }
	    link_file $source $target
	    lappend linked_files $target
	}
    }
}

# Set initial values for global variables of interest
# to us that might be changed by PROBLEM.rc.
#
set PROBLEM $problem
set EXTENSION $extension
#
set problem_required_files $PROBLEM$EXTENSION
set problem_optional_files ""
set problem_make_files \
	" { $PROBLEM.fout
	    {Scoring_Filter < $PROBLEM.out 
			    > $PROBLEM.fout }
	    Scoring_Filter $PROBLEM.out }
	  { $PROBLEM.ftest
	    {Scoring_Filter < $PROBLEM.test 
			    > $PROBLEM.ftest }
	    Scoring_Filter $PROBLEM.test }
	"
set problem_link_files \
        " { Makefile Makefile$EXTENSION Makefile }
	  $PROBLEM.in
	  { $PROBLEM.test $PROBLEM.out $PROBLEM.test }
        "
set problem_optional_link_files \
        " Scoring_Filter
	  { $PROBLEM.ftest $PROBLEM.fout $PROBLEM.ftest }
	"

# Link and source any PROBLEM.rc file.
#
execute_links $problem.rc \
              "initial problem .rc file linking" 1
if { [file exists $problem.rc] } {
    source_file $problem.rc
}

# Force scoring mode if there was a -manual option.
#
if { $manual } {
    set scoring_mode manual
}

# Make problem_make_files.  First we check to see if we
# can prove there is nothing to do, as we do not want to
# lock the solution directory unnecessarily.  First_
# target is the first file that will be made if any are
# to be made.
#
if { [catch {llength $problem_make_files}] } {
    error "problem_make_files value is not a TCL list:\
           $problem_make_files"
}
set first_target ""
set sd $solution_directory
foreach instruction $problem_make_files {
    if { [catch {llength $instruction}] } {
	error "problem_make_files instruction\
	       is not a TCL list: $instruction"
    }

    set sources [lrange $instruction 2 end]
    set non_existant_input_found 0
    foreach source $sources {
        if { ! [file exists $sd/$source] } {
	    set non_existant_input_found 1
	    break
	}
    }
    if { $non_existant_input_found } continue

    set target [lindex $instruction 0]
    if { ! [file exists $sd/$target] } {
        set first_target $target
	break
    }

    set mtime [file mtime $sd/$target]
    foreach source $sources {
	if { [file mtime $sd/$source] > $mtime } {
	    set first_target $target
	    break
	}
    }
    if { $first_target != "" } break
}

# Try repeatedly to lock the solution directory, but if
# this fails after a short while, just give up and print
# a comment.
#
if { $first_target != "" } {
    set count 0
    while { "yes" } {
	if { [dispatch_lock $solution_directory] } break
	incr count
	if { $count >= 10 } {
	    puts "CANNOT LOCK $solution_directory: giving\
		  up on making $first_target"
	    set first_target ""
	    break
	}
	sleep 2
    }
}
# Execute problem_make_files instructions if neccssary.
#
if { $first_target != "" } {
    foreach instruction $problem_make_files {
	if { [catch {llength $instruction}] } {
	    error "problem_make_files instruction is\
	           not a TCL list: $instruction"
	}

	set sources [lrange $instruction 2 end]
	set non_existant_input_found 0
	foreach source $sources {
	    if { ! [file exists $sd/$source] } {
		set non_existant_input_found 1
		break
	    }
	}
	if { $non_existant_input_found } continue

	set target [lindex $instruction 0]
	if { [file exists $sd/$target] } {
	    set mtime [file mtime $sd/$target]
	    set skip 1
	    foreach source $sources {
		if { [file mtime $sd/$source] > $mtime \
		   } {
		    set skip 0
		    break
		}
	    }
	    if { $skip } continue
	}
	set command [lindex $instruction 1]
	puts "Making $target by executing $command"
	exec_in_directory $solution_directory \
			  $command >&@ stdout
    }
    dispatch_unlock $solution_directory
}

# List of all files extracted by extractmail.
#
set extracted_files ""

# Get submitted files.  If error, if SYSTEM ERROR call
# `error' function and otherwise reply to submitter.
# Compute list of extracted files in `extracted_files'.
#
if { [catch { exec extractmail } extractout] } {
    if { [regexp {SYSTEM ERROR} $extractout] } {
        error "System error during\
	       extractmail:\n\n$extractout"
    } else {

	# Create a reply file complaining of an extrac-
	# tion error, and email this reply to the
	# submitter.  Include the submission email in
	# the reply.
	#
	reply {LINE "ERROR during file extraction:" } \
	      BLANK \
	      [list LINES $extractout] \
	      BLANK \
	      { LINE "THIS SUBMISSION (see below)\
	              IGNORED" } \
	      { LINE "YOU MUST RESUBMIT" } \
	      BLANK \
	      { BAR "this message replies to:" } \
	      RECEIVED-FULL-HEADER \
	      BLANK \
	      RECEIVED-BODY

	puts $extractout
	puts "Reply indicating error emailed to\
	      submitter."

	exit 0
    }
} else {
    puts $extractout
    foreach line [split $extractout "\n"] {
        if { [regexp {^Extracted } $line] } {
	    lappend extracted_files [lindex $line 1]
	}
    }
}

# Process problem_link_files and problem_optional_link_
# files values.
#
execute_links $problem_link_files \
              "problem_link_files value"
execute_links $problem_optional_link_files \
              "problem_optional_link_files value" 1

# Function to send reply to user containing new auto
# score.
#
proc auto_score_reply { score } {

    global needs_reply_flag_file \
	   auto_score manual_score proposed_score \
	   submitted_problem submitted_extension \
	   problem extension

    set auto_score $score
    set manual_score None
    set proposed_score None
    set submitted_problem $problem
    set submitted_extension $extension
    set return_commands [compose_response]

    if { [lcontain $return_commands EDIT] } {
	error "EDIT response instruction executed"
    }

    send_response $return_commands

    if { [lcontain $return_commands FINAL] } {
	puts "Emailed final auto-score:\
	      \    $auto_score"
    } elseif { [lcontain $return_commands NOT-FINAL] } {
	set_flag $needs_reply_flag_file
	puts "Emailed auto-score (review later):\
	      \    $auto_score"
    } elseif { [lcontain $return_commands NO-REPLY] } {
	set_flag $needs_reply_flag_file
	puts "Auto-score (NOT emailed):\
	      \    $auto_score"
    } else {
        error "bad compose_response return value"
    }
}

# should_be_made [-nodelete] file_list1 file_list2 
#
# If any file_list1 file is older than any file_list2
# file, and all file_list2 files exist, delete any
# file_list1 files that exist and return `yes'.  If some
# file_list1 file does not exist, and all file_list2
# files exist, return `yes'.  Else return `no'.  If
# -nodelete option given, suppress deleting of files.
#
#
proc should_be_made { args } {

    set nodelete \
        [expr { [lindex $args 0] == "-nodelete" }]
    set file_list1 [lindex $args end-1]
    set file_list2 [lindex $args end]

    # Set mtime1 to the oldest of the file_list1
    # mtimes, or 0 if some file_list1 file does not
    # exist.
    #
    set mtime1 0
    foreach file1 $file_list1 {
	if { [file exists $file1] } {
	    set mt [file mtime $file1]
	    if { $mt < 0 } { error "negative mtime" }
	    if { $mtime1 == 0 || $mtime1 > $mt } {
	    	set mtime1 $mt
	    }
	} else {
	    set mtime1 0
	    break
	}
    }
    # Set mtime2 to the newest of the file_list2
    # mtimes, or 0 if any file_list2 file does not
    # exist.
    #
    set mtime2 0
    foreach file2 $file_list2 {
	if { [file exists $file2] } {
	    set mt [file mtime $file2]
	    if { $mt < 0 } { error "negative mtime" }
	    if { $mtime2 < $mt } {
	    	set mtime2 $mt
	    }
	} else {
	    set mtime2 0
	    break
	}
    }

    # If mtime1 < mtime2 we need to make file_list1
    # from file_list2
    #
    if { $mtime1 < $mtime2 } {
        if { ! $nodelete } {
	    foreach file1 $file_list1 {
		if { [file exists $file1] } {
		    puts "Deleting out-of-date $file1"
		    file delete -force $file1
		}
	    }
	}
	return yes
    } else {
        return no
    }
}

# If necessary compile submitted file to produce
# binary.  If this fails, announce `Syntax Error'
# as the score.
#
if { [should_be_made \
         [list $problem $problem.cerr] \
	 [concat $linked_files \
	 	 $extracted_files]] } {

    puts "Making $problem"
    catch { make_file $problem $problem.cerr }

    # Print any non-empty .cerr file.
    #
    if { [file exists $problem.cerr] \
	 && [file size $problem.cerr] > 0 } {
	puts ""
	if { [file executable $problem] } {
	    puts "========== COMPILER WARNINGS\
	          ($problem.cerr) =========="
	} else {
	    puts "========== COMPILER ERRORS\
	          ($problem.cerr) =========="
	}
	put_file $problem.cerr stdout 10
	puts "============================="
	puts ""
    }

    # If no executable binary produced, record and
    # send `Syntax Error' reply.
    #
    if { ! [file executable $problem] } {

	puts "No executable `$problem' file produced"

	if { [file exists $auto_score_file] } {
	    file delete -force $auto_score_file
	}
	write_file $auto_score_file "Syntax Error"
	set_flag $score_flag_file
	auto_score_reply "Syntax Error"
	exit 0
    }
}

# Make .out file if necessary.
#
if { [should_be_made \
         [list $problem.out $problem.err] \
	 [concat [list $problem] \
	 	 $linked_files \
	 	 $extracted_files]] \
     && [file executable $problem] } {

    puts "Making $problem.out"
    catch { make_file $problem.out $problem.err }

    # Remove any a+x on the current directory as a
    # `best effort' security measure in the face of
    # the JAVA bug that requires .. to be a+x.
    #
    deny_access "."

    # Print any non-empty .err file.
    #
    if { [file exists $problem.err] \
	 && [file size $problem.err] > 0 } {
	puts ""
	puts "========== ERRORS ($problem.err)\
	      =========="
	put_file $problem.err stdout 10
	puts "============================="
	puts ""
    } elseif { ! [file exists $problem.out] } {
	puts "No `$problem.out' file produced"
    }
}

# Make .fout file if appropriate.
#
if { [should_be_made \
         [list $problem.fout] \
	 [concat [list $problem.out \
	               $scoring_filter_file] \
	 	 $linked_files \
	 	 $extracted_files]] \
     && [file size $problem.out] > 0 } {

    puts "Making $problem.fout"
    exec $scoring_filter_file < $problem.out \
    			      > $problem.fout
}

# Make $auto_score_file if necessary.
#
if { [file exists $scoring_filter_file] } {

    set file_list [list $problem.ftest]

    if { [file exists $problem.fout] } {
	lappend file_list $problem.fout
    }
} else {
    set file_list [list $problem.test]

    if { [file exists $problem.out] } {
	lappend file_list $problem.out
    }
}
if { [file exists $problem.err] } {
    lappend file_list $problem.err
}

# If an attempt was made to make .out, then .err must
# exist for file_list must have at least 2 elements.
#
if { [llength $file_list] >= 2 \
     && [should_be_made \
            [list $auto_score_file] \
	    $file_list] } {

    exec autoscore $problem 2>@ stderr
}

# Make $reply_file if necessary.
#
if { [should_be_made -nodelete \
         [list $reply_file] \
	 [concat [list $auto_score_file] \
	 	 $linked_files]] } {

    auto_score_reply [read_file $auto_score_file]
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
