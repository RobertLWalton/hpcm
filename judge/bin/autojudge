#!/bin/sh
#
# Compute all the files needed in a program submission
# directory in order to score a submission.
#
# File:		autojudge
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Oct  3 04:50:44 EDT 2005
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2005/10/03 08:46:34 $
#   $RCSfile: autojudge,v $
#   $Revision: 1.105 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# In this program:
#
#	PROBLEM is the problem name.
#	EXTENSION is the extension from received file
#	    Subject: submit $PROBLEM$EXTENSION ...
#	s_d is the problem solution directory.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
source $lib_directory/scoring_common.tcl
catch {

set document "
cd submission_directory
autojudge \[-manual\] \[problem\[.extension\]\
	  \[qualifier\]\]

    Given the submission directory as the current dir-
    ectory, and given that the submission directory
    contains the file `Received_Mail', this program
    makes everything needed to compute the score file,
    `Auto_Score', and then automatically computes that
    file.  This program may report the score to the sub-
    mitter by creating and sending the `Reply_Mail' file
    as specified by the `scoring_mode' global variable.

    If the -manual program option is given, it sets the
    scoring_mode to `manual' while this program is run-
    ning.  This suppresses sending email to the submit-
    ter.

    If the problem name, optional extension, and option-
    al submit qualifier are not given as arguments, they
    are extracted from the

      Subject: submit problem\[.extension\]\
      		      \[qualifier\]

    field of the message in the Received_Mail file.
    Here `problem' names the problem and the solution
    binary, and is the basename of the .in, .out, .test,
    .fout, .ftest, .jout, .jtest, jfout, jftest, .cerr,
    .err, and .score files.  If `extension' is given, it
    tells the programming language being used, and must
    be a member of the `allowed_extensions' global
    variable value, which by default is:
    
    	$allowed_extensions

    In this document the words `PROBLEM' and `EXTENSION'
    are used to denote the problem name and extension as
    given in an argument or `Subject:' field.  Also, the
    solution directory below is the problem directory
    within the solutions directory, i.e., the directory
    with name:

    	<judging_directory>/solutions/PROBLEM

    More specifically, this program makes the following
    in order:

      * `PROBLEM.rc' file, if it exists.  If it exists
        (in the problem's solution directory), it is
        sourced, and may set some of the global varibles
	mentioned below.  See the `Problem .rc Files'
	section of hpcm_judging.rc for detailed specifi-
	cation of the values of these global variables
	and their defaults.

      . Submitted files which are extracted from the
        submitted message in the Received_Mail file
        by the extractmail program.  These files must
	all be listed in the problem_required_files or
	problem_optional_files global variables.
	The default is for PROBLEM.EXTENSION to be
	the only required file if EXTENSION is not
	empty.

      . Files listed in the problem_make_files global
        variable, which gives instructions on when and
	how to make files in the problem's solution
	directory.  E.g., the Scoring_Filter program
	may be compiled there if necessary.  The
	default is to make .in, .fout, .jout, .jfout,
	.ftest, .jtest, and .jftest files whenever
	their necessary inputs exist.  This if xxx.out
	and Scoring_Filter exist, xxx.fout will be made,
	and if xxx.jin also exists, then xxx.jfout will
	be made.

      * Files listed in the problem_link_files and
        problem_optional_link_files global variables are
	linked from the problem solution directory to
	the current submission directory.  Then the
	following are linked if they do not exist in the
	submission directory and they do exist in the
	solution directory: Makefile, Scoring_Filter,
	and for each problem_input_names F, F.in,
	F.test, F.jin, F.ftest, F.jtest, F.jftest.

      . The program binary file `PROBLEM' and the
	compiler error file PROBLEM.cerr are made by
	executing `make PROBLEM' in the submission
	directory, using the Makefile.  If there is
	an error, the score is `Syntax Error', and
	autojudge terminates.

      . For each F in problem_input_names, PROBLEM.in is
        linked to F.in, PROBLEM.out is made by executing
	`make PROBLEM.out' using the Makefile, the
	standard error from make is directed to
	PROBLEM.err, and PROBLEM.out and PROBLEM.err are
	then renamed F.err and F.out.

	If F.err is non-empty after this, the score is 
	`Cpu Time Limit Exceeded', `Output Size Limit
	Exceeded', or `Program Crashed', according to
	the contents of F.err, and autojudge terminates.

	If F.out is empty or non-existent but F.err is
	empty, then the score is `Program Crashed' and
	autojudge terminates.

      . For each F in problem_input_names, F.fout is
        made if Scoring_Filter exists, F.jfout if in
	addition F.jin exists, and F.jout is made if
	F.jin exists but Scoring_Filter does not.

      . The PROBLEM.score and Auto_Score files are made.
        Whenever Auto_Score is made, the Score_Flag is
	set, a Reply_Mail file is made, and this reply
	is sent to the submitter if the scoring_mode is
	not `manual'.

    Here files marked with * are linked into the current
    submission directory from the problem's solution
    directory.
    
    In general, this program does not make a file that
    already exists, unless one of the files input to
    make the file is more recent that the file to be
    made.  So, for example, if the Received_Mail file
    is more recent than an extracted file, the files
    will be re-extracted, whereas if extracted files
    exist and are all as recent as the Received_Mail
    file, file extraction will be skipped.

    In general, this program may detect two kinds of
    errors: system errors and submitter errors.  A
    system error means the judging files are incorrectly
    set up, and a submitter error means the submitter
    sent the wrong information.  On a system error, this
    program logs the error in an error log file in the
    current directory and prints information about the
    error to the standard error output.  On a submitter
    error, this program creates a Reply_Mail file that
    contains a description of the error and sends this
    to the submitter as the final word on the submis-
    sion.  In either case this program terminates after
    reporting the error.

    Errors in extraction are classified as system errors
    if extractmail outputs the phrase `SYSTEM ERROR' and
    submitter errors otherwise.

    While making files in the problem solution direc-
    tory, program locks the solution directory with a
    Dispatch_PID file.
 
    For purposes of computing file dependencies, all
    non-extracted files made (not linked) by this pro-
    gram in the submission directory are assumed to
    depend upon all the extracted and linked files.

    When this program creates a `Reply_Mail' file is
    uses instructions in the `response_instructions'
    global variable.  This variable contains instruc-
    tions that format the reply for a given Auto_Score
    value and a given value of the scoring_mode global
    variable.  The format of the response instructions
    is described in hpcm_judging.rc, where a default
    value is also given for the `response_instructions'
    variable.
    
    With default response instructions, this program
    sends a reply if the score is `Completely Correct'
    or the scoring_mode is `auto' or `auto+manual'.  If
    the mode is `auto' or the score is `Completely Cor-
    rect', the reply is final, and is stored in the
    Reply_Mail file.  Otherwise the reply is not final,
    and informs its receiver that the score is prelim-
    inary and will be manually reviewed and possibly
    changed.  When the reply is not final, this program
    does not create a Reply_Mail file, even when it
    sends a reply (the reply is recorded in any case in
    the Reply_Mail_History file).  The absence of a
    Reply_Mail file signals that the final reply has
    not been given to the submitter, and further action
    using the `manualreply' program is necessary to gen-
    erate a final reply.

    This program prints information about its progress.
 
    Unless this program creates a Reply_Mail file that
    is intended to be the final reply to the submitter
    (e.g., because the score is `Completely Correct' or
    the scoring mode is `auto'), this program sets the
    `needs reply' flag (the Needs_Reply_Flag file in
    the flag directory).  This signals other programs
    (e.g. tracker) that they should search for submis-
    sion directories for which the manualreply program
    should be called.

    If this program writes the Auto_Score file, it also
    sets the score flag (the flag directory Score_Flag
    file), to signal that any scoreboards need to be
    recomputed.

    Problem names that contain `/' or `.' or begin with
    `-' or have no solution directory are illegal, and
    are submitter errors.  Similarly extension names
    not listed in the `allowed_extensions' global vari-
    able are unallowed and are submitter errors, as are
    misformatted Received_Mail file `Subject:' fields.
    It is a system error if the `Received_Mail' file is
    not readable, of if `extractmail' returns a system
    error.  It is a system error if an existing
    `response_instructions' global variable value is
    misformatted."

# Do not change argc or argv so error printouts will be
# correct.
#
set my_argc $argc
set my_argv $argv

# Process any -manual argument.
#
set manual 0
if { [lindex $my_argv 0] == "-manual" } {
    set manual 1
    set my_argv [lrange $my_argv 1 end]
    incr my_argc -1
}

# If too many arguments or -doc argument, print docu-
# mentation and exit.
#
if {    $my_argc > 1 \
     || [regexp {^-doc} [lindex $my_argv 0]] } {
    puts $document
    exit 1
}

# Handle submitter error in subject.
#
proc subject_error { what } {
    global message_subject
    reply "LINE {ERROR: $what\
	  	 `Subject:$message_subject'}" \
	  BLANK \
	  { LINE "THIS SUBMISSION (see below)\
	          IGNORED" } \
	  { LINE "You must resubmit with a legal\
	         message subject." } \
	  BLANK \
	  { BAR "this message replies to:" } \
	  RECEIVED-HEADER
    puts "SUBMISSION ERROR: $what in\
          `Subject:$message_subject'"
    exit 0
}

# Compute problem name and extension and submit
# qualifier.
#
if { $my_argc >= 1 } {
    set argument [lindex $my_argv 0]
    set submit_qualifier [lindex $my_argv 1]
} else {

    # Read message header.
    #
    set received_ch [open Received_Mail r]
    read_header $received_ch
    close $received_ch

    # Get problem.
    #
    if {    [catch { llength $message_subject }] \
         || [llength $message_subject] < 2 \
         || [llength $message_subject] > 3 \
	 || [lindex $message_subject 0] != "submit" } {
	subject_error "badly formatted"
    }
    set argument [lindex $message_subject 1]
    set submit_qualifier [lindex $message_subject 2]
}
set PROBLEM [file rootname $argument]
set EXTENSION [file extension $argument]

# Check legality of problem name and optional extension.
#
if {    $PROBLEM == "" \
     || [regexp {\.} $PROBLEM] \
     || [regexp {/}  $PROBLEM] \
     || [regexp {^-} $PROBLEM]  } {
    subject_error "illegal problem name `$PROBLEM' in"
}
if { $EXTENSION != "" \
     && ! [lcontain $allowed_extensions $EXTENSION] } {
    subject_error "unallowed extension `$EXTENSION'\
      (should be one of $allowed_extensions) in"
} elseif { [regexp {/} $EXTENSION] } {
    # should never happen
    error "/ in extension `$EXTENSION'"
}

# Check legality of submit qualifier.
#
if { ! [lcontain $allowed_qualifiers \
                 $submit_qualifier] } {
    subject_error \
        "unknown submit qualifier `$submit_qualifier'"
}

# Check for existence of problem solution directory.
#
set s_d $solutions_directory/$PROBLEM
if { ! [file isdirectory $s_d] } {
    subject_error "unallowed problem name `$PROBLEM' in"
}

# Global variable that is list of all files linked
# into the submission directory by autojudge.  Various
# output files depend on all these (must not be older
# than any of these).
#
set linked_files ""

# Function that links files according to the data that
# has the format of a problem_link_files global variable
# value: see hpcm_judging.rc.  Name describes the data
# for error message purposes.  Optional is 1 if links
# are options, 0 if they are required.  Exists is 1 if
# linking is suppressed when the target exists (it CAN
# be a dangling link), and 0 otherwise.  Appends files
# linked to linked_files above.
#
# The global s_d names the problem solution directory.
#
proc execute_links \
	{ data name { optional 0 } { exists 0 } } {

    global s_d linked_files

    if { [catch { llength $data }] } {
	error "bad $name, not a TCL list: $data"
    }

    foreach item $data {
	if { [catch { set length [llength $item] }] } {
	    error "bad $name element, not a TCL list:\
	           $item"
	}
	if { $length == 0 } {
	    error "bad $name element, empty TCL list"
	} elseif { $length == 1 } {
	    set source_list [lindex $item 0]
	    set target $source_list
	} else {
	    set source_list [lrange $item 1 end]
	    set target [lindex $item 0]
	}
	set source ""
	foreach file $source_list {
	    if { [file exists $s_d/$file] } {
		set source $s_d/$file
		break
	    }
	}
	if { $target == "" || [regexp {/} $target ] } {
	    error "Bad $name target in $item"
	}

	if { [catch { set type [file type $target] }] \
	            } {
	    set type none
	} elseif { $type == "link" \
		   && \
		   $source != "" \
		   && \
		   [file readlink $target] \
			 == $source } {
	    set type done
	}

	if { $type == "link" && ! $exists } {
	    puts "Deleting $target"
	    file delete -force $target
	    set type none
	}

	if { $type != "none" } {
	    if { ! [lcontain $linked_files $target] } {
		lappend linked_files $target
	    }
	} elseif { $source == "" } {
	    if { ! $optional } {
	        error "no source files exist for\
		       $item in $name"
	    }
	} else {
	    set tail [file tail $source]
	    if { $tail == $target } {
		puts "Linking $target"
	    } else {
		puts "Linking $tail to\
		      $target"
	    }
	    link_file $source $target
	    lappend linked_files $target
	}
    }
}

# Switch that is use by execute_makes to indicate that
# the s_d is locked.  If set at the end of the sequence
# of execute_makes calls, the directory must be
# unlocked.
#
set s_d_is_locked 0

# Function that makes files according to the data that
# has the format of a problem_make_files global variable
# value: see hpcm_judging.rc.  Name describes the data
# for error message purposes.
#
# The global s_d names the problem solution directory.
#
proc execute_makes { data name } {

    global s_d s_d_is_locked

    if { [catch {llength $data}] } {
	error "$name is not a TCL list: $data"
    }

    # If we need to lock the solution directory, we
    # first check to see if we can prove there is
    # nothing to do, as we do not want to lock the
    # solution directory unnecessarily.  First_target is
    # the first file that will be made if any are to be
    # made.
    #
    if { ! $s_d_is_locked } {

	# Loop through all instructions.
	#
	set first_target ""
	foreach instruction $data {
	    if { [catch {llength $instruction}] } {
		error "$name instruction is not a TCL\
		       list: $instruction"
	    }

	    # If a source file in the instruction does
	    # not exist, ignore instruction.
	    #
	    set sources [lrange $instruction 2 end]
	    set non_existant_input_found 0
	    foreach source $sources {
		if { ! [file exists $s_d/$source] } {
		    set non_existant_input_found 1
		    break
		}
	    }
	    if { $non_existant_input_found } continue

	    # If target file of the instruction does
	    # not exist, it must be made: end loop.
	    #
	    set target [lindex $instruction 0]
	    if { ! [file exists $s_d/$target] } {
		set first_target $target
		break
	    }

	    # If any source file is more recent than the
	    # target, the target must be made: end loop.
	    #
	    set mtime [file mtime $s_d/$target]
	    foreach source $sources {
		if {   [file mtime $s_d/$source] \
		     > $mtime } {
		    set first_target $target
		    break
		}
	    }
	    if { $first_target != "" } break
	}

	# If there is nothing to do, exit procedure.
	#
	if { $first_target == "" } return

	# Try repeatedly to lock the solution directory,
	# but if this fails after a while, just give up
	# and call error.
	#
	set seconds 0
	set limit 120
	set sleep 2
	set step 5
	# puts's are at step * sleep second intervals
	#
	while { "yes" } {
	    if { [dispatch_lock $s_d] } {
	    	break
	    } elseif { $seconds >= $limit } {
		error "CANNOT LOCK $s_d:\
		       giving up on making\
		       $first_target"
	    } elseif { $seconds == 0 } {
	    	# do nothing
	    } elseif { $seconds == $step * $sleep } {
	        puts "Waiting for $s_d lock"
	    } elseif { $seconds \
		       % ( $step * $sleep ) == 0 } {
	        puts "....will wait\
		      [expr $limit - $seconds]\
		      more seconds"
	    }
	    sleep $sleep
	    incr seconds $sleep
	}
	puts "Locked $s_d"
	set s_d_is_locked 1
    }

    # Execute each instruction if neccssary.
    #
    foreach instruction $data {

    	# Note: we may not have done this check above.
	#
	if { [catch {llength $instruction}] } {
	    error "$name instruction is not a TCL list:\
	           $instruction"
	}

	# If a source file in the instruction does
	# not exist, ignore instruction.
	#
	set sources [lrange $instruction 2 end]
	set non_existant_input_found 0
	foreach source $sources {
	    if { ! [file exists $s_d/$source] } {
		set non_existant_input_found 1
		break
	    }
	}
	if { $non_existant_input_found } continue

	set target [lindex $instruction 0]
	if { [file exists $s_d/$target] } {

	    # If target file exists and no source file
	    # is more recent, skip instruction.
	    #
	    set mtime [file mtime $s_d/$target]
	    set skip 1
	    foreach source $sources {
		if {   [file mtime $s_d/$source] \
		     > $mtime } {
		    set skip 0
		    break
		}
	    }
	    if { $skip } continue
	}

	if { [llength $instruction] == 1 } {
	    set command "make $target"
	} else {
	    set command [lindex $instruction 1]
	}
	puts "Making $target by executing $command"
	exec_in_directory $s_d $command >&@ stdout
    }
}

# Source any PROBLEM.rc file.
#
execute_links $PROBLEM.rc \
              "initial problem .rc file linking" 1
if { [file exists $PROBLEM.rc] } {
    source_file $PROBLEM.rc
}

# Force scoring mode if there was a -manual option.
#
if { $manual } {
    set scoring_mode manual
}

# List of all files extracted by extractmail.
#
set extracted_files ""

# Extract submitted files.  If error, if SYSTEM ERROR
# call `error' function and otherwise reply to submit-
# ter.  Compute list of extracted files in `extracted_
# files'.
#
if { [catch { exec extractmail } extractout] } {
    if { [regexp {SYSTEM ERROR} $extractout] } {
        error "System error during\
	       extractmail:\n\n$extractout"
    } else {

	# Create a reply file complaining of an extrac-
	# tion error, and email this reply to the
	# submitter.  Include the submission email in
	# the reply.
	#
	reply {LINE "ERROR during file extraction:" } \
	      BLANK \
	      [list LINES $extractout] \
	      BLANK \
	      { LINE "THIS SUBMISSION (see below)\
	              IGNORED" } \
	      { LINE "YOU MUST RESUBMIT" } \
	      BLANK \
	      { BAR "this message replies to:" } \
	      RECEIVED-FULL-HEADER \
	      BLANK \
	      RECEIVED-BODY

	puts $extractout
	puts "Reply indicating error has been emailed\
	      to submitter."

	exit 0
    }
} else {
    puts $extractout
    foreach line [split $extractout "\n"] {
        if { [regexp {^Extracted } $line] } {
	    lappend extracted_files [lindex $line 1]
	}
    }
}

# Execute problem_make_files instructions if any.
#
if { [info exists problem_make_files] } {
    execute_makes $problem_make_files \
    		  "problem_make_files value"
}

# Compute list of input names from problem_input_names
# or from existing files.
#
if { [info exists problem_input_names] } {
    set input_names $problem_input_names
} else {

    # Make default list, which contains names F such
    # that F.in or F.jin exist.  Eliminate duplicates.
    # Do not list $PROBLEM.in if any other names found,
    # as it should be just a link to another .in name
    # in that case.
    #
    set input_names ""
    set problem_in_found 0
    foreach name [glob -nocomplain "$s_d/*"] {
	set tail [file tail $name]
	if { $tail == "$PROBLEM.in" } {
	    set problem_in_found 1
	    continue
	}

	set ext [file extension $tail]
	set root [file rootname $tail]
	if { ! [lcontain  {.in .jin} $ext] } continue
	if { [lcontain $input_names $root] } continue
	lappend input_names $root
    }
    if {    $problem_in_found \
	 && [llength $input_names] == 0 } {
	lappend input_names $PROBLEM
    }
    set input_names [lsort $input_names]
}

# Set switch for future reference.
#
set scoring_filter_exists \
    [file exists $s_d/Scoring_Filter]

# Make .in files from .jin files.
#
# If Scoring_Filter exists, make .fout files from .out
# files, .ftest files from .test files, .jfout files
# from .fout files, .jftest files from .ftest files.
#
# If Scoring Filter does not exist, make .jout files
# from .out files and .jtest files from .test files>
#
set instructions ""
foreach name $input_names {
    lappend instructions \
            "$name.in {jfilter $name.jin $name.in}\
	              $name.jin"
    if { $scoring_filter_exists } {
	lappend instructions \
		"$name.fout\
		 {Scoring_Filter $name.in <$name.out\
		                 >$name.fout}\
	         Scoring_Filter $name.in $name.out" \
		"$name.ftest\
		 {Scoring_Filter $name.in <$name.test\
		                 >$name.ftest}\
	         Scoring_Filter $name.in $name.test" \
		"$name.jfout\
		 {jfilter $name.jin $name.fout\
		          $name.jfout}\
		 $name.jin $name.fout" \
		"$name.jftest\
		 {jfilter $name.jin $name.ftest\
		          $name.jftest}\
		 $name.jin $name.ftest"
    } else {
	lappend instructions \
		"$name.jout\
		 {jfilter $name.jin $name.out\
		          $name.jout}\
		 $name.jin $name.out" \
		"$name.jtest\
		 {jfilter $name.jin $name.test\
		          $name.jtest}\
		 $name.jin $name.test"
    }
}
execute_makes $instructions \
	      "autojudge generated instructions"

if { $s_d_is_locked } {
    dispatch_unlock $s_d
    puts "Unlocked $s_d"
}

# Execute problem_link_files instructions if any.
# Otherwise execute default.
#
if { [info exists problem_link_files] } {
    execute_links $problem_link_files \
    		  "problem_link_files value"
}
# Execute problem_optional_link_files instructions if
# any.
#
if { [info exists problem_optional_link_files] } {
    execute_links $problem_optional_link_files \
    		  "problem_optional_link_files value" 1
}

# Link everything that does not exist that we need.
# These links are not optional, but should not be done
# if target exists.
#
set instructions ""
lappend instructions \
	" Makefile Makefile$EXTENSION Makefile "
if { $scoring_filter_exists } {
    lappend instructions " Scoring_Filter "
}
foreach name $input_names {
    set jin_exists [file exists $s_d/$name.jin]
    lappend instructions \
            $name.in \
	    " $name.test $name.out $name.test "
    if { $jin_exists } {
	lappend instructions $name.jin
    }
    if { $scoring_filter_exists } {
	lappend instructions \
	    " $name.ftest $name.fout $name.ftest "
	if { $jin_exists } {
	    lappend instructions \
		" $name.jftest $name.jfout\
		                $name.jftest "
	}
    } elseif { $jin_exists } {
	lappend instructions \
	    " $name.jtest $name.jout $name.jtest "
    }
}
execute_links $instructions \
              "autojudge generated required link\
	       instructions" \
	      0 1

# Function to send reply to user containing new auto
# score.
#
proc auto_score_reply { score { marker "" } } {

    global auto_score auto_score_marker \
           manual_score proposed_score \
	   submitted_problem submitted_extension \
	   PROBLEM EXTENSION

    if { [file exists Auto_Score] } {
	puts "Deleting out-of-date Auto_Score"
	file delete -force Auto_Score
    }
    switch { [llength $marker] } {
        0 { set s $score }
	1 { set s "[lindex $marker 0]: $score" }
	default { set s "[join $marker :] $score" }
    }
    write_file Auto_Score $s
    set_flag Score_flag

    set auto_score $score
    set auto_score_marker $marker
    set manual_score None
    set proposed_score None
    set submitted_problem $PROBLEM
    set submitted_extension $EXTENSION
    set return_commands [compose_response]

    if { [lcontain $return_commands EDIT] } {
	error "EDIT response instruction executed"
    }

    send_response $return_commands

    if { [lcontain $return_commands FINAL] } {
	puts "Emailed final auto-score:\
	      \    $auto_score"
    } elseif { [lcontain $return_commands NOT-FINAL] } {
	set_flag Needs_Reply_Flag
	puts "Emailed auto-score (review later):\
	      \    $auto_score"
    } elseif { [lcontain $return_commands NO-REPLY] } {
	set_flag Needs_Reply_Flag
	puts "Auto-score (NOT emailed):\
	      \    $auto_score"
    } else {
        error "bad compose_response return value"
    }
}

# should_be_made [-nodelete] file_list1 file_list2 
#
# If any file_list1 file is older than any file_list2
# file, and all file_list2 files exist, delete any
# file_list1 files that exist and return `yes'.  If some
# file_list1 file does not exist, and all file_list2
# files exist, delete any file_list1 files that do exist
# and return `yes'.  Else return `no'.  If -nodelete
# option given, suppress deleting of files.
#
#
proc should_be_made { args } {

    set nodelete \
        [expr { [lindex $args 0] == "-nodelete" }]
    set file_list1 [lindex $args end-1]
    set file_list2 [lindex $args end]

    # Set mtime1 to the oldest of the file_list1
    # mtimes, or 0 if some file_list1 file does not
    # exist.
    #
    set mtime1 0
    foreach file1 $file_list1 {
	if { [file exists $file1] } {
	    set mt [file mtime $file1]
	    if { $mt < 0 } { error "negative mtime" }
	    if { $mtime1 == 0 || $mtime1 > $mt } {
	    	set mtime1 $mt
	    }
	} else {
	    set mtime1 0
	    break
	}
    }
    # Set mtime2 to the newest of the file_list2
    # mtimes, or 0 if any file_list2 file does not
    # exist.
    #
    set mtime2 0
    foreach file2 $file_list2 {
	if { [file exists $file2] } {
	    set mt [file mtime $file2]
	    if { $mt < 0 } { error "negative mtime" }
	    if { $mtime2 < $mt } {
	    	set mtime2 $mt
	    }
	} else {
	    set mtime2 0
	    break
	}
    }

    # If mtime1 < mtime2 we need to make file_list1
    # from file_list2
    #
    if { $mtime1 < $mtime2 } {
        if { ! $nodelete } {
	    foreach file1 $file_list1 {
		if { [file exists $file1] } {
		    puts "Deleting out-of-date $file1"
		    file delete -force $file1
		}
	    }
	}
	return yes
    } else {
        return no
    }
}

# If necessary compile submitted file to produce
# binary.  If this fails, announce `Syntax Error'
# as the score.
#
if { [should_be_made \
         [list $PROBLEM $PROBLEM.cerr] \
	 [concat $linked_files \
	 	 $extracted_files]] } {

    puts "Making $PROBLEM"
    catch { make_file $PROBLEM $PROBLEM.cerr }

    # Print any non-empty .cerr file.
    #
    if { [file exists $PROBLEM.cerr] \
	 && [file size $PROBLEM.cerr] > 0 } {
	puts ""
	if { [file executable $PROBLEM] } {
	    puts "========== COMPILER WARNINGS\
	          ($PROBLEM.cerr) =========="
	} else {
	    puts "========== COMPILER ERRORS\
	          ($PROBLEM.cerr) =========="
	}
	put_file $PROBLEM.cerr stdout 10
	puts "============================="
	puts ""
    }

    # If no executable binary produced, record and
    # send `Syntax Error' reply.
    #
    if { ! [file executable $PROBLEM] } {
	puts "No executable `$PROBLEM' file produced"
	foreach name $input_names {
	    file delete -force -- \
	         $name.err $name.out $name.fout \
		           $name.jout $name.fjout
	}
	auto_score_reply "Syntax Error"
	exit 0
    }
}

# Make .out and .err files as necessary.
#
foreach name $input_names {
    if { [should_be_made \
	     [list $name.out $name.err] \
	     [concat [list $name] \
		     $linked_files \
		     $extracted_files]] \
	 && [file executable $PROBLEM] } {

	if { $name != $PROBLEM } {
	    puts "Linking $name.in to $PROBLEM.in"
	    file delete -force $name.in
	    link_file $name.in $PROBLEM.in
	}
	file delete -force \
	     $PROBLEM.out $PROBLEM.err $PROBLEM.fout
	puts "Making $PROBLEM.out and $PROBLEM.err"
	catch { make_file $PROBLEM.out $PROBLEM.err }

	# Remove any a+x on the current directory as a
	# `best effort' security measure in the face of
	# the JAVA bug that requires .. to be a+x.
	#
	deny_access "."

	# Print any non-empty .err file.
	#
	if {    [file exists $name.err] \
	     && [file size $name.err] > 0 } {
	    puts ""
	    puts "========== ERRORS ($name.err)\
		  =========="

	    set error_fd [open $name.err r]
	    set count 0
	    set score ""
	    while { "yes" } {
		set line [gets $error_fd]
		if { [eof $error_fd] } break
		if { [regexp -nocase -- \
			     $time_limit_regexp \
			     $line] } {
		    set score "Cpu Time Limit Exceeded"
		} elseif { [regexp -nocase -- \
			     $output_limit_regexp \
			     $line] } {
		    set score \
		        "Output Size Limit Exceeded"
		}
		if { $count < 10 } { puts $line }
		incr count
	    }
	    close $error_fd

	    if { $score == "" } {
		set score "Program Crashed"
	    }

	    puts "============================="
	    puts ""
	    auto_score_reply $score [list $name]
	    exit 0
	} elseif { ! [file exists $name.out] } {
	    puts "No `$name.out' file produced"
	    auto_score_reply "Program Crashed" \
	    		     [list $name]
	    exit 0
	} elseif { [file size $name.out] == 0 } {
	    puts "Empty `$name.out' file produced"
	    auto_score_reply "Program Crashed" \
	    		     [list $name]
	    exit 0
	}

	if { $name != $PROBLEM } {
	    foreach ext {out err} {
		if { [file exists $PROBLEM.$ext] } {
		    puts "Renaming $PROBLEM.$ext to\
			  $name.$ext"
		    file delete -force -- $name.$ext
		    file rename $PROBLEM.$ext $name.$ext
		}
	    }
	}
    }
}

# Do a system check that all .out files exist and are
# non-empty and all .err files do not exist or are
# empty.
#
foreach name $input_names {
    if { ! [file exists $name.out] } {
        error "File $name.out should exist"
    }
    if { [file size $name.out] == 0 } {
        error "File $name.out should be non-empty"
    }
    if { ! [file exists $name.err] } continue
    if { [file size $name.err] == 0 } continue
    error "File $name.err should no exist or be empty"
}


# Make .fout, .jout, or .jfout files as appropriate.
#
foreach name $input_names {
    if { $scoring_filter_exists } {
	if { [should_be_made \
		 [list $name.fout] \
		 [list Scoring_Filter $name.out]] } {

	    puts "Making $name.fout"
	    exec Scoring_Filter $name.in \
	         < $name.out > $name.fout
	}
	if { [should_be_made \
		 [list $name.jfout] \
		 [list $name.jin $name.fout]] } {

	    puts "Making $name.jfout"
	    exec jfilter $name.in $name.fout $name.jfout
	}
    } else {
	if { [should_be_made \
		 [list $name.jout] \
		 [list $name.out $name.jin]] } {

	    puts "Making $name.jout"
	    exec jfilter $name.jin $name.out $name.jout
	}
    }
}

# Make .*score files and compute Auto_Score.
#
# Do not try to be efficient in the case where not
# everything needs to be computed, as that is an
# exceptional case.
#
# Compute the mtime of the most recent .*score file for
# use in deciding whether to recompute the Auto_Score
# file.
#
set score_mtime 0
#
# The following variables hold the first marker found
# for the indicated score.
#
set incorrect_output ""
set incomplete_output ""
set formatting_error ""
#
foreach name $input_names {
    if { [file exists $name.jin] } {
        set jin_instructions [exec jfilter $name.jin]
	set jin_instructions \
	    [string trim $jin_instructions]
	if { $jin_instructions == "none" } {
	    compute_instruction_array \
		$scoring_instructions \
		"scoring_instructions variable value"
	} else {
	    compute_instruction_array \
		$jin_instructions "$name.jin file"
	}
	if { $scoring_filter_exists } {
	    if { [should_be_made [list $name.jfscore] \
		    [list $name.jfout $name.jftest]] } {
		compute_score_file \
		    $name.jfout $name.jftest \
		    $name.jfscore -filtered
	    }
	    set score_file $name.jfscore
	} else {
	    if { [should_be_made [list $name.jscore] \
		      [list $name.jout $name.jtest]] } {
		compute_score_file \
		    $name.jout $name.jtest \
		    $name.jscore -filtered
	    }
	    set score_file $name.jscore
	}
    } else {
	compute_instruction_array \
	    $scoring_instructions \
	    "scoring_instructions variable value"
	if { $scoring_filter_exists } {
	    if { [should_be_made [list $name.fscore] \
		      [list $name.fout $name.ftest]] } {
		compute_score_file \
		    $name.fout $name.ftest $name.fscore
	    }
	    set score_file $name.fscore
    	} else {
	    if { [should_be_made [list $name.score] \
		      [list $name.out $name.test]] } {
		compute_score_file \
		    $name.out $name.test $name.score
	    }
	    set score_file $name.score
	}
    }
    if { ! [file exists $score_file] } {
        error "$score_file does not exist - maybe\
	       correspondence problem between .*test\
	       and .*out files"
    }
    set mtime [file mtime $score_file]
    if { $mtime > $score_mtime } {
        set score_mtime $mtime
    }

    compute_score_and_proof_arrays $score_file
    compute_score
    foreach x {incorrect_output incomplete_output\
	       formatting_error} {
	set marker [set ${x}_marker]
	if { $marker != "" && [set $x] == "" } {
	    set $x [concat [list $score_file] \
	    		   [lrange $marker 0 1]]
	}
    }
}

if {    [file exists Auto_Score] \
     &&    [file mtime Auto_Score] \
        >= $score_mtime } {
    # do nothing
} elseif { $incorrect_output != "" } {
    auto_score_reply \
        "Incorrect Output" $incorrect_output
} elseif { $incomplete_output != "" } {
    auto_score_reply \
        "Incomplete Output" $incomplete_output
} elseif { $formatting_error != "" } {
    auto_score_reply \
        "Formatting Error" $formatting_error
} else {
    auto_score_reply "Completely Correct"
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
