#!/bin/sh
#
# Compute all the files needed in a program submission
# directory in order to score a submission.
#
# File:		autojudge
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Mon Nov 19 04:45:13 EST 2001
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: hc3 $
#   $Date: 2001/11/19 09:45:47 $
#   $RCSfile: autojudge,v $
#   $Revision: 1.36 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
catch {

set document "
cd submission_directory
autojudge \[problem\[.extension\]\]

    Given the submission directory as the current dir-
    ectory, and given that the submission directory
    contains the file `$received_file', this program
    makes everything needed to compute the score file,
    `$auto_score_file', and automatically computes that
    file.  Then this program may report the score to the
    submitter by creating and sending `$reply_file' as
    specified by the scoring mode.

    If the the problem name and optional extension is
    not given as an argument, it is extracted from the

    	Subject: problemname\[.extension\]

    field of the message in the $received_file file. \
    	The
    `problem' names the problem and the solution binary,
    and is the basename of the .in, .out, .test, .cerr,
    .err, and .score files.  The extension, if given,
    tells the language being used, and must be a member
    of the `allowed_extensions' global variable value,
    which by default is:
    
    	$allowed_extensions

    Specifically, this program makes the following in
    order:

	$files_file file, if it exists
	the submitted files by calling extractmail
	$make_file file
	$scoring_instructions_file file, if it exists
	.in solution input file
	.test solution output file
	the program binary (and .cerr file)
	the .out file (and .err file)
	the .score file
	the $auto_score_file file
	the $reply_file file, sometimes

    If any of these files exists, this program checks to
    be sure it is not older than the previous files
    (starting with the submitted file not being older
    than the $received_file file), and remakes any of
    the above files that are out-of-date.  Errors in
    making the program binary can cause $auto_score_file
    and maybe $reply_file to be generated early.

    First, this program verifies the existence of a so-
    lution directory for the problem and symbolically
    links the $files_file file from this directory into
    the current directory, if that file exists.  Then
    this program calls `extractmail' to extract the
    submitted files from the program.  If there is a
    non-system error in this extraction, this program
    generates and sends `$reply_file' automatically to
    the submitter.

    If the extraction had no errors, this program sym-
    bolically links the following solution directory
    files into the current directory:

    	$make_file
	$scoring_instructions_file if it exists
	.in solution input file
	.test solution output file

    In the solution directory, the `$files_file' file\
    may be present in several forms under names of the
    form `$files_file.extension'.  If one of these forms
    has an extension matching that given with the pro-
    blem name, it is linked into the current directory
    under the name `$files_file'.  Otherwise there is an
    error.  The `$make_file' file is treated similarly.

    The .test file is linked to the solution .out file
    if that exists, or the solution .test file other-
    wise.  If the solution .out file exists and the
    the current directory .test file is linked to the
    solution directory .test file, the current directory
    .test file is relinked to the solution .out file.
    Thus the solution .out file always has preference
    over the solution .test file.

    Next this program makes the program binary by using
    the $make_file.  Any compiler error messages are
    captured in a .cerr file.  If no executable binary
    is made, this program writes `Syntax Error' into the
    $auto_score_file file, and skips to the end of this
    program where a $reply_file file containing the auto
    score may be created and sent to the user.

    If an executable binary file was made, this program
    makes a .out output file by using the $make_file,
    and captures any error output in a .err file.  Then
    this program runs `autoscore' to produce a .score
    file and an automatic score in the $auto_score_file
    file.  Any .score file will be not produced (and
    even deleted if it exists) if the score can be
    determined without it, i.e., if the score is deter-
    mined by the .err file or if the .out file does not
    exist or is empty.

    Lastly, this program may create a `$reply_file'
    and send it as email to the submitter.  It does this
    if the score is `Completely Correct' or the scoring_
    mode is `auto' or `auto+manual'.  If the mode is
    `auto+manual' and the score is not `Completely Cor-
    rect', the email informs its receiver that the score
    is preliminary and will be manually reviewed and
    possibly changed.
    
    If the score is to be manually reviewed, this prog-
    ram does not create a $reply_file file, even when it
    sends a reply (the reply is recorded in any case in
    the $reply_history_file file).  The absence of a
    $reply_file file signals that the final reply has
    not been given to the submitter, and further manual
    action is necessary to generate this reply.

    This program prints information about its progress.

    Unless this program creates a $reply_file file that
    is intended to be the final reply to the submitter
    (because the score is `Completely Correct' or the
    scoring mode is `auto'), this program sets the
    `needs reply' flag (the $needs_reply_flag_file\
    			file in
    the flag directory).  This signals other programs
    (e.g. tracker) that they should search for submis-
    sion directories for which the manualreply program
    should be called.

    If this program (because of a `Syntax Error') or the
    `autoscore' program writes the $auto_score_file\
    	file,
    the program will set the score flag (the flag direc-
    tory $score_flag_file file), to signal that any\
	score-
    boards need to be recomputed.

    If something goes very wrong, such as finding that
    the `$received_file' file is not readable, or having
    `extractmail' return a system error, this program
    creates an error log file in the current directory,
    prints information about the error to the standard
    error output, and exits with exit code 0."

# If too many arguments or -doc argument, print docu-
# mentation and exit.
#
if { $argc > 1 || [regexp {^-doc} [lindex $argv 0]] } {
    puts $document
    exit 1
}

# Compute problem name.
#
if { $argc == 1 } {
    set argument [lindex $argv 0]
} else {

    # Read message header.
    #
    set received_ch [open $received_file r]
    read_header $received_ch
    close $received_ch

    # Get problem.
    #
    if {    [llength $message_subject] != 2 \
	 || [lindex $message_subject 0] != "submit" } {
	error "Illegal message subject:\
	      $message_subject"
    }
    set argument [lindex $message_subject 1]
}
set problem [file rootname $argument]
set extension [file extension $argument]

# Signal error if bad problem name or extension.
#
proc argument_error {} {
    global argument
    reply \
          "ERROR: problem name is illegal: $problem" \
	  ""  \
	  "THIS SUBMISSION (see below) IGNORED"  \
	  "YOU MUST RESUBMIT WITH A LEGAL PROBLEM NAME"
    puts "SUBMISSION ERROR: problem name or extension\
          is illegal: $argument"
    exit 0
}

# Check legality of problem name and optional extension.
#
if {    $problem = "" \
     || [regexp {\.} $problem] \
     || [regexp {/} $problem] \
     || [regexp {^-} $problem]  } {
    argument_error
}
if { $extension != "" \
     && [lsearch -exact $allowed_extensions \
     			$extension] < 0 } {
    argument_error
}


# Compute names.
#
set submitted_program $problem
set program_solution \
    $solutions_directory/$submitted_program

# Check for existence of problem solution directory.
#
if { ! [file isdirectory $program_solution] } {
    argument_error
}

# Line $files_file or $make_file if possible.
#
proc link_optional_file { name } {

    global extension program_solution

    if { [file readable $name] } return

    if { [file exists $program_solution/$name] } {
	puts "Linking $name"
	link_file $program_solution/$name
	return
    } 
    if { [file exists \
               $program_solution/$name.$extension] } {
	puts "Linking $name.$extension to $name"
	link_file $program_solution/$name.$extension \
		  $name
    }

    if { [llength [glob -nocomplain $name.*]] > 0 } {
        argument_error
    }
}

# Link in any $files_file.
#
link_optional_file $files_file

# Get submitted files.  If error, on SYSTEM ERROR pass
# to `error' function and otherwise reply to submitter.
#
if { [catch { exec extractmail } extractout] } {
    if { [regexp {SYSTEM ERROR} $extractout] } {
        error "System error during\
	       extractmail:\n\n$extractout"
    } else {

	# Create a reply file complaining of an extrac-
	# tion error, and email this reply to the
	# submitter.  Include the submission email in
	# the reply.
	#
	reply -all \
            "ERROR during file extraction:" \
	    "" \
	    $extractout \
	    "" \
	    "THIS SUBMISSION (see below) IGNORED" \
	    "YOU MUST RESUBMIT"

	puts $extractout
	puts "Reply indicating error emailed to\
	     submitter."

	exit 0
    }
} else {
    puts $extractout
}

# Link $make_file, etc.
#
link_optional_file $make_file

set sif $scoring_instructions_file
if { ! [file readable $sif] \
     && [file exists $program_solution/$sif] } {
    puts "Linking $sif"
    link_file $program_solution/$sif
}

if { ! [file readable $submitted_program.in] } {
    puts "Linking $submitted_program.in"
    link_file \
         $program_solution/$submitted_program.in
}

set solout \
    $program_solution/$submitted_program.out
set soltest \
    $program_solution/$submitted_program.test
if { ! [file readable $submitted_program.test] \
     || ( [file readable $solout] \
          && [file extension \
	           [file readlink \
		         $submitted_program.test]] \
	     == ".test" ) } {
    if { ! [catch { file type \
                         $submitted_program.test \
			 }] } {
	puts "Deleting obsolete\
	      $submitted_program.test"
	file delete -force $submitted_program.test
    }
    if { [file readable $solout] } {
	puts "Linking $submitted_program.test to\
	      solution $submitted_program.out"
	link_file $solout $submitted_program.test
    } else {
	puts "Linking $submitted_program.test"
	link_file $soltest
    }
}

# Send reply to user containing new auto score.
#
proc auto_score_reply { auto_score } {

    global scoring_mode reply_file submitted_file \
           needs_reply_flag_file

    if { $auto_score == "Completely Correct" \
         || $scoring_mode == "auto" } {
	reply "For $submitted_file the automatically\
	       determined final score is:" \
	      "" \
	      "    $auto_score"
	puts "Emailed final auto-score:\
	      \    $auto_score"
    } elseif { [regexp {auto} $scoring_mode] } {
	compose_reply \
              "For $submitted_file the automatically\
	       determined score is:" \
	      "" \
	      "    $auto_score" \
	      "" \
	      "However, this score WILL BE REVIEWED by\
	       the human judge (soon)."
	send_reply -notfinal
	set_flag $needs_reply_flag_file
	puts "Emailed auto-score (review later):\
	      \    $auto_score"
    } else {
	set_flag $needs_reply_flag_file
	puts "Auto-score (NOT emailed):\
	      \    $auto_score"
    }
}

# should_be_made file_list1 file_list2 
#
# If any file_list1 file is older than any file_list2
# file, and all file_list2 files exist, delete any
# file_list1 files that exist and return `yes'.  If no
# file_list1 files exists and all file_list2 files
# exist, return `yes'.  Else return `no'.
#
#
proc should_be_made { file_list1 file_list2 } {

    # Set mtime1 to the oldest of the file_list1
    # mtimes, or 0 if no file_list1 file exists.
    #
    set mtime1 0
    foreach file1 $file_list1 {
	if { [file exists $file1] } {
	    set mt [file mtime $file1]
	    if { $mtime1 == 0 || $mtime1 > $mt } {
	    	set mtime1 $mt
	    }
	}
    }
    # Set mtime2 to the newest of the file_list2
    # mtimes, or 0 if any file_list2 file does not
    # exist.
    #
    set mtime2 0
    foreach file2 $file_list2 {
	if { [file exists $file2] } {
	    set mt [file mtime $file2]
	    if { $mtime2 < $mt } {
	    	set mtime2 $mt
	    }
	} else {
	    set mtime2 0
	    break
	}
    }

    # If mtime1 < mtime2 we need to make file_list1
    # from file_list2
    #
    if { $mtime1 < $mtime2 } {
    	foreach file1 $file_list1 {
	    if { [file exists $file1] } {
	        puts "Deleting out-of-date $file1"
		file delete -force $file1
	    }
	}
	return yes
    } else {
        return no
    }
}

# If necessary compile submitted file to produce
# binary.  If this fails, announce `Syntax Error'
# as the score.
#
if { [should_be_made \
         [list $submitted_program \
	       $submitted_program.cerr] \
	 [list $make_file \
	       $submitted_file]] } {

    puts "Making $submitted_program"
    catch { make_file $submitted_program \
    		      $submitted_program.cerr }

    # Print any non-empty .cerr file.
    #
    if { [file exists $submitted_program.cerr] \
	 && [file size $submitted_program.cerr] \
	    > 0 } {
	puts ""
	if { [file executable $submitted_program] } {
	    puts "========== COMPILER WARNINGS\
	          ($submitted_program.cerr)\
		  =========="
	} else {
	    puts "========== COMPILER ERRORS\
	          ($submitted_program.cerr)\
		  =========="
	}
	put_file $submitted_program.cerr stdout 10
	puts "============================="
	puts ""
    }

    # If no executable binary produced, record and
    # send `Syntax Error' reply.
    #
    if { ! [file executable $submitted_program] } {

	puts "No executable `$submitted_program' file\
	      produced"

	if { [file exists $auto_score_file] } {
	    file delete -force $auto_score_file
	}
	write_file $auto_score_file "Syntax Error"
	set_flag $score_flag_file
	auto_score_reply "Syntax Error"
	exit 0
    }
}

# Make .out file if necessary.
#
if { [should_be_made \
         [list $submitted_program.out \
	       $submitted_program.err] \
	 [list $submitted_program \
	       $make_file \
	       $submitted_program.in]] \
     && [file executable $submitted_program] } {

    puts "Making $submitted_program.out"
    catch { make_file $submitted_program.out \
		      $submitted_program.err }

    # Remove any a+x on the current directory as a
    # `best effort' security measure in the face of
    # the JAVA bug that requires .. to be a+x.
    #
    deny_access "."

    # Print any non-empty .err file.
    #
    if { [file exists $submitted_program.err] \
	 && [file size $submitted_program.err] \
	      > 0 } {
	puts ""
	puts "========== ERRORS\
	      ($submitted_program.err) =========="
	put_file $submitted_program.err stdout 10
	puts "============================="
	puts ""
    } elseif { ! [file exists \
                       $submitted_program.out] } {
	puts "No `$submitted_program.out' file\
	      produced"
    }
}

# Make $auto_score_file if necessary.
#
set file_list [list $submitted_program.test]

if { [file exists $submitted_program.out] } {
    lappend file_list $submitted_program.out
}
if { [file exists $submitted_program.err] } {
    lappend file_list $submitted_program.err
}

if { [llength $file_list] >= 2 \
     && [should_be_made \
            [list $auto_score_file] \
	    $file_list] } {

    exec autoscore $submitted_program 2>@ stderr
}

# Make $reply_file if necessary.
#
if { [should_be_made \
         [list $reply_file] \
	 [list $auto_score_file]] } {

    auto_score_reply [read_file $auto_score_file]
}

exit 0

# Include common error catching code:
#
} caught_output
caught_error
