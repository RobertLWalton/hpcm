#!/bin/sh
#
# Compute all the files needed in a program submission
# directory in order to score a submission.
#
# File:		autojudge
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Fri Jan 13 02:54:08 EST 2017
#
#   vi:filetype=tcl
#
# The next lines start tclsh \
trap "echo autojudge: Terminated by Signal" \
    HUP INT QUIT; \
tclsh "$0" "$@"; exit $status

# In this program:
#
#	PROBLEM is the problem name.
#	EXTENSION is the extension from received file
#	    Subject: submit $PROBLEM$EXTENSION ...
#	s_d is the problem solution directory.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source $lib_directory/judging_common.tcl
source $lib_directory/scoring_common.tcl
catch {

set document "
cd submission_directory
autojudge \[-rerun|-manual\] 

    Given the submission directory as the current dir-
    ectory, and given that the submission directory
    contains the file `Received_Mail', this program
    makes everything needed to compute the score file,
    `Auto_Score', and then automatically computes that
    file.  This program may report the score to the sub-
    mitter by creating and sending the `Reply_Mail' file
    as specified by the `scoring_mode' global variable.

    If the -manual program option is given, it sets the
    scoring_mode to `manual' while this program is run-
    ning.  This suppresses sending email to the submit-
    ter.

    If the -rerun option is given, this sets scoring_
    mode to `manual' and does the following:

        Pre-Processing (before everything else):

	    If Auto_Score exists and Old_Auto_Score does
	    not, rename Auto_Score to Old_Auto_Score.
	    Then delete all files except
	    
	      Received_Mail     No_Reply,
	      Reply_Mail        Reply_Mail_History
	      Old_Auto_Score    Manual_Score,
	      autodispatch.log  autodispatch.log-history

	Post-Processing (after everything else):

	    If Old_Auto_Score and Auto_Score both exist
	    and are equal, delete Old_Auto_Score.

    The `Auto_Score' file consists of one line with one
    of the following forms:

     Completely Correct
     Syntax Error
     <file>:<group>:<case>: Incorrect Output
     <file>:<group>:<case>: Cpu Time Limit Exceeded
     <file>:<group>:<case>: Output Size Limit Exceeded
     <file>:<group>:<case>: Program Crashed
     <file>:<group>:<case>: Incomplete Output
     <file>:<group>:<case>: Formatting Error

    Here <file> is the name of the .*score file (e.g., 
    count.jscore), and <group> and <case> are the group
    number and case number to be given to jfilter to
    locate the associated judge's input and output.
    Here <group> or <case> may be 0 if they are missing
    because they cannot be computed (e.g., no .jin file,
    or no groups in the input).

    The first error to occur determines the score,
    except in the case of Formatting Error, which is
    ignored if there is some other error.  The .*score
    file reports a <group> and <case> for both the
    .*out and .*test files that are being compared, so
    there are two possible values of <group> and <case>
    that could be reported.  The smaller is reported for
    `Incorrect Output' and `Formatting Error', and the
    larger for the other errors.

    The `Cpu Time Limit Exceeded', `Output Size Limit
    Exceeded', and `Program Crashed' scores are reported
    only if a .out file is empty or a .err file is non-
    empty.  `Cpu Time Limit Exceeded' is reported if the
    `time_limit_regexp' global variable value matches
    (ignoring case) some part of some line in a .err
    file.  Similarly `Output Size Limit Exceeded' is re-
    ported if the `output_limit_regexp' global variable
    value matches (ignoring case) some part of some line
    in a .err file.  Otherwise `Program Crashed' is re-
    ported if a .err file is non-empty.  `Program
    Crashed' is also reported if a .out file is empty.
    `Incomplete Output' is reported only if a .out file
    is non-empty but incomplete and the associated .err
    file is empty.

    The problem name, optional extension, and optional
    submit qualifier are extracted from the

      Subject: submit PROBLEM\[.EXTENSION\]\
      		      \[QUALIFIER\]

    field of the message in the Received_Mail file.
    Here `PROBLEM' names the problem and the solution
    binary, and is the basename of the .in, .out, .cerr,
    .err, and .score files.  If `EXTENSION' is given,
    it tells the programming language being used, and
    must be a member of the `allowed_extensions' global
    variable value, which by default is:

    	$allowed_extensions

    The submit qualifier, QUALIFIER, becomes the value
    of the global variable `submit_qualifier', which may
    be used by response_instructions to tailor the re-
    sponse to the submitter.  It must be a member of the
    `allowed_qualifiers' global variable value, which by
    default is:

    	$allowed_qualifiers

    In this document the words `PROBLEM' and `EXTENSION'
    are used to denote the problem name and extension as
    given in the `Subject:' field.  Also, the solution
    directory below is the problem directory within the
    solutions directory, i.e., the directory with name:

    	<judging_directory>/solutions/PROBLEM

    More specifically, this program makes the following
    in order:

      * `PROBLEM.rc' file, if it exists.  If it exists
        (in the problem's solution directory), it is
        sourced, and may set some of the global varia-
	bles mentioned below.  See the `Problem .rc
	Files' section of hpcm_judging.rc for detailed
	specification of the values of these global
	variables and their defaults.

      . Submitted files which are extracted from the
        submitted message in the Received_Mail file
        by the extractmail program.  These files must
	all be listed in the problem_required_files or
	problem_optional_files global variables.
	The default is for PROBLEM.EXTENSION to be
	the only required file if EXTENSION is not
	empty.

      . Files listed in the problem_make_files global
        variable, which gives instructions on when and
	how to make files in the problem's solution
	directory.  E.g., the Scoring_Filter program
	may be compiled there if necessary.  The default
	is to make for each input name N, N.in, N.fout,
	N.jout, N.jfout, N.ftest, N.jtest, and N.jftest
	files whenever the input files needed to make
	them exist.  This if N.out and Scoring_Filter
	exist, N.fout will be made, and if N.jin also
	exists, then N.jfout will be made.

      . A list of input names is computed.  If the
        global variable problem_input_names exists, its
	value is the list of input names.  Otherwise N
	is on the list if and only if N.in or N.jin
	exist in the problem solution directory.  How-
	ever PROBLEM is treated specially.  First, if
	the list would contain PROBLEM and some other
	name N, and if PROBLEM.in exists as a real file
	and not a symbolic link, or PROBLEM.jin exists,
	then it is an error.  Otherwise if there is some
	N on the list besides PROBLEM, PROBLEM is re-
	moved from the list.

      * Files listed in the problem_{link,copy}_files
        and problem_optional_{link,copy}_files global
	variables are {linked,copied} from the problem
	solution directory to the current submission
	directory.  Then the following are linked if
	they do not exist in the submission directory
	and they do exist in the solution directory:
	Makefile, Scoring_Filter, and for each input
	names N, N.in, N.test, N.jin, N.ftest, N.jtest,
	N.jftest.

	Note that if N.out exists in the problem solu-
	tion directory, it will be linked to N.test in
	the submission directory, in preference over
	N.test in the solution directory.  Ditto for
	.ftest, .jtest, .jftest.

        The only reason for copying files instead of
	linking them is when hpcm_sandbox needs to
	access the file, as it has no permission on
	the solution directory.

      . The program binary file `PROBLEM' and the
	compiler error file PROBLEM.cerr are made by
	executing `make PROBLEM' in the submission
	directory, using the Makefile.  If there is
	an error, the score is `Syntax Error'.  The
	Auto_Score file is written and autojudge termi-
	nates.

      . For each input name N, PROBLEM.in is linked to
        N.in, PROBLEM.out is made by executing `make
	PROBLEM.out' using the Makefile, the standard
	error from make is directed to PROBLEM.err, and
	PROBLEM.out and PROBLEM.err are then renamed
	N.err and N.out.  If N == PROBLEM this is done
	without the linking or renaming.

      . For each input name N, N.fout is made if
        Scoring_Filter exists, N.jfout if in addition
	N.jin exists, and N.jout is made if N.jin exists
	but Scoring_Filter does not.

      . For each input name N, one of N.score, N.fscore,
        N.jscore, or N.jfscore is made, according to
	whether or not Scoring_Filter and N.jin exist.

      . Auto_Score is computed from the resulting
	.*score files.  Whenever Auto_Score is made, the
	Score_Flag is set, and a Reply_Mail file is made
	and sent to to the submitter if the scoring_mode
	is not `manual'.

    Here files marked with * are linked into the current
    submission directory from the problem's solution
    directory.

    In general, this program does not make a file that
    already exists, unless one of the files input to
    make the file is more recent that the file to be
    made.  So, for example, if the Received_Mail file
    is more recent than an extracted file, the files
    will be re-extracted, whereas if extracted files
    exist and are all as recent as the Received_Mail
    file, file extraction will be skipped.

    In general, this program may detect two kinds of
    errors: system errors and submitter errors.  A
    system error means the judging files are incorrectly
    set up, and a submitter error means the submitter
    sent the wrong information.  On a system error, this
    program logs the error in an error log file in the
    current directory and prints information about the
    error to the standard error output.  On a submitter
    error, this program creates a Reply_Mail file that
    contains a description of the error and sends this
    to the submitter as the final word on the submis-
    sion.  In either case this program terminates after
    reporting the error.

    Errors in extraction are classified as system errors
    if extractmail outputs the phrase `SYSTEM ERROR' and
    submitter errors otherwise.  SYSTEM ERRORs are log-
    ged by extractmail, who also replies to the submit-
    ter according to the logging mode, so autojudge just
    prints the output and exits when an extractmail
    system error occurs.

    While making files in the problem solution direc-
    tory, this program locks the solution directory with
    a Dispatch_PID file.

    For purposes of computing file dependencies, all
    non-extracted files made (not linked) by this pro-
    gram in the submission directory are assumed to
    depend upon all the extracted and linked files.

    When this program creates a `Reply_Mail' file it
    uses instructions in the `response_instructions'
    global variable.  This variable contains instruc-
    tions that format the reply for a given Auto_Score
    value and a given value of the scoring_mode and
    response_mode global variables.  The format of the
    response instructions is described in hpcm_
    judging.rc, where a default value is also given for
    the `response_instructions' variable.

    With default response instructions, this program
    sends a reply if the score is `Completely Correct'
    or the scoring_mode is `auto' or `auto+manual'.  If
    the mode is `auto' or the score is `Completely Cor-
    rect', the reply is final, and is stored in the
    Reply_Mail file.  Otherwise the reply is not final,
    and informs its receiver that the score is prelim-
    inary and will be manually reviewed and possibly
    changed.  When the reply is not final, this program
    does not create a Reply_Mail file, even when it
    sends a reply (the reply is recorded in any case in
    the Reply_Mail_History file).  The absence of a
    Reply_Mail file signals that the final reply has
    not been given to the submitter, and further action
    using the `manualreply' program is necessary to gen-
    erate a final reply.

    This program prints information about its progress.

    Unless this program creates a Reply_Mail file that
    is intended to be the final reply to the submitter
    (e.g., because the score is `Completely Correct' or
    the scoring mode is `auto'), this program sets the
    `needs reply' flag (the Needs_Reply_Flag file in
    the flag directory).  This signals other programs
    (e.g. tracker) that they should search for submis-
    sion directories for which the manualreply program
    should be called.

    If this program writes the Auto_Score file, it also
    sets the score flag (the flag directory Score_Flag
    file), to signal that any scoreboards need to be
    recomputed.

    Problem names that contain `/' or `.' or begin with
    `-' or have no solution directory are illegal, and
    are submitter errors.  Similarly extension names
    not listed in the `allowed_extensions' global vari-
    able are unallowed and are submitter errors, as are
    misformatted Received_Mail file `Subject:' fields.
    It is a system error if the `Received_Mail' file is
    not readable, of if `extractmail' returns a system
    error.  It is a system error if an existing global
    variable value is misformatted.
"

# Do not change argc or argv so error printouts will be
# correct.
#
set my_argc $argc
set my_argv $argv

# Process any -rerun or -manual argument.
#
set manual 0
set rerun 0
if { [lindex $my_argv 0] == "-manual" } {
    set manual 1
    set my_argv [lrange $my_argv 1 end]
    incr my_argc -1
} elseif { [lindex $my_argv 0] == "-rerun" } {
    set rerun 1
    set my_argv [lrange $my_argv 1 end]
    incr my_argc -1
}

# If too many arguments print documentation and exit.
#
if { $my_argc > 0 } {
    exec << $document less -F >&@ stdout
    exit 1
}

# Do -rerun preprocessing.
#
if { $rerun } {

    # Safety check that we are in a submission
    # directory (before we start deleting things).
    #
    if { ! [file readable Received_Mail] } {
        error "Received_Mail not readable"
    }

    # Move Auto_Score to Old_Auto_Score.
    #
    if {    [file exists Auto_Score] \
	 && ! [file exists Old_Auto_Score] } {
	puts "Renaming Auto_Score to Old_Auto_Score"
	file rename Auto_Score Old_Auto_Score
    }

    # Delete files.
    #
    foreach file [glob -nocomplain *] {
	if { [lcontain {Received_Mail
			Reply_Mail
			Reply_Mail_History
			No_Reply
			Old_Auto_Score
			Manual_Score
			autodispatch.log
			autodispatch.log-history} \
			$file] } {
	    continue
	}
	puts "Deleting $file"
	file delete -force -- $file
    }

    # Set up -rerun post-processing.
    #
    proc exit_cleanup {} {

	# Delete or keep Old_Auto_Score.
	#
	if {    [file exists Auto_Score] \
	     && [file exists Old_Auto_Score] } {
	    set auto_score \
		[read_entire_file Auto_Score]
	    set old_auto_score \
		[read_entire_file Old_Auto_Score]
	    if { $auto_score == $old_auto_score } {
		puts "Auto_Score == Old_Auto_Score"
		puts "Deleting Old_Auto_Score"
		file delete -force -- Old_Auto_Score
	    } else {
		puts "Auto_Score: new $auto_score"
		puts "         != old $old_auto_score"
	    }
	}
    }
}

# Handle submitter error in subject.
#
proc subject_error { what } {
    global message_subject
    reply "LINE {ERROR: $what\
	  	 `Subject:$message_subject'}" \
	  BLANK \
	  { LINE "THIS SUBMISSION (see below)\
	          IGNORED" } \
	  { LINE "You must resubmit with a legal\
	         message subject." } \
	  BLANK \
	  { BAR "this message replies to:" } \
	  RECEIVED-HEADER
    puts "SUBMISSION ERROR: $what\
          `Subject:$message_subject'"
    exit_cleanup
    exit 0
}

# Read Received_Mail message header.
#
set received_ch [open Received_Mail r]
read_header $received_ch
close $received_ch

# Get PROBLEM and EXTENSION.
#
if {    [catch { llength $message_subject }] \
     || [llength $message_subject] < 2 \
     || [llength $message_subject] > 3 \
     || [lindex $message_subject 0] != "submit" } {
    subject_error "badly formatted"
}
set filename [lindex $message_subject 1]
set submit_qualifier [lindex $message_subject 2]
set PROBLEM [file rootname $filename]
set EXTENSION [file extension $filename]

# Check legality of PROBLEM.
#
if {    $PROBLEM == "" \
     || [regexp {\.} $PROBLEM] \
     || [regexp {/}  $PROBLEM] \
     || [regexp {^-} $PROBLEM]  } {
    subject_error "illegal problem name\
                   `$PROBLEM'\n  in"
}

# Legality check for EXTENSION and submit_qualifier is
# deferred until after PROBLEM.rc is read.

# Check for existence of problem solution directory.
#
set s_d $judging_directory/solutions/$PROBLEM
if { ! [file isdirectory $s_d] } {
    subject_error "problem `$PROBLEM' is not allowed in\
                   this contest\n  in"
}

# Global variable that is list of all files linked
# or copied into the submission directory by autojudge.
# Various output files depend on all these (must not be
# older than any of these).
#
set linked_or_copied_files ""

# Function that {links,copies} files according to the
# data that has the format of a problem_link_files
# global variable value: see hpcm_judging.rc.  Name
# describes the data for error message purposes.  Copy
# is 1 to copy instead of link.  Optional is 1 if
# {links,copies} are options, 0 if they are required.
# Relink is 1 (the default) if existing {links,copies}
# are deleted and {relinked,recopied}, and 0 otherwise.
#
# Appends files that exist or are newly linked to
# linked_or_copied_files above.
#
# The global s_d names the problem solution directory.
#
proc execute_links_or_copies \
	{ data name {copy 0 } { optional 0 } \
	            { relink 1 } } {

    global s_d linked_or_copied_files

    if { [catch { llength $data }] } {
	error "bad $name, not a TCL list: $data"
    }

    foreach item $data {
	if { [catch { set length [llength $item] }] } {
	    error "bad $name element, not a TCL list:\
	           $item"
	}
	if { $length == 0 } {
	    error "bad $name element, empty TCL list"
	} elseif { $length == 1 } {
	    set source_list [lindex $item 0]
	    set target $source_list
	} else {
	    set source_list [lrange $item 1 end]
	    set target [lindex $item 0]
	}
	set source ""
	foreach file $source_list {
	    if { [file exists $s_d/$file] } {
		set source $s_d/$file
		break
	    }
	}
	if { $target == "" || [regexp {/} $target ] } {
	    error "Bad $name target in $item"
	}

	if { [catch { set type [file type $target] }] \
	            } {
	    set type none
	}

	if {    ! $copy && $type == "link" && $relink \
	     && ( $source == "" \
		  ||    [file readlink $target] \
		     != $source ) } {
	    puts "Deleting $target"
	    file delete -force $target
	    set type none
	}
	if {    $copy && $type == "file" && $relink \
	     && ( ! [compare_files $source $target] \
	          || \
		  [file attributes $source \
		                   -permissions] \
		  != \
		  [file attributes $target \
		                   -permissions] ) } {
	    puts "Deleting $target"
	    file delete -force $target
	    set type none
	}

	if { $type != "none" } {
	    if { ! [lcontain $linked_or_copied_files \
	                     $target] } {
		lappend linked_or_copied_files $target
	    }
	} elseif { $source == "" } {
	    if { ! $optional } {
	        error "no source files exist for\
		       $item in $name"
	    }
	} else {
	    set tail [file tail $source]
	    if { $copy } {
		if { $tail == $target } {
		    puts "Copying $target"
		} else {
		    puts "Copying $tail to\
			  $target"
		}
		copy_file $source $target
	    } else {
		if { $tail == $target } {
		    puts "Linking $target"
		} else {
		    puts "Linking $tail to\
			  $target"
		}
		link_file $source $target
	    }
	    lappend linked_or_copied_files $target
	}
    }
}

# Switch that is use by execute_locked_makes to indicate
# that the s_d is locked.  If set at the end of the
# sequence of execute_locked_makes calls, s_d must be
# unlocked.
#
set s_d_is_locked 0

# Source any PROBLEM.rc file.
#
execute_links_or_copies \
    $PROBLEM.rc "initial problem .rc file linking" 0 1
source_file $PROBLEM.rc
if { [info exists problem_rc($PROBLEM)] } {
    eval $problem_rc($PROBLEM)
}

# Check legality of EXTENSION and submit_qualifier.
#
if { $EXTENSION != "" \
     && ! [lcontain $allowed_extensions $EXTENSION] } {
    subject_error "unallowed extension\
      `$EXTENSION'\n  (should be one of\
      $allowed_extensions)\n  in"
} elseif { [regexp {/} $EXTENSION] } {
    # should never happen
    error "/ in extension `$EXTENSION'"
}

# Check legality of submit qualifier.
#
if { ! [lcontain $allowed_qualifiers \
                 $submit_qualifier] } {
    subject_error \
        "unallowed submit qualifier\
	 `$submit_qualifier'\n  (should be one of\
	 $allowed_qualifiers)\n  in"
}

# Force scoring mode if there was a -manual or -rerun
# option.
#
if { $manual || $rerun } {
    set scoring_mode manual
}

# List of all files extracted by extractmail.
#
set extracted_files ""

# Extract submitted files.

# If non-SYSTEM ERROR error, reply to submitter.  If
# SYSTEM ERROR error, merely print extractmail output
# and exit 0, as all logging and replying is done by
# extractmail.
#
# Compute list of extracted files in `extracted_files'.
#
#
if { [catch { exec extractmail } extractout] } {
    if { [regexp {SYSTEM ERROR} $extractout] } {
	puts $extractout
	exit_cleanup
        exit 0
    } else {

	# Create a reply file complaining of an extrac-
	# tion error, and email this reply to the
	# submitter.  Include the submission email in
	# the reply.
	#
	reply {LINE "ERROR during file extraction:" } \
	      BLANK \
	      [list LINES $extractout] \
	      BLANK \
	      { LINE "THIS SUBMISSION (see below)\
	              IGNORED" } \
	      { LINE "YOU MUST RESUBMIT" } \
	      BLANK \
	      { BAR "this message replies to:" } \
	      RECEIVED-FULL-HEADER \
	      BLANK \
	      RECEIVED-BODY

	puts $extractout
	puts "Reply indicating error has been emailed\
	      to submitter."

	exit_cleanup
	exit 0
    }
} else {
    puts $extractout
    foreach line [split $extractout "\n"] {
        if { [regexp {^Extracted } $line] } {
	    lappend extracted_files [lindex $line 1]
	}
    }
}

# Execute problem_make_files instructions if any.
#
if { [info exists problem_make_files] } {
    execute_locked_makes $problem_make_files $s_d \
    		         "problem_make_files value" \
			 s_d_is_locked
}

# Compute list of input names from problem_input_names
# or from existing files.
#
if { [info exists problem_input_names] } {
    set input_names $problem_input_names
} else {

    # Make default list, which contains names N such
    # that N.in or N.jin exist.  Eliminate duplicates.
    # Do not list $PROBLEM.in if any other names found,
    # as it should be just a link to another .in name
    # in that case.
    #
    set input_names ""
    set problem_found 0
    set non_link_problem_found 0
    foreach name [glob -nocomplain "$s_d/*"] {
	set tail [file tail $name]
	if { $tail == "$PROBLEM.in" } {
	    set problem_found 1
	    if { [file type $name] != "link" } { 
		set non_link_problem_found 1
	    }
	    continue
	} elseif { $tail == "$PROBLEM.jin" } {
	    set problem_found 1
	    set non_link_problem_found 1
	    continue
	}

	set ext [file extension $tail]
	set root [file rootname $tail]
	if { ! [lcontain  {.in .jin} $ext] } continue
	if { [lcontain $input_names $root] } continue
	lappend input_names $root
    }
    if { [llength $input_names] == 0 } {
	if { $problem_found } {
	    lappend input_names $PROBLEM
	} else {
	    error "No *.in or *.jin files found"
	}
    } elseif { $non_link_problem_found } {
	error "$PROBLEM.in exists and is not a symbolic\
	       link, or $PROBLEM.jin exists,\n    and\
	       N.{in,jin} exists for some other N"
    }
    set input_names [lsort $input_names]
    set problem_input_names $input_names
}

# Set switch for future reference.
#
set scoring_filter_exists \
    [file exists $s_d/Scoring_Filter]

# Make .in files from .jin files.
#
# If Scoring_Filter exists, make .fout files from .out
# files, .ftest files from .test files, .jfout files
# from .fout files, .jftest files from .ftest files.
#
# If Scoring Filter does not exist, make .jout files
# from .out files and .jtest files from .test files.
#
set instructions ""
foreach name $input_names {
    lappend instructions \
            "$name.in {jfilter $name.jin $name.in}\
	              $name.jin"
    if { $scoring_filter_exists } {
	lappend instructions \
		"$name.fout\
		 {Scoring_Filter $name.in <$name.out\
		                 >$name.fout}\
	         Scoring_Filter $name.in $name.out" \
		"$name.ftest\
		 {Scoring_Filter $name.in <$name.test\
		                 >$name.ftest}\
	         Scoring_Filter $name.in $name.test" \
		"$name.jfout\
		 {jfilter $name.jin $name.fout\
		          $name.jfout}\
		 $name.jin $name.fout" \
		"$name.jftest\
		 {jfilter $name.jin $name.ftest\
		          $name.jftest}\
		 $name.jin $name.ftest"
    } else {
	lappend instructions \
		"$name.jout\
		 {jfilter $name.jin $name.out\
		          $name.jout}\
		 $name.jin $name.out" \
		"$name.jtest\
		 {jfilter $name.jin $name.test\
		          $name.jtest}\
		 $name.jin $name.test"
    }
}

execute_locked_makes \
    $instructions $s_d \
    "autojudge generated instructions" \
    s_d_is_locked

if { $s_d_is_locked } {
    dispatch_unlock $s_d
    puts "Unlocked $s_d"
}

# Execute problem_link_files instructions if any.
# Otherwise execute default.
#
if { [info exists problem_link_files] } {
    execute_links_or_copies \
        $problem_link_files "problem_link_files value"
}
# Execute problem_copy_files instructions if any.
# Otherwise execute default.
#
if { [info exists problem_copy_files] } {
    execute_links_or_copies \
        $problem_copy_files "problem_copy_files value" 1
}
# Execute problem_optional_link_files instructions if
# any.
#
if { [info exists problem_optional_link_files] } {
    execute_links_or_copies \
        $problem_optional_link_files \
	"problem_optional_link_files value" 0 1
}
# Execute problem_optional_copy_files instructions if
# any.
#
if { [info exists problem_optional_copy_files] } {
    execute_links_or_copies \
        $problem_optional_copy_files \
        "problem_optional_copy_files value" 1 1
}

# Link everything that does not exist that we need.
# These links are not optional, but should not be done
# if target is an existing file or link.
#
set EXT [string range $EXTENSION 1 end]
set instructions ""
lappend instructions \
	" Makefile Makefile_$EXT Makefile "
if { $scoring_filter_exists } {
    lappend instructions " Scoring_Filter "
}
foreach name $input_names {
    set jin_exists [file exists $s_d/$name.jin]
    lappend instructions \
            $name.in \
	    " $name.test $name.out \
	      $name.test_$EXT $name.test "
    if { $jin_exists } {
	lappend instructions $name.jin
    }
    if { $scoring_filter_exists } {
	lappend instructions \
	    " $name.ftest $name.fout \
	      $name.ftest_$EXT $name.ftest "
	if { $jin_exists } {
	    lappend instructions \
		" $name.jftest $name.jfout \
		  $name.jftest_$EXT $name.jftest "
	}
    } elseif { $jin_exists } {
	lappend instructions \
	    " $name.jtest $name.jout \
	      $name.jtest_$EXT $name.jtest "
    }
}
execute_links_or_copies \
    $instructions "autojudge generated required link\
	           instructions" 0 0

# Function to send reply to user containing new auto
# score.
#
proc auto_score_reply { score { marker "" } } {

    global auto_score auto_score_marker \
           manual_score proposed_score \
	   old_auto_score \
	   submitted_problem submitted_extension \
	   PROBLEM EXTENSION

    if { [file exists Auto_Score] } {
	puts "Deleting out-of-date Auto_Score"
	file delete -force Auto_Score
    }
    if { $marker == "" } {
	set s $score
    } else {
	set s "[join $marker :] $score"
    }
    write_file Auto_Score $s
    set_flag Score_Flag

    set auto_score $score
    set auto_score_marker $marker
    set old_auto_score None
    set manual_score None
    set proposed_score None
    set submitted_problem $PROBLEM
    set submitted_extension $EXTENSION
    set return_commands [compose_response]

    if { [lcontain $return_commands EDIT] } {
	error "EDIT response instruction executed"
    }

    send_response $return_commands

    if { [lcontain $return_commands FINAL] } {
	puts "Emailed final auto-score:\
	      \    $auto_score"
    } elseif { [lcontain $return_commands NOT-FINAL] } {
	set_flag Needs_Reply_Flag
	puts "Emailed auto-score (review later):\
	      \    $auto_score"
    } elseif { [lcontain $return_commands NO-REPLY] } {
	set_flag Needs_Reply_Flag
	puts "Auto-score (NOT emailed):\
	      \    $auto_score"
    } else {
        error "bad compose_response return\
	       value:\n   $return_commands"
    }
}

# should_be_made [-nodelete] file_list1 file_list2 
#
# If any file_list1 file is older than any file_list2
# file, and all file_list2 files exist, delete any
# file_list1 files that exist and return `yes'.  If some
# file_list1 file does not exist, and all file_list2
# files exist, delete any file_list1 files that do exist
# and return `yes'.  Else return `no'.  If -nodelete
# option given, suppress deleting of files.
#
#
proc should_be_made { args } {

    set nodelete \
        [expr { [lindex $args 0] == "-nodelete" }]
    set file_list1 [lindex $args end-1]
    set file_list2 [lindex $args end]

    # Set mtime1 to the oldest of the file_list1
    # mtimes, or 0 if some file_list1 file does not
    # exist.
    #
    set mtime1 0
    foreach file1 $file_list1 {
	if { [file exists $file1] } {
	    set mt [file mtime $file1]
	    if { $mt < 0 } { error "negative mtime" }
	    if { $mtime1 == 0 || $mtime1 > $mt } {
	    	set mtime1 $mt
	    }
	} else {
	    set mtime1 0
	    break
	}
    }
    # Set mtime2 to the newest of the file_list2
    # mtimes, or 0 if any file_list2 file does not
    # exist.
    #
    set mtime2 0
    foreach file2 $file_list2 {
	if { [file exists $file2] } {
	    set mt [file mtime $file2]
	    if { $mt < 0 } { error "negative mtime" }
	    if { $mtime2 < $mt } {
	    	set mtime2 $mt
	    }
	} else {
	    set mtime2 0
	    break
	}
    }

    # If mtime1 < mtime2 we need to make file_list1
    # from file_list2
    #
    if { $mtime1 < $mtime2 } {
        if { ! $nodelete } {
	    foreach file1 $file_list1 {
		if { [file exists $file1] } {
		    puts "Deleting out-of-date $file1"
		    file delete -force $file1
		}
	    }
	}
	return yes
    } else {
        return no
    }
}

# If necessary compile submitted file to produce
# binary.  If this fails, announce `Syntax Error'
# as the score.
#
if { [should_be_made \
         [list $PROBLEM $PROBLEM.cerr] \
	 [concat $linked_or_copied_files \
	 	 $extracted_files]] } {

    puts "Making $PROBLEM"
    catch { make_file $PROBLEM $PROBLEM.cerr }

    # Print any non-empty .cerr file.
    #
    if { [file exists $PROBLEM.cerr] \
	 && [file size $PROBLEM.cerr] > 0 } {
	puts ""
	if { [file executable $PROBLEM] } {
	    puts "========== COMPILER WARNINGS\
	          ($PROBLEM.cerr) =========="
	} else {
	    puts "========== COMPILER ERRORS\
	          ($PROBLEM.cerr) =========="
	}
	put_file $PROBLEM.cerr stdout 10
	puts "============================="
	puts ""
    }

    # If no executable binary produced, record and
    # send `Syntax Error' reply.
    #
    if { ! [file executable $PROBLEM] } {
	puts "No executable `$PROBLEM' file produced"
	foreach name $input_names {
	    file delete -force -- \
	         $name.err $name.out $name.fout \
		           $name.jout $name.fjout
	}
	auto_score_reply "Syntax Error"
	exit_cleanup
	exit 0
    }
}

# For each name in input_names compute if necessary
# (according to should_be_made) the output file
# ${name}.${fix}out where fix is "", f, j, or jf.  Then
# compute ${name}.${fix}score if necessary.  Record the
# maximum of all ${name}.${fix}score in mtimes in
# score_mtime for use in deciding whether to recompute
# the Auto_Score file.
#
# Then update `score', `marker', and `fmarker' from
# the ${name}.${fix}score file.  The first error found
# sets the `score' and `marker' variables, EXCEPT, if a
# Formatting Error is found, it just sets the `fmarker'
# variable to the first formatting error marker.
# Markers have the form
#
#	{ scoring-file-name group-number case-number }
#
# If no non-formatting errors are found, `score' is left
# as "".  The `marker' variable value is not meaningful
# unless `score' is not "".
#
set score ""
set marker ""
set fmarker ""
set score_mtime 0
#
foreach name $input_names {
 
    # Make .out and .err files as necessary.
    #
    if { [should_be_made \
	     [list $name.out $name.err] \
	     [concat [list $PROBLEM] \
		     $linked_or_copied_files \
		     $extracted_files]] \
	 && [file executable $PROBLEM] } {

	if { $name != $PROBLEM } {
	    puts "Linking $name.in to $PROBLEM.in"
	    file delete -force $PROBLEM.in
	    link_file $name.in $PROBLEM.in
	}
	file delete -force $PROBLEM.out $PROBLEM.err
	puts "Making $PROBLEM.out and $PROBLEM.err"
	catch { make_file $PROBLEM.out $PROBLEM.err }

	# Remove any a+x on the current directory as a
	# `best effort' security measure in the face of
	# the JAVA bug that requires .. to be a+x.
	#
	deny_access "."

	# Rename .out and .err files if necessary.
	#
	if { $name != $PROBLEM } {
	    foreach ext {out err} {
		if { [file exists $PROBLEM.$ext] } {
		    puts "Renaming $PROBLEM.$ext to\
			  $name.$ext"
		    file delete -force -- $name.$ext
		    file rename $PROBLEM.$ext $name.$ext
		}
	    }
	}

	# The .out file should exist but may be empty.
	#
	if { ! [file exists $name.out] } {
	    error "File $name.out should exist"
	}
    }

    # Make .fout, .jout, or .jfout files as appropriate.
    #
    if { $scoring_filter_exists } {
	if { [should_be_made \
		 [list $name.fout] \
		 [list Scoring_Filter $name.out]] } {

	    puts "Making $name.fout"
	    exec Scoring_Filter $name.in \
	         < $name.out > $name.fout
	}
	if { [should_be_made \
		 [list $name.jfout] \
		 [list $name.jin $name.fout]] } {

	    puts "Making $name.jfout"
	    exec jfilter \
	         $name.jin $name.fout $name.jfout
	}
    } else {
	if { [should_be_made \
		 [list $name.jout] \
		 [list $name.out $name.jin]] } {

	    puts "Making $name.jout"
	    exec jfilter $name.jin $name.out $name.jout
	}
    }

    # Make .*score files.
    #
    if { [file exists $name.jin] } {
        set jin_instructions [exec jfilter $name.jin]
	set jin_instructions \
	    [string trim $jin_instructions]
	if { $jin_instructions == "none" } {
	    compute_instruction_array \
		$scoring_instructions \
		"scoring_instructions variable value"
	} else {
	    compute_instruction_array \
		$jin_instructions "$name.jin file"
	}
	if { $scoring_filter_exists } {
	    if { [should_be_made [list $name.jfscore] \
		    [list $name.jfout $name.jftest]] } {
		compute_score_file \
		    $name.jfout $name.jftest \
		    $name.jfscore -filtered
	    }
	    set fix jf
	} else {
	    if { [should_be_made [list $name.jscore] \
		      [list $name.jout $name.jtest]] } {
		compute_score_file \
		    $name.jout $name.jtest \
		    $name.jscore -filtered
	    }
	    set fix j
	}
    } else {
	compute_instruction_array \
	    $scoring_instructions \
	    "scoring_instructions variable value"
	if { $scoring_filter_exists } {
	    if { [should_be_made [list $name.fscore] \
		      [list $name.fout $name.ftest]] } {
		compute_score_file \
		    $name.fout $name.ftest $name.fscore
	    }
	    set fix f
    	} else {
	    if { [should_be_made [list $name.score] \
		      [list $name.out $name.test]] } {
		compute_score_file \
		    $name.out $name.test $name.score
	    }
	    set fix ""
	}
    }
    set score_file ${name}.${fix}score
    if { ! [file exists $score_file] } {
        error "$score_file does not exist\n   - maybe\
	       correspondence problem between .*test\
	       and .*out files"
    }
    set mtime [file mtime $score_file]
    if { $mtime > $score_mtime } {
        set score_mtime $mtime
    }

    # Compute markers.
    #
    compute_score_and_proof_arrays "${name}.${fix}score"
    compute_score

    # Set the marker that will be used if there is noth-
    # ing but formatting errors in the output, but the
    # .err file is non-empty (or the pathological case
    # where .out and .test are BOTH empty).
    #
    set marker [concat [list ${name}.${fix}score] \
		       [lrange $end_marker 0 1]]

    foreach x {incorrect_output incomplete_output\
	       formatting_error} {

	set m [set ${x}_marker]

	if { $m != "" } {

	    # Marker is {OG OC TG TC}
	    #
            # For incorrect_output and incomplete_output
            # choose the smaller of {OG GC} and {TG TC}.
            # For incomplete_output choose the larger.
	    # However, as a special case, if {OG OC} ==
	    # {0 0}, choose {TG TC} (which should be
	    # {0 1} or {1 1}).
            #
	    set choose_first [expr { \
                  [lindex $m 0] \
                < [lindex $m 2] \
                || (    [lindex $m 0] \
                     == [lindex $m 2] \
                     && \
                        [lindex $m 1] \
                     <  [lindex $m 3] ) }]
	    if { $x == "incomplete_output" } {
	        set choose_first \
		    [expr { ! $choose_first }]
	    }
	    if {    [lindex $m 0] == 0 \
	         && [lindex $m 1] == 0 } {
	        set choose_first 0
	    }
	    if { $choose_first } {
		set m [lrange $m 0 1]
	    } else {
		set m [lrange $m 2 3]
	    }
	    set m [concat [list ${name}.${fix}score] $m]

	    switch $x {
	    incorrect_output {
		set score "Incorrect Output"
		set marker $m
		break
	    }
	    incomplete_output {
		set score "Incomplete Output"
		set marker $m
	    }
	    formatting_error {
		if { $fmarker == "" } {
		    set fmarker $m
		}
	    }
	    }
	}
    }

    # Print any non-empty .err file, look for
    # lines indicating the type of program crash,
    # and adjust score.
    #
    set largest_marker \
        [concat [list ${name}.${fix}score] \
	        [lrange $largest_marker 0 1]]
    if {    [file exists $name.err] \
	 && [file size $name.err] > 0 \
	 && (    $score != "Incorrect Output" \
	      || (    [lindex $marker 1] \
	           == [lindex $largest_marker 1] \
	           && \
	              [lindex $marker 2] \
		   == [lindex $largest_marker 2] ) ) } {

	puts ""
	puts "========== ERRORS ($name.err)\
	      =========="

	set error_fd [open $name.err r]
	set count 0
	set score "Program Crashed"
	while { "yes" } {
	    set line [gets $error_fd]
	    if { [eof $error_fd] } break
	    if { [regexp -nocase -- \
			 $time_limit_regexp \
			 $line] } {
		set score \
		    "Cpu Time Limit Exceeded"
	    } elseif { [regexp -nocase -- \
			 $output_limit_regexp \
			 $line] } {
		set score \
		    "Output Size Limit Exceeded"
	    }
	    if { $count < 10 } { puts $line }
	    incr count
	}
	close $error_fd
	puts "============================="
	puts ""
	break
    } elseif { [file size $name.out] == 0 } {
	puts "Empty `$name.out' file produced"
	set score "Program Crashed"
	break
    } elseif { $score != "" } {
        break
    }
}

# If .*score files used to compute score have not
# changed since Auto_Score file changed, exit.
#
if {    [file exists Auto_Score] \
     &&    [file mtime Auto_Score] \
        >= $score_mtime } {
    exit_cleanup
    exit 0
}

if { $score != "" } {
    auto_score_reply $score $marker
} elseif { $fmarker != "" } {
    auto_score_reply "Formatting Error" $fmarker
} else {
    auto_score_reply "Completely Correct"
}

exit_cleanup
exit 0

# Include common error catching code:
#
} caught_output
caught_error
