#!/bin/sh -f
#
# Compute all the files needed in a program submission
# directory in order to score a submission.
#
# File:		autojudge
# Author:	Bob Walton (walton@deas.harvard.edu)
# Date:		Wed Aug 16 06:43:27 EDT 2000
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: acm-cont $
#   $Date: 2000/08/28 12:32:05 $
#   $RCSfile: autojudge,v $
#   $Revision: 1.18 $
#
# The next line starts tcl \
exec tcl "$0" "$@"

# Use tcl rather than tclsh so that `signal' is defined.

# Include common code and parameters:
#
set lib_directory "[file dirname $argv0]/../lib"
source "$lib_directory/judging_common.tcl"
catch {

set document "
cd submission_directory; judge

    Given the submission directory as the current dir-
    ectory, and given that the submission directory
    contains the file `$received_file', this program
    makes everything needed to compute the score file,
    `$auto_score_file', and automatically computes that
    file.  Then this program may report the score to the
    submitter by creating and sending `$reply_file' as
    specified by the scoring mode.


    Specifically, this program calls `extractmail' to
    extract the submitted file from the program.  This
    program then checks the legality of the submitted
    file name, and generates and sends `$reply_file'
    automatically if the name is illegal.
    
    If the file name is legal, this program symbolical-
    ly links the following solution directory files into
    the current directory:

    		$make_file
		$instructions_file if it exists
		.in solution input file
		.test solution output file
    
    Next this program makes the program binary by using
    the $make_file.  If there is a compliler error, the
    error messages are captured in a .cerr file.  If
    there is a non-empty .cerr file or no binary is
    made, this program writes `Syntax Error' into the
    $auto_score_file file, and skips to the end of this
    program where a $replay_file containing the auto
    score may be created and sent to the user.

    If the binary file was made without error, this
    program makes a .out output file and a .err error
    file by using the $make_file.  Then this program
    runs `autoscore' to produce an automatic score in
    the $auto_score_file file.

    Lastly, this program may create a `$reply_file'
    and send it as email to the submitter.  It does this
    if the score is `Completely Correct' or the scoring_
    mode is `auto' or `auto+manual'.  If the mode is
    `auto+manual' and the score is not `Completely Cor-
    rect', the email informs its receiver that the score
    is preliminary and will be manually reviewed and
    possibly changed.
    
    If the score is to be manually reviewed, this prog-
    ram deletes any $reply_file it may create, to signal
    that the final reply has not been given to the sub-
    mitter, and manual action is necessary to generate
    this reply.

    This program prints information about its progress.

    This program exits with non-zero error code only if
    something is very wrong, e.g. the `$received_file'
    file is not readable or the `$reply_file' file is
    not writable."

if { $argc != 0 } {
    puts $document
    exit 1
}

proc illegal_filename_error { filename } {
    reply \
          "ERROR: submitted file has illegal name:\
	  $filename" \
	  ""  \
	  "THIS SUBMISSION (see below) IGNORED"  \
	  "YOU MUST RESUBMIT WITH A LEGAL FILENAME"
    puts "SUBMISSION ERROR: submitted file has illegal\
          name: $filename"
    exit 0
}

set submitted_file [exec extractmail]

if { $submitted_file == "" } {
    if { [file readable $reply_file] } {
        exit 0
    } else {
	error "Extract failed but $reply_file\
	       is unreadable"
    }
}

set submitted_program [file rootname $submitted_file]
set submitted_extension [file extension $submitted_file]

set program_solution \
    "$solutions_directory/$submitted_program"

if { ! [file isdirectory $program_solution] } {
    illegal_filename_error $submitted_file
}

if { [lsearch -exact $allowed_extensions \
                     $submitted_extension] < 0 } {
    illegal_filename_error $submitted_file
}

if { ! [file readable $make_file] } {
    puts "Linking $make_file"
    link_file "$program_solution/$make_file"
}

if { ! [file readable $instructions_file] \
     && [file exists \
	  "$program_solution/$instructions_file"] } {
    puts "Linking $instructions_file"
    link_file "$program_solution/$instructions_file"
}

if { ! [file readable ${submitted_program}.in] } {
    puts "Linking ${submitted_program}.in"
    link_file \
         "$program_solution/${submitted_program}.in"
}

if { ! [file readable ${submitted_program}.test] } {
    puts "Linking ${submitted_program}.test to\
          solution ${submitted_program}.out"
    link_file \
         "$program_solution/${submitted_program}.out" \
         "${submitted_program}.test"
}

proc auto_score_replay { auto_score } {

    global scoring_mode reply_file

    if { $auto_score == "Completely Correct" \
         || $scoring_mode == "auto" } {
	reply "For ${submitted_file} the automatically\
	       determined final score is:\
	       \    $auto_score"
    } elseif { [regexp {auto} $scoring_mode] } {
	reply "For ${submitted_file} the automatically\
	       determined score is:     $auto_score" \
	      "" \
	      "However, this score WILL BE REVIEWED by\
	       the human judge (soon)."
	file delete -force $reply_file
    }
    puts "Automatic Score:    $auto_score"
}

if { ! [file readable $submitted_program] \
     || [file mtime $submitted_program] \
           < [file mtime Makefile] \
     || [file mtime $submitted_program] \
           < [file mtime $submitted_file] } {

    if { [file exists $submitted_program] } {
	puts "Deleting out-of-date $submitted_program"
    	file delete -force $submitted_program
    }

    if { [file exists "${submitted_program}.cerr"] } {
	puts "Deleting out-of-date \
	     ${submitted_program}.cerr"
    	file delete -force "${submitted_program}.cerr"
    }

    puts "Making ${submitted_program}"
    catch { exec make $submitted_program } out
    puts $out

    if { ( [file exists "${submitted_program}.cerr"] \
	   && [file size "${submitted_program}.cerr"] \
	      > 0 ) \
         || ! [file exists $submitted_program"] } {

	if { [file exists \
		   "${submitted_program}.cerr"] \
	     && [file size \
		      "${submitted_program}.cerr"] \
		  > 0 ) } {
	    put_file "${submitted_program}.cerr"
	} else {
	    puts "No $submitted_program file produced"
	}

	if { [file exists $auto_score_file] } {
	    file delete -force $auto_score_file
	}
	write_file $auto_score_file "Syntax Error"
	auto_score_reply "Syntax Error"
	exit 0
    }

    exec chmod a+x $submitted_program
}

if { ! [file readable "${submitted_program}.out"] \
     || [file mtime "${submitted_program}.out"] \
           < [file mtime $submitted_program] \
     || [file mtime "${submitted_program}.out"] \
           < [file mtime "${submitted_program}.in"] } {

    if { [file exists "${submitted_program}.out"] } {
	puts "Deleting out-of-date\
	               ${submitted_program}.out"
    	file delete -force "${submitted_program}.out"
    }

    if { [file exists "${submitted_program}.err"] } {
	puts "Deleting out-of-date\
	               ${submitted_program}.err"
    	file delete -force "${submitted_program}.err"
    }

    puts "Making ${submitted_program}.out"
    catch { exec make "${submitted_program}.out" } out
    puts $out

    set auto_score [exec autoscore $submitted_program]

} elseif { ! [file exists $auto_score_file] } {
    set auto_score [exec autoscore $submitted_program]

} else {
    set auto_score  [file_read "$auto_score_file]
}

auto_score_reply $auto_score

exit 0

# Include common error catching code:
#
} caught_output
caught_error
